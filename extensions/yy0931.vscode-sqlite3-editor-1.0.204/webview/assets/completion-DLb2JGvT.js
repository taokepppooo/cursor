import{k as e,e as t}from"./index-DjmdYdSm.js";/* empty css              */const n={abs:{args:"(X)",docs:"The abs(X) function returns the absolute value of the numeric argument X. Abs(X) returns NULL if X is NULL. Abs(X) returns 0.0 if X is a string or blob that cannot be converted to a numeric value. If X is the integer -9223372036854775808 then abs(X) throws an integer overflow error since there is no equivalent positive 64-bit two complement value."},changes:{args:"()",docs:"The changes() function returns the number of database rows that were changed or inserted or deleted by the most recently completed INSERT, DELETE, or UPDATE statement, exclusive of statements in lower-level triggers. The changes() SQL function is a wrapper around the [sqlite3\\_changes64()](https://www.sqlite.org/c3ref/changes.html) C/C++ function and hence follows the same rules for counting changes."},char:{args:"(X1,X2,...,XN)",docs:"The char(X1,X2,...,XN) function returns a string composed of characters having the unicode code point values of integers X1 through XN, respectively."},coalesce:{args:"(X,Y,...)",docs:"The coalesce() function returns a copy of its first non-NULL argument, or NULL if all arguments are NULL. Coalesce() must have at least 2 arguments."},concat:{args:"(X,...)",docs:"The concat(...) function returns a string which is the concatenation of the string representation of all of its non-NULL arguments. If all arguments are NULL, then concat() returns an empty string."},concat_ws:{args:"(SEP,X,...)",docs:"The concat\\_ws(SEP,...) function returns a string that is the concatenation of all non-null arguments beyond the first argument, using the text value of the first argument as a separator. If the first argument is NULL, then concat\\_ws() returns NULL. If all arguments other than the first are NULL, then concat\\_ws() returns an empty string."},format:{args:"(FORMAT,...)",docs:"The format(FORMAT,...) SQL function works like the [sqlite3\\_mprintf()](https://www.sqlite.org/c3ref/mprintf.html) C-language function and the printf() function from the standard C library. The first argument is a format string that specifies how to construct the output string using values taken from subsequent arguments. If the FORMAT argument is missing or NULL then the result is NULL. The %n format is silently ignored and does not consume an argument. The %p format is an alias for %X. The %z format is interchangeable with %s. If there are too few arguments in the argument list, missing arguments are assumed to have a NULL value, which is translated into 0 or 0.0 for numeric formats or an empty string for %s. See the [built-in printf()](https://www.sqlite.org/printf.html) documentation for additional information."},glob:{args:"(X,Y)",docs:"The glob(X,Y) function is equivalent to the expression \"**Y GLOB X**\". Note that the X and Y arguments are reversed in the glob() function relative to the infix [GLOB](https://www.sqlite.org/lang_expr.html#glob) operator. Y is the string and X is the pattern. So, for example, the following expressions are equivalent:\n\n>      name GLOB '\\*helium\\*'\n>      glob('\\*helium\\*',name)\n>   \n\nIf the [sqlite3\\_create\\_function()](https://www.sqlite.org/c3ref/create_function.html) interface is used to override the glob(X,Y) function with an alternative implementation then the [GLOB](https://www.sqlite.org/lang_expr.html#glob) operator will invoke the alternative implementation."},hex:{args:"(X)",docs:'The hex() function interprets its argument as a BLOB and returns a string which is the upper-case hexadecimal rendering of the content of that blob.\n\nIf the argument _X_ in "hex(_X_)" is an integer or floating point number, then "interprets its argument as a BLOB" means that the binary number is first converted into a UTF8 text representation, then that text is interpreted as a BLOB. Hence, "hex(12345678)" renders as "3132333435363738" not the binary representation of the integer value "0000000000BC614E".\n\nSee also: [unhex()](https://www.sqlite.org/lang_corefunc.html#unhex)'},ifnull:{args:"(X,Y)",docs:"The ifnull() function returns a copy of its first non-NULL argument, or NULL if both arguments are NULL. Ifnull() must have exactly 2 arguments. The ifnull() function is equivalent to [coalesce()](https://www.sqlite.org/lang_corefunc.html#coalesce) with two arguments."},iif:{args:"(X,Y,Z?)",docs:'The iif(B1,V1,...,BN,VN) function takes arguments in pairs. The first argument of each pair is a Boolean and the second argument is a value to return if the Boolean is true. The iif() function returns the value associated with the first true Boolean. If the number of arguments to iif() is odd, then the last argument is a value that returned if all prior Boolean arguments are false. If the number of arguments is even and all Boolean arguments are false, then NULL is returned. The iif() function requires at least two arguments. The iif() function is really a short-hand notation for a [CASE expression](https://www.sqlite.org/lang_expr.html#case). For example, the iif(X,Y,Z) function is logically equivalent to and generates the same [bytecode](https://www.sqlite.org/opcode.html) as the [CASE expression](https://www.sqlite.org/lang_expr.html#case) "CASE WHEN X THEN Y ELSE Z END". The if() function is just an alternative spelling for iif().\n\nThe iif() function uses short-circuit evaluation. Arguments are only evaluated if necessary to compute the final result. So, for example, if one of the value arguments involves an expensive computation (such as an elaborate subquery) but the corresponding Boolean is false, the expensive computation never occurs. Similarly, Boolean arguments past the first one that is true are never evaluated.\n\nThe iif() function originally required exactly three arguments. The two-argument version of iif() and the ability to spell the function as "if()" where features added in SQLite version 3.48.0 (2025-01-14) The ability to accept more than 3 arguments was added in SQLite version 3.49.0 (2025-02-06).'},if:{args:"(X,Y,Z?)",docs:'The iif(B1,V1,...,BN,VN) function takes arguments in pairs. The first argument of each pair is a Boolean and the second argument is a value to return if the Boolean is true. The iif() function returns the value associated with the first true Boolean. If the number of arguments to iif() is odd, then the last argument is a value that returned if all prior Boolean arguments are false. If the number of arguments is even and all Boolean arguments are false, then NULL is returned. The iif() function requires at least two arguments. The iif() function is really a short-hand notation for a [CASE expression](https://www.sqlite.org/lang_expr.html#case). For example, the iif(X,Y,Z) function is logically equivalent to and generates the same [bytecode](https://www.sqlite.org/opcode.html) as the [CASE expression](https://www.sqlite.org/lang_expr.html#case) "CASE WHEN X THEN Y ELSE Z END". The if() function is just an alternative spelling for iif().\n\nThe iif() function uses short-circuit evaluation. Arguments are only evaluated if necessary to compute the final result. So, for example, if one of the value arguments involves an expensive computation (such as an elaborate subquery) but the corresponding Boolean is false, the expensive computation never occurs. Similarly, Boolean arguments past the first one that is true are never evaluated.\n\nThe iif() function originally required exactly three arguments. The two-argument version of iif() and the ability to spell the function as "if()" where features added in SQLite version 3.48.0 (2025-01-14) The ability to accept more than 3 arguments was added in SQLite version 3.49.0 (2025-02-06).'},instr:{args:"(X,Y)",docs:"The instr(X,Y) function finds the first occurrence of string Y within string X and returns the number of prior characters plus 1, or 0 if Y is nowhere found within X. Or, if X and Y are both BLOBs, then instr(X,Y) returns one more than the number bytes prior to the first occurrence of Y, or 0 if Y does not occur anywhere within X. If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs then both are interpreted as strings. If either X or Y are NULL in instr(X,Y) then the result is NULL."},last_insert_rowid:{args:"()",docs:"The last\\_insert\\_rowid() function returns the [ROWID](https://www.sqlite.org/lang_createtable.html#rowid) of the last row insert from the database connection which invoked the function. The last\\_insert\\_rowid() SQL function is a wrapper around the [sqlite3\\_last\\_insert\\_rowid()](https://www.sqlite.org/c3ref/last_insert_rowid.html) C/C++ interface function."},length:{args:"(X)",docs:"For a string value X, the length(X) function returns the number of Unicode code points (not bytes) in input string X prior to the first U+0000 character. Since SQLite strings do not normally contain NUL characters, the length(X) function will usually return the total number of characters in the string X. For a blob value X, length(X) returns the number of bytes in the blob. If X is NULL then length(X) is NULL. If X is numeric then length(X) returns the length of a string representation of X.\n\nNote that for strings, the length(X) function returns the _character_ or _code-point_ length of the string, not the byte length. The character length is the number of characters in the string. The character length is always different from the byte length for UTF-16 strings, and can be different from the byte length for UTF-8 strings if the string contains multi-byte characters. Use the [octet\\_length()](https://www.sqlite.org/lang_corefunc.html#octet_length) function to find the byte length of a string.\n\nFor BLOB values, length(X) always returns the byte-length of the BLOB.\n\nFor string values, length(X) must read the entire string into memory in order to compute the character length. But for BLOB values, reading the whole string into memory is not necessary as SQLite already knows how many bytes are in the BLOB. Hence, for multi-megabyte values, the length(X) function is usually much faster for BLOBs than for strings, since it does not need to load the value into memory."},like:{args:"(X,Y,Z)",docs:"The like() function is used to implement the \"**Y LIKE X \\[ESCAPE Z\\]**\" expression. If the optional ESCAPE clause is present, then the like() function is invoked with three arguments. Otherwise, it is invoked with two arguments only. Note that the X and Y parameters are reversed in the like() function relative to the infix [LIKE](https://www.sqlite.org/lang_expr.html#like) operator. X is the pattern and Y is the string to match against that pattern. Hence, the following expressions are equivalent:\n\n>      name LIKE '%neon%'\n>      like('%neon%',name)\n>   \n\nThe [sqlite3\\_create\\_function()](https://www.sqlite.org/c3ref/create_function.html) interface can be used to override the like() function and thereby change the operation of the [LIKE](https://www.sqlite.org/lang_expr.html#like) operator. When overriding the like() function, it may be important to override both the two and three argument versions of the like() function. Otherwise, different code may be called to implement the [LIKE](https://www.sqlite.org/lang_expr.html#like) operator depending on whether or not an ESCAPE clause was specified."},likelihood:{args:"(X,Y)",docs:"The likelihood(X,Y) function returns argument X unchanged. The value Y in likelihood(X,Y) must be a floating point constant between 0.0 and 1.0, inclusive. The likelihood(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles during run-time (that is, during calls to [sqlite3\\_step()](https://www.sqlite.org/c3ref/step.html)). The purpose of the likelihood(X,Y) function is to provide a hint to the query planner that the argument X is a boolean that is true with a probability of approximately Y. The [unlikely(X)](https://www.sqlite.org/lang_corefunc.html#unlikely) function is short-hand for likelihood(X,0.0625). The [likely(X)](https://www.sqlite.org/lang_corefunc.html#likely) function is short-hand for likelihood(X,0.9375)."},likely:{args:"(X)",docs:"The likely(X) function returns the argument X unchanged. The likely(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles at run-time (that is, during calls to [sqlite3\\_step()](https://www.sqlite.org/c3ref/step.html)). The purpose of the likely(X) function is to provide a hint to the query planner that the argument X is a boolean value that is usually true. The likely(X) function is equivalent to [likelihood](https://www.sqlite.org/lang_corefunc.html#likelihood)(X,0.9375). See also: [unlikely(X)](https://www.sqlite.org/lang_corefunc.html#unlikely)."},load_extension:{args:"(X,Y)",docs:"The load\\_extension(X,Y) function loads [SQLite extensions](https://www.sqlite.org/loadext.html) out of the shared library file named X using the entry point Y. The result of load\\_extension() is always a NULL. If Y is omitted then the default entry point name is used. The load\\_extension() function raises an exception if the extension fails to load or initialize correctly.\n\nThe load\\_extension() function will fail if the extension attempts to modify or delete an SQL function or collating sequence. The extension can add new functions or collating sequences, but cannot modify or delete existing functions or collating sequences because those functions and/or collating sequences might be used elsewhere in the currently running SQL statement. To load an extension that changes or deletes functions or collating sequences, use the [sqlite3\\_load\\_extension()](https://www.sqlite.org/c3ref/load_extension.html) C-language API.\n\nFor security reasons, extension loading is disabled by default and must be enabled by a prior call to [sqlite3\\_enable\\_load\\_extension()](https://www.sqlite.org/c3ref/enable_load_extension.html)."},lower:{args:"(X)",docs:"The lower(X) function returns a copy of string X with all ASCII characters converted to lower case. The default built-in lower() function works for ASCII characters only. To do case conversions on non-ASCII characters, load the ICU extension."},ltrim:{args:"(X,Y)",docs:"The ltrim(X,Y) function returns a string formed by removing any and all characters that appear in Y from the left side of X. If the Y argument is omitted, ltrim(X) removes spaces from the left side of X."},max:{args:"(X)",docs:"The max() aggregate function returns the maximum value of all values in the group. The maximum value is the value that would be returned last in an ORDER BY on the same column. Aggregate max() returns NULL if and only if there are no non-NULL values in the group."},min:{args:"(X)",docs:"The min() aggregate function returns the minimum non-NULL value of all values in the group. The minimum value is the first non-NULL value that would appear in an ORDER BY of the column. Aggregate min() returns NULL if and only if there are no non-NULL values in the group."},nullif:{args:"(X,Y)",docs:"The nullif(X,Y) function returns its first argument if the arguments are different and NULL if the arguments are the same. The nullif(X,Y) function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If neither argument to nullif() defines a collating function then the BINARY collating function is used."},octet_length:{args:"(X)",docs:"The octet\\_length(X) function returns the number of bytes in the encoding of text string X. If X is NULL then octet\\_length(X) returns NULL. If X is a BLOB value, then octet\\_length(X) is the same as [length(X)](https://www.sqlite.org/lang_corefunc.html#length). If X is a numeric value, then octet\\_length(X) returns the number of bytes in a text rendering of that number.\n\nBecause octet\\_length(X) returns the number of bytes in X, not the number of characters or code-points, the value returned depends on the database encoding. The octet\\_length() function can return different answers for the same input string if the database encoding is UTF16 instead of UTF8.\n\nIf argument X is a table column and the value is of type text or blob, then octet\\_length(X) avoids reading the content of X from disk, as the byte length can be computed from metadata. Thus, octet\\_length(X) is efficient even if X is a column containing a multi-megabyte text or blob value."},printf:{args:"(FORMAT,...)",docs:"The printf() SQL function is an alias for the [format() SQL function](https://www.sqlite.org/lang_corefunc.html#format). The format() SQL function was originally named printf(). But the name was later changed to format() for compatibility with other database engines. The printf() name is retained as an alias so as not to break legacy code."},quote:{args:"(X)",docs:"The quote(X) function returns the text of an SQL literal which is the value of its argument suitable for inclusion into an SQL statement. Strings are surrounded by single-quotes with escapes on interior quotes as needed. BLOBs are encoded as hexadecimal literals. Strings with embedded NUL characters cannot be represented as string literals in SQL and hence the returned string literal is truncated prior to the first NUL."},random:{args:"()",docs:"The random() function returns a pseudo-random integer between -9223372036854775808 and +9223372036854775807."},randomblob:{args:"(N)",docs:"The randomblob(N) function return an N-byte blob containing pseudo-random bytes. If N is less than 1 then a 1-byte random blob is returned.\n\nHint: applications can generate globally unique identifiers using this function together with [hex()](https://www.sqlite.org/lang_corefunc.html#hex) and/or [lower()](https://www.sqlite.org/lang_corefunc.html#lower) like this:\n\n> hex(randomblob(16))  \n>   \n> lower(hex(randomblob(16)))"},replace:{args:"(X,Y,Z)",docs:"The replace(X,Y,Z) function returns a string formed by substituting string Z for every occurrence of string Y in string X. The [BINARY](https://www.sqlite.org/datatype3.html#collation) collating sequence is used for comparisons. If Y is an empty string then return X unchanged. If Z is not initially a string, it is cast to a UTF-8 string prior to processing."},round:{args:"(X,Y)",docs:"The round(X,Y) function returns a floating-point value X rounded to Y digits to the right of the decimal point. If the Y argument is omitted or negative, it is taken to be 0."},rtrim:{args:"(X,Y)",docs:"The rtrim(X,Y) function returns a string formed by removing any and all characters that appear in Y from the right side of X. If the Y argument is omitted, rtrim(X) removes spaces from the right side of X."},sign:{args:"(X)",docs:"The sign(X) function returns -1, 0, or +1 if the argument X is a numeric value that is negative, zero, or positive, respectively. If the argument to sign(X) is NULL or is a string or blob that cannot be losslessly converted into a number, then sign(X) returns NULL."},soundex:{args:"(X)",docs:'The soundex(X) function returns a string that is the soundex encoding of the string X. The string "?000" is returned if the argument is NULL or contains no ASCII alphabetic characters. This function is omitted from SQLite by default. It is only available if the [SQLITE\\_SOUNDEX](https://www.sqlite.org/compile.html#soundex) compile-time option is used when SQLite is built.'},sqlite_compileoption_get:{args:"(N)",docs:"The sqlite\\_compileoption\\_get() SQL function is a wrapper around the [sqlite3\\_compileoption\\_get()](https://www.sqlite.org/c3ref/compileoption_get.html) C/C++ function. This routine returns the N-th compile-time option used to build SQLite or NULL if N is out of range. See also the [compile\\_options pragma](https://www.sqlite.org/pragma.html#pragma_compile_options)."},sqlite_compileoption_used:{args:"(X)",docs:"The sqlite\\_compileoption\\_used() SQL function is a wrapper around the [sqlite3\\_compileoption\\_used()](https://www.sqlite.org/c3ref/compileoption_get.html) C/C++ function. When the argument X to sqlite\\_compileoption\\_used(X) is a string which is the name of a compile-time option, this routine returns true (1) or false (0) depending on whether or not that option was used during the build."},sqlite_offset:{args:"(X)",docs:"The sqlite\\_offset(X) function returns the byte offset in the database file for the beginning of the record from which value would be read. If X is not a column in an ordinary table, then sqlite\\_offset(X) returns NULL. The value returned by sqlite\\_offset(X) might reference either the original table or an index, depending on the query. If the value X would normally be extracted from an index, the sqlite\\_offset(X) returns the offset to the corresponding index record. If the value X would be extracted from the original table, then sqlite\\_offset(X) returns the offset to the table record.\n\nThe sqlite\\_offset(X) SQL function is only available if SQLite is built using the [\\-DSQLITE\\_ENABLE\\_OFFSET\\_SQL\\_FUNC](https://www.sqlite.org/compile.html#enable_offset_sql_func) compile-time option."},sqlite_source_id:{args:"()",docs:"The sqlite\\_source\\_id() function returns a string that identifies the specific version of the source code that was used to build the SQLite library. The string returned by sqlite\\_source\\_id() is the date and time that the source code was checked in followed by the SHA3-256 hash for that check-in. This function is an SQL wrapper around the [sqlite3\\_sourceid()](https://www.sqlite.org/c3ref/libversion.html) C interface."},sqlite_version:{args:"()",docs:"The sqlite\\_version() function returns the version string for the SQLite library that is running. This function is an SQL wrapper around the [sqlite3\\_libversion()](https://www.sqlite.org/c3ref/libversion.html) C-interface."},substr:{args:"(X,Y)",docs:'The substr(X,Y,Z) function returns a substring of input string X that begins with the Y-th character and which is Z characters long. If Z is omitted then substr(X,Y) returns all characters through the end of the string X beginning with the Y-th. The left-most character of X is number 1. If Y is negative then the first character of the substring is found by counting from the right rather than the left. If Z is negative then the abs(Z) characters preceding the Y-th character are returned. If X is a string then characters indices refer to actual UTF-8 characters. If X is a BLOB then the indices refer to bytes.\n\n"substring()" is an alias for "substr()" beginning with SQLite version 3.34.'},substring:{args:"(X,Y)",docs:'The substr(X,Y,Z) function returns a substring of input string X that begins with the Y-th character and which is Z characters long. If Z is omitted then substr(X,Y) returns all characters through the end of the string X beginning with the Y-th. The left-most character of X is number 1. If Y is negative then the first character of the substring is found by counting from the right rather than the left. If Z is negative then the abs(Z) characters preceding the Y-th character are returned. If X is a string then characters indices refer to actual UTF-8 characters. If X is a BLOB then the indices refer to bytes.\n\n"substring()" is an alias for "substr()" beginning with SQLite version 3.34.'},total_changes:{args:"()",docs:"The total\\_changes() function returns the number of row changes caused by INSERT, UPDATE or DELETE statements since the current database connection was opened. This function is a wrapper around the [sqlite3\\_total\\_changes64()](https://www.sqlite.org/c3ref/total_changes.html) C/C++ interface."},trim:{args:"(X,Y)",docs:"The trim(X,Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X."},typeof:{args:"(X)",docs:'The typeof(X) function returns a string that indicates the [datatype](https://www.sqlite.org/datatype3.html) of the expression X: "null", "integer", "real", "text", or "blob".'},unhex:{args:"(X,Y)",docs:"The unhex(X,Y) function returns a BLOB value which is the decoding of the hexadecimal string X. If X contains any characters that are not hexadecimal digits and which are not in Y, then unhex(X,Y) returns NULL. If Y is omitted, it is understood to be an empty string and hence X must be a pure hexadecimal string. All hexadecimal digits in X must occur in pairs, with both digits of each pair beginning immediately adjacent to one another, or else unhex(X,Y) returns NULL. If either parameter X or Y is NULL, then unhex(X,Y) returns NULL. The X input may contain an arbitrary mix of upper and lower case hexadecimal digits. Hexadecimal digits in Y have no affect on the translation of X. Only characters in Y that are not hexadecimal digits are ignored in X.\n\nSee also: [hex()](https://www.sqlite.org/lang_corefunc.html#hex)"},unicode:{args:"(X)",docs:"The unicode(X) function returns the numeric unicode code point corresponding to the first character of the string X. If the argument to unicode(X) is not a string then the result is undefined."},unlikely:{args:"(X)",docs:"The unlikely(X) function returns the argument X unchanged. The unlikely(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles at run-time (that is, during calls to [sqlite3\\_step()](https://www.sqlite.org/c3ref/step.html)). The purpose of the unlikely(X) function is to provide a hint to the query planner that the argument X is a boolean value that is usually not true. The unlikely(X) function is equivalent to [likelihood](https://www.sqlite.org/lang_corefunc.html#likelihood)(X, 0.0625)."},upper:{args:"(X)",docs:"The upper(X) function returns a copy of input string X in which all lower-case ASCII characters are converted to their upper-case equivalent."},zeroblob:{args:"(N)",docs:"The zeroblob(N) function returns a BLOB consisting of N bytes of 0x00. SQLite manages these zeroblobs very efficiently. Zeroblobs can be used to reserve space for a BLOB that is later written using [incremental BLOB I/O](https://www.sqlite.org/c3ref/blob_open.html). This SQL function is implemented using the [sqlite3\\_result\\_zeroblob()](https://www.sqlite.org/c3ref/result_blob.html) routine from the C/C++ interface."},date:{args:"(time-value, modifier, modifier, ...)",docs:'1\\. Overview SQLite supports seven [scalar](https://www.sqlite.org/lang_corefunc.html) date and time functions as follows:*   **date(**_time-value, modifier, modifier, ..._**)**\n*   **time(**_time-value, modifier, modifier, ..._**)**\n*   **datetime(**_time-value, modifier, modifier, ..._**)**\n*   **julianday(**_time-value, modifier, modifier, ..._**)**\n*   **unixepoch(**_time-value, modifier, modifier, ..._**)**\n*   **strftime(**_format, time-value, modifier, modifier, ..._**)**\n*   **timediff(**_time-value, time-value_**)**\nThe first six date and time functions take an optional [time-value](https://www.sqlite.org/lang_datefunc.html#tmval) as an argument, followed by zero or more [modifiers](https://www.sqlite.org/lang_datefunc.html#dtmods). The strftime() function also takes a format string as its first argument. The timediff() function takes exactly two arguments which are both [time-values](https://www.sqlite.org/lang_datefunc.html#tmval). SQLite does not have a dedicated date/time datatype. Instead, date and time values can stored as any of the following:\n\n<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><a href="http://en.wikipedia.org/wiki/ISO_8601">ISO-8601</a></td><td>A text string that is one of the ISO 8601 date/time values shown in <a href="about:blank#tmval">items 1 through 10 below</a>. Example: <tt>\'2025-05-29 14:16:00\'</tt></td></tr><tr><td><a href="http://en.wikipedia.org/wiki/Julian_day">Julian&nbsp;day&nbsp;number</a></td><td>The number of days including fractional days since -4713-11-24 12:00:00 Example: <tt>2460825.09444444</tt></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Unix_time">Unix timestamp</a></td><td>The number of seconds including fractional seconds since 1970-01-01 00:00:00 Example: <tt>1748528160</tt></td></tr></tbody></table>\n\nThese three formats are collectively known as [time-values](https://www.sqlite.org/lang_datefunc.html#tmval). All of the date time functions accept time-values as either ISO-8601 text or as Julian day numbers. They can also be made to accept unix timestamps by adding optional modifiers arguments [\'auto\'](https://www.sqlite.org/lang_datefunc.html#automod) or [\'unixepoch\'](https://www.sqlite.org/lang_datefunc.html#jdmod). Since the timediff() function does not accept modifiers, it can only use ISO-8601 and julian day number time-values. The **date()** function returns the date as text in this format: YYYY-MM-DD. The **time()** function returns the time as text in formatted as HH:MM:SS or as HH:MM:SS.SSS if the [subsec modifier](https://www.sqlite.org/lang_datefunc.html#subsec) is used. The **datetime()** function returns the date and time formatted as YYYY-MM-DD HH:MM:SS or as YYYY-MM-DD HH:MM:SS.SSS if the [subsec modifier](https://www.sqlite.org/lang_datefunc.html#subsec) is used. The **julianday()** function returns the [Julian day](http://en.wikipedia.org/wiki/Julian_day) - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. ([Proleptic Gregorian calendar](http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar)). The **unixepoch()** function returns a unix timestamp - the number of seconds since 1970-01-01 00:00:00 UTC. The unixepoch() function normally returns an integer number of seconds, but with the optional [subsec modifier](https://www.sqlite.org/lang_datefunc.html#subsec) it will return a floating point number which is the fractional number of seconds. The **strftime()** function returns the date formatted according to the format string specified as the first argument. The format string supports the most common substitutions found in the [strftime() function](http://opengroup.org/onlinepubs/007908799/xsh/strftime.html) from the standard C library plus two new substitutions, %f and %J. The following is a complete list of valid strftime() substitutions as of version 3.46.0 (2024-05-23). Earlier versions of SQLite might not support all substitutions. If an undefined or unsupported substitution is seen, the result is NULL.\n\n<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td></td><td width="10"></td><td></td></tr><tr><td>%d</td><td></td><td>day of month: 01-31</td></tr><tr><td>%e</td><td></td><td>day of month without leading zero: 1-31</td></tr><tr><td>%f</td><td></td><td>fractional seconds: SS.SSS</td></tr><tr><td>%F</td><td></td><td>ISO 8601 date: YYYY-MM-DD</td></tr><tr><td>%G</td><td></td><td>ISO 8601 year corresponding to %V</td></tr><tr><td>%g</td><td></td><td>2-digit ISO 8601 year corresponding to %V</td></tr><tr><td>%H</td><td></td><td>hour: 00-24</td></tr><tr><td>%I</td><td></td><td>hour for 12-hour clock: 01-12</td></tr><tr><td>%j</td><td></td><td>day of year: 001-366</td></tr><tr><td>%J</td><td></td><td>Julian day number (fractional)</td></tr><tr><td>%k</td><td></td><td>hour without leading zero: 0-24</td></tr><tr><td>%l</td><td></td><td>%I without leading zero: 1-12</td></tr><tr><td>%m</td><td></td><td>month: 01-12</td></tr><tr><td>%M</td><td></td><td>minute: 00-59</td></tr><tr><td>%p</td><td></td><td>"AM" or "PM" depending on the hour</td></tr><tr><td>%P</td><td></td><td>"am" or "pm" depending on the hour</td></tr><tr><td>%R</td><td></td><td>ISO 8601 time: HH:MM</td></tr><tr><td>%s</td><td></td><td>seconds since 1970-01-01</td></tr><tr><td>%S</td><td></td><td>seconds: 00-59</td></tr><tr><td>%T</td><td></td><td>ISO 8601 time: HH:MM:SS</td></tr><tr><td>%U</td><td></td><td>week of year (00-53) - week 01 starts on the first Sunday</td></tr><tr><td>%u</td><td></td><td>day of week 1-7 with Monday==1</td></tr><tr><td>%V</td><td></td><td>ISO 8601 week of year</td></tr><tr><td>%w</td><td></td><td>day of week 0-6 with Sunday==0</td></tr><tr><td>%W</td><td></td><td>week of year (00-53) - week 01 starts on the first Monday</td></tr><tr><td>%Y</td><td></td><td>year: 0000-9999</td></tr><tr><td>%%</td><td></td><td>%</td></tr></tbody></table>\n\nOther date and time functions can be expressed in terms of strftime():\n\n<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><b>Function</b></td><td width="30"></td><td><b>Equivalent strftime()</b></td></tr><tr><td>date(...)</td><td></td><td>strftime(\'%F\', ...)</td></tr><tr><td>time(...)</td><td></td><td>strftime(\'%T\', ...)</td></tr><tr><td>datetime(...)</td><td></td><td>strftime(\'%F %T\', ...)</td></tr><tr><td>julianday(...)</td><td></td><td><nobr>CAST(strftime(\'%J\', ...) as REAL)</nobr></td></tr><tr><td>unixepoch(...)</td><td></td><td><nobr>CAST(strftime(\'%s\', ...) as INT)</nobr></td></tr></tbody></table>\n\nThe date(), time(), and datetime() functions all return text, and so their strftime() equivalents are exact. However, the julianday() and unixepoch() functions return numeric values. Their strftime() equivalents return a string that is the text representation of the corresponding number. The main reasons for providing functions other than strftime() are for convenience and for efficiency. The julianday() and unixepoch() functions return real and integer values respectively, and do not incur the format conversion costs or inexactitude resulting from use of the \'%J\' or \'%s\' format specifiers with the strftime() function. The **timediff(A,B)** function returns a string that describes the amount of time that must be added to B in order to reach time A. The format of the timediff() result is designed to be human-readable. The format is: (+|-)YYYY-MM-DD HH:MM:SS.SSS This time difference string is also an allowed modifier for the other date/time functions. The following invariant holds for time-values A and B: datetime(A) = datetime(B, timediff(A,B)) The length of months and years vary. February is shorter than March. Leap years are longer than non-leap years. The output from timediff() takes this all into account. The timediff() function is intended to provide a human-friendly description of the time span. If you want to know the number of days or seconds between two dates, A and B, then you can always do one of these: SELECT julianday(B) - julianday(A);  \nSELECT unixepoch(B) - unixepoch(A); The timediff(A,B) might return the same result even for values A and B that span a different number of days - depending on the starting date. For example, both of the following two timediff() calls return the same result ("-0000-01-00 00:00:00.000") even though the first timespan is 28 days and the seconds is 31 days: SELECT timediff(\'2023-02-15\',\'2023-03-15\');  \nSELECT timediff(\'2023-03-15\',\'2023-04-15\'); Summary: If you want a human-friendly time span, use timediff(). If you want a precise time difference (in days or seconds) use the difference between two julianday() or unixepoch() calls. 2\\. Time ValuesA time-value can be in any of the following formats shown below. The value is usually a string, though it can be an integer or floating point number in the case of format 12.*   _YYYY-MM-DD_\n*   _YYYY-MM-DD HH:MM_\n*   _YYYY-MM-DD HH:MM:SS_\n*   _YYYY-MM-DD HH:MM:SS.SSS_\n*   _YYYY-MM-DD_**T**_HH:MM_\n*   _YYYY-MM-DD_**T**_HH:MM:SS_\n*   _YYYY-MM-DD_**T**_HH:MM:SS.SSS_\n*   _HH:MM_\n*   _HH:MM:SS_\n*   _HH:MM:SS.SSS_\n*   **now**\n*   _DDDDDDDDDD_\nIn formats 5 through 7, the "T" is a literal character separating the date and the time, as required by [ISO-8601](http://www.w3c.org/TR/NOTE-datetime). Formats 8 through 10 that specify only a time assume a date of 2000-01-01. Format 11, the string \'now\', is converted into the current date and time as obtained from the xCurrentTime method of the [sqlite3\\_vfs](https://www.sqlite.org/c3ref/vfs.html) object in use. The \'now\' argument to date and time functions always returns exactly the same value for multiple invocations within the same [sqlite3\\_step()](https://www.sqlite.org/c3ref/step.html) call. [Universal Coordinated Time (UTC)](http://en.wikipedia.org/wiki/Coordinated_Universal_Time) is used. Format 12 is the [Julian day number](http://en.wikipedia.org/wiki/Julian_day) expressed as an integer or floating point value. Format 12 might also be interpreted as a unix timestamp if it is immediately followed either the [\'auto\'](https://www.sqlite.org/lang_datefunc.html#automod) or [\'unixepoch\'](https://www.sqlite.org/lang_datefunc.html#jdmod) modifier. Formats 2 through 10 may be optionally followed by a timezone indicator of the form "_\\[+-\\]HH:MM_" or just "_Z_". The date and time functions use UTC or "zulu" time internally, and so the "Z" suffix is a no-op. Any non-zero "HH:MM" suffix is subtracted from the indicated date and time in order to compute zulu time. For example, all of the following time-values are equivalent: 2013-10-07 08:23:19.120  \n2013-10-07T08:23:19.120Z  \n2013-10-07 04:23:19.120-04:00  \n2456572.84952685 In formats 4, 7, and 10, the fractional seconds value SS.SSS can have one or more digits following the decimal point. Exactly three digits are shown in the examples because only the first three digits are significant to the result, but the input string can have fewer or more than three digits and the date/time functions will still operate correctly. Similarly, format 12 is shown with 10 significant digits, but the date/time functions will really accept as many or as few digits as are necessary to represent the Julian day number. [ISO-8601](http://www.w3c.org/TR/NOTE-datetime) supports a wide variety of alternative date/time formats, but SQLite only supports the ones specifically enumerated above. In all functions other than timediff(), the time-value (and all modifiers) may be omitted, in which case a time value of \'now\' is assumed. 3\\. ModifiersFor all date/time functions other than timediff(), the time-value argument can be followed by zero or more modifiers that alter date and/or time. Each modifier is a transformation that is applied to the time-value to its left. Modifiers are applied from left to right; order is important. The available modifiers are as follows.*   NNN days\n*   NNN hours\n*   NNN minutes\n*   NNN seconds\n*   NNN months\n*   NNN years\n*   ±HH:MM\n*   ±HH:MM:SS\n*   ±HH:MM:SS.SSS\n*   ±YYYY-MM-DD\n*   ±YYYY-MM-DD HH:MM\n*   ±YYYY-MM-DD HH:MM:SS\n*   ±YYYY-MM-DD HH:MM:SS.SSS\n*   ceiling\n*   floor\n*   start of month\n*   start of year\n*   start of day\n*   weekday N\n*   unixepoch\n*   julianday\n*   auto\n*   localtime\n*   utc\n*   subsec\n*   subsecond\nThe first thirteen modifiers (1 through 13) add the specified amount of time to the date and time specified by the arguments to its left. The \'s\' character at the end of the modifier names in 1 through 6 is optional. The NNN value can be any floating point number, with an optional \'+\' or \'-\' prefix. The **time shift modifiers** (7 through 13) move the time-value by the number of years, months, days, hours, minutes, and/or seconds specified. An initial "+" or "-" is required for formats 10 through 13 but is optional for formats 7, 8, and 9. The changes are applies from left to right. First the year is shifted by YYYY, then the month by MM, and then day by DD, and so forth. The timediff(A,B) function returns a time shift in format 13 that shifts the time-value B into A.Because the length of a month or year changes from one month or year to the next, ambiguities can arise when shifting a date by months and/or years. For example, what is the date one year after 2024-02-29? Is it 2025-02-28 or 2025-03-01? Or what is the date that is two months after 2023-12-31? Is it 2024-02-29 or 2024-03-02? There is no consensus on how to resolve this ambiguity, so the "**ceiling**" and "**floor**" modifiers (14 and 15) are available to let the programmer decide. If the next modifier after a time shift is "ceiling", then any ambiguity in the date is resolved by choosing the later date. The "floor" modifier resolves ambiguities by resolving to the last day of the previous month. The default behavior is "ceiling". The "**start of**" modifiers (16 through 18) shift the date backwards to the beginning of the subject month, year or day.The "**weekday**" modifier advances the date forward, if necessary, to the next date where the weekday number is N. Sunday is 0, Monday is 1, and so forth. If the date is already on the desired weekday, the "weekday" modifier leaves the date unchanged. The "**unixepoch**" modifier (20) only works if it immediately follows a time-value in the DDDDDDDDDD format. This modifier causes the DDDDDDDDDD to be interpreted not as a Julian day number as it normally would be, but as [Unix Time](http://en.wikipedia.org/wiki/Unix_time) - the number of seconds since 1970. If the "unixepoch" modifier does not follow a time-value of the form DDDDDDDDDD which expresses the number of seconds since 1970 or if other modifiers separate the "unixepoch" modifier from prior DDDDDDDDDD then the behavior is undefined. The "**julianday**" modifier must immediately follow the initial time-value which must be of the form DDDDDDDDD. Any other use of the \'julianday\' modifier is an error and causes the function to return NULL. The \'julianday\' modifier forces the time-value number to be interpreted as a julian-day number. As this is the default behavior, the \'julianday\' modifier is scarcely more than a no-op. The only difference is that adding \'julianday\' forces the DDDDDDDDD time-value format, and causes a NULL to be returned if any other time-value format is used. The "**auto**" modifier must immediately follow the initial time-value. If the time-value is numeric (the DDDDDDDDDD format) then the \'auto\' modifier causes the time-value to interpreted as either a julian day number or a unix timestamp, depending on its magnitude. If the value is between 0.0 and 5373484.499999, then it is interpreted as a julian day number (corresponding to dates between -4713-11-24 12:00:00 and 9999-12-31 23:59:59, inclusive). For numeric values outside of the range of valid julian day numbers, but within the range of -210866760000 to 253402300799, the \'auto\' modifier causes the value to be interpreted as a unix timestamp. Other numeric values are out of range and cause a NULL return. The \'auto\' modifier is a no-op for ISO 8601 text time-values. The "auto" modifier is designed to work with time-values even in cases where it is not known which time-value format is stored in the database file, or in cases where the same column stores time-values in different formats on different rows. The \'auto\' modifier will automatically select the appropriate format. However, there is some ambiguity. Unix timestamps for the first 63 days of 1970 will be interpreted as julian day numbers. The \'auto\' modifier is very useful when the dataset is guaranteed to contain no dates within that range, but should be avoided for applications that might make use of dates in the opening months of 1970. The "**localtime**" modifier assumes the time-value to its left is in Universal Coordinated Time (UTC) and adjusts that time value so that it is in localtime. If "localtime" follows a time that is not UTC, then the behavior is undefined. The "**utc**" modifier is the opposite of "localtime". "utc" assumes that the time-value to its left is in the local timezone and adjusts that time-value to be in UTC. If the time to the left is not in localtime, then the result of "utc" is undefined. The "**subsecond**" modifier (which may be abbreviated as just "**subsec**") increases the resolution of the output for [datetime()](https://www.sqlite.org/lang_datefunc.html#dttm), [time()](https://www.sqlite.org/lang_datefunc.html#dttm), and [unixepoch()](https://www.sqlite.org/lang_datefunc.html#uepch), and for the "%s" format string in [strftime()](https://www.sqlite.org/lang_datefunc.html#strftm). The "subsecond" modifier has no effect on other date/time functions. The current implemention increases the resolution from seconds to milliseconds, but this might increase to a higher resolution in future releases of SQLite. When "subsec" is used with [datetime()](https://www.sqlite.org/lang_datefunc.html#dttm) or [time()](https://www.sqlite.org/lang_datefunc.html#dttm), the seconds field at the end is followed by a decimal point and one or more digits to show fractional seconds. When "subsec" is used with [unixepoch()](https://www.sqlite.org/lang_datefunc.html#uepch), the result is a floating point value which is the number of seconds and fractional seconds since 1970-01-01. The "subsecond" and "subsec" modifiers have the special property that they can occur as the first argument to date/time functions (or as the first argument after the format string for strftime()). When this happens, the time-value that is normally in the first argument is understood to be "now". For example, a short cut to get the current time in seconds since 1970 with millisecond precision is to say: SELECT unixepoch(\'subsec\'); 4\\. ExamplesCompute the current date. SELECT date();Compute the last day of the current month.SELECT date(\'now\',\'start of month\',\'+1 month\',\'-1 day\'); Compute the date and time given a unix timestamp 1092941466. SELECT datetime(1092941466, \'unixepoch\');  \nSELECT datetime(1092941466, \'auto\'); -- Does not work for early 1970! Compute the date and time given a unix timestamp 1092941466, and compensate for your local timezone. SELECT datetime(1092941466, \'unixepoch\', \'localtime\'); Compute the current unix timestamp. SELECT unixepoch();  \nSELECT strftime(\'%s\'); Compute the number of days since the signing of the US Declaration of Independence. SELECT julianday(\'now\') - julianday(\'1776-07-04\'); Compute the number of seconds since a particular moment in 2004: SELECT unixepoch() - unixepoch(\'2004-01-01 02:34:56\'); Compute the date of the first Tuesday in October for the current year. SELECT date(\'now\',\'start of year\',\'+9 months\',\'weekday 2\'); Compute the time since the unix epoch in seconds with millisecond precision: SELECT (julianday(\'now\') - 2440587.5)\\*86400.0;  \nSELECT unixepoch(\'now\',\'subsec\'); Compute how old Abraham Lincoln would be if he were still alive today: SELECT timediff(\'now\',\'1809-02-12\'); 5\\. Caveats And BugsThe computation of local time depends heavily on the whim of politicians and is thus difficult to get correct for all locales. In this implementation, the standard C library function localtime\\_r() is used to assist in the calculation of local time. The localtime\\_r() C function normally only works for years between 1970 and 2037. For dates outside this range, SQLite attempts to map the year into an equivalent year within this range, do the calculation, then map the year back.These functions only work for dates between 0000-01-01 00:00:00 and 9999-12-31 23:59:59 (julian day numbers 1721059.5 through 5373484.5). For dates outside that range, the results of these functions are undefined.Non-Vista Windows platforms only support one set of DST rules. Vista only supports two. Therefore, on these platforms, historical DST calculations will be incorrect. For example, in the US, in 2007 the DST rules changed. Non-Vista Windows platforms apply the new 2007 DST rules to all previous years as well. Vista does somewhat better getting results correct back to 1986, when the rules were also changed.All internal computations assume the [Gregorian calendar](http://en.wikipedia.org/wiki/Gregorian_calendar) system. They also assume that every day is exactly 86400 seconds in duration; no leap seconds are incorporated.'},time:{args:"(time-value, modifier, modifier, ...)",docs:'1\\. Overview SQLite supports seven [scalar](https://www.sqlite.org/lang_corefunc.html) date and time functions as follows:*   **date(**_time-value, modifier, modifier, ..._**)**\n*   **time(**_time-value, modifier, modifier, ..._**)**\n*   **datetime(**_time-value, modifier, modifier, ..._**)**\n*   **julianday(**_time-value, modifier, modifier, ..._**)**\n*   **unixepoch(**_time-value, modifier, modifier, ..._**)**\n*   **strftime(**_format, time-value, modifier, modifier, ..._**)**\n*   **timediff(**_time-value, time-value_**)**\nThe first six date and time functions take an optional [time-value](https://www.sqlite.org/lang_datefunc.html#tmval) as an argument, followed by zero or more [modifiers](https://www.sqlite.org/lang_datefunc.html#dtmods). The strftime() function also takes a format string as its first argument. The timediff() function takes exactly two arguments which are both [time-values](https://www.sqlite.org/lang_datefunc.html#tmval). SQLite does not have a dedicated date/time datatype. Instead, date and time values can stored as any of the following:\n\n<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><a href="http://en.wikipedia.org/wiki/ISO_8601">ISO-8601</a></td><td>A text string that is one of the ISO 8601 date/time values shown in <a href="about:blank#tmval">items 1 through 10 below</a>. Example: <tt>\'2025-05-29 14:16:00\'</tt></td></tr><tr><td><a href="http://en.wikipedia.org/wiki/Julian_day">Julian&nbsp;day&nbsp;number</a></td><td>The number of days including fractional days since -4713-11-24 12:00:00 Example: <tt>2460825.09444444</tt></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Unix_time">Unix timestamp</a></td><td>The number of seconds including fractional seconds since 1970-01-01 00:00:00 Example: <tt>1748528160</tt></td></tr></tbody></table>\n\nThese three formats are collectively known as [time-values](https://www.sqlite.org/lang_datefunc.html#tmval). All of the date time functions accept time-values as either ISO-8601 text or as Julian day numbers. They can also be made to accept unix timestamps by adding optional modifiers arguments [\'auto\'](https://www.sqlite.org/lang_datefunc.html#automod) or [\'unixepoch\'](https://www.sqlite.org/lang_datefunc.html#jdmod). Since the timediff() function does not accept modifiers, it can only use ISO-8601 and julian day number time-values. The **date()** function returns the date as text in this format: YYYY-MM-DD. The **time()** function returns the time as text in formatted as HH:MM:SS or as HH:MM:SS.SSS if the [subsec modifier](https://www.sqlite.org/lang_datefunc.html#subsec) is used. The **datetime()** function returns the date and time formatted as YYYY-MM-DD HH:MM:SS or as YYYY-MM-DD HH:MM:SS.SSS if the [subsec modifier](https://www.sqlite.org/lang_datefunc.html#subsec) is used. The **julianday()** function returns the [Julian day](http://en.wikipedia.org/wiki/Julian_day) - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. ([Proleptic Gregorian calendar](http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar)). The **unixepoch()** function returns a unix timestamp - the number of seconds since 1970-01-01 00:00:00 UTC. The unixepoch() function normally returns an integer number of seconds, but with the optional [subsec modifier](https://www.sqlite.org/lang_datefunc.html#subsec) it will return a floating point number which is the fractional number of seconds. The **strftime()** function returns the date formatted according to the format string specified as the first argument. The format string supports the most common substitutions found in the [strftime() function](http://opengroup.org/onlinepubs/007908799/xsh/strftime.html) from the standard C library plus two new substitutions, %f and %J. The following is a complete list of valid strftime() substitutions as of version 3.46.0 (2024-05-23). Earlier versions of SQLite might not support all substitutions. If an undefined or unsupported substitution is seen, the result is NULL.\n\n<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td></td><td width="10"></td><td></td></tr><tr><td>%d</td><td></td><td>day of month: 01-31</td></tr><tr><td>%e</td><td></td><td>day of month without leading zero: 1-31</td></tr><tr><td>%f</td><td></td><td>fractional seconds: SS.SSS</td></tr><tr><td>%F</td><td></td><td>ISO 8601 date: YYYY-MM-DD</td></tr><tr><td>%G</td><td></td><td>ISO 8601 year corresponding to %V</td></tr><tr><td>%g</td><td></td><td>2-digit ISO 8601 year corresponding to %V</td></tr><tr><td>%H</td><td></td><td>hour: 00-24</td></tr><tr><td>%I</td><td></td><td>hour for 12-hour clock: 01-12</td></tr><tr><td>%j</td><td></td><td>day of year: 001-366</td></tr><tr><td>%J</td><td></td><td>Julian day number (fractional)</td></tr><tr><td>%k</td><td></td><td>hour without leading zero: 0-24</td></tr><tr><td>%l</td><td></td><td>%I without leading zero: 1-12</td></tr><tr><td>%m</td><td></td><td>month: 01-12</td></tr><tr><td>%M</td><td></td><td>minute: 00-59</td></tr><tr><td>%p</td><td></td><td>"AM" or "PM" depending on the hour</td></tr><tr><td>%P</td><td></td><td>"am" or "pm" depending on the hour</td></tr><tr><td>%R</td><td></td><td>ISO 8601 time: HH:MM</td></tr><tr><td>%s</td><td></td><td>seconds since 1970-01-01</td></tr><tr><td>%S</td><td></td><td>seconds: 00-59</td></tr><tr><td>%T</td><td></td><td>ISO 8601 time: HH:MM:SS</td></tr><tr><td>%U</td><td></td><td>week of year (00-53) - week 01 starts on the first Sunday</td></tr><tr><td>%u</td><td></td><td>day of week 1-7 with Monday==1</td></tr><tr><td>%V</td><td></td><td>ISO 8601 week of year</td></tr><tr><td>%w</td><td></td><td>day of week 0-6 with Sunday==0</td></tr><tr><td>%W</td><td></td><td>week of year (00-53) - week 01 starts on the first Monday</td></tr><tr><td>%Y</td><td></td><td>year: 0000-9999</td></tr><tr><td>%%</td><td></td><td>%</td></tr></tbody></table>\n\nOther date and time functions can be expressed in terms of strftime():\n\n<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><b>Function</b></td><td width="30"></td><td><b>Equivalent strftime()</b></td></tr><tr><td>date(...)</td><td></td><td>strftime(\'%F\', ...)</td></tr><tr><td>time(...)</td><td></td><td>strftime(\'%T\', ...)</td></tr><tr><td>datetime(...)</td><td></td><td>strftime(\'%F %T\', ...)</td></tr><tr><td>julianday(...)</td><td></td><td><nobr>CAST(strftime(\'%J\', ...) as REAL)</nobr></td></tr><tr><td>unixepoch(...)</td><td></td><td><nobr>CAST(strftime(\'%s\', ...) as INT)</nobr></td></tr></tbody></table>\n\nThe date(), time(), and datetime() functions all return text, and so their strftime() equivalents are exact. However, the julianday() and unixepoch() functions return numeric values. Their strftime() equivalents return a string that is the text representation of the corresponding number. The main reasons for providing functions other than strftime() are for convenience and for efficiency. The julianday() and unixepoch() functions return real and integer values respectively, and do not incur the format conversion costs or inexactitude resulting from use of the \'%J\' or \'%s\' format specifiers with the strftime() function. The **timediff(A,B)** function returns a string that describes the amount of time that must be added to B in order to reach time A. The format of the timediff() result is designed to be human-readable. The format is: (+|-)YYYY-MM-DD HH:MM:SS.SSS This time difference string is also an allowed modifier for the other date/time functions. The following invariant holds for time-values A and B: datetime(A) = datetime(B, timediff(A,B)) The length of months and years vary. February is shorter than March. Leap years are longer than non-leap years. The output from timediff() takes this all into account. The timediff() function is intended to provide a human-friendly description of the time span. If you want to know the number of days or seconds between two dates, A and B, then you can always do one of these: SELECT julianday(B) - julianday(A);  \nSELECT unixepoch(B) - unixepoch(A); The timediff(A,B) might return the same result even for values A and B that span a different number of days - depending on the starting date. For example, both of the following two timediff() calls return the same result ("-0000-01-00 00:00:00.000") even though the first timespan is 28 days and the seconds is 31 days: SELECT timediff(\'2023-02-15\',\'2023-03-15\');  \nSELECT timediff(\'2023-03-15\',\'2023-04-15\'); Summary: If you want a human-friendly time span, use timediff(). If you want a precise time difference (in days or seconds) use the difference between two julianday() or unixepoch() calls. 2\\. Time ValuesA time-value can be in any of the following formats shown below. The value is usually a string, though it can be an integer or floating point number in the case of format 12.*   _YYYY-MM-DD_\n*   _YYYY-MM-DD HH:MM_\n*   _YYYY-MM-DD HH:MM:SS_\n*   _YYYY-MM-DD HH:MM:SS.SSS_\n*   _YYYY-MM-DD_**T**_HH:MM_\n*   _YYYY-MM-DD_**T**_HH:MM:SS_\n*   _YYYY-MM-DD_**T**_HH:MM:SS.SSS_\n*   _HH:MM_\n*   _HH:MM:SS_\n*   _HH:MM:SS.SSS_\n*   **now**\n*   _DDDDDDDDDD_\nIn formats 5 through 7, the "T" is a literal character separating the date and the time, as required by [ISO-8601](http://www.w3c.org/TR/NOTE-datetime). Formats 8 through 10 that specify only a time assume a date of 2000-01-01. Format 11, the string \'now\', is converted into the current date and time as obtained from the xCurrentTime method of the [sqlite3\\_vfs](https://www.sqlite.org/c3ref/vfs.html) object in use. The \'now\' argument to date and time functions always returns exactly the same value for multiple invocations within the same [sqlite3\\_step()](https://www.sqlite.org/c3ref/step.html) call. [Universal Coordinated Time (UTC)](http://en.wikipedia.org/wiki/Coordinated_Universal_Time) is used. Format 12 is the [Julian day number](http://en.wikipedia.org/wiki/Julian_day) expressed as an integer or floating point value. Format 12 might also be interpreted as a unix timestamp if it is immediately followed either the [\'auto\'](https://www.sqlite.org/lang_datefunc.html#automod) or [\'unixepoch\'](https://www.sqlite.org/lang_datefunc.html#jdmod) modifier. Formats 2 through 10 may be optionally followed by a timezone indicator of the form "_\\[+-\\]HH:MM_" or just "_Z_". The date and time functions use UTC or "zulu" time internally, and so the "Z" suffix is a no-op. Any non-zero "HH:MM" suffix is subtracted from the indicated date and time in order to compute zulu time. For example, all of the following time-values are equivalent: 2013-10-07 08:23:19.120  \n2013-10-07T08:23:19.120Z  \n2013-10-07 04:23:19.120-04:00  \n2456572.84952685 In formats 4, 7, and 10, the fractional seconds value SS.SSS can have one or more digits following the decimal point. Exactly three digits are shown in the examples because only the first three digits are significant to the result, but the input string can have fewer or more than three digits and the date/time functions will still operate correctly. Similarly, format 12 is shown with 10 significant digits, but the date/time functions will really accept as many or as few digits as are necessary to represent the Julian day number. [ISO-8601](http://www.w3c.org/TR/NOTE-datetime) supports a wide variety of alternative date/time formats, but SQLite only supports the ones specifically enumerated above. In all functions other than timediff(), the time-value (and all modifiers) may be omitted, in which case a time value of \'now\' is assumed. 3\\. ModifiersFor all date/time functions other than timediff(), the time-value argument can be followed by zero or more modifiers that alter date and/or time. Each modifier is a transformation that is applied to the time-value to its left. Modifiers are applied from left to right; order is important. The available modifiers are as follows.*   NNN days\n*   NNN hours\n*   NNN minutes\n*   NNN seconds\n*   NNN months\n*   NNN years\n*   ±HH:MM\n*   ±HH:MM:SS\n*   ±HH:MM:SS.SSS\n*   ±YYYY-MM-DD\n*   ±YYYY-MM-DD HH:MM\n*   ±YYYY-MM-DD HH:MM:SS\n*   ±YYYY-MM-DD HH:MM:SS.SSS\n*   ceiling\n*   floor\n*   start of month\n*   start of year\n*   start of day\n*   weekday N\n*   unixepoch\n*   julianday\n*   auto\n*   localtime\n*   utc\n*   subsec\n*   subsecond\nThe first thirteen modifiers (1 through 13) add the specified amount of time to the date and time specified by the arguments to its left. The \'s\' character at the end of the modifier names in 1 through 6 is optional. The NNN value can be any floating point number, with an optional \'+\' or \'-\' prefix. The **time shift modifiers** (7 through 13) move the time-value by the number of years, months, days, hours, minutes, and/or seconds specified. An initial "+" or "-" is required for formats 10 through 13 but is optional for formats 7, 8, and 9. The changes are applies from left to right. First the year is shifted by YYYY, then the month by MM, and then day by DD, and so forth. The timediff(A,B) function returns a time shift in format 13 that shifts the time-value B into A.Because the length of a month or year changes from one month or year to the next, ambiguities can arise when shifting a date by months and/or years. For example, what is the date one year after 2024-02-29? Is it 2025-02-28 or 2025-03-01? Or what is the date that is two months after 2023-12-31? Is it 2024-02-29 or 2024-03-02? There is no consensus on how to resolve this ambiguity, so the "**ceiling**" and "**floor**" modifiers (14 and 15) are available to let the programmer decide. If the next modifier after a time shift is "ceiling", then any ambiguity in the date is resolved by choosing the later date. The "floor" modifier resolves ambiguities by resolving to the last day of the previous month. The default behavior is "ceiling". The "**start of**" modifiers (16 through 18) shift the date backwards to the beginning of the subject month, year or day.The "**weekday**" modifier advances the date forward, if necessary, to the next date where the weekday number is N. Sunday is 0, Monday is 1, and so forth. If the date is already on the desired weekday, the "weekday" modifier leaves the date unchanged. The "**unixepoch**" modifier (20) only works if it immediately follows a time-value in the DDDDDDDDDD format. This modifier causes the DDDDDDDDDD to be interpreted not as a Julian day number as it normally would be, but as [Unix Time](http://en.wikipedia.org/wiki/Unix_time) - the number of seconds since 1970. If the "unixepoch" modifier does not follow a time-value of the form DDDDDDDDDD which expresses the number of seconds since 1970 or if other modifiers separate the "unixepoch" modifier from prior DDDDDDDDDD then the behavior is undefined. The "**julianday**" modifier must immediately follow the initial time-value which must be of the form DDDDDDDDD. Any other use of the \'julianday\' modifier is an error and causes the function to return NULL. The \'julianday\' modifier forces the time-value number to be interpreted as a julian-day number. As this is the default behavior, the \'julianday\' modifier is scarcely more than a no-op. The only difference is that adding \'julianday\' forces the DDDDDDDDD time-value format, and causes a NULL to be returned if any other time-value format is used. The "**auto**" modifier must immediately follow the initial time-value. If the time-value is numeric (the DDDDDDDDDD format) then the \'auto\' modifier causes the time-value to interpreted as either a julian day number or a unix timestamp, depending on its magnitude. If the value is between 0.0 and 5373484.499999, then it is interpreted as a julian day number (corresponding to dates between -4713-11-24 12:00:00 and 9999-12-31 23:59:59, inclusive). For numeric values outside of the range of valid julian day numbers, but within the range of -210866760000 to 253402300799, the \'auto\' modifier causes the value to be interpreted as a unix timestamp. Other numeric values are out of range and cause a NULL return. The \'auto\' modifier is a no-op for ISO 8601 text time-values. The "auto" modifier is designed to work with time-values even in cases where it is not known which time-value format is stored in the database file, or in cases where the same column stores time-values in different formats on different rows. The \'auto\' modifier will automatically select the appropriate format. However, there is some ambiguity. Unix timestamps for the first 63 days of 1970 will be interpreted as julian day numbers. The \'auto\' modifier is very useful when the dataset is guaranteed to contain no dates within that range, but should be avoided for applications that might make use of dates in the opening months of 1970. The "**localtime**" modifier assumes the time-value to its left is in Universal Coordinated Time (UTC) and adjusts that time value so that it is in localtime. If "localtime" follows a time that is not UTC, then the behavior is undefined. The "**utc**" modifier is the opposite of "localtime". "utc" assumes that the time-value to its left is in the local timezone and adjusts that time-value to be in UTC. If the time to the left is not in localtime, then the result of "utc" is undefined. The "**subsecond**" modifier (which may be abbreviated as just "**subsec**") increases the resolution of the output for [datetime()](https://www.sqlite.org/lang_datefunc.html#dttm), [time()](https://www.sqlite.org/lang_datefunc.html#dttm), and [unixepoch()](https://www.sqlite.org/lang_datefunc.html#uepch), and for the "%s" format string in [strftime()](https://www.sqlite.org/lang_datefunc.html#strftm). The "subsecond" modifier has no effect on other date/time functions. The current implemention increases the resolution from seconds to milliseconds, but this might increase to a higher resolution in future releases of SQLite. When "subsec" is used with [datetime()](https://www.sqlite.org/lang_datefunc.html#dttm) or [time()](https://www.sqlite.org/lang_datefunc.html#dttm), the seconds field at the end is followed by a decimal point and one or more digits to show fractional seconds. When "subsec" is used with [unixepoch()](https://www.sqlite.org/lang_datefunc.html#uepch), the result is a floating point value which is the number of seconds and fractional seconds since 1970-01-01. The "subsecond" and "subsec" modifiers have the special property that they can occur as the first argument to date/time functions (or as the first argument after the format string for strftime()). When this happens, the time-value that is normally in the first argument is understood to be "now". For example, a short cut to get the current time in seconds since 1970 with millisecond precision is to say: SELECT unixepoch(\'subsec\'); 4\\. ExamplesCompute the current date. SELECT date();Compute the last day of the current month.SELECT date(\'now\',\'start of month\',\'+1 month\',\'-1 day\'); Compute the date and time given a unix timestamp 1092941466. SELECT datetime(1092941466, \'unixepoch\');  \nSELECT datetime(1092941466, \'auto\'); -- Does not work for early 1970! Compute the date and time given a unix timestamp 1092941466, and compensate for your local timezone. SELECT datetime(1092941466, \'unixepoch\', \'localtime\'); Compute the current unix timestamp. SELECT unixepoch();  \nSELECT strftime(\'%s\'); Compute the number of days since the signing of the US Declaration of Independence. SELECT julianday(\'now\') - julianday(\'1776-07-04\'); Compute the number of seconds since a particular moment in 2004: SELECT unixepoch() - unixepoch(\'2004-01-01 02:34:56\'); Compute the date of the first Tuesday in October for the current year. SELECT date(\'now\',\'start of year\',\'+9 months\',\'weekday 2\'); Compute the time since the unix epoch in seconds with millisecond precision: SELECT (julianday(\'now\') - 2440587.5)\\*86400.0;  \nSELECT unixepoch(\'now\',\'subsec\'); Compute how old Abraham Lincoln would be if he were still alive today: SELECT timediff(\'now\',\'1809-02-12\'); 5\\. Caveats And BugsThe computation of local time depends heavily on the whim of politicians and is thus difficult to get correct for all locales. In this implementation, the standard C library function localtime\\_r() is used to assist in the calculation of local time. The localtime\\_r() C function normally only works for years between 1970 and 2037. For dates outside this range, SQLite attempts to map the year into an equivalent year within this range, do the calculation, then map the year back.These functions only work for dates between 0000-01-01 00:00:00 and 9999-12-31 23:59:59 (julian day numbers 1721059.5 through 5373484.5). For dates outside that range, the results of these functions are undefined.Non-Vista Windows platforms only support one set of DST rules. Vista only supports two. Therefore, on these platforms, historical DST calculations will be incorrect. For example, in the US, in 2007 the DST rules changed. Non-Vista Windows platforms apply the new 2007 DST rules to all previous years as well. Vista does somewhat better getting results correct back to 1986, when the rules were also changed.All internal computations assume the [Gregorian calendar](http://en.wikipedia.org/wiki/Gregorian_calendar) system. They also assume that every day is exactly 86400 seconds in duration; no leap seconds are incorporated.'},datetime:{args:"(time-value, modifier, modifier, ...)",docs:'1\\. Overview SQLite supports seven [scalar](https://www.sqlite.org/lang_corefunc.html) date and time functions as follows:*   **date(**_time-value, modifier, modifier, ..._**)**\n*   **time(**_time-value, modifier, modifier, ..._**)**\n*   **datetime(**_time-value, modifier, modifier, ..._**)**\n*   **julianday(**_time-value, modifier, modifier, ..._**)**\n*   **unixepoch(**_time-value, modifier, modifier, ..._**)**\n*   **strftime(**_format, time-value, modifier, modifier, ..._**)**\n*   **timediff(**_time-value, time-value_**)**\nThe first six date and time functions take an optional [time-value](https://www.sqlite.org/lang_datefunc.html#tmval) as an argument, followed by zero or more [modifiers](https://www.sqlite.org/lang_datefunc.html#dtmods). The strftime() function also takes a format string as its first argument. The timediff() function takes exactly two arguments which are both [time-values](https://www.sqlite.org/lang_datefunc.html#tmval). SQLite does not have a dedicated date/time datatype. Instead, date and time values can stored as any of the following:\n\n<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><a href="http://en.wikipedia.org/wiki/ISO_8601">ISO-8601</a></td><td>A text string that is one of the ISO 8601 date/time values shown in <a href="about:blank#tmval">items 1 through 10 below</a>. Example: <tt>\'2025-05-29 14:16:00\'</tt></td></tr><tr><td><a href="http://en.wikipedia.org/wiki/Julian_day">Julian&nbsp;day&nbsp;number</a></td><td>The number of days including fractional days since -4713-11-24 12:00:00 Example: <tt>2460825.09444444</tt></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Unix_time">Unix timestamp</a></td><td>The number of seconds including fractional seconds since 1970-01-01 00:00:00 Example: <tt>1748528160</tt></td></tr></tbody></table>\n\nThese three formats are collectively known as [time-values](https://www.sqlite.org/lang_datefunc.html#tmval). All of the date time functions accept time-values as either ISO-8601 text or as Julian day numbers. They can also be made to accept unix timestamps by adding optional modifiers arguments [\'auto\'](https://www.sqlite.org/lang_datefunc.html#automod) or [\'unixepoch\'](https://www.sqlite.org/lang_datefunc.html#jdmod). Since the timediff() function does not accept modifiers, it can only use ISO-8601 and julian day number time-values. The **date()** function returns the date as text in this format: YYYY-MM-DD. The **time()** function returns the time as text in formatted as HH:MM:SS or as HH:MM:SS.SSS if the [subsec modifier](https://www.sqlite.org/lang_datefunc.html#subsec) is used. The **datetime()** function returns the date and time formatted as YYYY-MM-DD HH:MM:SS or as YYYY-MM-DD HH:MM:SS.SSS if the [subsec modifier](https://www.sqlite.org/lang_datefunc.html#subsec) is used. The **julianday()** function returns the [Julian day](http://en.wikipedia.org/wiki/Julian_day) - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. ([Proleptic Gregorian calendar](http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar)). The **unixepoch()** function returns a unix timestamp - the number of seconds since 1970-01-01 00:00:00 UTC. The unixepoch() function normally returns an integer number of seconds, but with the optional [subsec modifier](https://www.sqlite.org/lang_datefunc.html#subsec) it will return a floating point number which is the fractional number of seconds. The **strftime()** function returns the date formatted according to the format string specified as the first argument. The format string supports the most common substitutions found in the [strftime() function](http://opengroup.org/onlinepubs/007908799/xsh/strftime.html) from the standard C library plus two new substitutions, %f and %J. The following is a complete list of valid strftime() substitutions as of version 3.46.0 (2024-05-23). Earlier versions of SQLite might not support all substitutions. If an undefined or unsupported substitution is seen, the result is NULL.\n\n<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td></td><td width="10"></td><td></td></tr><tr><td>%d</td><td></td><td>day of month: 01-31</td></tr><tr><td>%e</td><td></td><td>day of month without leading zero: 1-31</td></tr><tr><td>%f</td><td></td><td>fractional seconds: SS.SSS</td></tr><tr><td>%F</td><td></td><td>ISO 8601 date: YYYY-MM-DD</td></tr><tr><td>%G</td><td></td><td>ISO 8601 year corresponding to %V</td></tr><tr><td>%g</td><td></td><td>2-digit ISO 8601 year corresponding to %V</td></tr><tr><td>%H</td><td></td><td>hour: 00-24</td></tr><tr><td>%I</td><td></td><td>hour for 12-hour clock: 01-12</td></tr><tr><td>%j</td><td></td><td>day of year: 001-366</td></tr><tr><td>%J</td><td></td><td>Julian day number (fractional)</td></tr><tr><td>%k</td><td></td><td>hour without leading zero: 0-24</td></tr><tr><td>%l</td><td></td><td>%I without leading zero: 1-12</td></tr><tr><td>%m</td><td></td><td>month: 01-12</td></tr><tr><td>%M</td><td></td><td>minute: 00-59</td></tr><tr><td>%p</td><td></td><td>"AM" or "PM" depending on the hour</td></tr><tr><td>%P</td><td></td><td>"am" or "pm" depending on the hour</td></tr><tr><td>%R</td><td></td><td>ISO 8601 time: HH:MM</td></tr><tr><td>%s</td><td></td><td>seconds since 1970-01-01</td></tr><tr><td>%S</td><td></td><td>seconds: 00-59</td></tr><tr><td>%T</td><td></td><td>ISO 8601 time: HH:MM:SS</td></tr><tr><td>%U</td><td></td><td>week of year (00-53) - week 01 starts on the first Sunday</td></tr><tr><td>%u</td><td></td><td>day of week 1-7 with Monday==1</td></tr><tr><td>%V</td><td></td><td>ISO 8601 week of year</td></tr><tr><td>%w</td><td></td><td>day of week 0-6 with Sunday==0</td></tr><tr><td>%W</td><td></td><td>week of year (00-53) - week 01 starts on the first Monday</td></tr><tr><td>%Y</td><td></td><td>year: 0000-9999</td></tr><tr><td>%%</td><td></td><td>%</td></tr></tbody></table>\n\nOther date and time functions can be expressed in terms of strftime():\n\n<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><b>Function</b></td><td width="30"></td><td><b>Equivalent strftime()</b></td></tr><tr><td>date(...)</td><td></td><td>strftime(\'%F\', ...)</td></tr><tr><td>time(...)</td><td></td><td>strftime(\'%T\', ...)</td></tr><tr><td>datetime(...)</td><td></td><td>strftime(\'%F %T\', ...)</td></tr><tr><td>julianday(...)</td><td></td><td><nobr>CAST(strftime(\'%J\', ...) as REAL)</nobr></td></tr><tr><td>unixepoch(...)</td><td></td><td><nobr>CAST(strftime(\'%s\', ...) as INT)</nobr></td></tr></tbody></table>\n\nThe date(), time(), and datetime() functions all return text, and so their strftime() equivalents are exact. However, the julianday() and unixepoch() functions return numeric values. Their strftime() equivalents return a string that is the text representation of the corresponding number. The main reasons for providing functions other than strftime() are for convenience and for efficiency. The julianday() and unixepoch() functions return real and integer values respectively, and do not incur the format conversion costs or inexactitude resulting from use of the \'%J\' or \'%s\' format specifiers with the strftime() function. The **timediff(A,B)** function returns a string that describes the amount of time that must be added to B in order to reach time A. The format of the timediff() result is designed to be human-readable. The format is: (+|-)YYYY-MM-DD HH:MM:SS.SSS This time difference string is also an allowed modifier for the other date/time functions. The following invariant holds for time-values A and B: datetime(A) = datetime(B, timediff(A,B)) The length of months and years vary. February is shorter than March. Leap years are longer than non-leap years. The output from timediff() takes this all into account. The timediff() function is intended to provide a human-friendly description of the time span. If you want to know the number of days or seconds between two dates, A and B, then you can always do one of these: SELECT julianday(B) - julianday(A);  \nSELECT unixepoch(B) - unixepoch(A); The timediff(A,B) might return the same result even for values A and B that span a different number of days - depending on the starting date. For example, both of the following two timediff() calls return the same result ("-0000-01-00 00:00:00.000") even though the first timespan is 28 days and the seconds is 31 days: SELECT timediff(\'2023-02-15\',\'2023-03-15\');  \nSELECT timediff(\'2023-03-15\',\'2023-04-15\'); Summary: If you want a human-friendly time span, use timediff(). If you want a precise time difference (in days or seconds) use the difference between two julianday() or unixepoch() calls. 2\\. Time ValuesA time-value can be in any of the following formats shown below. The value is usually a string, though it can be an integer or floating point number in the case of format 12.*   _YYYY-MM-DD_\n*   _YYYY-MM-DD HH:MM_\n*   _YYYY-MM-DD HH:MM:SS_\n*   _YYYY-MM-DD HH:MM:SS.SSS_\n*   _YYYY-MM-DD_**T**_HH:MM_\n*   _YYYY-MM-DD_**T**_HH:MM:SS_\n*   _YYYY-MM-DD_**T**_HH:MM:SS.SSS_\n*   _HH:MM_\n*   _HH:MM:SS_\n*   _HH:MM:SS.SSS_\n*   **now**\n*   _DDDDDDDDDD_\nIn formats 5 through 7, the "T" is a literal character separating the date and the time, as required by [ISO-8601](http://www.w3c.org/TR/NOTE-datetime). Formats 8 through 10 that specify only a time assume a date of 2000-01-01. Format 11, the string \'now\', is converted into the current date and time as obtained from the xCurrentTime method of the [sqlite3\\_vfs](https://www.sqlite.org/c3ref/vfs.html) object in use. The \'now\' argument to date and time functions always returns exactly the same value for multiple invocations within the same [sqlite3\\_step()](https://www.sqlite.org/c3ref/step.html) call. [Universal Coordinated Time (UTC)](http://en.wikipedia.org/wiki/Coordinated_Universal_Time) is used. Format 12 is the [Julian day number](http://en.wikipedia.org/wiki/Julian_day) expressed as an integer or floating point value. Format 12 might also be interpreted as a unix timestamp if it is immediately followed either the [\'auto\'](https://www.sqlite.org/lang_datefunc.html#automod) or [\'unixepoch\'](https://www.sqlite.org/lang_datefunc.html#jdmod) modifier. Formats 2 through 10 may be optionally followed by a timezone indicator of the form "_\\[+-\\]HH:MM_" or just "_Z_". The date and time functions use UTC or "zulu" time internally, and so the "Z" suffix is a no-op. Any non-zero "HH:MM" suffix is subtracted from the indicated date and time in order to compute zulu time. For example, all of the following time-values are equivalent: 2013-10-07 08:23:19.120  \n2013-10-07T08:23:19.120Z  \n2013-10-07 04:23:19.120-04:00  \n2456572.84952685 In formats 4, 7, and 10, the fractional seconds value SS.SSS can have one or more digits following the decimal point. Exactly three digits are shown in the examples because only the first three digits are significant to the result, but the input string can have fewer or more than three digits and the date/time functions will still operate correctly. Similarly, format 12 is shown with 10 significant digits, but the date/time functions will really accept as many or as few digits as are necessary to represent the Julian day number. [ISO-8601](http://www.w3c.org/TR/NOTE-datetime) supports a wide variety of alternative date/time formats, but SQLite only supports the ones specifically enumerated above. In all functions other than timediff(), the time-value (and all modifiers) may be omitted, in which case a time value of \'now\' is assumed. 3\\. ModifiersFor all date/time functions other than timediff(), the time-value argument can be followed by zero or more modifiers that alter date and/or time. Each modifier is a transformation that is applied to the time-value to its left. Modifiers are applied from left to right; order is important. The available modifiers are as follows.*   NNN days\n*   NNN hours\n*   NNN minutes\n*   NNN seconds\n*   NNN months\n*   NNN years\n*   ±HH:MM\n*   ±HH:MM:SS\n*   ±HH:MM:SS.SSS\n*   ±YYYY-MM-DD\n*   ±YYYY-MM-DD HH:MM\n*   ±YYYY-MM-DD HH:MM:SS\n*   ±YYYY-MM-DD HH:MM:SS.SSS\n*   ceiling\n*   floor\n*   start of month\n*   start of year\n*   start of day\n*   weekday N\n*   unixepoch\n*   julianday\n*   auto\n*   localtime\n*   utc\n*   subsec\n*   subsecond\nThe first thirteen modifiers (1 through 13) add the specified amount of time to the date and time specified by the arguments to its left. The \'s\' character at the end of the modifier names in 1 through 6 is optional. The NNN value can be any floating point number, with an optional \'+\' or \'-\' prefix. The **time shift modifiers** (7 through 13) move the time-value by the number of years, months, days, hours, minutes, and/or seconds specified. An initial "+" or "-" is required for formats 10 through 13 but is optional for formats 7, 8, and 9. The changes are applies from left to right. First the year is shifted by YYYY, then the month by MM, and then day by DD, and so forth. The timediff(A,B) function returns a time shift in format 13 that shifts the time-value B into A.Because the length of a month or year changes from one month or year to the next, ambiguities can arise when shifting a date by months and/or years. For example, what is the date one year after 2024-02-29? Is it 2025-02-28 or 2025-03-01? Or what is the date that is two months after 2023-12-31? Is it 2024-02-29 or 2024-03-02? There is no consensus on how to resolve this ambiguity, so the "**ceiling**" and "**floor**" modifiers (14 and 15) are available to let the programmer decide. If the next modifier after a time shift is "ceiling", then any ambiguity in the date is resolved by choosing the later date. The "floor" modifier resolves ambiguities by resolving to the last day of the previous month. The default behavior is "ceiling". The "**start of**" modifiers (16 through 18) shift the date backwards to the beginning of the subject month, year or day.The "**weekday**" modifier advances the date forward, if necessary, to the next date where the weekday number is N. Sunday is 0, Monday is 1, and so forth. If the date is already on the desired weekday, the "weekday" modifier leaves the date unchanged. The "**unixepoch**" modifier (20) only works if it immediately follows a time-value in the DDDDDDDDDD format. This modifier causes the DDDDDDDDDD to be interpreted not as a Julian day number as it normally would be, but as [Unix Time](http://en.wikipedia.org/wiki/Unix_time) - the number of seconds since 1970. If the "unixepoch" modifier does not follow a time-value of the form DDDDDDDDDD which expresses the number of seconds since 1970 or if other modifiers separate the "unixepoch" modifier from prior DDDDDDDDDD then the behavior is undefined. The "**julianday**" modifier must immediately follow the initial time-value which must be of the form DDDDDDDDD. Any other use of the \'julianday\' modifier is an error and causes the function to return NULL. The \'julianday\' modifier forces the time-value number to be interpreted as a julian-day number. As this is the default behavior, the \'julianday\' modifier is scarcely more than a no-op. The only difference is that adding \'julianday\' forces the DDDDDDDDD time-value format, and causes a NULL to be returned if any other time-value format is used. The "**auto**" modifier must immediately follow the initial time-value. If the time-value is numeric (the DDDDDDDDDD format) then the \'auto\' modifier causes the time-value to interpreted as either a julian day number or a unix timestamp, depending on its magnitude. If the value is between 0.0 and 5373484.499999, then it is interpreted as a julian day number (corresponding to dates between -4713-11-24 12:00:00 and 9999-12-31 23:59:59, inclusive). For numeric values outside of the range of valid julian day numbers, but within the range of -210866760000 to 253402300799, the \'auto\' modifier causes the value to be interpreted as a unix timestamp. Other numeric values are out of range and cause a NULL return. The \'auto\' modifier is a no-op for ISO 8601 text time-values. The "auto" modifier is designed to work with time-values even in cases where it is not known which time-value format is stored in the database file, or in cases where the same column stores time-values in different formats on different rows. The \'auto\' modifier will automatically select the appropriate format. However, there is some ambiguity. Unix timestamps for the first 63 days of 1970 will be interpreted as julian day numbers. The \'auto\' modifier is very useful when the dataset is guaranteed to contain no dates within that range, but should be avoided for applications that might make use of dates in the opening months of 1970. The "**localtime**" modifier assumes the time-value to its left is in Universal Coordinated Time (UTC) and adjusts that time value so that it is in localtime. If "localtime" follows a time that is not UTC, then the behavior is undefined. The "**utc**" modifier is the opposite of "localtime". "utc" assumes that the time-value to its left is in the local timezone and adjusts that time-value to be in UTC. If the time to the left is not in localtime, then the result of "utc" is undefined. The "**subsecond**" modifier (which may be abbreviated as just "**subsec**") increases the resolution of the output for [datetime()](https://www.sqlite.org/lang_datefunc.html#dttm), [time()](https://www.sqlite.org/lang_datefunc.html#dttm), and [unixepoch()](https://www.sqlite.org/lang_datefunc.html#uepch), and for the "%s" format string in [strftime()](https://www.sqlite.org/lang_datefunc.html#strftm). The "subsecond" modifier has no effect on other date/time functions. The current implemention increases the resolution from seconds to milliseconds, but this might increase to a higher resolution in future releases of SQLite. When "subsec" is used with [datetime()](https://www.sqlite.org/lang_datefunc.html#dttm) or [time()](https://www.sqlite.org/lang_datefunc.html#dttm), the seconds field at the end is followed by a decimal point and one or more digits to show fractional seconds. When "subsec" is used with [unixepoch()](https://www.sqlite.org/lang_datefunc.html#uepch), the result is a floating point value which is the number of seconds and fractional seconds since 1970-01-01. The "subsecond" and "subsec" modifiers have the special property that they can occur as the first argument to date/time functions (or as the first argument after the format string for strftime()). When this happens, the time-value that is normally in the first argument is understood to be "now". For example, a short cut to get the current time in seconds since 1970 with millisecond precision is to say: SELECT unixepoch(\'subsec\'); 4\\. ExamplesCompute the current date. SELECT date();Compute the last day of the current month.SELECT date(\'now\',\'start of month\',\'+1 month\',\'-1 day\'); Compute the date and time given a unix timestamp 1092941466. SELECT datetime(1092941466, \'unixepoch\');  \nSELECT datetime(1092941466, \'auto\'); -- Does not work for early 1970! Compute the date and time given a unix timestamp 1092941466, and compensate for your local timezone. SELECT datetime(1092941466, \'unixepoch\', \'localtime\'); Compute the current unix timestamp. SELECT unixepoch();  \nSELECT strftime(\'%s\'); Compute the number of days since the signing of the US Declaration of Independence. SELECT julianday(\'now\') - julianday(\'1776-07-04\'); Compute the number of seconds since a particular moment in 2004: SELECT unixepoch() - unixepoch(\'2004-01-01 02:34:56\'); Compute the date of the first Tuesday in October for the current year. SELECT date(\'now\',\'start of year\',\'+9 months\',\'weekday 2\'); Compute the time since the unix epoch in seconds with millisecond precision: SELECT (julianday(\'now\') - 2440587.5)\\*86400.0;  \nSELECT unixepoch(\'now\',\'subsec\'); Compute how old Abraham Lincoln would be if he were still alive today: SELECT timediff(\'now\',\'1809-02-12\'); 5\\. Caveats And BugsThe computation of local time depends heavily on the whim of politicians and is thus difficult to get correct for all locales. In this implementation, the standard C library function localtime\\_r() is used to assist in the calculation of local time. The localtime\\_r() C function normally only works for years between 1970 and 2037. For dates outside this range, SQLite attempts to map the year into an equivalent year within this range, do the calculation, then map the year back.These functions only work for dates between 0000-01-01 00:00:00 and 9999-12-31 23:59:59 (julian day numbers 1721059.5 through 5373484.5). For dates outside that range, the results of these functions are undefined.Non-Vista Windows platforms only support one set of DST rules. Vista only supports two. Therefore, on these platforms, historical DST calculations will be incorrect. For example, in the US, in 2007 the DST rules changed. Non-Vista Windows platforms apply the new 2007 DST rules to all previous years as well. Vista does somewhat better getting results correct back to 1986, when the rules were also changed.All internal computations assume the [Gregorian calendar](http://en.wikipedia.org/wiki/Gregorian_calendar) system. They also assume that every day is exactly 86400 seconds in duration; no leap seconds are incorporated.'},julianday:{args:"(time-value, modifier, modifier, ...)",docs:'1\\. Overview SQLite supports seven [scalar](https://www.sqlite.org/lang_corefunc.html) date and time functions as follows:*   **date(**_time-value, modifier, modifier, ..._**)**\n*   **time(**_time-value, modifier, modifier, ..._**)**\n*   **datetime(**_time-value, modifier, modifier, ..._**)**\n*   **julianday(**_time-value, modifier, modifier, ..._**)**\n*   **unixepoch(**_time-value, modifier, modifier, ..._**)**\n*   **strftime(**_format, time-value, modifier, modifier, ..._**)**\n*   **timediff(**_time-value, time-value_**)**\nThe first six date and time functions take an optional [time-value](https://www.sqlite.org/lang_datefunc.html#tmval) as an argument, followed by zero or more [modifiers](https://www.sqlite.org/lang_datefunc.html#dtmods). The strftime() function also takes a format string as its first argument. The timediff() function takes exactly two arguments which are both [time-values](https://www.sqlite.org/lang_datefunc.html#tmval). SQLite does not have a dedicated date/time datatype. Instead, date and time values can stored as any of the following:\n\n<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><a href="http://en.wikipedia.org/wiki/ISO_8601">ISO-8601</a></td><td>A text string that is one of the ISO 8601 date/time values shown in <a href="about:blank#tmval">items 1 through 10 below</a>. Example: <tt>\'2025-05-29 14:16:00\'</tt></td></tr><tr><td><a href="http://en.wikipedia.org/wiki/Julian_day">Julian&nbsp;day&nbsp;number</a></td><td>The number of days including fractional days since -4713-11-24 12:00:00 Example: <tt>2460825.09444444</tt></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Unix_time">Unix timestamp</a></td><td>The number of seconds including fractional seconds since 1970-01-01 00:00:00 Example: <tt>1748528160</tt></td></tr></tbody></table>\n\nThese three formats are collectively known as [time-values](https://www.sqlite.org/lang_datefunc.html#tmval). All of the date time functions accept time-values as either ISO-8601 text or as Julian day numbers. They can also be made to accept unix timestamps by adding optional modifiers arguments [\'auto\'](https://www.sqlite.org/lang_datefunc.html#automod) or [\'unixepoch\'](https://www.sqlite.org/lang_datefunc.html#jdmod). Since the timediff() function does not accept modifiers, it can only use ISO-8601 and julian day number time-values. The **date()** function returns the date as text in this format: YYYY-MM-DD. The **time()** function returns the time as text in formatted as HH:MM:SS or as HH:MM:SS.SSS if the [subsec modifier](https://www.sqlite.org/lang_datefunc.html#subsec) is used. The **datetime()** function returns the date and time formatted as YYYY-MM-DD HH:MM:SS or as YYYY-MM-DD HH:MM:SS.SSS if the [subsec modifier](https://www.sqlite.org/lang_datefunc.html#subsec) is used. The **julianday()** function returns the [Julian day](http://en.wikipedia.org/wiki/Julian_day) - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. ([Proleptic Gregorian calendar](http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar)). The **unixepoch()** function returns a unix timestamp - the number of seconds since 1970-01-01 00:00:00 UTC. The unixepoch() function normally returns an integer number of seconds, but with the optional [subsec modifier](https://www.sqlite.org/lang_datefunc.html#subsec) it will return a floating point number which is the fractional number of seconds. The **strftime()** function returns the date formatted according to the format string specified as the first argument. The format string supports the most common substitutions found in the [strftime() function](http://opengroup.org/onlinepubs/007908799/xsh/strftime.html) from the standard C library plus two new substitutions, %f and %J. The following is a complete list of valid strftime() substitutions as of version 3.46.0 (2024-05-23). Earlier versions of SQLite might not support all substitutions. If an undefined or unsupported substitution is seen, the result is NULL.\n\n<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td></td><td width="10"></td><td></td></tr><tr><td>%d</td><td></td><td>day of month: 01-31</td></tr><tr><td>%e</td><td></td><td>day of month without leading zero: 1-31</td></tr><tr><td>%f</td><td></td><td>fractional seconds: SS.SSS</td></tr><tr><td>%F</td><td></td><td>ISO 8601 date: YYYY-MM-DD</td></tr><tr><td>%G</td><td></td><td>ISO 8601 year corresponding to %V</td></tr><tr><td>%g</td><td></td><td>2-digit ISO 8601 year corresponding to %V</td></tr><tr><td>%H</td><td></td><td>hour: 00-24</td></tr><tr><td>%I</td><td></td><td>hour for 12-hour clock: 01-12</td></tr><tr><td>%j</td><td></td><td>day of year: 001-366</td></tr><tr><td>%J</td><td></td><td>Julian day number (fractional)</td></tr><tr><td>%k</td><td></td><td>hour without leading zero: 0-24</td></tr><tr><td>%l</td><td></td><td>%I without leading zero: 1-12</td></tr><tr><td>%m</td><td></td><td>month: 01-12</td></tr><tr><td>%M</td><td></td><td>minute: 00-59</td></tr><tr><td>%p</td><td></td><td>"AM" or "PM" depending on the hour</td></tr><tr><td>%P</td><td></td><td>"am" or "pm" depending on the hour</td></tr><tr><td>%R</td><td></td><td>ISO 8601 time: HH:MM</td></tr><tr><td>%s</td><td></td><td>seconds since 1970-01-01</td></tr><tr><td>%S</td><td></td><td>seconds: 00-59</td></tr><tr><td>%T</td><td></td><td>ISO 8601 time: HH:MM:SS</td></tr><tr><td>%U</td><td></td><td>week of year (00-53) - week 01 starts on the first Sunday</td></tr><tr><td>%u</td><td></td><td>day of week 1-7 with Monday==1</td></tr><tr><td>%V</td><td></td><td>ISO 8601 week of year</td></tr><tr><td>%w</td><td></td><td>day of week 0-6 with Sunday==0</td></tr><tr><td>%W</td><td></td><td>week of year (00-53) - week 01 starts on the first Monday</td></tr><tr><td>%Y</td><td></td><td>year: 0000-9999</td></tr><tr><td>%%</td><td></td><td>%</td></tr></tbody></table>\n\nOther date and time functions can be expressed in terms of strftime():\n\n<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><b>Function</b></td><td width="30"></td><td><b>Equivalent strftime()</b></td></tr><tr><td>date(...)</td><td></td><td>strftime(\'%F\', ...)</td></tr><tr><td>time(...)</td><td></td><td>strftime(\'%T\', ...)</td></tr><tr><td>datetime(...)</td><td></td><td>strftime(\'%F %T\', ...)</td></tr><tr><td>julianday(...)</td><td></td><td><nobr>CAST(strftime(\'%J\', ...) as REAL)</nobr></td></tr><tr><td>unixepoch(...)</td><td></td><td><nobr>CAST(strftime(\'%s\', ...) as INT)</nobr></td></tr></tbody></table>\n\nThe date(), time(), and datetime() functions all return text, and so their strftime() equivalents are exact. However, the julianday() and unixepoch() functions return numeric values. Their strftime() equivalents return a string that is the text representation of the corresponding number. The main reasons for providing functions other than strftime() are for convenience and for efficiency. The julianday() and unixepoch() functions return real and integer values respectively, and do not incur the format conversion costs or inexactitude resulting from use of the \'%J\' or \'%s\' format specifiers with the strftime() function. The **timediff(A,B)** function returns a string that describes the amount of time that must be added to B in order to reach time A. The format of the timediff() result is designed to be human-readable. The format is: (+|-)YYYY-MM-DD HH:MM:SS.SSS This time difference string is also an allowed modifier for the other date/time functions. The following invariant holds for time-values A and B: datetime(A) = datetime(B, timediff(A,B)) The length of months and years vary. February is shorter than March. Leap years are longer than non-leap years. The output from timediff() takes this all into account. The timediff() function is intended to provide a human-friendly description of the time span. If you want to know the number of days or seconds between two dates, A and B, then you can always do one of these: SELECT julianday(B) - julianday(A);  \nSELECT unixepoch(B) - unixepoch(A); The timediff(A,B) might return the same result even for values A and B that span a different number of days - depending on the starting date. For example, both of the following two timediff() calls return the same result ("-0000-01-00 00:00:00.000") even though the first timespan is 28 days and the seconds is 31 days: SELECT timediff(\'2023-02-15\',\'2023-03-15\');  \nSELECT timediff(\'2023-03-15\',\'2023-04-15\'); Summary: If you want a human-friendly time span, use timediff(). If you want a precise time difference (in days or seconds) use the difference between two julianday() or unixepoch() calls. 2\\. Time ValuesA time-value can be in any of the following formats shown below. The value is usually a string, though it can be an integer or floating point number in the case of format 12.*   _YYYY-MM-DD_\n*   _YYYY-MM-DD HH:MM_\n*   _YYYY-MM-DD HH:MM:SS_\n*   _YYYY-MM-DD HH:MM:SS.SSS_\n*   _YYYY-MM-DD_**T**_HH:MM_\n*   _YYYY-MM-DD_**T**_HH:MM:SS_\n*   _YYYY-MM-DD_**T**_HH:MM:SS.SSS_\n*   _HH:MM_\n*   _HH:MM:SS_\n*   _HH:MM:SS.SSS_\n*   **now**\n*   _DDDDDDDDDD_\nIn formats 5 through 7, the "T" is a literal character separating the date and the time, as required by [ISO-8601](http://www.w3c.org/TR/NOTE-datetime). Formats 8 through 10 that specify only a time assume a date of 2000-01-01. Format 11, the string \'now\', is converted into the current date and time as obtained from the xCurrentTime method of the [sqlite3\\_vfs](https://www.sqlite.org/c3ref/vfs.html) object in use. The \'now\' argument to date and time functions always returns exactly the same value for multiple invocations within the same [sqlite3\\_step()](https://www.sqlite.org/c3ref/step.html) call. [Universal Coordinated Time (UTC)](http://en.wikipedia.org/wiki/Coordinated_Universal_Time) is used. Format 12 is the [Julian day number](http://en.wikipedia.org/wiki/Julian_day) expressed as an integer or floating point value. Format 12 might also be interpreted as a unix timestamp if it is immediately followed either the [\'auto\'](https://www.sqlite.org/lang_datefunc.html#automod) or [\'unixepoch\'](https://www.sqlite.org/lang_datefunc.html#jdmod) modifier. Formats 2 through 10 may be optionally followed by a timezone indicator of the form "_\\[+-\\]HH:MM_" or just "_Z_". The date and time functions use UTC or "zulu" time internally, and so the "Z" suffix is a no-op. Any non-zero "HH:MM" suffix is subtracted from the indicated date and time in order to compute zulu time. For example, all of the following time-values are equivalent: 2013-10-07 08:23:19.120  \n2013-10-07T08:23:19.120Z  \n2013-10-07 04:23:19.120-04:00  \n2456572.84952685 In formats 4, 7, and 10, the fractional seconds value SS.SSS can have one or more digits following the decimal point. Exactly three digits are shown in the examples because only the first three digits are significant to the result, but the input string can have fewer or more than three digits and the date/time functions will still operate correctly. Similarly, format 12 is shown with 10 significant digits, but the date/time functions will really accept as many or as few digits as are necessary to represent the Julian day number. [ISO-8601](http://www.w3c.org/TR/NOTE-datetime) supports a wide variety of alternative date/time formats, but SQLite only supports the ones specifically enumerated above. In all functions other than timediff(), the time-value (and all modifiers) may be omitted, in which case a time value of \'now\' is assumed. 3\\. ModifiersFor all date/time functions other than timediff(), the time-value argument can be followed by zero or more modifiers that alter date and/or time. Each modifier is a transformation that is applied to the time-value to its left. Modifiers are applied from left to right; order is important. The available modifiers are as follows.*   NNN days\n*   NNN hours\n*   NNN minutes\n*   NNN seconds\n*   NNN months\n*   NNN years\n*   ±HH:MM\n*   ±HH:MM:SS\n*   ±HH:MM:SS.SSS\n*   ±YYYY-MM-DD\n*   ±YYYY-MM-DD HH:MM\n*   ±YYYY-MM-DD HH:MM:SS\n*   ±YYYY-MM-DD HH:MM:SS.SSS\n*   ceiling\n*   floor\n*   start of month\n*   start of year\n*   start of day\n*   weekday N\n*   unixepoch\n*   julianday\n*   auto\n*   localtime\n*   utc\n*   subsec\n*   subsecond\nThe first thirteen modifiers (1 through 13) add the specified amount of time to the date and time specified by the arguments to its left. The \'s\' character at the end of the modifier names in 1 through 6 is optional. The NNN value can be any floating point number, with an optional \'+\' or \'-\' prefix. The **time shift modifiers** (7 through 13) move the time-value by the number of years, months, days, hours, minutes, and/or seconds specified. An initial "+" or "-" is required for formats 10 through 13 but is optional for formats 7, 8, and 9. The changes are applies from left to right. First the year is shifted by YYYY, then the month by MM, and then day by DD, and so forth. The timediff(A,B) function returns a time shift in format 13 that shifts the time-value B into A.Because the length of a month or year changes from one month or year to the next, ambiguities can arise when shifting a date by months and/or years. For example, what is the date one year after 2024-02-29? Is it 2025-02-28 or 2025-03-01? Or what is the date that is two months after 2023-12-31? Is it 2024-02-29 or 2024-03-02? There is no consensus on how to resolve this ambiguity, so the "**ceiling**" and "**floor**" modifiers (14 and 15) are available to let the programmer decide. If the next modifier after a time shift is "ceiling", then any ambiguity in the date is resolved by choosing the later date. The "floor" modifier resolves ambiguities by resolving to the last day of the previous month. The default behavior is "ceiling". The "**start of**" modifiers (16 through 18) shift the date backwards to the beginning of the subject month, year or day.The "**weekday**" modifier advances the date forward, if necessary, to the next date where the weekday number is N. Sunday is 0, Monday is 1, and so forth. If the date is already on the desired weekday, the "weekday" modifier leaves the date unchanged. The "**unixepoch**" modifier (20) only works if it immediately follows a time-value in the DDDDDDDDDD format. This modifier causes the DDDDDDDDDD to be interpreted not as a Julian day number as it normally would be, but as [Unix Time](http://en.wikipedia.org/wiki/Unix_time) - the number of seconds since 1970. If the "unixepoch" modifier does not follow a time-value of the form DDDDDDDDDD which expresses the number of seconds since 1970 or if other modifiers separate the "unixepoch" modifier from prior DDDDDDDDDD then the behavior is undefined. The "**julianday**" modifier must immediately follow the initial time-value which must be of the form DDDDDDDDD. Any other use of the \'julianday\' modifier is an error and causes the function to return NULL. The \'julianday\' modifier forces the time-value number to be interpreted as a julian-day number. As this is the default behavior, the \'julianday\' modifier is scarcely more than a no-op. The only difference is that adding \'julianday\' forces the DDDDDDDDD time-value format, and causes a NULL to be returned if any other time-value format is used. The "**auto**" modifier must immediately follow the initial time-value. If the time-value is numeric (the DDDDDDDDDD format) then the \'auto\' modifier causes the time-value to interpreted as either a julian day number or a unix timestamp, depending on its magnitude. If the value is between 0.0 and 5373484.499999, then it is interpreted as a julian day number (corresponding to dates between -4713-11-24 12:00:00 and 9999-12-31 23:59:59, inclusive). For numeric values outside of the range of valid julian day numbers, but within the range of -210866760000 to 253402300799, the \'auto\' modifier causes the value to be interpreted as a unix timestamp. Other numeric values are out of range and cause a NULL return. The \'auto\' modifier is a no-op for ISO 8601 text time-values. The "auto" modifier is designed to work with time-values even in cases where it is not known which time-value format is stored in the database file, or in cases where the same column stores time-values in different formats on different rows. The \'auto\' modifier will automatically select the appropriate format. However, there is some ambiguity. Unix timestamps for the first 63 days of 1970 will be interpreted as julian day numbers. The \'auto\' modifier is very useful when the dataset is guaranteed to contain no dates within that range, but should be avoided for applications that might make use of dates in the opening months of 1970. The "**localtime**" modifier assumes the time-value to its left is in Universal Coordinated Time (UTC) and adjusts that time value so that it is in localtime. If "localtime" follows a time that is not UTC, then the behavior is undefined. The "**utc**" modifier is the opposite of "localtime". "utc" assumes that the time-value to its left is in the local timezone and adjusts that time-value to be in UTC. If the time to the left is not in localtime, then the result of "utc" is undefined. The "**subsecond**" modifier (which may be abbreviated as just "**subsec**") increases the resolution of the output for [datetime()](https://www.sqlite.org/lang_datefunc.html#dttm), [time()](https://www.sqlite.org/lang_datefunc.html#dttm), and [unixepoch()](https://www.sqlite.org/lang_datefunc.html#uepch), and for the "%s" format string in [strftime()](https://www.sqlite.org/lang_datefunc.html#strftm). The "subsecond" modifier has no effect on other date/time functions. The current implemention increases the resolution from seconds to milliseconds, but this might increase to a higher resolution in future releases of SQLite. When "subsec" is used with [datetime()](https://www.sqlite.org/lang_datefunc.html#dttm) or [time()](https://www.sqlite.org/lang_datefunc.html#dttm), the seconds field at the end is followed by a decimal point and one or more digits to show fractional seconds. When "subsec" is used with [unixepoch()](https://www.sqlite.org/lang_datefunc.html#uepch), the result is a floating point value which is the number of seconds and fractional seconds since 1970-01-01. The "subsecond" and "subsec" modifiers have the special property that they can occur as the first argument to date/time functions (or as the first argument after the format string for strftime()). When this happens, the time-value that is normally in the first argument is understood to be "now". For example, a short cut to get the current time in seconds since 1970 with millisecond precision is to say: SELECT unixepoch(\'subsec\'); 4\\. ExamplesCompute the current date. SELECT date();Compute the last day of the current month.SELECT date(\'now\',\'start of month\',\'+1 month\',\'-1 day\'); Compute the date and time given a unix timestamp 1092941466. SELECT datetime(1092941466, \'unixepoch\');  \nSELECT datetime(1092941466, \'auto\'); -- Does not work for early 1970! Compute the date and time given a unix timestamp 1092941466, and compensate for your local timezone. SELECT datetime(1092941466, \'unixepoch\', \'localtime\'); Compute the current unix timestamp. SELECT unixepoch();  \nSELECT strftime(\'%s\'); Compute the number of days since the signing of the US Declaration of Independence. SELECT julianday(\'now\') - julianday(\'1776-07-04\'); Compute the number of seconds since a particular moment in 2004: SELECT unixepoch() - unixepoch(\'2004-01-01 02:34:56\'); Compute the date of the first Tuesday in October for the current year. SELECT date(\'now\',\'start of year\',\'+9 months\',\'weekday 2\'); Compute the time since the unix epoch in seconds with millisecond precision: SELECT (julianday(\'now\') - 2440587.5)\\*86400.0;  \nSELECT unixepoch(\'now\',\'subsec\'); Compute how old Abraham Lincoln would be if he were still alive today: SELECT timediff(\'now\',\'1809-02-12\'); 5\\. Caveats And BugsThe computation of local time depends heavily on the whim of politicians and is thus difficult to get correct for all locales. In this implementation, the standard C library function localtime\\_r() is used to assist in the calculation of local time. The localtime\\_r() C function normally only works for years between 1970 and 2037. For dates outside this range, SQLite attempts to map the year into an equivalent year within this range, do the calculation, then map the year back.These functions only work for dates between 0000-01-01 00:00:00 and 9999-12-31 23:59:59 (julian day numbers 1721059.5 through 5373484.5). For dates outside that range, the results of these functions are undefined.Non-Vista Windows platforms only support one set of DST rules. Vista only supports two. Therefore, on these platforms, historical DST calculations will be incorrect. For example, in the US, in 2007 the DST rules changed. Non-Vista Windows platforms apply the new 2007 DST rules to all previous years as well. Vista does somewhat better getting results correct back to 1986, when the rules were also changed.All internal computations assume the [Gregorian calendar](http://en.wikipedia.org/wiki/Gregorian_calendar) system. They also assume that every day is exactly 86400 seconds in duration; no leap seconds are incorporated.'},unixepoch:{args:"(time-value, modifier, modifier, ...)",docs:'1\\. Overview SQLite supports seven [scalar](https://www.sqlite.org/lang_corefunc.html) date and time functions as follows:*   **date(**_time-value, modifier, modifier, ..._**)**\n*   **time(**_time-value, modifier, modifier, ..._**)**\n*   **datetime(**_time-value, modifier, modifier, ..._**)**\n*   **julianday(**_time-value, modifier, modifier, ..._**)**\n*   **unixepoch(**_time-value, modifier, modifier, ..._**)**\n*   **strftime(**_format, time-value, modifier, modifier, ..._**)**\n*   **timediff(**_time-value, time-value_**)**\nThe first six date and time functions take an optional [time-value](https://www.sqlite.org/lang_datefunc.html#tmval) as an argument, followed by zero or more [modifiers](https://www.sqlite.org/lang_datefunc.html#dtmods). The strftime() function also takes a format string as its first argument. The timediff() function takes exactly two arguments which are both [time-values](https://www.sqlite.org/lang_datefunc.html#tmval). SQLite does not have a dedicated date/time datatype. Instead, date and time values can stored as any of the following:\n\n<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><a href="http://en.wikipedia.org/wiki/ISO_8601">ISO-8601</a></td><td>A text string that is one of the ISO 8601 date/time values shown in <a href="about:blank#tmval">items 1 through 10 below</a>. Example: <tt>\'2025-05-29 14:16:00\'</tt></td></tr><tr><td><a href="http://en.wikipedia.org/wiki/Julian_day">Julian&nbsp;day&nbsp;number</a></td><td>The number of days including fractional days since -4713-11-24 12:00:00 Example: <tt>2460825.09444444</tt></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Unix_time">Unix timestamp</a></td><td>The number of seconds including fractional seconds since 1970-01-01 00:00:00 Example: <tt>1748528160</tt></td></tr></tbody></table>\n\nThese three formats are collectively known as [time-values](https://www.sqlite.org/lang_datefunc.html#tmval). All of the date time functions accept time-values as either ISO-8601 text or as Julian day numbers. They can also be made to accept unix timestamps by adding optional modifiers arguments [\'auto\'](https://www.sqlite.org/lang_datefunc.html#automod) or [\'unixepoch\'](https://www.sqlite.org/lang_datefunc.html#jdmod). Since the timediff() function does not accept modifiers, it can only use ISO-8601 and julian day number time-values. The **date()** function returns the date as text in this format: YYYY-MM-DD. The **time()** function returns the time as text in formatted as HH:MM:SS or as HH:MM:SS.SSS if the [subsec modifier](https://www.sqlite.org/lang_datefunc.html#subsec) is used. The **datetime()** function returns the date and time formatted as YYYY-MM-DD HH:MM:SS or as YYYY-MM-DD HH:MM:SS.SSS if the [subsec modifier](https://www.sqlite.org/lang_datefunc.html#subsec) is used. The **julianday()** function returns the [Julian day](http://en.wikipedia.org/wiki/Julian_day) - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. ([Proleptic Gregorian calendar](http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar)). The **unixepoch()** function returns a unix timestamp - the number of seconds since 1970-01-01 00:00:00 UTC. The unixepoch() function normally returns an integer number of seconds, but with the optional [subsec modifier](https://www.sqlite.org/lang_datefunc.html#subsec) it will return a floating point number which is the fractional number of seconds. The **strftime()** function returns the date formatted according to the format string specified as the first argument. The format string supports the most common substitutions found in the [strftime() function](http://opengroup.org/onlinepubs/007908799/xsh/strftime.html) from the standard C library plus two new substitutions, %f and %J. The following is a complete list of valid strftime() substitutions as of version 3.46.0 (2024-05-23). Earlier versions of SQLite might not support all substitutions. If an undefined or unsupported substitution is seen, the result is NULL.\n\n<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td></td><td width="10"></td><td></td></tr><tr><td>%d</td><td></td><td>day of month: 01-31</td></tr><tr><td>%e</td><td></td><td>day of month without leading zero: 1-31</td></tr><tr><td>%f</td><td></td><td>fractional seconds: SS.SSS</td></tr><tr><td>%F</td><td></td><td>ISO 8601 date: YYYY-MM-DD</td></tr><tr><td>%G</td><td></td><td>ISO 8601 year corresponding to %V</td></tr><tr><td>%g</td><td></td><td>2-digit ISO 8601 year corresponding to %V</td></tr><tr><td>%H</td><td></td><td>hour: 00-24</td></tr><tr><td>%I</td><td></td><td>hour for 12-hour clock: 01-12</td></tr><tr><td>%j</td><td></td><td>day of year: 001-366</td></tr><tr><td>%J</td><td></td><td>Julian day number (fractional)</td></tr><tr><td>%k</td><td></td><td>hour without leading zero: 0-24</td></tr><tr><td>%l</td><td></td><td>%I without leading zero: 1-12</td></tr><tr><td>%m</td><td></td><td>month: 01-12</td></tr><tr><td>%M</td><td></td><td>minute: 00-59</td></tr><tr><td>%p</td><td></td><td>"AM" or "PM" depending on the hour</td></tr><tr><td>%P</td><td></td><td>"am" or "pm" depending on the hour</td></tr><tr><td>%R</td><td></td><td>ISO 8601 time: HH:MM</td></tr><tr><td>%s</td><td></td><td>seconds since 1970-01-01</td></tr><tr><td>%S</td><td></td><td>seconds: 00-59</td></tr><tr><td>%T</td><td></td><td>ISO 8601 time: HH:MM:SS</td></tr><tr><td>%U</td><td></td><td>week of year (00-53) - week 01 starts on the first Sunday</td></tr><tr><td>%u</td><td></td><td>day of week 1-7 with Monday==1</td></tr><tr><td>%V</td><td></td><td>ISO 8601 week of year</td></tr><tr><td>%w</td><td></td><td>day of week 0-6 with Sunday==0</td></tr><tr><td>%W</td><td></td><td>week of year (00-53) - week 01 starts on the first Monday</td></tr><tr><td>%Y</td><td></td><td>year: 0000-9999</td></tr><tr><td>%%</td><td></td><td>%</td></tr></tbody></table>\n\nOther date and time functions can be expressed in terms of strftime():\n\n<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><b>Function</b></td><td width="30"></td><td><b>Equivalent strftime()</b></td></tr><tr><td>date(...)</td><td></td><td>strftime(\'%F\', ...)</td></tr><tr><td>time(...)</td><td></td><td>strftime(\'%T\', ...)</td></tr><tr><td>datetime(...)</td><td></td><td>strftime(\'%F %T\', ...)</td></tr><tr><td>julianday(...)</td><td></td><td><nobr>CAST(strftime(\'%J\', ...) as REAL)</nobr></td></tr><tr><td>unixepoch(...)</td><td></td><td><nobr>CAST(strftime(\'%s\', ...) as INT)</nobr></td></tr></tbody></table>\n\nThe date(), time(), and datetime() functions all return text, and so their strftime() equivalents are exact. However, the julianday() and unixepoch() functions return numeric values. Their strftime() equivalents return a string that is the text representation of the corresponding number. The main reasons for providing functions other than strftime() are for convenience and for efficiency. The julianday() and unixepoch() functions return real and integer values respectively, and do not incur the format conversion costs or inexactitude resulting from use of the \'%J\' or \'%s\' format specifiers with the strftime() function. The **timediff(A,B)** function returns a string that describes the amount of time that must be added to B in order to reach time A. The format of the timediff() result is designed to be human-readable. The format is: (+|-)YYYY-MM-DD HH:MM:SS.SSS This time difference string is also an allowed modifier for the other date/time functions. The following invariant holds for time-values A and B: datetime(A) = datetime(B, timediff(A,B)) The length of months and years vary. February is shorter than March. Leap years are longer than non-leap years. The output from timediff() takes this all into account. The timediff() function is intended to provide a human-friendly description of the time span. If you want to know the number of days or seconds between two dates, A and B, then you can always do one of these: SELECT julianday(B) - julianday(A);  \nSELECT unixepoch(B) - unixepoch(A); The timediff(A,B) might return the same result even for values A and B that span a different number of days - depending on the starting date. For example, both of the following two timediff() calls return the same result ("-0000-01-00 00:00:00.000") even though the first timespan is 28 days and the seconds is 31 days: SELECT timediff(\'2023-02-15\',\'2023-03-15\');  \nSELECT timediff(\'2023-03-15\',\'2023-04-15\'); Summary: If you want a human-friendly time span, use timediff(). If you want a precise time difference (in days or seconds) use the difference between two julianday() or unixepoch() calls. 2\\. Time ValuesA time-value can be in any of the following formats shown below. The value is usually a string, though it can be an integer or floating point number in the case of format 12.*   _YYYY-MM-DD_\n*   _YYYY-MM-DD HH:MM_\n*   _YYYY-MM-DD HH:MM:SS_\n*   _YYYY-MM-DD HH:MM:SS.SSS_\n*   _YYYY-MM-DD_**T**_HH:MM_\n*   _YYYY-MM-DD_**T**_HH:MM:SS_\n*   _YYYY-MM-DD_**T**_HH:MM:SS.SSS_\n*   _HH:MM_\n*   _HH:MM:SS_\n*   _HH:MM:SS.SSS_\n*   **now**\n*   _DDDDDDDDDD_\nIn formats 5 through 7, the "T" is a literal character separating the date and the time, as required by [ISO-8601](http://www.w3c.org/TR/NOTE-datetime). Formats 8 through 10 that specify only a time assume a date of 2000-01-01. Format 11, the string \'now\', is converted into the current date and time as obtained from the xCurrentTime method of the [sqlite3\\_vfs](https://www.sqlite.org/c3ref/vfs.html) object in use. The \'now\' argument to date and time functions always returns exactly the same value for multiple invocations within the same [sqlite3\\_step()](https://www.sqlite.org/c3ref/step.html) call. [Universal Coordinated Time (UTC)](http://en.wikipedia.org/wiki/Coordinated_Universal_Time) is used. Format 12 is the [Julian day number](http://en.wikipedia.org/wiki/Julian_day) expressed as an integer or floating point value. Format 12 might also be interpreted as a unix timestamp if it is immediately followed either the [\'auto\'](https://www.sqlite.org/lang_datefunc.html#automod) or [\'unixepoch\'](https://www.sqlite.org/lang_datefunc.html#jdmod) modifier. Formats 2 through 10 may be optionally followed by a timezone indicator of the form "_\\[+-\\]HH:MM_" or just "_Z_". The date and time functions use UTC or "zulu" time internally, and so the "Z" suffix is a no-op. Any non-zero "HH:MM" suffix is subtracted from the indicated date and time in order to compute zulu time. For example, all of the following time-values are equivalent: 2013-10-07 08:23:19.120  \n2013-10-07T08:23:19.120Z  \n2013-10-07 04:23:19.120-04:00  \n2456572.84952685 In formats 4, 7, and 10, the fractional seconds value SS.SSS can have one or more digits following the decimal point. Exactly three digits are shown in the examples because only the first three digits are significant to the result, but the input string can have fewer or more than three digits and the date/time functions will still operate correctly. Similarly, format 12 is shown with 10 significant digits, but the date/time functions will really accept as many or as few digits as are necessary to represent the Julian day number. [ISO-8601](http://www.w3c.org/TR/NOTE-datetime) supports a wide variety of alternative date/time formats, but SQLite only supports the ones specifically enumerated above. In all functions other than timediff(), the time-value (and all modifiers) may be omitted, in which case a time value of \'now\' is assumed. 3\\. ModifiersFor all date/time functions other than timediff(), the time-value argument can be followed by zero or more modifiers that alter date and/or time. Each modifier is a transformation that is applied to the time-value to its left. Modifiers are applied from left to right; order is important. The available modifiers are as follows.*   NNN days\n*   NNN hours\n*   NNN minutes\n*   NNN seconds\n*   NNN months\n*   NNN years\n*   ±HH:MM\n*   ±HH:MM:SS\n*   ±HH:MM:SS.SSS\n*   ±YYYY-MM-DD\n*   ±YYYY-MM-DD HH:MM\n*   ±YYYY-MM-DD HH:MM:SS\n*   ±YYYY-MM-DD HH:MM:SS.SSS\n*   ceiling\n*   floor\n*   start of month\n*   start of year\n*   start of day\n*   weekday N\n*   unixepoch\n*   julianday\n*   auto\n*   localtime\n*   utc\n*   subsec\n*   subsecond\nThe first thirteen modifiers (1 through 13) add the specified amount of time to the date and time specified by the arguments to its left. The \'s\' character at the end of the modifier names in 1 through 6 is optional. The NNN value can be any floating point number, with an optional \'+\' or \'-\' prefix. The **time shift modifiers** (7 through 13) move the time-value by the number of years, months, days, hours, minutes, and/or seconds specified. An initial "+" or "-" is required for formats 10 through 13 but is optional for formats 7, 8, and 9. The changes are applies from left to right. First the year is shifted by YYYY, then the month by MM, and then day by DD, and so forth. The timediff(A,B) function returns a time shift in format 13 that shifts the time-value B into A.Because the length of a month or year changes from one month or year to the next, ambiguities can arise when shifting a date by months and/or years. For example, what is the date one year after 2024-02-29? Is it 2025-02-28 or 2025-03-01? Or what is the date that is two months after 2023-12-31? Is it 2024-02-29 or 2024-03-02? There is no consensus on how to resolve this ambiguity, so the "**ceiling**" and "**floor**" modifiers (14 and 15) are available to let the programmer decide. If the next modifier after a time shift is "ceiling", then any ambiguity in the date is resolved by choosing the later date. The "floor" modifier resolves ambiguities by resolving to the last day of the previous month. The default behavior is "ceiling". The "**start of**" modifiers (16 through 18) shift the date backwards to the beginning of the subject month, year or day.The "**weekday**" modifier advances the date forward, if necessary, to the next date where the weekday number is N. Sunday is 0, Monday is 1, and so forth. If the date is already on the desired weekday, the "weekday" modifier leaves the date unchanged. The "**unixepoch**" modifier (20) only works if it immediately follows a time-value in the DDDDDDDDDD format. This modifier causes the DDDDDDDDDD to be interpreted not as a Julian day number as it normally would be, but as [Unix Time](http://en.wikipedia.org/wiki/Unix_time) - the number of seconds since 1970. If the "unixepoch" modifier does not follow a time-value of the form DDDDDDDDDD which expresses the number of seconds since 1970 or if other modifiers separate the "unixepoch" modifier from prior DDDDDDDDDD then the behavior is undefined. The "**julianday**" modifier must immediately follow the initial time-value which must be of the form DDDDDDDDD. Any other use of the \'julianday\' modifier is an error and causes the function to return NULL. The \'julianday\' modifier forces the time-value number to be interpreted as a julian-day number. As this is the default behavior, the \'julianday\' modifier is scarcely more than a no-op. The only difference is that adding \'julianday\' forces the DDDDDDDDD time-value format, and causes a NULL to be returned if any other time-value format is used. The "**auto**" modifier must immediately follow the initial time-value. If the time-value is numeric (the DDDDDDDDDD format) then the \'auto\' modifier causes the time-value to interpreted as either a julian day number or a unix timestamp, depending on its magnitude. If the value is between 0.0 and 5373484.499999, then it is interpreted as a julian day number (corresponding to dates between -4713-11-24 12:00:00 and 9999-12-31 23:59:59, inclusive). For numeric values outside of the range of valid julian day numbers, but within the range of -210866760000 to 253402300799, the \'auto\' modifier causes the value to be interpreted as a unix timestamp. Other numeric values are out of range and cause a NULL return. The \'auto\' modifier is a no-op for ISO 8601 text time-values. The "auto" modifier is designed to work with time-values even in cases where it is not known which time-value format is stored in the database file, or in cases where the same column stores time-values in different formats on different rows. The \'auto\' modifier will automatically select the appropriate format. However, there is some ambiguity. Unix timestamps for the first 63 days of 1970 will be interpreted as julian day numbers. The \'auto\' modifier is very useful when the dataset is guaranteed to contain no dates within that range, but should be avoided for applications that might make use of dates in the opening months of 1970. The "**localtime**" modifier assumes the time-value to its left is in Universal Coordinated Time (UTC) and adjusts that time value so that it is in localtime. If "localtime" follows a time that is not UTC, then the behavior is undefined. The "**utc**" modifier is the opposite of "localtime". "utc" assumes that the time-value to its left is in the local timezone and adjusts that time-value to be in UTC. If the time to the left is not in localtime, then the result of "utc" is undefined. The "**subsecond**" modifier (which may be abbreviated as just "**subsec**") increases the resolution of the output for [datetime()](https://www.sqlite.org/lang_datefunc.html#dttm), [time()](https://www.sqlite.org/lang_datefunc.html#dttm), and [unixepoch()](https://www.sqlite.org/lang_datefunc.html#uepch), and for the "%s" format string in [strftime()](https://www.sqlite.org/lang_datefunc.html#strftm). The "subsecond" modifier has no effect on other date/time functions. The current implemention increases the resolution from seconds to milliseconds, but this might increase to a higher resolution in future releases of SQLite. When "subsec" is used with [datetime()](https://www.sqlite.org/lang_datefunc.html#dttm) or [time()](https://www.sqlite.org/lang_datefunc.html#dttm), the seconds field at the end is followed by a decimal point and one or more digits to show fractional seconds. When "subsec" is used with [unixepoch()](https://www.sqlite.org/lang_datefunc.html#uepch), the result is a floating point value which is the number of seconds and fractional seconds since 1970-01-01. The "subsecond" and "subsec" modifiers have the special property that they can occur as the first argument to date/time functions (or as the first argument after the format string for strftime()). When this happens, the time-value that is normally in the first argument is understood to be "now". For example, a short cut to get the current time in seconds since 1970 with millisecond precision is to say: SELECT unixepoch(\'subsec\'); 4\\. ExamplesCompute the current date. SELECT date();Compute the last day of the current month.SELECT date(\'now\',\'start of month\',\'+1 month\',\'-1 day\'); Compute the date and time given a unix timestamp 1092941466. SELECT datetime(1092941466, \'unixepoch\');  \nSELECT datetime(1092941466, \'auto\'); -- Does not work for early 1970! Compute the date and time given a unix timestamp 1092941466, and compensate for your local timezone. SELECT datetime(1092941466, \'unixepoch\', \'localtime\'); Compute the current unix timestamp. SELECT unixepoch();  \nSELECT strftime(\'%s\'); Compute the number of days since the signing of the US Declaration of Independence. SELECT julianday(\'now\') - julianday(\'1776-07-04\'); Compute the number of seconds since a particular moment in 2004: SELECT unixepoch() - unixepoch(\'2004-01-01 02:34:56\'); Compute the date of the first Tuesday in October for the current year. SELECT date(\'now\',\'start of year\',\'+9 months\',\'weekday 2\'); Compute the time since the unix epoch in seconds with millisecond precision: SELECT (julianday(\'now\') - 2440587.5)\\*86400.0;  \nSELECT unixepoch(\'now\',\'subsec\'); Compute how old Abraham Lincoln would be if he were still alive today: SELECT timediff(\'now\',\'1809-02-12\'); 5\\. Caveats And BugsThe computation of local time depends heavily on the whim of politicians and is thus difficult to get correct for all locales. In this implementation, the standard C library function localtime\\_r() is used to assist in the calculation of local time. The localtime\\_r() C function normally only works for years between 1970 and 2037. For dates outside this range, SQLite attempts to map the year into an equivalent year within this range, do the calculation, then map the year back.These functions only work for dates between 0000-01-01 00:00:00 and 9999-12-31 23:59:59 (julian day numbers 1721059.5 through 5373484.5). For dates outside that range, the results of these functions are undefined.Non-Vista Windows platforms only support one set of DST rules. Vista only supports two. Therefore, on these platforms, historical DST calculations will be incorrect. For example, in the US, in 2007 the DST rules changed. Non-Vista Windows platforms apply the new 2007 DST rules to all previous years as well. Vista does somewhat better getting results correct back to 1986, when the rules were also changed.All internal computations assume the [Gregorian calendar](http://en.wikipedia.org/wiki/Gregorian_calendar) system. They also assume that every day is exactly 86400 seconds in duration; no leap seconds are incorporated.'},strftime:{args:"(format, time-value, modifier, modifier, ...)",docs:'1\\. Overview SQLite supports seven [scalar](https://www.sqlite.org/lang_corefunc.html) date and time functions as follows:*   **date(**_time-value, modifier, modifier, ..._**)**\n*   **time(**_time-value, modifier, modifier, ..._**)**\n*   **datetime(**_time-value, modifier, modifier, ..._**)**\n*   **julianday(**_time-value, modifier, modifier, ..._**)**\n*   **unixepoch(**_time-value, modifier, modifier, ..._**)**\n*   **strftime(**_format, time-value, modifier, modifier, ..._**)**\n*   **timediff(**_time-value, time-value_**)**\nThe first six date and time functions take an optional [time-value](https://www.sqlite.org/lang_datefunc.html#tmval) as an argument, followed by zero or more [modifiers](https://www.sqlite.org/lang_datefunc.html#dtmods). The strftime() function also takes a format string as its first argument. The timediff() function takes exactly two arguments which are both [time-values](https://www.sqlite.org/lang_datefunc.html#tmval). SQLite does not have a dedicated date/time datatype. Instead, date and time values can stored as any of the following:\n\n<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><a href="http://en.wikipedia.org/wiki/ISO_8601">ISO-8601</a></td><td>A text string that is one of the ISO 8601 date/time values shown in <a href="about:blank#tmval">items 1 through 10 below</a>. Example: <tt>\'2025-05-29 14:16:00\'</tt></td></tr><tr><td><a href="http://en.wikipedia.org/wiki/Julian_day">Julian&nbsp;day&nbsp;number</a></td><td>The number of days including fractional days since -4713-11-24 12:00:00 Example: <tt>2460825.09444444</tt></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Unix_time">Unix timestamp</a></td><td>The number of seconds including fractional seconds since 1970-01-01 00:00:00 Example: <tt>1748528160</tt></td></tr></tbody></table>\n\nThese three formats are collectively known as [time-values](https://www.sqlite.org/lang_datefunc.html#tmval). All of the date time functions accept time-values as either ISO-8601 text or as Julian day numbers. They can also be made to accept unix timestamps by adding optional modifiers arguments [\'auto\'](https://www.sqlite.org/lang_datefunc.html#automod) or [\'unixepoch\'](https://www.sqlite.org/lang_datefunc.html#jdmod). Since the timediff() function does not accept modifiers, it can only use ISO-8601 and julian day number time-values. The **date()** function returns the date as text in this format: YYYY-MM-DD. The **time()** function returns the time as text in formatted as HH:MM:SS or as HH:MM:SS.SSS if the [subsec modifier](https://www.sqlite.org/lang_datefunc.html#subsec) is used. The **datetime()** function returns the date and time formatted as YYYY-MM-DD HH:MM:SS or as YYYY-MM-DD HH:MM:SS.SSS if the [subsec modifier](https://www.sqlite.org/lang_datefunc.html#subsec) is used. The **julianday()** function returns the [Julian day](http://en.wikipedia.org/wiki/Julian_day) - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. ([Proleptic Gregorian calendar](http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar)). The **unixepoch()** function returns a unix timestamp - the number of seconds since 1970-01-01 00:00:00 UTC. The unixepoch() function normally returns an integer number of seconds, but with the optional [subsec modifier](https://www.sqlite.org/lang_datefunc.html#subsec) it will return a floating point number which is the fractional number of seconds. The **strftime()** function returns the date formatted according to the format string specified as the first argument. The format string supports the most common substitutions found in the [strftime() function](http://opengroup.org/onlinepubs/007908799/xsh/strftime.html) from the standard C library plus two new substitutions, %f and %J. The following is a complete list of valid strftime() substitutions as of version 3.46.0 (2024-05-23). Earlier versions of SQLite might not support all substitutions. If an undefined or unsupported substitution is seen, the result is NULL.\n\n<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td></td><td width="10"></td><td></td></tr><tr><td>%d</td><td></td><td>day of month: 01-31</td></tr><tr><td>%e</td><td></td><td>day of month without leading zero: 1-31</td></tr><tr><td>%f</td><td></td><td>fractional seconds: SS.SSS</td></tr><tr><td>%F</td><td></td><td>ISO 8601 date: YYYY-MM-DD</td></tr><tr><td>%G</td><td></td><td>ISO 8601 year corresponding to %V</td></tr><tr><td>%g</td><td></td><td>2-digit ISO 8601 year corresponding to %V</td></tr><tr><td>%H</td><td></td><td>hour: 00-24</td></tr><tr><td>%I</td><td></td><td>hour for 12-hour clock: 01-12</td></tr><tr><td>%j</td><td></td><td>day of year: 001-366</td></tr><tr><td>%J</td><td></td><td>Julian day number (fractional)</td></tr><tr><td>%k</td><td></td><td>hour without leading zero: 0-24</td></tr><tr><td>%l</td><td></td><td>%I without leading zero: 1-12</td></tr><tr><td>%m</td><td></td><td>month: 01-12</td></tr><tr><td>%M</td><td></td><td>minute: 00-59</td></tr><tr><td>%p</td><td></td><td>"AM" or "PM" depending on the hour</td></tr><tr><td>%P</td><td></td><td>"am" or "pm" depending on the hour</td></tr><tr><td>%R</td><td></td><td>ISO 8601 time: HH:MM</td></tr><tr><td>%s</td><td></td><td>seconds since 1970-01-01</td></tr><tr><td>%S</td><td></td><td>seconds: 00-59</td></tr><tr><td>%T</td><td></td><td>ISO 8601 time: HH:MM:SS</td></tr><tr><td>%U</td><td></td><td>week of year (00-53) - week 01 starts on the first Sunday</td></tr><tr><td>%u</td><td></td><td>day of week 1-7 with Monday==1</td></tr><tr><td>%V</td><td></td><td>ISO 8601 week of year</td></tr><tr><td>%w</td><td></td><td>day of week 0-6 with Sunday==0</td></tr><tr><td>%W</td><td></td><td>week of year (00-53) - week 01 starts on the first Monday</td></tr><tr><td>%Y</td><td></td><td>year: 0000-9999</td></tr><tr><td>%%</td><td></td><td>%</td></tr></tbody></table>\n\nOther date and time functions can be expressed in terms of strftime():\n\n<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><b>Function</b></td><td width="30"></td><td><b>Equivalent strftime()</b></td></tr><tr><td>date(...)</td><td></td><td>strftime(\'%F\', ...)</td></tr><tr><td>time(...)</td><td></td><td>strftime(\'%T\', ...)</td></tr><tr><td>datetime(...)</td><td></td><td>strftime(\'%F %T\', ...)</td></tr><tr><td>julianday(...)</td><td></td><td><nobr>CAST(strftime(\'%J\', ...) as REAL)</nobr></td></tr><tr><td>unixepoch(...)</td><td></td><td><nobr>CAST(strftime(\'%s\', ...) as INT)</nobr></td></tr></tbody></table>\n\nThe date(), time(), and datetime() functions all return text, and so their strftime() equivalents are exact. However, the julianday() and unixepoch() functions return numeric values. Their strftime() equivalents return a string that is the text representation of the corresponding number. The main reasons for providing functions other than strftime() are for convenience and for efficiency. The julianday() and unixepoch() functions return real and integer values respectively, and do not incur the format conversion costs or inexactitude resulting from use of the \'%J\' or \'%s\' format specifiers with the strftime() function. The **timediff(A,B)** function returns a string that describes the amount of time that must be added to B in order to reach time A. The format of the timediff() result is designed to be human-readable. The format is: (+|-)YYYY-MM-DD HH:MM:SS.SSS This time difference string is also an allowed modifier for the other date/time functions. The following invariant holds for time-values A and B: datetime(A) = datetime(B, timediff(A,B)) The length of months and years vary. February is shorter than March. Leap years are longer than non-leap years. The output from timediff() takes this all into account. The timediff() function is intended to provide a human-friendly description of the time span. If you want to know the number of days or seconds between two dates, A and B, then you can always do one of these: SELECT julianday(B) - julianday(A);  \nSELECT unixepoch(B) - unixepoch(A); The timediff(A,B) might return the same result even for values A and B that span a different number of days - depending on the starting date. For example, both of the following two timediff() calls return the same result ("-0000-01-00 00:00:00.000") even though the first timespan is 28 days and the seconds is 31 days: SELECT timediff(\'2023-02-15\',\'2023-03-15\');  \nSELECT timediff(\'2023-03-15\',\'2023-04-15\'); Summary: If you want a human-friendly time span, use timediff(). If you want a precise time difference (in days or seconds) use the difference between two julianday() or unixepoch() calls. 2\\. Time ValuesA time-value can be in any of the following formats shown below. The value is usually a string, though it can be an integer or floating point number in the case of format 12.*   _YYYY-MM-DD_\n*   _YYYY-MM-DD HH:MM_\n*   _YYYY-MM-DD HH:MM:SS_\n*   _YYYY-MM-DD HH:MM:SS.SSS_\n*   _YYYY-MM-DD_**T**_HH:MM_\n*   _YYYY-MM-DD_**T**_HH:MM:SS_\n*   _YYYY-MM-DD_**T**_HH:MM:SS.SSS_\n*   _HH:MM_\n*   _HH:MM:SS_\n*   _HH:MM:SS.SSS_\n*   **now**\n*   _DDDDDDDDDD_\nIn formats 5 through 7, the "T" is a literal character separating the date and the time, as required by [ISO-8601](http://www.w3c.org/TR/NOTE-datetime). Formats 8 through 10 that specify only a time assume a date of 2000-01-01. Format 11, the string \'now\', is converted into the current date and time as obtained from the xCurrentTime method of the [sqlite3\\_vfs](https://www.sqlite.org/c3ref/vfs.html) object in use. The \'now\' argument to date and time functions always returns exactly the same value for multiple invocations within the same [sqlite3\\_step()](https://www.sqlite.org/c3ref/step.html) call. [Universal Coordinated Time (UTC)](http://en.wikipedia.org/wiki/Coordinated_Universal_Time) is used. Format 12 is the [Julian day number](http://en.wikipedia.org/wiki/Julian_day) expressed as an integer or floating point value. Format 12 might also be interpreted as a unix timestamp if it is immediately followed either the [\'auto\'](https://www.sqlite.org/lang_datefunc.html#automod) or [\'unixepoch\'](https://www.sqlite.org/lang_datefunc.html#jdmod) modifier. Formats 2 through 10 may be optionally followed by a timezone indicator of the form "_\\[+-\\]HH:MM_" or just "_Z_". The date and time functions use UTC or "zulu" time internally, and so the "Z" suffix is a no-op. Any non-zero "HH:MM" suffix is subtracted from the indicated date and time in order to compute zulu time. For example, all of the following time-values are equivalent: 2013-10-07 08:23:19.120  \n2013-10-07T08:23:19.120Z  \n2013-10-07 04:23:19.120-04:00  \n2456572.84952685 In formats 4, 7, and 10, the fractional seconds value SS.SSS can have one or more digits following the decimal point. Exactly three digits are shown in the examples because only the first three digits are significant to the result, but the input string can have fewer or more than three digits and the date/time functions will still operate correctly. Similarly, format 12 is shown with 10 significant digits, but the date/time functions will really accept as many or as few digits as are necessary to represent the Julian day number. [ISO-8601](http://www.w3c.org/TR/NOTE-datetime) supports a wide variety of alternative date/time formats, but SQLite only supports the ones specifically enumerated above. In all functions other than timediff(), the time-value (and all modifiers) may be omitted, in which case a time value of \'now\' is assumed. 3\\. ModifiersFor all date/time functions other than timediff(), the time-value argument can be followed by zero or more modifiers that alter date and/or time. Each modifier is a transformation that is applied to the time-value to its left. Modifiers are applied from left to right; order is important. The available modifiers are as follows.*   NNN days\n*   NNN hours\n*   NNN minutes\n*   NNN seconds\n*   NNN months\n*   NNN years\n*   ±HH:MM\n*   ±HH:MM:SS\n*   ±HH:MM:SS.SSS\n*   ±YYYY-MM-DD\n*   ±YYYY-MM-DD HH:MM\n*   ±YYYY-MM-DD HH:MM:SS\n*   ±YYYY-MM-DD HH:MM:SS.SSS\n*   ceiling\n*   floor\n*   start of month\n*   start of year\n*   start of day\n*   weekday N\n*   unixepoch\n*   julianday\n*   auto\n*   localtime\n*   utc\n*   subsec\n*   subsecond\nThe first thirteen modifiers (1 through 13) add the specified amount of time to the date and time specified by the arguments to its left. The \'s\' character at the end of the modifier names in 1 through 6 is optional. The NNN value can be any floating point number, with an optional \'+\' or \'-\' prefix. The **time shift modifiers** (7 through 13) move the time-value by the number of years, months, days, hours, minutes, and/or seconds specified. An initial "+" or "-" is required for formats 10 through 13 but is optional for formats 7, 8, and 9. The changes are applies from left to right. First the year is shifted by YYYY, then the month by MM, and then day by DD, and so forth. The timediff(A,B) function returns a time shift in format 13 that shifts the time-value B into A.Because the length of a month or year changes from one month or year to the next, ambiguities can arise when shifting a date by months and/or years. For example, what is the date one year after 2024-02-29? Is it 2025-02-28 or 2025-03-01? Or what is the date that is two months after 2023-12-31? Is it 2024-02-29 or 2024-03-02? There is no consensus on how to resolve this ambiguity, so the "**ceiling**" and "**floor**" modifiers (14 and 15) are available to let the programmer decide. If the next modifier after a time shift is "ceiling", then any ambiguity in the date is resolved by choosing the later date. The "floor" modifier resolves ambiguities by resolving to the last day of the previous month. The default behavior is "ceiling". The "**start of**" modifiers (16 through 18) shift the date backwards to the beginning of the subject month, year or day.The "**weekday**" modifier advances the date forward, if necessary, to the next date where the weekday number is N. Sunday is 0, Monday is 1, and so forth. If the date is already on the desired weekday, the "weekday" modifier leaves the date unchanged. The "**unixepoch**" modifier (20) only works if it immediately follows a time-value in the DDDDDDDDDD format. This modifier causes the DDDDDDDDDD to be interpreted not as a Julian day number as it normally would be, but as [Unix Time](http://en.wikipedia.org/wiki/Unix_time) - the number of seconds since 1970. If the "unixepoch" modifier does not follow a time-value of the form DDDDDDDDDD which expresses the number of seconds since 1970 or if other modifiers separate the "unixepoch" modifier from prior DDDDDDDDDD then the behavior is undefined. The "**julianday**" modifier must immediately follow the initial time-value which must be of the form DDDDDDDDD. Any other use of the \'julianday\' modifier is an error and causes the function to return NULL. The \'julianday\' modifier forces the time-value number to be interpreted as a julian-day number. As this is the default behavior, the \'julianday\' modifier is scarcely more than a no-op. The only difference is that adding \'julianday\' forces the DDDDDDDDD time-value format, and causes a NULL to be returned if any other time-value format is used. The "**auto**" modifier must immediately follow the initial time-value. If the time-value is numeric (the DDDDDDDDDD format) then the \'auto\' modifier causes the time-value to interpreted as either a julian day number or a unix timestamp, depending on its magnitude. If the value is between 0.0 and 5373484.499999, then it is interpreted as a julian day number (corresponding to dates between -4713-11-24 12:00:00 and 9999-12-31 23:59:59, inclusive). For numeric values outside of the range of valid julian day numbers, but within the range of -210866760000 to 253402300799, the \'auto\' modifier causes the value to be interpreted as a unix timestamp. Other numeric values are out of range and cause a NULL return. The \'auto\' modifier is a no-op for ISO 8601 text time-values. The "auto" modifier is designed to work with time-values even in cases where it is not known which time-value format is stored in the database file, or in cases where the same column stores time-values in different formats on different rows. The \'auto\' modifier will automatically select the appropriate format. However, there is some ambiguity. Unix timestamps for the first 63 days of 1970 will be interpreted as julian day numbers. The \'auto\' modifier is very useful when the dataset is guaranteed to contain no dates within that range, but should be avoided for applications that might make use of dates in the opening months of 1970. The "**localtime**" modifier assumes the time-value to its left is in Universal Coordinated Time (UTC) and adjusts that time value so that it is in localtime. If "localtime" follows a time that is not UTC, then the behavior is undefined. The "**utc**" modifier is the opposite of "localtime". "utc" assumes that the time-value to its left is in the local timezone and adjusts that time-value to be in UTC. If the time to the left is not in localtime, then the result of "utc" is undefined. The "**subsecond**" modifier (which may be abbreviated as just "**subsec**") increases the resolution of the output for [datetime()](https://www.sqlite.org/lang_datefunc.html#dttm), [time()](https://www.sqlite.org/lang_datefunc.html#dttm), and [unixepoch()](https://www.sqlite.org/lang_datefunc.html#uepch), and for the "%s" format string in [strftime()](https://www.sqlite.org/lang_datefunc.html#strftm). The "subsecond" modifier has no effect on other date/time functions. The current implemention increases the resolution from seconds to milliseconds, but this might increase to a higher resolution in future releases of SQLite. When "subsec" is used with [datetime()](https://www.sqlite.org/lang_datefunc.html#dttm) or [time()](https://www.sqlite.org/lang_datefunc.html#dttm), the seconds field at the end is followed by a decimal point and one or more digits to show fractional seconds. When "subsec" is used with [unixepoch()](https://www.sqlite.org/lang_datefunc.html#uepch), the result is a floating point value which is the number of seconds and fractional seconds since 1970-01-01. The "subsecond" and "subsec" modifiers have the special property that they can occur as the first argument to date/time functions (or as the first argument after the format string for strftime()). When this happens, the time-value that is normally in the first argument is understood to be "now". For example, a short cut to get the current time in seconds since 1970 with millisecond precision is to say: SELECT unixepoch(\'subsec\'); 4\\. ExamplesCompute the current date. SELECT date();Compute the last day of the current month.SELECT date(\'now\',\'start of month\',\'+1 month\',\'-1 day\'); Compute the date and time given a unix timestamp 1092941466. SELECT datetime(1092941466, \'unixepoch\');  \nSELECT datetime(1092941466, \'auto\'); -- Does not work for early 1970! Compute the date and time given a unix timestamp 1092941466, and compensate for your local timezone. SELECT datetime(1092941466, \'unixepoch\', \'localtime\'); Compute the current unix timestamp. SELECT unixepoch();  \nSELECT strftime(\'%s\'); Compute the number of days since the signing of the US Declaration of Independence. SELECT julianday(\'now\') - julianday(\'1776-07-04\'); Compute the number of seconds since a particular moment in 2004: SELECT unixepoch() - unixepoch(\'2004-01-01 02:34:56\'); Compute the date of the first Tuesday in October for the current year. SELECT date(\'now\',\'start of year\',\'+9 months\',\'weekday 2\'); Compute the time since the unix epoch in seconds with millisecond precision: SELECT (julianday(\'now\') - 2440587.5)\\*86400.0;  \nSELECT unixepoch(\'now\',\'subsec\'); Compute how old Abraham Lincoln would be if he were still alive today: SELECT timediff(\'now\',\'1809-02-12\'); 5\\. Caveats And BugsThe computation of local time depends heavily on the whim of politicians and is thus difficult to get correct for all locales. In this implementation, the standard C library function localtime\\_r() is used to assist in the calculation of local time. The localtime\\_r() C function normally only works for years between 1970 and 2037. For dates outside this range, SQLite attempts to map the year into an equivalent year within this range, do the calculation, then map the year back.These functions only work for dates between 0000-01-01 00:00:00 and 9999-12-31 23:59:59 (julian day numbers 1721059.5 through 5373484.5). For dates outside that range, the results of these functions are undefined.Non-Vista Windows platforms only support one set of DST rules. Vista only supports two. Therefore, on these platforms, historical DST calculations will be incorrect. For example, in the US, in 2007 the DST rules changed. Non-Vista Windows platforms apply the new 2007 DST rules to all previous years as well. Vista does somewhat better getting results correct back to 1986, when the rules were also changed.All internal computations assume the [Gregorian calendar](http://en.wikipedia.org/wiki/Gregorian_calendar) system. They also assume that every day is exactly 86400 seconds in duration; no leap seconds are incorporated.'},timediff:{args:"(time-value, time-value)",docs:'1\\. Overview SQLite supports seven [scalar](https://www.sqlite.org/lang_corefunc.html) date and time functions as follows:*   **date(**_time-value, modifier, modifier, ..._**)**\n*   **time(**_time-value, modifier, modifier, ..._**)**\n*   **datetime(**_time-value, modifier, modifier, ..._**)**\n*   **julianday(**_time-value, modifier, modifier, ..._**)**\n*   **unixepoch(**_time-value, modifier, modifier, ..._**)**\n*   **strftime(**_format, time-value, modifier, modifier, ..._**)**\n*   **timediff(**_time-value, time-value_**)**\nThe first six date and time functions take an optional [time-value](https://www.sqlite.org/lang_datefunc.html#tmval) as an argument, followed by zero or more [modifiers](https://www.sqlite.org/lang_datefunc.html#dtmods). The strftime() function also takes a format string as its first argument. The timediff() function takes exactly two arguments which are both [time-values](https://www.sqlite.org/lang_datefunc.html#tmval). SQLite does not have a dedicated date/time datatype. Instead, date and time values can stored as any of the following:\n\n<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><a href="http://en.wikipedia.org/wiki/ISO_8601">ISO-8601</a></td><td>A text string that is one of the ISO 8601 date/time values shown in <a href="about:blank#tmval">items 1 through 10 below</a>. Example: <tt>\'2025-05-29 14:16:00\'</tt></td></tr><tr><td><a href="http://en.wikipedia.org/wiki/Julian_day">Julian&nbsp;day&nbsp;number</a></td><td>The number of days including fractional days since -4713-11-24 12:00:00 Example: <tt>2460825.09444444</tt></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Unix_time">Unix timestamp</a></td><td>The number of seconds including fractional seconds since 1970-01-01 00:00:00 Example: <tt>1748528160</tt></td></tr></tbody></table>\n\nThese three formats are collectively known as [time-values](https://www.sqlite.org/lang_datefunc.html#tmval). All of the date time functions accept time-values as either ISO-8601 text or as Julian day numbers. They can also be made to accept unix timestamps by adding optional modifiers arguments [\'auto\'](https://www.sqlite.org/lang_datefunc.html#automod) or [\'unixepoch\'](https://www.sqlite.org/lang_datefunc.html#jdmod). Since the timediff() function does not accept modifiers, it can only use ISO-8601 and julian day number time-values. The **date()** function returns the date as text in this format: YYYY-MM-DD. The **time()** function returns the time as text in formatted as HH:MM:SS or as HH:MM:SS.SSS if the [subsec modifier](https://www.sqlite.org/lang_datefunc.html#subsec) is used. The **datetime()** function returns the date and time formatted as YYYY-MM-DD HH:MM:SS or as YYYY-MM-DD HH:MM:SS.SSS if the [subsec modifier](https://www.sqlite.org/lang_datefunc.html#subsec) is used. The **julianday()** function returns the [Julian day](http://en.wikipedia.org/wiki/Julian_day) - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. ([Proleptic Gregorian calendar](http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar)). The **unixepoch()** function returns a unix timestamp - the number of seconds since 1970-01-01 00:00:00 UTC. The unixepoch() function normally returns an integer number of seconds, but with the optional [subsec modifier](https://www.sqlite.org/lang_datefunc.html#subsec) it will return a floating point number which is the fractional number of seconds. The **strftime()** function returns the date formatted according to the format string specified as the first argument. The format string supports the most common substitutions found in the [strftime() function](http://opengroup.org/onlinepubs/007908799/xsh/strftime.html) from the standard C library plus two new substitutions, %f and %J. The following is a complete list of valid strftime() substitutions as of version 3.46.0 (2024-05-23). Earlier versions of SQLite might not support all substitutions. If an undefined or unsupported substitution is seen, the result is NULL.\n\n<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td></td><td width="10"></td><td></td></tr><tr><td>%d</td><td></td><td>day of month: 01-31</td></tr><tr><td>%e</td><td></td><td>day of month without leading zero: 1-31</td></tr><tr><td>%f</td><td></td><td>fractional seconds: SS.SSS</td></tr><tr><td>%F</td><td></td><td>ISO 8601 date: YYYY-MM-DD</td></tr><tr><td>%G</td><td></td><td>ISO 8601 year corresponding to %V</td></tr><tr><td>%g</td><td></td><td>2-digit ISO 8601 year corresponding to %V</td></tr><tr><td>%H</td><td></td><td>hour: 00-24</td></tr><tr><td>%I</td><td></td><td>hour for 12-hour clock: 01-12</td></tr><tr><td>%j</td><td></td><td>day of year: 001-366</td></tr><tr><td>%J</td><td></td><td>Julian day number (fractional)</td></tr><tr><td>%k</td><td></td><td>hour without leading zero: 0-24</td></tr><tr><td>%l</td><td></td><td>%I without leading zero: 1-12</td></tr><tr><td>%m</td><td></td><td>month: 01-12</td></tr><tr><td>%M</td><td></td><td>minute: 00-59</td></tr><tr><td>%p</td><td></td><td>"AM" or "PM" depending on the hour</td></tr><tr><td>%P</td><td></td><td>"am" or "pm" depending on the hour</td></tr><tr><td>%R</td><td></td><td>ISO 8601 time: HH:MM</td></tr><tr><td>%s</td><td></td><td>seconds since 1970-01-01</td></tr><tr><td>%S</td><td></td><td>seconds: 00-59</td></tr><tr><td>%T</td><td></td><td>ISO 8601 time: HH:MM:SS</td></tr><tr><td>%U</td><td></td><td>week of year (00-53) - week 01 starts on the first Sunday</td></tr><tr><td>%u</td><td></td><td>day of week 1-7 with Monday==1</td></tr><tr><td>%V</td><td></td><td>ISO 8601 week of year</td></tr><tr><td>%w</td><td></td><td>day of week 0-6 with Sunday==0</td></tr><tr><td>%W</td><td></td><td>week of year (00-53) - week 01 starts on the first Monday</td></tr><tr><td>%Y</td><td></td><td>year: 0000-9999</td></tr><tr><td>%%</td><td></td><td>%</td></tr></tbody></table>\n\nOther date and time functions can be expressed in terms of strftime():\n\n<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><b>Function</b></td><td width="30"></td><td><b>Equivalent strftime()</b></td></tr><tr><td>date(...)</td><td></td><td>strftime(\'%F\', ...)</td></tr><tr><td>time(...)</td><td></td><td>strftime(\'%T\', ...)</td></tr><tr><td>datetime(...)</td><td></td><td>strftime(\'%F %T\', ...)</td></tr><tr><td>julianday(...)</td><td></td><td><nobr>CAST(strftime(\'%J\', ...) as REAL)</nobr></td></tr><tr><td>unixepoch(...)</td><td></td><td><nobr>CAST(strftime(\'%s\', ...) as INT)</nobr></td></tr></tbody></table>\n\nThe date(), time(), and datetime() functions all return text, and so their strftime() equivalents are exact. However, the julianday() and unixepoch() functions return numeric values. Their strftime() equivalents return a string that is the text representation of the corresponding number. The main reasons for providing functions other than strftime() are for convenience and for efficiency. The julianday() and unixepoch() functions return real and integer values respectively, and do not incur the format conversion costs or inexactitude resulting from use of the \'%J\' or \'%s\' format specifiers with the strftime() function. The **timediff(A,B)** function returns a string that describes the amount of time that must be added to B in order to reach time A. The format of the timediff() result is designed to be human-readable. The format is: (+|-)YYYY-MM-DD HH:MM:SS.SSS This time difference string is also an allowed modifier for the other date/time functions. The following invariant holds for time-values A and B: datetime(A) = datetime(B, timediff(A,B)) The length of months and years vary. February is shorter than March. Leap years are longer than non-leap years. The output from timediff() takes this all into account. The timediff() function is intended to provide a human-friendly description of the time span. If you want to know the number of days or seconds between two dates, A and B, then you can always do one of these: SELECT julianday(B) - julianday(A);  \nSELECT unixepoch(B) - unixepoch(A); The timediff(A,B) might return the same result even for values A and B that span a different number of days - depending on the starting date. For example, both of the following two timediff() calls return the same result ("-0000-01-00 00:00:00.000") even though the first timespan is 28 days and the seconds is 31 days: SELECT timediff(\'2023-02-15\',\'2023-03-15\');  \nSELECT timediff(\'2023-03-15\',\'2023-04-15\'); Summary: If you want a human-friendly time span, use timediff(). If you want a precise time difference (in days or seconds) use the difference between two julianday() or unixepoch() calls. 2\\. Time ValuesA time-value can be in any of the following formats shown below. The value is usually a string, though it can be an integer or floating point number in the case of format 12.*   _YYYY-MM-DD_\n*   _YYYY-MM-DD HH:MM_\n*   _YYYY-MM-DD HH:MM:SS_\n*   _YYYY-MM-DD HH:MM:SS.SSS_\n*   _YYYY-MM-DD_**T**_HH:MM_\n*   _YYYY-MM-DD_**T**_HH:MM:SS_\n*   _YYYY-MM-DD_**T**_HH:MM:SS.SSS_\n*   _HH:MM_\n*   _HH:MM:SS_\n*   _HH:MM:SS.SSS_\n*   **now**\n*   _DDDDDDDDDD_\nIn formats 5 through 7, the "T" is a literal character separating the date and the time, as required by [ISO-8601](http://www.w3c.org/TR/NOTE-datetime). Formats 8 through 10 that specify only a time assume a date of 2000-01-01. Format 11, the string \'now\', is converted into the current date and time as obtained from the xCurrentTime method of the [sqlite3\\_vfs](https://www.sqlite.org/c3ref/vfs.html) object in use. The \'now\' argument to date and time functions always returns exactly the same value for multiple invocations within the same [sqlite3\\_step()](https://www.sqlite.org/c3ref/step.html) call. [Universal Coordinated Time (UTC)](http://en.wikipedia.org/wiki/Coordinated_Universal_Time) is used. Format 12 is the [Julian day number](http://en.wikipedia.org/wiki/Julian_day) expressed as an integer or floating point value. Format 12 might also be interpreted as a unix timestamp if it is immediately followed either the [\'auto\'](https://www.sqlite.org/lang_datefunc.html#automod) or [\'unixepoch\'](https://www.sqlite.org/lang_datefunc.html#jdmod) modifier. Formats 2 through 10 may be optionally followed by a timezone indicator of the form "_\\[+-\\]HH:MM_" or just "_Z_". The date and time functions use UTC or "zulu" time internally, and so the "Z" suffix is a no-op. Any non-zero "HH:MM" suffix is subtracted from the indicated date and time in order to compute zulu time. For example, all of the following time-values are equivalent: 2013-10-07 08:23:19.120  \n2013-10-07T08:23:19.120Z  \n2013-10-07 04:23:19.120-04:00  \n2456572.84952685 In formats 4, 7, and 10, the fractional seconds value SS.SSS can have one or more digits following the decimal point. Exactly three digits are shown in the examples because only the first three digits are significant to the result, but the input string can have fewer or more than three digits and the date/time functions will still operate correctly. Similarly, format 12 is shown with 10 significant digits, but the date/time functions will really accept as many or as few digits as are necessary to represent the Julian day number. [ISO-8601](http://www.w3c.org/TR/NOTE-datetime) supports a wide variety of alternative date/time formats, but SQLite only supports the ones specifically enumerated above. In all functions other than timediff(), the time-value (and all modifiers) may be omitted, in which case a time value of \'now\' is assumed. 3\\. ModifiersFor all date/time functions other than timediff(), the time-value argument can be followed by zero or more modifiers that alter date and/or time. Each modifier is a transformation that is applied to the time-value to its left. Modifiers are applied from left to right; order is important. The available modifiers are as follows.*   NNN days\n*   NNN hours\n*   NNN minutes\n*   NNN seconds\n*   NNN months\n*   NNN years\n*   ±HH:MM\n*   ±HH:MM:SS\n*   ±HH:MM:SS.SSS\n*   ±YYYY-MM-DD\n*   ±YYYY-MM-DD HH:MM\n*   ±YYYY-MM-DD HH:MM:SS\n*   ±YYYY-MM-DD HH:MM:SS.SSS\n*   ceiling\n*   floor\n*   start of month\n*   start of year\n*   start of day\n*   weekday N\n*   unixepoch\n*   julianday\n*   auto\n*   localtime\n*   utc\n*   subsec\n*   subsecond\nThe first thirteen modifiers (1 through 13) add the specified amount of time to the date and time specified by the arguments to its left. The \'s\' character at the end of the modifier names in 1 through 6 is optional. The NNN value can be any floating point number, with an optional \'+\' or \'-\' prefix. The **time shift modifiers** (7 through 13) move the time-value by the number of years, months, days, hours, minutes, and/or seconds specified. An initial "+" or "-" is required for formats 10 through 13 but is optional for formats 7, 8, and 9. The changes are applies from left to right. First the year is shifted by YYYY, then the month by MM, and then day by DD, and so forth. The timediff(A,B) function returns a time shift in format 13 that shifts the time-value B into A.Because the length of a month or year changes from one month or year to the next, ambiguities can arise when shifting a date by months and/or years. For example, what is the date one year after 2024-02-29? Is it 2025-02-28 or 2025-03-01? Or what is the date that is two months after 2023-12-31? Is it 2024-02-29 or 2024-03-02? There is no consensus on how to resolve this ambiguity, so the "**ceiling**" and "**floor**" modifiers (14 and 15) are available to let the programmer decide. If the next modifier after a time shift is "ceiling", then any ambiguity in the date is resolved by choosing the later date. The "floor" modifier resolves ambiguities by resolving to the last day of the previous month. The default behavior is "ceiling". The "**start of**" modifiers (16 through 18) shift the date backwards to the beginning of the subject month, year or day.The "**weekday**" modifier advances the date forward, if necessary, to the next date where the weekday number is N. Sunday is 0, Monday is 1, and so forth. If the date is already on the desired weekday, the "weekday" modifier leaves the date unchanged. The "**unixepoch**" modifier (20) only works if it immediately follows a time-value in the DDDDDDDDDD format. This modifier causes the DDDDDDDDDD to be interpreted not as a Julian day number as it normally would be, but as [Unix Time](http://en.wikipedia.org/wiki/Unix_time) - the number of seconds since 1970. If the "unixepoch" modifier does not follow a time-value of the form DDDDDDDDDD which expresses the number of seconds since 1970 or if other modifiers separate the "unixepoch" modifier from prior DDDDDDDDDD then the behavior is undefined. The "**julianday**" modifier must immediately follow the initial time-value which must be of the form DDDDDDDDD. Any other use of the \'julianday\' modifier is an error and causes the function to return NULL. The \'julianday\' modifier forces the time-value number to be interpreted as a julian-day number. As this is the default behavior, the \'julianday\' modifier is scarcely more than a no-op. The only difference is that adding \'julianday\' forces the DDDDDDDDD time-value format, and causes a NULL to be returned if any other time-value format is used. The "**auto**" modifier must immediately follow the initial time-value. If the time-value is numeric (the DDDDDDDDDD format) then the \'auto\' modifier causes the time-value to interpreted as either a julian day number or a unix timestamp, depending on its magnitude. If the value is between 0.0 and 5373484.499999, then it is interpreted as a julian day number (corresponding to dates between -4713-11-24 12:00:00 and 9999-12-31 23:59:59, inclusive). For numeric values outside of the range of valid julian day numbers, but within the range of -210866760000 to 253402300799, the \'auto\' modifier causes the value to be interpreted as a unix timestamp. Other numeric values are out of range and cause a NULL return. The \'auto\' modifier is a no-op for ISO 8601 text time-values. The "auto" modifier is designed to work with time-values even in cases where it is not known which time-value format is stored in the database file, or in cases where the same column stores time-values in different formats on different rows. The \'auto\' modifier will automatically select the appropriate format. However, there is some ambiguity. Unix timestamps for the first 63 days of 1970 will be interpreted as julian day numbers. The \'auto\' modifier is very useful when the dataset is guaranteed to contain no dates within that range, but should be avoided for applications that might make use of dates in the opening months of 1970. The "**localtime**" modifier assumes the time-value to its left is in Universal Coordinated Time (UTC) and adjusts that time value so that it is in localtime. If "localtime" follows a time that is not UTC, then the behavior is undefined. The "**utc**" modifier is the opposite of "localtime". "utc" assumes that the time-value to its left is in the local timezone and adjusts that time-value to be in UTC. If the time to the left is not in localtime, then the result of "utc" is undefined. The "**subsecond**" modifier (which may be abbreviated as just "**subsec**") increases the resolution of the output for [datetime()](https://www.sqlite.org/lang_datefunc.html#dttm), [time()](https://www.sqlite.org/lang_datefunc.html#dttm), and [unixepoch()](https://www.sqlite.org/lang_datefunc.html#uepch), and for the "%s" format string in [strftime()](https://www.sqlite.org/lang_datefunc.html#strftm). The "subsecond" modifier has no effect on other date/time functions. The current implemention increases the resolution from seconds to milliseconds, but this might increase to a higher resolution in future releases of SQLite. When "subsec" is used with [datetime()](https://www.sqlite.org/lang_datefunc.html#dttm) or [time()](https://www.sqlite.org/lang_datefunc.html#dttm), the seconds field at the end is followed by a decimal point and one or more digits to show fractional seconds. When "subsec" is used with [unixepoch()](https://www.sqlite.org/lang_datefunc.html#uepch), the result is a floating point value which is the number of seconds and fractional seconds since 1970-01-01. The "subsecond" and "subsec" modifiers have the special property that they can occur as the first argument to date/time functions (or as the first argument after the format string for strftime()). When this happens, the time-value that is normally in the first argument is understood to be "now". For example, a short cut to get the current time in seconds since 1970 with millisecond precision is to say: SELECT unixepoch(\'subsec\'); 4\\. ExamplesCompute the current date. SELECT date();Compute the last day of the current month.SELECT date(\'now\',\'start of month\',\'+1 month\',\'-1 day\'); Compute the date and time given a unix timestamp 1092941466. SELECT datetime(1092941466, \'unixepoch\');  \nSELECT datetime(1092941466, \'auto\'); -- Does not work for early 1970! Compute the date and time given a unix timestamp 1092941466, and compensate for your local timezone. SELECT datetime(1092941466, \'unixepoch\', \'localtime\'); Compute the current unix timestamp. SELECT unixepoch();  \nSELECT strftime(\'%s\'); Compute the number of days since the signing of the US Declaration of Independence. SELECT julianday(\'now\') - julianday(\'1776-07-04\'); Compute the number of seconds since a particular moment in 2004: SELECT unixepoch() - unixepoch(\'2004-01-01 02:34:56\'); Compute the date of the first Tuesday in October for the current year. SELECT date(\'now\',\'start of year\',\'+9 months\',\'weekday 2\'); Compute the time since the unix epoch in seconds with millisecond precision: SELECT (julianday(\'now\') - 2440587.5)\\*86400.0;  \nSELECT unixepoch(\'now\',\'subsec\'); Compute how old Abraham Lincoln would be if he were still alive today: SELECT timediff(\'now\',\'1809-02-12\'); 5\\. Caveats And BugsThe computation of local time depends heavily on the whim of politicians and is thus difficult to get correct for all locales. In this implementation, the standard C library function localtime\\_r() is used to assist in the calculation of local time. The localtime\\_r() C function normally only works for years between 1970 and 2037. For dates outside this range, SQLite attempts to map the year into an equivalent year within this range, do the calculation, then map the year back.These functions only work for dates between 0000-01-01 00:00:00 and 9999-12-31 23:59:59 (julian day numbers 1721059.5 through 5373484.5). For dates outside that range, the results of these functions are undefined.Non-Vista Windows platforms only support one set of DST rules. Vista only supports two. Therefore, on these platforms, historical DST calculations will be incorrect. For example, in the US, in 2007 the DST rules changed. Non-Vista Windows platforms apply the new 2007 DST rules to all previous years as well. Vista does somewhat better getting results correct back to 1986, when the rules were also changed.All internal computations assume the [Gregorian calendar](http://en.wikipedia.org/wiki/Gregorian_calendar) system. They also assume that every day is exactly 86400 seconds in duration; no leap seconds are incorporated.'},avg:{args:"(X)",docs:"The avg() function returns the average value of all non-NULL _X_ within a group. String and BLOB values that do not look like numbers are interpreted as 0. The result of avg() is always a floating point value whenever there is at least one non-NULL input even if all inputs are integers. The result of avg() is NULL if there are no non-NULL inputs. The result of avg() is computed as [total()](https://www.sqlite.org/lang_aggfunc.html#sumunc)/[count()](https://www.sqlite.org/lang_aggfunc.html#count) so all of the constraints that apply to [total()](https://www.sqlite.org/lang_aggfunc.html#sumunc) also apply to avg()."},count:{args:"(*)",docs:"The count(X) function returns a count of the number of times that _X_ is not NULL in a group. The count(\\*) function (with no arguments) returns the total number of rows in the group."},group_concat:{args:"(X,Y)",docs:'The group\\_concat() function returns a string which is the concatenation of all non-NULL values of _X_. If parameter _Y_ is present then it is used as the separator between instances of _X_.A comma (",") is used as the separator if _Y_ is omitted.\n\nThe string\\_agg(X,Y) function is an alias for group\\_concat(X,Y). String\\_agg() is compatible with PostgreSQL and SQL-Server and group\\_concat() is compatible with MySQL.\n\nThe order of the concatenated elements is arbitrary unless an ORDER BY argument is included immediately after the last parameter.'},string_agg:{args:"(X,Y)",docs:'The group\\_concat() function returns a string which is the concatenation of all non-NULL values of _X_. If parameter _Y_ is present then it is used as the separator between instances of _X_.A comma (",") is used as the separator if _Y_ is omitted.\n\nThe string\\_agg(X,Y) function is an alias for group\\_concat(X,Y). String\\_agg() is compatible with PostgreSQL and SQL-Server and group\\_concat() is compatible with MySQL.\n\nThe order of the concatenated elements is arbitrary unless an ORDER BY argument is included immediately after the last parameter.'},sum:{args:"(X)",docs:'The sum() and total() aggregate functions return the sum of all non-NULL values in the group. If there are no non-NULL input rows then sum() returns NULL but total() returns 0.0. NULL is not normally a helpful result for the sum of no rows but the SQL standard requires it and most other SQL database engines implement sum() that way so SQLite does it in the same way in order to be compatible. The non-standard total() function is provided as a convenient way to work around this design problem in the SQL language.\n\nThe result of total() is always a floating point value. The result of sum() is an integer value if all non-NULL inputs are integers. If any input to sum() is neither an integer nor a NULL, then sum() returns a floating point value which is an approximation of the mathematical sum.\n\nSum() will throw an "integer overflow" exception if all inputs are integers or NULL and an integer overflow occurs at any point during the computation. No overflow error is ever raised if any prior input was a floating point value. Total() never throws an integer overflow.\n\nWhen summing floating-point values, if the magnitudes of the values differ wildly then the resulting sum might be imprecise due to the fact that [IEEE 754 floating point values are approximations](https://www.sqlite.org/floatingpoint.html#fpapprox). Use the decimal\\_sum(X) aggregate in the [decimal extension](https://www.sqlite.org/floatingpoint.html#decext) to obtain an exact summation of floating point numbers. Consider this test case:\n\n> CREATE TABLE t1(x REAL);\n> INSERT INTO t1 VALUES(1.55e+308),(1.23),(3.2e-16),(-1.23),(-1.55e308);\n> SELECT sum(x), decimal\\_sum(x) FROM t1;\n\nThe large values ±1.55e+308 cancel each other out, but the cancellation does not occur until the end of the sum and in the meantime the large +1.55e+308 swamps the tiny 3.2e-16 value. The end result is an imprecise result for the sum(). The decimal\\_sum() aggregate generates an exact answer, at the cost of additional CPU and memory usage. Note also that decimal\\_sum() is not built into the SQLite core; it is a [loadable extension](https://www.sqlite.org/loadext.html).\n\nIf sum of inputs is too large to represent as a IEEE 754 floating point value, then a +Infinity or -Infinity result may be returned. If very large values with differing signs are used such that the SUM() or TOTAL() function is unable to determine if the correct result is +Infinity or -Infinity or some other value in between, then the result is NULL. Hence, for example, the following query returns NULL:\n\n> WITH t1(x) AS (VALUES(1.0),(-9e+999),(2.0),(+9e+999),(3.0))\n>  SELECT sum(x) FROM t1;'},total:{args:"(X)",docs:'The sum() and total() aggregate functions return the sum of all non-NULL values in the group. If there are no non-NULL input rows then sum() returns NULL but total() returns 0.0. NULL is not normally a helpful result for the sum of no rows but the SQL standard requires it and most other SQL database engines implement sum() that way so SQLite does it in the same way in order to be compatible. The non-standard total() function is provided as a convenient way to work around this design problem in the SQL language.\n\nThe result of total() is always a floating point value. The result of sum() is an integer value if all non-NULL inputs are integers. If any input to sum() is neither an integer nor a NULL, then sum() returns a floating point value which is an approximation of the mathematical sum.\n\nSum() will throw an "integer overflow" exception if all inputs are integers or NULL and an integer overflow occurs at any point during the computation. No overflow error is ever raised if any prior input was a floating point value. Total() never throws an integer overflow.\n\nWhen summing floating-point values, if the magnitudes of the values differ wildly then the resulting sum might be imprecise due to the fact that [IEEE 754 floating point values are approximations](https://www.sqlite.org/floatingpoint.html#fpapprox). Use the decimal\\_sum(X) aggregate in the [decimal extension](https://www.sqlite.org/floatingpoint.html#decext) to obtain an exact summation of floating point numbers. Consider this test case:\n\n> CREATE TABLE t1(x REAL);\n> INSERT INTO t1 VALUES(1.55e+308),(1.23),(3.2e-16),(-1.23),(-1.55e308);\n> SELECT sum(x), decimal\\_sum(x) FROM t1;\n\nThe large values ±1.55e+308 cancel each other out, but the cancellation does not occur until the end of the sum and in the meantime the large +1.55e+308 swamps the tiny 3.2e-16 value. The end result is an imprecise result for the sum(). The decimal\\_sum() aggregate generates an exact answer, at the cost of additional CPU and memory usage. Note also that decimal\\_sum() is not built into the SQLite core; it is a [loadable extension](https://www.sqlite.org/loadext.html).\n\nIf sum of inputs is too large to represent as a IEEE 754 floating point value, then a +Infinity or -Infinity result may be returned. If very large values with differing signs are used such that the SUM() or TOTAL() function is unable to determine if the correct result is +Infinity or -Infinity or some other value in between, then the result is NULL. Hence, for example, the following query returns NULL:\n\n> WITH t1(x) AS (VALUES(1.0),(-9e+999),(2.0),(+9e+999),(3.0))\n>  SELECT sum(x) FROM t1;'},row_number:{args:"()",docs:"The number of the row within the current partition. Rows are numbered starting from 1 in the order defined by the ORDER BY clause in the window definition, or in arbitrary order otherwise."},rank:{args:"()",docs:"The row\\_number() of the first peer in each group - the rank of the current row with gaps. If there is no ORDER BY clause, then all rows are considered peers and this function always returns 1."},dense_rank:{args:"()",docs:"The number of the current row's peer group within its partition - the rank of the current row without gaps. Rows are numbered starting from 1 in the order defined by the ORDER BY clause in the window definition. If there is no ORDER BY clause, then all rows are considered peers and this function always returns 1."},percent_rank:{args:"()",docs:"Despite the name, this function always returns a value between 0.0 and 1.0 equal to (_rank_ - 1)/(_partition-rows_ - 1), where _rank_ is the value returned by built-in window function rank() and _partition-rows_ is the total number of rows in the partition. If the partition contains only one row, this function returns 0.0."},cume_dist:{args:"()",docs:"The cumulative distribution. Calculated as _row-number_/_partition-rows_, where _row-number_ is the value returned by row\\_number() for the last peer in the group and _partition-rows_ the number of rows in the partition."},ntile:{args:"(N)",docs:"Argument _N_ is handled as an integer. This function divides the partition into N groups as evenly as possible and assigns an integer between 1 and _N_ to each group, in the order defined by the ORDER BY clause, or in arbitrary order otherwise. If necessary, larger groups occur first. This function returns the integer value assigned to the group that the current row is a part of."},lag:{args:"(expr, offset, default)",docs:"The first form of the lag() function returns the result of evaluating expression _expr_ against the previous row in the partition. Or, if there is no previous row (because the current row is the first), NULL.\n\nIf the _offset_ argument is provided, then it must be a non-negative integer. In this case the value returned is the result of evaluating _expr_ against the row _offset_ rows before the current row within the partition. If _offset_ is 0, then _expr_ is evaluated against the current row. If there is no row _offset_ rows before the current row, NULL is returned.\n\nIf _default_ is also provided, then it is returned instead of NULL if the row identified by _offset_ does not exist."},lead:{args:"(expr, offset, default)",docs:"The first form of the lead() function returns the result of evaluating expression _expr_ against the next row in the partition. Or, if there is no next row (because the current row is the last), NULL.\n\nIf the _offset_ argument is provided, then it must be a non-negative integer. In this case the value returned is the result of evaluating _expr_ against the row _offset_ rows after the current row within the partition. If _offset_ is 0, then _expr_ is evaluated against the current row. If there is no row _offset_ rows after the current row, NULL is returned.\n\nIf _default_ is also provided, then it is returned instead of NULL if the row identified by _offset_ does not exist."},first_value:{args:"(expr)",docs:"This built-in window function calculates the window frame for each row in the same way as an aggregate window function. It returns the value of _expr_ evaluated against the first row in the window frame for each row."},last_value:{args:"(expr)",docs:"This built-in window function calculates the window frame for each row in the same way as an aggregate window function. It returns the value of _expr_ evaluated against the last row in the window frame for each row."},nth_value:{args:"(expr, N)",docs:"This built-in window function calculates the window frame for each row in the same way as an aggregate window function. It returns the value of _expr_ evaluated against the row _N_ of the window frame. Rows are numbered within the window frame starting from 1 in the order defined by the ORDER BY clause if one is present, or in arbitrary order otherwise. If there is no _N_th row in the partition, then NULL is returned."},acos:{args:"(X)",docs:"Return the arccosine of X. The result is in radians."},acosh:{args:"(X)",docs:"Return the hyperbolic arccosine of X."},asin:{args:"(X)",docs:"Return the arcsine of X. The result is in radians."},asinh:{args:"(X)",docs:"Return the hyperbolic arcsine of X."},atan:{args:"(X)",docs:"Return the arctangent of X. The result is in radians."},atan2:{args:"(Y,X)",docs:"Return the arctangent of Y/X. The result is in radians. The result is placed into correct quadrant depending on the signs of X and Y."},atanh:{args:"(X)",docs:"Return the hyperbolic arctangent of X."},ceil:{args:"(X)",docs:"Return the first representable integer value greater than or equal to X. For positive values of X, this routine rounds away from zero. For negative values of X, this routine rounds toward zero."},ceiling:{args:"(X)",docs:"Return the first representable integer value greater than or equal to X. For positive values of X, this routine rounds away from zero. For negative values of X, this routine rounds toward zero."},cos:{args:"(X)",docs:"Return the cosine of X. X is in radians."},cosh:{args:"(X)",docs:"Return the hyperbolic cosine of X."},degrees:{args:"(X)",docs:"Convert value X from radians into degrees."},exp:{args:"(X)",docs:"Compute _e_ (Euler's number, approximately 2.71828182845905) raised to the power X."},floor:{args:"(X)",docs:"Return the first representable integer value less than or equal to X. For positive numbers, this function rounds toward zero. For negative numbers, this function rounds away from zero."},ln:{args:"(X)",docs:"Return the natural logarithm of X."},log:{args:"(B,X)",docs:"Return the base-10 logarithm for X. Or, for the two-argument version, return the base-B logarithm of X.\n\nCompatibility note: SQLite works like PostgreSQL in that the log() function computes a base-10 logarithm. Most other SQL database engines compute a natural logarithm for log(). In the two-argument version of log(B,X), the first argument is the base and the second argument is the operand. This is the same as in PostgreSQL and MySQL, but is reversed from SQL Server which uses the second argument as the base and the first argument as the operand."},log10:{args:"(X)",docs:"Return the base-10 logarithm for X. Or, for the two-argument version, return the base-B logarithm of X.\n\nCompatibility note: SQLite works like PostgreSQL in that the log() function computes a base-10 logarithm. Most other SQL database engines compute a natural logarithm for log(). In the two-argument version of log(B,X), the first argument is the base and the second argument is the operand. This is the same as in PostgreSQL and MySQL, but is reversed from SQL Server which uses the second argument as the base and the first argument as the operand."},log2:{args:"(X)",docs:"Return the logarithm base-2 for the number X."},mod:{args:"(X,Y)",docs:"Return the remainder after dividing X by Y. This is similar to the '%' operator, except that it works for non-integer arguments."},pi:{args:"()",docs:"Return an approximation for π."},pow:{args:"(X,Y)",docs:"Compute X raised to the power Y."},power:{args:"(X,Y)",docs:"Compute X raised to the power Y."},radians:{args:"(X)",docs:"Convert X from degrees into radians."},sin:{args:"(X)",docs:"Return the sine of X. X is in radians."},sinh:{args:"(X)",docs:"Return the hyperbolic sine of X."},sqrt:{args:"(X)",docs:"Return the square root of X. NULL is returned if X is negative."},tan:{args:"(X)",docs:"Return the tangent of X. X is in radians."},tanh:{args:"(X)",docs:"Return the hyperbolic tangent of X."},trunc:{args:"(X)",docs:"Return the representable integer in between X and 0 (inclusive) that is furthest away from zero. Or, in other words, return the integer part of X, rounding toward zero. The trunc() function is similar to [ceiling(X)](https://www.sqlite.org/lang_mathfunc.html#ceil) and [floor(X)](https://www.sqlite.org/lang_mathfunc.html#floor) except that it always rounds toward zero whereas ceiling(X) and floor(X) round up and down, respectively."},json:{args:"(json)",docs:'The json(X) function verifies that its argument X is a valid JSON string or JSONB blob and returns a minified version of that JSON string with all unnecessary whitespace removed. If X is not a well-formed JSON string or JSONB blob, then this routine throws an error. If the input is JSON5 text, then it is converted into canonical RFC-8259 text prior to being returned. If the argument X to json(X) contains JSON objects with duplicate labels, then it is undefined whether or not the duplicates are preserved. The current implementation preserves duplicates. However, future enhancements to this routine may choose to silently remove duplicates. Example:*   json(\' { "this" : "is", "a": \\[ "test" \\] } \') → \'{"this":"is","a":\\["test"\\]}\''},jsonb:{args:"(json)",docs:'The json(X) function verifies that its argument X is a valid JSON string or JSONB blob and returns a minified version of that JSON string with all unnecessary whitespace removed. If X is not a well-formed JSON string or JSONB blob, then this routine throws an error. If the input is JSON5 text, then it is converted into canonical RFC-8259 text prior to being returned. If the argument X to json(X) contains JSON objects with duplicate labels, then it is undefined whether or not the duplicates are preserved. The current implementation preserves duplicates. However, future enhancements to this routine may choose to silently remove duplicates. Example:*   json(\' { "this" : "is", "a": \\[ "test" \\] } \') → \'{"this":"is","a":\\["test"\\]}\''},json_array:{args:"(value1, value2, ...)",docs:"The json\\_array() SQL function accepts zero or more arguments and returns a well-formed JSON array that is composed from those arguments. If any argument to json\\_array() is a BLOB then an error is thrown. An argument with SQL type TEXT is normally converted into a quoted JSON string. However, if the argument is the output from another json1 function, then it is stored as JSON. This allows calls to json\\_array() and [json\\_object()](https://www.sqlite.org/json1.html#jobj) to be nested. The [json()](https://www.sqlite.org/json1.html#jmini) function can also be used to force strings to be recognized as JSON. Examples:*   json\\_array(1,2,'3',4) → '\\[1,2,\"3\",4\\]'\n*   json\\_array('\\[1,2\\]') → '\\[\"\\[1,2\\]\"\\]'\n*   json\\_array(json\\_array(1,2)) → '\\[\\[1,2\\]\\]'\n*   json\\_array(1,null,'3','\\[4,5\\]','{\"six\":7.7}') → '\\[1,null,\"3\",\"\\[4,5\\]\",\"{\\\\\"six\\\\\":7.7}\"\\]'\n*   json\\_array(1,null,'3',json('\\[4,5\\]'),json('{\"six\":7.7}')) → '\\[1,null,\"3\",\\[4,5\\],{\"six\":7.7}\\]'"},jsonb_array:{args:"(value1, value2, ...)",docs:"The json\\_array() SQL function accepts zero or more arguments and returns a well-formed JSON array that is composed from those arguments. If any argument to json\\_array() is a BLOB then an error is thrown. An argument with SQL type TEXT is normally converted into a quoted JSON string. However, if the argument is the output from another json1 function, then it is stored as JSON. This allows calls to json\\_array() and [json\\_object()](https://www.sqlite.org/json1.html#jobj) to be nested. The [json()](https://www.sqlite.org/json1.html#jmini) function can also be used to force strings to be recognized as JSON. Examples:*   json\\_array(1,2,'3',4) → '\\[1,2,\"3\",4\\]'\n*   json\\_array('\\[1,2\\]') → '\\[\"\\[1,2\\]\"\\]'\n*   json\\_array(json\\_array(1,2)) → '\\[\\[1,2\\]\\]'\n*   json\\_array(1,null,'3','\\[4,5\\]','{\"six\":7.7}') → '\\[1,null,\"3\",\"\\[4,5\\]\",\"{\\\\\"six\\\\\":7.7}\"\\]'\n*   json\\_array(1,null,'3',json('\\[4,5\\]'),json('{\"six\":7.7}')) → '\\[1,null,\"3\",\\[4,5\\],{\"six\":7.7}\\]'"},json_array_length:{args:"(json, path?)",docs:"The json\\_array\\_length(X) function returns the number of elements in the JSON array X, or 0 if X is some kind of JSON value other than an array. The json\\_array\\_length(X,P) locates the array at path P within X and returns the length of that array, or 0 if path P locates an element in X that is not a JSON array, and NULL if path P does not locate any element of X. Errors are thrown if either X is not well-formed JSON or if P is not a well-formed path. Examples:*   json\\_array\\_length('\\[1,2,3,4\\]') → 4\n*   json\\_array\\_length('\\[1,2,3,4\\]', '$') → 4\n*   json\\_array\\_length('\\[1,2,3,4\\]', '$\\[2\\]') → 0\n*   json\\_array\\_length('{\"one\":\\[1,2,3\\]}') → 0\n*   json\\_array\\_length('{\"one\":\\[1,2,3\\]}', '$.one') → 3\n*   json\\_array\\_length('{\"one\":\\[1,2,3\\]}', '$.two') → NULL"},json_error_position:{args:"(json)",docs:"The json\\_error\\_position(X) function returns 0 if the input X is a well-formed JSON or JSON5 string. If the input X contains one or more syntax errors, then this function returns the character position of the first syntax error. The left-most character is position 1. If the input X is a BLOB, then this routine returns 0 if X is a well-formed JSONB blob. If the return value is positive, then it represents the _approximate_ 1-based position in the BLOB of the first detected error. The json\\_error\\_position() function was added with SQLite version 3.42.0 (2023-05-16)."},json_extract:{args:"(json, path1, path2, ...)",docs:'The json\\_extract(X,P1,P2,...) extracts and returns one or more values from the well-formed JSON at X. If only a single path P1 is provided, then the SQL datatype of the result is NULL for a JSON null, INTEGER or REAL for a JSON numeric value, an INTEGER zero for a JSON false value, an INTEGER one for a JSON true value, the dequoted text for a JSON string value, and a text representation for JSON object and array values. If there are multiple path arguments (P1, P2, and so forth) then this routine returns SQLite text which is a well-formed JSON array holding the various values. Examples:*   json\\_extract(\'{"a":2,"c":\\[4,5,{"f":7}\\]}\', \'$\') → \'{"a":2,"c":\\[4,5,{"f":7}\\]}\'\n*   json\\_extract(\'{"a":2,"c":\\[4,5,{"f":7}\\]}\', \'$.c\') → \'\\[4,5,{"f":7}\\]\'\n*   json\\_extract(\'{"a":2,"c":\\[4,5,{"f":7}\\]}\', \'$.c\\[2\\]\') → \'{"f":7}\'\n*   json\\_extract(\'{"a":2,"c":\\[4,5,{"f":7}\\]}\', \'$.c\\[2\\].f\') → 7\n*   json\\_extract(\'{"a":2,"c":\\[4,5\\],"f":7}\',\'$.c\',\'$.a\') → \'\\[\\[4,5\\],2\\]\'\n*   json\\_extract(\'{"a":2,"c":\\[4,5\\],"f":7}\',\'$.c\\[#-1\\]\') → 5\n*   json\\_extract(\'{"a":2,"c":\\[4,5,{"f":7}\\]}\', \'$.x\') → NULL\n*   json\\_extract(\'{"a":2,"c":\\[4,5,{"f":7}\\]}\', \'$.x\', \'$.a\') → \'\\[null,2\\]\'\n*   json\\_extract(\'{"a":"xyz"}\', \'$.a\') → \'xyz\'\n*   json\\_extract(\'{"a":null}\', \'$.a\') → NULL\nThere is a subtle incompatibility between the json\\_extract() function in SQLite and the json\\_extract() function in MySQL. The MySQL version of json\\_extract() always returns JSON. The SQLite version of json\\_extract() only returns JSON if there are two or more PATH arguments (because the result is then a JSON array) or if the single PATH argument references an array or object. In SQLite, if json\\_extract() has only a single PATH argument and that PATH references a JSON null or a string or a numeric value, then json\\_extract() returns the corresponding SQL NULL, TEXT, INTEGER, or REAL value. The difference between MySQL json\\_extract() and SQLite json\\_extract() really only stands out when accessing individual values within the JSON that are strings or NULLs. The following table demonstrates the difference:\n\n| Operation | SQLite Result | MySQL Result |\n| --- | --- | --- |\n| json\\_extract(\'{"a":null,"b":"xyz"}\',\'$.a\') | NULL | \'null\' |\n| json\\_extract(\'{"a":null,"b":"xyz"}\',\'$.b\') | \'xyz\' | \'"xyz"\' |'},jsonb_extract:{args:"(json, path1, path2, ...)",docs:'The json\\_extract(X,P1,P2,...) extracts and returns one or more values from the well-formed JSON at X. If only a single path P1 is provided, then the SQL datatype of the result is NULL for a JSON null, INTEGER or REAL for a JSON numeric value, an INTEGER zero for a JSON false value, an INTEGER one for a JSON true value, the dequoted text for a JSON string value, and a text representation for JSON object and array values. If there are multiple path arguments (P1, P2, and so forth) then this routine returns SQLite text which is a well-formed JSON array holding the various values. Examples:*   json\\_extract(\'{"a":2,"c":\\[4,5,{"f":7}\\]}\', \'$\') → \'{"a":2,"c":\\[4,5,{"f":7}\\]}\'\n*   json\\_extract(\'{"a":2,"c":\\[4,5,{"f":7}\\]}\', \'$.c\') → \'\\[4,5,{"f":7}\\]\'\n*   json\\_extract(\'{"a":2,"c":\\[4,5,{"f":7}\\]}\', \'$.c\\[2\\]\') → \'{"f":7}\'\n*   json\\_extract(\'{"a":2,"c":\\[4,5,{"f":7}\\]}\', \'$.c\\[2\\].f\') → 7\n*   json\\_extract(\'{"a":2,"c":\\[4,5\\],"f":7}\',\'$.c\',\'$.a\') → \'\\[\\[4,5\\],2\\]\'\n*   json\\_extract(\'{"a":2,"c":\\[4,5\\],"f":7}\',\'$.c\\[#-1\\]\') → 5\n*   json\\_extract(\'{"a":2,"c":\\[4,5,{"f":7}\\]}\', \'$.x\') → NULL\n*   json\\_extract(\'{"a":2,"c":\\[4,5,{"f":7}\\]}\', \'$.x\', \'$.a\') → \'\\[null,2\\]\'\n*   json\\_extract(\'{"a":"xyz"}\', \'$.a\') → \'xyz\'\n*   json\\_extract(\'{"a":null}\', \'$.a\') → NULL\nThere is a subtle incompatibility between the json\\_extract() function in SQLite and the json\\_extract() function in MySQL. The MySQL version of json\\_extract() always returns JSON. The SQLite version of json\\_extract() only returns JSON if there are two or more PATH arguments (because the result is then a JSON array) or if the single PATH argument references an array or object. In SQLite, if json\\_extract() has only a single PATH argument and that PATH references a JSON null or a string or a numeric value, then json\\_extract() returns the corresponding SQL NULL, TEXT, INTEGER, or REAL value. The difference between MySQL json\\_extract() and SQLite json\\_extract() really only stands out when accessing individual values within the JSON that are strings or NULLs. The following table demonstrates the difference:\n\n| Operation | SQLite Result | MySQL Result |\n| --- | --- | --- |\n| json\\_extract(\'{"a":null,"b":"xyz"}\',\'$.a\') | NULL | \'null\' |\n| json\\_extract(\'{"a":null,"b":"xyz"}\',\'$.b\') | \'xyz\' | \'"xyz"\' |'},json_insert:{args:"(json, path1, value1, path2, value2, ...)",docs:'The json\\_insert(), json\\_replace, and json\\_set() functions all take a single JSON value as their first argument followed by zero or more pairs of path and value arguments, and return a new JSON string formed by updating the input JSON by the path/value pairs. The functions differ only in how they deal with creating new values and overwriting preexisting values.\n\n| Function | Overwrite if already exists? | Create if does not exist? |\n| --- | --- | --- |\n| json\\_insert() | No | Yes |\n| json\\_replace() | Yes | No |\n| json\\_set() | Yes | Yes |\n\nThe json\\_insert(), json\\_replace(), and json\\_set() functions always take an odd number of arguments. The first argument is always the original JSON to be edited. Subsequent arguments occur in pairs with the first element of each pair being a path and the second element being the value to insert or replace or set on that path. Edits occur sequentially from left to right. Changes caused by prior edits can affect the path search for subsequent edits. If the value of a path/value pair is an SQLite TEXT value, then it is normally inserted as a quoted JSON string, even if the string looks like valid JSON. However, if the value is the result of another json function (such as [json()](https://www.sqlite.org/json1.html#jmini) or [json\\_array()](https://www.sqlite.org/json1.html#jarray) or [json\\_object()](https://www.sqlite.org/json1.html#jobj)) or if it is the result of [the -> operator](https://www.sqlite.org/json1.html#jptr), then it is interpreted as JSON and is inserted as JSON retaining all of its substructure. Values that are the result of [the ->> operator](https://www.sqlite.org/json1.html#jptr) are always interpreted as TEXT and are inserted as a JSON string even if they look like valid JSON. These routines throw an error if the first JSON argument is not well-formed or if any PATH argument is not well-formed or if any argument is a BLOB. To append an element onto the end of an array, using json\\_insert() with an array index of "#". Examples:*   json\\_insert(\'\\[1,2,3,4\\]\',\'$\\[#\\]\',99) → \'\\[1,2,3,4,99\\]\'\n*   json\\_insert(\'\\[1,\\[2,3\\],4\\]\',\'$\\[1\\]\\[#\\]\',99) → \'\\[1,\\[2,3,99\\],4\\]\'\nOther examples:*   json\\_insert(\'{"a":2,"c":4}\', \'$.a\', 99) → \'{"a":2,"c":4}\'\n*   json\\_insert(\'{"a":2,"c":4}\', \'$.e\', 99) → \'{"a":2,"c":4,"e":99}\'\n*   json\\_replace(\'{"a":2,"c":4}\', \'$.a\', 99) → \'{"a":99,"c":4}\'\n*   json\\_replace(\'{"a":2,"c":4}\', \'$.e\', 99) → \'{"a":2,"c":4}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.a\', 99) → \'{"a":99,"c":4}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.e\', 99) → \'{"a":2,"c":4,"e":99}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.c\', \'\\[97,96\\]\') → \'{"a":2,"c":"\\[97,96\\]"}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.c\', json(\'\\[97,96\\]\')) → \'{"a":2,"c":\\[97,96\\]}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.c\', json\\_array(97,96)) → \'{"a":2,"c":\\[97,96\\]}\''},json_set:{args:"(json, path1, value1, path2, value2, ...)",docs:'The json\\_insert(), json\\_replace, and json\\_set() functions all take a single JSON value as their first argument followed by zero or more pairs of path and value arguments, and return a new JSON string formed by updating the input JSON by the path/value pairs. The functions differ only in how they deal with creating new values and overwriting preexisting values.\n\n| Function | Overwrite if already exists? | Create if does not exist? |\n| --- | --- | --- |\n| json\\_insert() | No | Yes |\n| json\\_replace() | Yes | No |\n| json\\_set() | Yes | Yes |\n\nThe json\\_insert(), json\\_replace(), and json\\_set() functions always take an odd number of arguments. The first argument is always the original JSON to be edited. Subsequent arguments occur in pairs with the first element of each pair being a path and the second element being the value to insert or replace or set on that path. Edits occur sequentially from left to right. Changes caused by prior edits can affect the path search for subsequent edits. If the value of a path/value pair is an SQLite TEXT value, then it is normally inserted as a quoted JSON string, even if the string looks like valid JSON. However, if the value is the result of another json function (such as [json()](https://www.sqlite.org/json1.html#jmini) or [json\\_array()](https://www.sqlite.org/json1.html#jarray) or [json\\_object()](https://www.sqlite.org/json1.html#jobj)) or if it is the result of [the -> operator](https://www.sqlite.org/json1.html#jptr), then it is interpreted as JSON and is inserted as JSON retaining all of its substructure. Values that are the result of [the ->> operator](https://www.sqlite.org/json1.html#jptr) are always interpreted as TEXT and are inserted as a JSON string even if they look like valid JSON. These routines throw an error if the first JSON argument is not well-formed or if any PATH argument is not well-formed or if any argument is a BLOB. To append an element onto the end of an array, using json\\_insert() with an array index of "#". Examples:*   json\\_insert(\'\\[1,2,3,4\\]\',\'$\\[#\\]\',99) → \'\\[1,2,3,4,99\\]\'\n*   json\\_insert(\'\\[1,\\[2,3\\],4\\]\',\'$\\[1\\]\\[#\\]\',99) → \'\\[1,\\[2,3,99\\],4\\]\'\nOther examples:*   json\\_insert(\'{"a":2,"c":4}\', \'$.a\', 99) → \'{"a":2,"c":4}\'\n*   json\\_insert(\'{"a":2,"c":4}\', \'$.e\', 99) → \'{"a":2,"c":4,"e":99}\'\n*   json\\_replace(\'{"a":2,"c":4}\', \'$.a\', 99) → \'{"a":99,"c":4}\'\n*   json\\_replace(\'{"a":2,"c":4}\', \'$.e\', 99) → \'{"a":2,"c":4}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.a\', 99) → \'{"a":99,"c":4}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.e\', 99) → \'{"a":2,"c":4,"e":99}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.c\', \'\\[97,96\\]\') → \'{"a":2,"c":"\\[97,96\\]"}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.c\', json(\'\\[97,96\\]\')) → \'{"a":2,"c":\\[97,96\\]}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.c\', json\\_array(97,96)) → \'{"a":2,"c":\\[97,96\\]}\''},jsonb_insert:{args:"(json, path1, value1, path2, value2, ...)",docs:'The json\\_insert(), json\\_replace, and json\\_set() functions all take a single JSON value as their first argument followed by zero or more pairs of path and value arguments, and return a new JSON string formed by updating the input JSON by the path/value pairs. The functions differ only in how they deal with creating new values and overwriting preexisting values.\n\n| Function | Overwrite if already exists? | Create if does not exist? |\n| --- | --- | --- |\n| json\\_insert() | No | Yes |\n| json\\_replace() | Yes | No |\n| json\\_set() | Yes | Yes |\n\nThe json\\_insert(), json\\_replace(), and json\\_set() functions always take an odd number of arguments. The first argument is always the original JSON to be edited. Subsequent arguments occur in pairs with the first element of each pair being a path and the second element being the value to insert or replace or set on that path. Edits occur sequentially from left to right. Changes caused by prior edits can affect the path search for subsequent edits. If the value of a path/value pair is an SQLite TEXT value, then it is normally inserted as a quoted JSON string, even if the string looks like valid JSON. However, if the value is the result of another json function (such as [json()](https://www.sqlite.org/json1.html#jmini) or [json\\_array()](https://www.sqlite.org/json1.html#jarray) or [json\\_object()](https://www.sqlite.org/json1.html#jobj)) or if it is the result of [the -> operator](https://www.sqlite.org/json1.html#jptr), then it is interpreted as JSON and is inserted as JSON retaining all of its substructure. Values that are the result of [the ->> operator](https://www.sqlite.org/json1.html#jptr) are always interpreted as TEXT and are inserted as a JSON string even if they look like valid JSON. These routines throw an error if the first JSON argument is not well-formed or if any PATH argument is not well-formed or if any argument is a BLOB. To append an element onto the end of an array, using json\\_insert() with an array index of "#". Examples:*   json\\_insert(\'\\[1,2,3,4\\]\',\'$\\[#\\]\',99) → \'\\[1,2,3,4,99\\]\'\n*   json\\_insert(\'\\[1,\\[2,3\\],4\\]\',\'$\\[1\\]\\[#\\]\',99) → \'\\[1,\\[2,3,99\\],4\\]\'\nOther examples:*   json\\_insert(\'{"a":2,"c":4}\', \'$.a\', 99) → \'{"a":2,"c":4}\'\n*   json\\_insert(\'{"a":2,"c":4}\', \'$.e\', 99) → \'{"a":2,"c":4,"e":99}\'\n*   json\\_replace(\'{"a":2,"c":4}\', \'$.a\', 99) → \'{"a":99,"c":4}\'\n*   json\\_replace(\'{"a":2,"c":4}\', \'$.e\', 99) → \'{"a":2,"c":4}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.a\', 99) → \'{"a":99,"c":4}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.e\', 99) → \'{"a":2,"c":4,"e":99}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.c\', \'\\[97,96\\]\') → \'{"a":2,"c":"\\[97,96\\]"}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.c\', json(\'\\[97,96\\]\')) → \'{"a":2,"c":\\[97,96\\]}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.c\', json\\_array(97,96)) → \'{"a":2,"c":\\[97,96\\]}\''},jsonb_set:{args:"(json, path1, value1, path2, value2, ...)",docs:'The json\\_insert(), json\\_replace, and json\\_set() functions all take a single JSON value as their first argument followed by zero or more pairs of path and value arguments, and return a new JSON string formed by updating the input JSON by the path/value pairs. The functions differ only in how they deal with creating new values and overwriting preexisting values.\n\n| Function | Overwrite if already exists? | Create if does not exist? |\n| --- | --- | --- |\n| json\\_insert() | No | Yes |\n| json\\_replace() | Yes | No |\n| json\\_set() | Yes | Yes |\n\nThe json\\_insert(), json\\_replace(), and json\\_set() functions always take an odd number of arguments. The first argument is always the original JSON to be edited. Subsequent arguments occur in pairs with the first element of each pair being a path and the second element being the value to insert or replace or set on that path. Edits occur sequentially from left to right. Changes caused by prior edits can affect the path search for subsequent edits. If the value of a path/value pair is an SQLite TEXT value, then it is normally inserted as a quoted JSON string, even if the string looks like valid JSON. However, if the value is the result of another json function (such as [json()](https://www.sqlite.org/json1.html#jmini) or [json\\_array()](https://www.sqlite.org/json1.html#jarray) or [json\\_object()](https://www.sqlite.org/json1.html#jobj)) or if it is the result of [the -> operator](https://www.sqlite.org/json1.html#jptr), then it is interpreted as JSON and is inserted as JSON retaining all of its substructure. Values that are the result of [the ->> operator](https://www.sqlite.org/json1.html#jptr) are always interpreted as TEXT and are inserted as a JSON string even if they look like valid JSON. These routines throw an error if the first JSON argument is not well-formed or if any PATH argument is not well-formed or if any argument is a BLOB. To append an element onto the end of an array, using json\\_insert() with an array index of "#". Examples:*   json\\_insert(\'\\[1,2,3,4\\]\',\'$\\[#\\]\',99) → \'\\[1,2,3,4,99\\]\'\n*   json\\_insert(\'\\[1,\\[2,3\\],4\\]\',\'$\\[1\\]\\[#\\]\',99) → \'\\[1,\\[2,3,99\\],4\\]\'\nOther examples:*   json\\_insert(\'{"a":2,"c":4}\', \'$.a\', 99) → \'{"a":2,"c":4}\'\n*   json\\_insert(\'{"a":2,"c":4}\', \'$.e\', 99) → \'{"a":2,"c":4,"e":99}\'\n*   json\\_replace(\'{"a":2,"c":4}\', \'$.a\', 99) → \'{"a":99,"c":4}\'\n*   json\\_replace(\'{"a":2,"c":4}\', \'$.e\', 99) → \'{"a":2,"c":4}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.a\', 99) → \'{"a":99,"c":4}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.e\', 99) → \'{"a":2,"c":4,"e":99}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.c\', \'\\[97,96\\]\') → \'{"a":2,"c":"\\[97,96\\]"}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.c\', json(\'\\[97,96\\]\')) → \'{"a":2,"c":\\[97,96\\]}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.c\', json\\_array(97,96)) → \'{"a":2,"c":\\[97,96\\]}\''},json_object:{args:"(label1, value1, label2, value2, ...)",docs:"The json\\_object() SQL function accepts zero or more pairs of arguments and returns a well-formed JSON object that is composed from those arguments. The first argument of each pair is the label and the second argument of each pair is the value. If any argument to json\\_object() is a BLOB then an error is thrown. The json\\_object() function currently allows duplicate labels without complaint, though this might change in a future enhancement. An argument with SQL type TEXT it is normally converted into a quoted JSON string even if the input text is well-formed JSON. However, if the argument is the direct result from another JSON function or [the -> operator](https://www.sqlite.org/json1.html#jptr) (but not [the ->> operator](https://www.sqlite.org/json1.html#jptr)), then it is treated as JSON and all of its JSON type information and substructure is preserved. This allows calls to json\\_object() and [json\\_array()](https://www.sqlite.org/json1.html#jarray) to be nested. The [json()](https://www.sqlite.org/json1.html#jmini) function can also be used to force strings to be recognized as JSON. Examples:*   json\\_object('a',2,'c',4) → '{\"a\":2,\"c\":4}'\n*   json\\_object('a',2,'c','{e:5}') → '{\"a\":2,\"c\":\"{e:5}\"}'\n*   json\\_object('a',2,'c',json\\_object('e',5)) → '{\"a\":2,\"c\":{\"e\":5}}'"},jsonb_object:{args:"(label1, value1, label2, value2, ...)",docs:"The json\\_object() SQL function accepts zero or more pairs of arguments and returns a well-formed JSON object that is composed from those arguments. The first argument of each pair is the label and the second argument of each pair is the value. If any argument to json\\_object() is a BLOB then an error is thrown. The json\\_object() function currently allows duplicate labels without complaint, though this might change in a future enhancement. An argument with SQL type TEXT it is normally converted into a quoted JSON string even if the input text is well-formed JSON. However, if the argument is the direct result from another JSON function or [the -> operator](https://www.sqlite.org/json1.html#jptr) (but not [the ->> operator](https://www.sqlite.org/json1.html#jptr)), then it is treated as JSON and all of its JSON type information and substructure is preserved. This allows calls to json\\_object() and [json\\_array()](https://www.sqlite.org/json1.html#jarray) to be nested. The [json()](https://www.sqlite.org/json1.html#jmini) function can also be used to force strings to be recognized as JSON. Examples:*   json\\_object('a',2,'c',4) → '{\"a\":2,\"c\":4}'\n*   json\\_object('a',2,'c','{e:5}') → '{\"a\":2,\"c\":\"{e:5}\"}'\n*   json\\_object('a',2,'c',json\\_object('e',5)) → '{\"a\":2,\"c\":{\"e\":5}}'"},json_patch:{args:"(json1, json2)",docs:'The json\\_patch(T,P) SQL function runs the [RFC-7396](https://tools.ietf.org/html/rfc7396) MergePatch algorithm to apply patch P against input T. The patched copy of T is returned. MergePatch can add, modify, or delete elements of a JSON Object, and so for JSON Objects, the json\\_patch() routine is a generalized replacement for [json\\_set()](https://www.sqlite.org/json1.html#jset) and [json\\_remove()](https://www.sqlite.org/json1.html#jrm). However, MergePatch treats JSON Array objects as atomic. MergePatch cannot append to an Array nor modify individual elements of an Array. It can only insert, replace, or delete the whole Array as a single unit. Hence, json\\_patch() is not as useful when dealing with JSON that includes Arrays, especially Arrays with lots of substructure. Examples:*   json\\_patch(\'{"a":1,"b":2}\',\'{"c":3,"d":4}\') → \'{"a":1,"b":2,"c":3,"d":4}\'\n*   json\\_patch(\'{"a":\\[1,2\\],"b":2}\',\'{"a":9}\') → \'{"a":9,"b":2}\'\n*   json\\_patch(\'{"a":\\[1,2\\],"b":2}\',\'{"a":null}\') → \'{"b":2}\'\n*   json\\_patch(\'{"a":1,"b":2}\',\'{"a":9,"b":null,"c":8}\') → \'{"a":9,"c":8}\'\n*   json\\_patch(\'{"a":{"x":1,"y":2},"b":3}\',\'{"a":{"y":9},"c":8}\') → \'{"a":{"x":1,"y":9},"b":3,"c":8}\''},jsonb_patch:{args:"(json1, json2)",docs:'The json\\_patch(T,P) SQL function runs the [RFC-7396](https://tools.ietf.org/html/rfc7396) MergePatch algorithm to apply patch P against input T. The patched copy of T is returned. MergePatch can add, modify, or delete elements of a JSON Object, and so for JSON Objects, the json\\_patch() routine is a generalized replacement for [json\\_set()](https://www.sqlite.org/json1.html#jset) and [json\\_remove()](https://www.sqlite.org/json1.html#jrm). However, MergePatch treats JSON Array objects as atomic. MergePatch cannot append to an Array nor modify individual elements of an Array. It can only insert, replace, or delete the whole Array as a single unit. Hence, json\\_patch() is not as useful when dealing with JSON that includes Arrays, especially Arrays with lots of substructure. Examples:*   json\\_patch(\'{"a":1,"b":2}\',\'{"c":3,"d":4}\') → \'{"a":1,"b":2,"c":3,"d":4}\'\n*   json\\_patch(\'{"a":\\[1,2\\],"b":2}\',\'{"a":9}\') → \'{"a":9,"b":2}\'\n*   json\\_patch(\'{"a":\\[1,2\\],"b":2}\',\'{"a":null}\') → \'{"b":2}\'\n*   json\\_patch(\'{"a":1,"b":2}\',\'{"a":9,"b":null,"c":8}\') → \'{"a":9,"c":8}\'\n*   json\\_patch(\'{"a":{"x":1,"y":2},"b":3}\',\'{"a":{"y":9},"c":8}\') → \'{"a":{"x":1,"y":9},"b":3,"c":8}\''},json_pretty:{args:"()",docs:"The json\\_pretty() function works like [json()](https://www.sqlite.org/json1.html#jmini) except that it adds extra whitespace to make the JSON result easier for humans to read. The first argument is the JSON or JSONB that is to be pretty-printed. The optional second argument is a text string that is used for indentation. If the second argument is omitted or is NULL, then indentation is four spaces per level. The json\\_pretty() function was added with SQLite version 3.46.0 (2024-05-23)."},json_remove:{args:"(json, path, ...)",docs:"The json\\_remove(X,P,...) function takes a single JSON value as its first argument followed by zero or more path arguments. The json\\_remove(X,P,...) function returns a copy of the X parameter with all the elements identified by path arguments removed. Paths that select elements not found in X are silently ignored. Removals occurs sequentially from left to right. Changes caused by prior removals can affect the path search for subsequent arguments. If the json\\_remove(X) function is called with no path arguments, then it returns the input X reformatted, with excess whitespace removed. The json\\_remove() function throws an error if the first argument is not well-formed JSON or if any later argument is not a well-formed path. Examples:*   json\\_remove('\\[0,1,2,3,4\\]','$\\[2\\]') → '\\[0,1,3,4\\]'\n*   json\\_remove('\\[0,1,2,3,4\\]','$\\[2\\]','$\\[0\\]') → '\\[1,3,4\\]'\n*   json\\_remove('\\[0,1,2,3,4\\]','$\\[0\\]','$\\[2\\]') → '\\[1,2,4\\]'\n*   json\\_remove('\\[0,1,2,3,4\\]','$\\[#-1\\]','$\\[0\\]') → '\\[1,2,3\\]'\n*   json\\_remove('{\"x\":25,\"y\":42}') → '{\"x\":25,\"y\":42}'\n*   json\\_remove('{\"x\":25,\"y\":42}','$.z') → '{\"x\":25,\"y\":42}'\n*   json\\_remove('{\"x\":25,\"y\":42}','$.y') → '{\"x\":25}'\n*   json\\_remove('{\"x\":25,\"y\":42}','$') → NULL"},jsonb_remove:{args:"(json, path, ...)",docs:"The json\\_remove(X,P,...) function takes a single JSON value as its first argument followed by zero or more path arguments. The json\\_remove(X,P,...) function returns a copy of the X parameter with all the elements identified by path arguments removed. Paths that select elements not found in X are silently ignored. Removals occurs sequentially from left to right. Changes caused by prior removals can affect the path search for subsequent arguments. If the json\\_remove(X) function is called with no path arguments, then it returns the input X reformatted, with excess whitespace removed. The json\\_remove() function throws an error if the first argument is not well-formed JSON or if any later argument is not a well-formed path. Examples:*   json\\_remove('\\[0,1,2,3,4\\]','$\\[2\\]') → '\\[0,1,3,4\\]'\n*   json\\_remove('\\[0,1,2,3,4\\]','$\\[2\\]','$\\[0\\]') → '\\[1,3,4\\]'\n*   json\\_remove('\\[0,1,2,3,4\\]','$\\[0\\]','$\\[2\\]') → '\\[1,2,4\\]'\n*   json\\_remove('\\[0,1,2,3,4\\]','$\\[#-1\\]','$\\[0\\]') → '\\[1,2,3\\]'\n*   json\\_remove('{\"x\":25,\"y\":42}') → '{\"x\":25,\"y\":42}'\n*   json\\_remove('{\"x\":25,\"y\":42}','$.z') → '{\"x\":25,\"y\":42}'\n*   json\\_remove('{\"x\":25,\"y\":42}','$.y') → '{\"x\":25}'\n*   json\\_remove('{\"x\":25,\"y\":42}','$') → NULL"},json_type:{args:"(json, path?)",docs:"The json\\_type(X) function returns the \"type\" of the outermost element of X. The json\\_type(X,P) function returns the \"type\" of the element in X that is selected by path P. The \"type\" returned by json\\_type() is one of the following SQL text values: 'null', 'true', 'false', 'integer', 'real', 'text', 'array', or 'object'. If the path P in json\\_type(X,P) selects an element that does not exist in X, then this function returns NULL. The json\\_type() function throws an error if its first argument is not well-formed JSON or JSONB or if its second argument is not a well-formed JSON path. Examples:*   json\\_type('{\"a\":\\[2,3.5,true,false,null,\"x\"\\]}') → 'object'\n*   json\\_type('{\"a\":\\[2,3.5,true,false,null,\"x\"\\]}','$') → 'object'\n*   json\\_type('{\"a\":\\[2,3.5,true,false,null,\"x\"\\]}','$.a') → 'array'\n*   json\\_type('{\"a\":\\[2,3.5,true,false,null,\"x\"\\]}','$.a\\[0\\]') → 'integer'\n*   json\\_type('{\"a\":\\[2,3.5,true,false,null,\"x\"\\]}','$.a\\[1\\]') → 'real'\n*   json\\_type('{\"a\":\\[2,3.5,true,false,null,\"x\"\\]}','$.a\\[2\\]') → 'true'\n*   json\\_type('{\"a\":\\[2,3.5,true,false,null,\"x\"\\]}','$.a\\[3\\]') → 'false'\n*   json\\_type('{\"a\":\\[2,3.5,true,false,null,\"x\"\\]}','$.a\\[4\\]') → 'null'\n*   json\\_type('{\"a\":\\[2,3.5,true,false,null,\"x\"\\]}','$.a\\[5\\]') → 'text'\n*   json\\_type('{\"a\":\\[2,3.5,true,false,null,\"x\"\\]}','$.a\\[6\\]') → NULL"},json_valid:{args:"(json)",docs:"The json\\_valid(X,Y) function return 1 if the argument X is well-formed JSON, or returns 0 if X is not well-formed. The Y parameter is an integer bitmask that defines what is meant by \"well-formed\". The following bits of Y are currently defined:*   **0x01** → The input is text that strictly complies with canonical RFC-8259 JSON, without any extensions.\n*   **0x02** → The input is text that is JSON with [JSON5](https://www.sqlite.org/json1.html#json5) extensions described above.\n*   **0x04** → The input is a BLOB that superficially appears to be [JSONB](https://www.sqlite.org/json1.html#jsonbx).\n*   **0x08** → The input is a BLOB that strictly conforms to the internal [JSONB](https://www.sqlite.org/json1.html#jsonbx) format.\nBy combining bits, the following useful values of Y can be derived:*   **1** → X is RFC-8259 JSON text\n*   **2** → X is [JSON5](https://www.sqlite.org/json1.html#json5) text\n*   **4** → X is probably [JSONB](https://www.sqlite.org/json1.html#jsonbx)\n*   **5** → X is RFC-8259 JSON text or [JSONB](https://www.sqlite.org/json1.html#jsonbx)\n*   **6** → X is [JSON5](https://www.sqlite.org/json1.html#json5) text or [JSONB](https://www.sqlite.org/json1.html#jsonbx) ← _This is probably the value you want_\n*   **8** → X is strictly conforming [JSONB](https://www.sqlite.org/json1.html#jsonbx)\n*   **9** → X is RFC-8259 or strictly conforming [JSONB](https://www.sqlite.org/json1.html#jsonbx)\n*   **10** → X is JSON5 or strictly conforming [JSONB](https://www.sqlite.org/json1.html#jsonbx)\nThe Y parameter is optional. If omitted, it defaults to 1, which means that the default behavior is to return true only if the input X is strictly conforming RFC-8259 JSON text without any extensions. This makes the one-argument version of json\\_valid() compatible with older versions of SQLite, prior to the addition of support for [JSON5](https://www.sqlite.org/json1.html#json5) and [JSONB](https://www.sqlite.org/json1.html#jsonbx). The difference between 0x04 and 0x08 bits in the Y parameter is that 0x04 only examines the outer wrapper of the BLOB to see if it superficially looks like [JSONB](https://www.sqlite.org/json1.html#jsonbx). This is sufficient for must purposes and is very fast. The 0x08 bit does a thorough examination of all internal details of the BLOB. The 0x08 bit takes time that is linear in the size of the X input and is much slower. The 0x04 bit is recommended for most purposes. If you just want to know if a value is a plausible input to one of the other JSON functions, a Y value of 6 is probably what you want to use. Any Y value less than 1 or greater than 15 raises an error, for the latest version of json\\_valid(). However, future versions of json\\_valid() might be enhanced to accept flag values outside of this range, having new meanings that we have not yet thought of. If either X or Y inputs to json\\_valid() are NULL, then the function returns NULL. Examples:*   json\\_valid('{\"x\":35}') → 1\n*   json\\_valid('{x:35}') → 0\n*   json\\_valid('{x:35}',6) → 1\n*   json\\_valid('{\"x\":35') → 0\n*   json\\_valid(NULL) → NULL"},json_quote:{args:"(value)",docs:"The json\\_quote(X) function converts the SQL value X (a number or a string) into its corresponding JSON representation. If X is a JSON value returned by another JSON function, then this function is a no-op. Examples:*   json\\_quote(3.14159) → 3.14159\n*   json\\_quote('verdant') → '\"verdant\"'\n*   json\\_quote('\\[1\\]') → '\"\\[1\\]\"'\n*   json\\_quote(json('\\[1\\]')) → '\\[1\\]'\n*   json\\_quote('\\[1,') → '\"\\[1,\"'"},json_each:{args:"(json, path?)",docs:"The json\\_each(X) and json\\_tree(X) [table-valued functions](https://www.sqlite.org/vtab.html#tabfunc2) walk the JSON value provided as their first argument and return one row for each element. The json\\_each(X) function only walks the immediate children of the top-level array or object, or just the top-level element itself if the top-level element is a primitive value. The json\\_tree(X) function recursively walks through the JSON substructure starting with the top-level element. The json\\_each(X,P) and json\\_tree(X,P) functions work just like their one-argument counterparts except that they treat the element identified by path P as the top-level element. The schema for the table returned by json\\_each() and json\\_tree() is as follows:\n\nCREATE TABLE json\\_tree(\n    key ANY,             -- key for current element relative to its parent\n    value ANY,           -- value for the current element\n    type TEXT,           -- 'object','array','string','integer', etc.\n    atom ANY,            -- value for primitive types, null for array & object\n    id INTEGER,          -- integer ID for this element\n    parent INTEGER,      -- integer ID for the parent of this element\n    fullkey TEXT,        -- full path describing the current element\n    path TEXT,           -- path to the container of the current row\n    json JSON HIDDEN,    -- 1st input parameter: the raw JSON\n    root TEXT HIDDEN     -- 2nd input parameter: the PATH at which to start\n);\n\nThe \"key\" column is the integer array index for elements of a JSON array and the text label for elements of a JSON object. The key column is NULL in all other cases. The \"atom\" column is the SQL value corresponding to primitive elements - elements other than JSON arrays and objects. The \"atom\" column is NULL for a JSON array or object. The \"value\" column is the same as the \"atom\" column for primitive JSON elements but takes on the text JSON value for arrays and objects. The \"type\" column is an SQL text value taken from ('null', 'true', 'false', 'integer', 'real', 'text', 'array', 'object') according to the type of the current JSON element. The \"id\" column is an integer that identifies a specific JSON element within the complete JSON string. The \"id\" integer is an internal housekeeping number, the computation of which might change in future releases. The only guarantee is that the \"id\" column will be different for every row. The \"parent\" column is always NULL for json\\_each(). For json\\_tree(), the \"parent\" column is the \"id\" integer for the parent of the current element, or NULL for the top-level JSON element or the element identified by the root path in the second argument. The \"fullkey\" column is a text path that uniquely identifies the current row element within the original JSON string. The complete key to the true top-level element is returned even if an alternative starting point is provided by the \"root\" argument. The \"path\" column is the path to the array or object container that holds the current row, or the path to the current row in the case where the iteration starts on a primitive type and thus only provides a single row of output. 4.23.1. Examples using json\\_each() and json\\_tree()Suppose the table \"CREATE TABLE user(name,phone)\" stores zero or more phone numbers as a JSON array object in the user.phone field. To find all users who have any phone number with a 704 area code:\n\nSELECT DISTINCT user.name\n  FROM user, json\\_each(user.phone)\n WHERE json\\_each.value LIKE '704-%';\n\nNow suppose the user.phone field contains plain text if the user has only a single phone number and a JSON array if the user has multiple phone numbers. The same question is posed: \"Which users have a phone number in the 704 area code?\" But now the json\\_each() function can only be called for those users that have two or more phone numbers since json\\_each() requires well-formed JSON as its first argument:\n\nSELECT name FROM user WHERE phone LIKE '704-%'\nUNION\nSELECT user.name\n  FROM user, json\\_each(user.phone)\n WHERE json\\_valid(user.phone)\n   AND json\\_each.value LIKE '704-%';\n\nConsider a different database with \"CREATE TABLE big(json JSON)\". To see a complete line-by-line decomposition of the data:\n\nSELECT big.rowid, fullkey, value\n  FROM big, json\\_tree(big.json)\n WHERE json\\_tree.type NOT IN ('object','array');\n\nIn the previous, the \"type NOT IN ('object','array')\" term of the WHERE clause suppresses containers and only lets through leaf elements. The same effect could be achieved this way:\n\nSELECT big.rowid, fullkey, atom\n  FROM big, json\\_tree(big.json)\n WHERE atom IS NOT NULL;\n\nSuppose each entry in the BIG table is a JSON object with a '$.id' field that is a unique identifier and a '$.partlist' field that can be a deeply nested object. You want to find the id of every entry that contains one or more references to uuid '6fa5181e-5721-11e5-a04e-57f3d7b32808' anywhere in its '$.partlist'.\n\nSELECT DISTINCT json\\_extract(big.json,'$.id')\n  FROM big, json\\_tree(big.json, '$.partlist')\n WHERE json\\_tree.key='uuid'\n   AND json\\_tree.value='6fa5181e-5721-11e5-a04e-57f3d7b32808';\n\n"},json_tree:{args:"(json, path?)",docs:"The json\\_each(X) and json\\_tree(X) [table-valued functions](https://www.sqlite.org/vtab.html#tabfunc2) walk the JSON value provided as their first argument and return one row for each element. The json\\_each(X) function only walks the immediate children of the top-level array or object, or just the top-level element itself if the top-level element is a primitive value. The json\\_tree(X) function recursively walks through the JSON substructure starting with the top-level element. The json\\_each(X,P) and json\\_tree(X,P) functions work just like their one-argument counterparts except that they treat the element identified by path P as the top-level element. The schema for the table returned by json\\_each() and json\\_tree() is as follows:\n\nCREATE TABLE json\\_tree(\n    key ANY,             -- key for current element relative to its parent\n    value ANY,           -- value for the current element\n    type TEXT,           -- 'object','array','string','integer', etc.\n    atom ANY,            -- value for primitive types, null for array & object\n    id INTEGER,          -- integer ID for this element\n    parent INTEGER,      -- integer ID for the parent of this element\n    fullkey TEXT,        -- full path describing the current element\n    path TEXT,           -- path to the container of the current row\n    json JSON HIDDEN,    -- 1st input parameter: the raw JSON\n    root TEXT HIDDEN     -- 2nd input parameter: the PATH at which to start\n);\n\nThe \"key\" column is the integer array index for elements of a JSON array and the text label for elements of a JSON object. The key column is NULL in all other cases. The \"atom\" column is the SQL value corresponding to primitive elements - elements other than JSON arrays and objects. The \"atom\" column is NULL for a JSON array or object. The \"value\" column is the same as the \"atom\" column for primitive JSON elements but takes on the text JSON value for arrays and objects. The \"type\" column is an SQL text value taken from ('null', 'true', 'false', 'integer', 'real', 'text', 'array', 'object') according to the type of the current JSON element. The \"id\" column is an integer that identifies a specific JSON element within the complete JSON string. The \"id\" integer is an internal housekeeping number, the computation of which might change in future releases. The only guarantee is that the \"id\" column will be different for every row. The \"parent\" column is always NULL for json\\_each(). For json\\_tree(), the \"parent\" column is the \"id\" integer for the parent of the current element, or NULL for the top-level JSON element or the element identified by the root path in the second argument. The \"fullkey\" column is a text path that uniquely identifies the current row element within the original JSON string. The complete key to the true top-level element is returned even if an alternative starting point is provided by the \"root\" argument. The \"path\" column is the path to the array or object container that holds the current row, or the path to the current row in the case where the iteration starts on a primitive type and thus only provides a single row of output. 4.23.1. Examples using json\\_each() and json\\_tree()Suppose the table \"CREATE TABLE user(name,phone)\" stores zero or more phone numbers as a JSON array object in the user.phone field. To find all users who have any phone number with a 704 area code:\n\nSELECT DISTINCT user.name\n  FROM user, json\\_each(user.phone)\n WHERE json\\_each.value LIKE '704-%';\n\nNow suppose the user.phone field contains plain text if the user has only a single phone number and a JSON array if the user has multiple phone numbers. The same question is posed: \"Which users have a phone number in the 704 area code?\" But now the json\\_each() function can only be called for those users that have two or more phone numbers since json\\_each() requires well-formed JSON as its first argument:\n\nSELECT name FROM user WHERE phone LIKE '704-%'\nUNION\nSELECT user.name\n  FROM user, json\\_each(user.phone)\n WHERE json\\_valid(user.phone)\n   AND json\\_each.value LIKE '704-%';\n\nConsider a different database with \"CREATE TABLE big(json JSON)\". To see a complete line-by-line decomposition of the data:\n\nSELECT big.rowid, fullkey, value\n  FROM big, json\\_tree(big.json)\n WHERE json\\_tree.type NOT IN ('object','array');\n\nIn the previous, the \"type NOT IN ('object','array')\" term of the WHERE clause suppresses containers and only lets through leaf elements. The same effect could be achieved this way:\n\nSELECT big.rowid, fullkey, atom\n  FROM big, json\\_tree(big.json)\n WHERE atom IS NOT NULL;\n\nSuppose each entry in the BIG table is a JSON object with a '$.id' field that is a unique identifier and a '$.partlist' field that can be a deeply nested object. You want to find the id of every entry that contains one or more references to uuid '6fa5181e-5721-11e5-a04e-57f3d7b32808' anywhere in its '$.partlist'.\n\nSELECT DISTINCT json\\_extract(big.json,'$.id')\n  FROM big, json\\_tree(big.json, '$.partlist')\n WHERE json\\_tree.key='uuid'\n   AND json\\_tree.value='6fa5181e-5721-11e5-a04e-57f3d7b32808';\n\n"},json_group_array:{args:"(value)",docs:'The json\\_group\\_array(X) function is an [aggregate SQL function](https://www.sqlite.org/lang_aggfunc.html) that returns a JSON array comprised of all X values in the aggregation. Similarly, the json\\_group\\_object(NAME,VALUE) function returns a JSON object comprised of all NAME/VALUE pairs in the aggregation. The "jsonb\\_" variants are the same except that they return their result in the binary [JSONB](https://www.sqlite.org/json1.html#jsonbx) format.'},jsonb_group_array:{args:"(value)",docs:'The json\\_group\\_array(X) function is an [aggregate SQL function](https://www.sqlite.org/lang_aggfunc.html) that returns a JSON array comprised of all X values in the aggregation. Similarly, the json\\_group\\_object(NAME,VALUE) function returns a JSON object comprised of all NAME/VALUE pairs in the aggregation. The "jsonb\\_" variants are the same except that they return their result in the binary [JSONB](https://www.sqlite.org/json1.html#jsonbx) format.'},json_group_object:{args:"(label, value)",docs:'The json\\_group\\_array(X) function is an [aggregate SQL function](https://www.sqlite.org/lang_aggfunc.html) that returns a JSON array comprised of all X values in the aggregation. Similarly, the json\\_group\\_object(NAME,VALUE) function returns a JSON object comprised of all NAME/VALUE pairs in the aggregation. The "jsonb\\_" variants are the same except that they return their result in the binary [JSONB](https://www.sqlite.org/json1.html#jsonbx) format.'},jsonb_group_object:{args:"(name, value)",docs:'The json\\_group\\_array(X) function is an [aggregate SQL function](https://www.sqlite.org/lang_aggfunc.html) that returns a JSON array comprised of all X values in the aggregation. Similarly, the json\\_group\\_object(NAME,VALUE) function returns a JSON object comprised of all NAME/VALUE pairs in the aggregation. The "jsonb\\_" variants are the same except that they return their result in the binary [JSONB](https://www.sqlite.org/json1.html#jsonbx) format.'},json_replace:{args:"(json, path1, value1, path2, value2, ...)",docs:'The json\\_insert(), json\\_replace, and json\\_set() functions all take a single JSON value as their first argument followed by zero or more pairs of path and value arguments, and return a new JSON string formed by updating the input JSON by the path/value pairs. The functions differ only in how they deal with creating new values and overwriting preexisting values.\n\n| Function | Overwrite if already exists? | Create if does not exist? |\n| --- | --- | --- |\n| json\\_insert() | No | Yes |\n| json\\_replace() | Yes | No |\n| json\\_set() | Yes | Yes |\n\nThe json\\_insert(), json\\_replace(), and json\\_set() functions always take an odd number of arguments. The first argument is always the original JSON to be edited. Subsequent arguments occur in pairs with the first element of each pair being a path and the second element being the value to insert or replace or set on that path. Edits occur sequentially from left to right. Changes caused by prior edits can affect the path search for subsequent edits. If the value of a path/value pair is an SQLite TEXT value, then it is normally inserted as a quoted JSON string, even if the string looks like valid JSON. However, if the value is the result of another json function (such as [json()](https://www.sqlite.org/json1.html#jmini) or [json\\_array()](https://www.sqlite.org/json1.html#jarray) or [json\\_object()](https://www.sqlite.org/json1.html#jobj)) or if it is the result of [the -> operator](https://www.sqlite.org/json1.html#jptr), then it is interpreted as JSON and is inserted as JSON retaining all of its substructure. Values that are the result of [the ->> operator](https://www.sqlite.org/json1.html#jptr) are always interpreted as TEXT and are inserted as a JSON string even if they look like valid JSON. These routines throw an error if the first JSON argument is not well-formed or if any PATH argument is not well-formed or if any argument is a BLOB. To append an element onto the end of an array, using json\\_insert() with an array index of "#". Examples:*   json\\_insert(\'\\[1,2,3,4\\]\',\'$\\[#\\]\',99) → \'\\[1,2,3,4,99\\]\'\n*   json\\_insert(\'\\[1,\\[2,3\\],4\\]\',\'$\\[1\\]\\[#\\]\',99) → \'\\[1,\\[2,3,99\\],4\\]\'\nOther examples:*   json\\_insert(\'{"a":2,"c":4}\', \'$.a\', 99) → \'{"a":2,"c":4}\'\n*   json\\_insert(\'{"a":2,"c":4}\', \'$.e\', 99) → \'{"a":2,"c":4,"e":99}\'\n*   json\\_replace(\'{"a":2,"c":4}\', \'$.a\', 99) → \'{"a":99,"c":4}\'\n*   json\\_replace(\'{"a":2,"c":4}\', \'$.e\', 99) → \'{"a":2,"c":4}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.a\', 99) → \'{"a":99,"c":4}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.e\', 99) → \'{"a":2,"c":4,"e":99}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.c\', \'\\[97,96\\]\') → \'{"a":2,"c":"\\[97,96\\]"}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.c\', json(\'\\[97,96\\]\')) → \'{"a":2,"c":\\[97,96\\]}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.c\', json\\_array(97,96)) → \'{"a":2,"c":\\[97,96\\]}\''},jsonb_replace:{args:"(json, path1, value1, path2, value2, ...)",docs:'The json\\_insert(), json\\_replace, and json\\_set() functions all take a single JSON value as their first argument followed by zero or more pairs of path and value arguments, and return a new JSON string formed by updating the input JSON by the path/value pairs. The functions differ only in how they deal with creating new values and overwriting preexisting values.\n\n| Function | Overwrite if already exists? | Create if does not exist? |\n| --- | --- | --- |\n| json\\_insert() | No | Yes |\n| json\\_replace() | Yes | No |\n| json\\_set() | Yes | Yes |\n\nThe json\\_insert(), json\\_replace(), and json\\_set() functions always take an odd number of arguments. The first argument is always the original JSON to be edited. Subsequent arguments occur in pairs with the first element of each pair being a path and the second element being the value to insert or replace or set on that path. Edits occur sequentially from left to right. Changes caused by prior edits can affect the path search for subsequent edits. If the value of a path/value pair is an SQLite TEXT value, then it is normally inserted as a quoted JSON string, even if the string looks like valid JSON. However, if the value is the result of another json function (such as [json()](https://www.sqlite.org/json1.html#jmini) or [json\\_array()](https://www.sqlite.org/json1.html#jarray) or [json\\_object()](https://www.sqlite.org/json1.html#jobj)) or if it is the result of [the -> operator](https://www.sqlite.org/json1.html#jptr), then it is interpreted as JSON and is inserted as JSON retaining all of its substructure. Values that are the result of [the ->> operator](https://www.sqlite.org/json1.html#jptr) are always interpreted as TEXT and are inserted as a JSON string even if they look like valid JSON. These routines throw an error if the first JSON argument is not well-formed or if any PATH argument is not well-formed or if any argument is a BLOB. To append an element onto the end of an array, using json\\_insert() with an array index of "#". Examples:*   json\\_insert(\'\\[1,2,3,4\\]\',\'$\\[#\\]\',99) → \'\\[1,2,3,4,99\\]\'\n*   json\\_insert(\'\\[1,\\[2,3\\],4\\]\',\'$\\[1\\]\\[#\\]\',99) → \'\\[1,\\[2,3,99\\],4\\]\'\nOther examples:*   json\\_insert(\'{"a":2,"c":4}\', \'$.a\', 99) → \'{"a":2,"c":4}\'\n*   json\\_insert(\'{"a":2,"c":4}\', \'$.e\', 99) → \'{"a":2,"c":4,"e":99}\'\n*   json\\_replace(\'{"a":2,"c":4}\', \'$.a\', 99) → \'{"a":99,"c":4}\'\n*   json\\_replace(\'{"a":2,"c":4}\', \'$.e\', 99) → \'{"a":2,"c":4}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.a\', 99) → \'{"a":99,"c":4}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.e\', 99) → \'{"a":2,"c":4,"e":99}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.c\', \'\\[97,96\\]\') → \'{"a":2,"c":"\\[97,96\\]"}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.c\', json(\'\\[97,96\\]\')) → \'{"a":2,"c":\\[97,96\\]}\'\n*   json\\_set(\'{"a":2,"c":4}\', \'$.c\', json\\_array(97,96)) → \'{"a":2,"c":\\[97,96\\]}\''}},i=["->","->>","abs","acos","acosh","asin","asinh","atan","atan2","atanh","avg","bm25","ceil","ceiling","changes","char","coalesce","concat","concat_ws","cos","cosh","count","cume_dist","current_date","current_time","current_timestamp","date","datetime","degrees","dense_rank","exp","first_value","floor","format","fts3_tokenizer","fts5","fts5_get_locale","fts5_insttoken","fts5_locale","fts5_source_id","glob","group_concat","hex","highlight","if","ifnull","iif","instr","json","json_array","json_array_length","json_error_position","json_extract","json_group_array","json_group_object","json_insert","json_object","json_patch","json_pretty","json_quote","json_remove","json_replace","json_set","json_type","json_valid","jsonb","jsonb_array","jsonb_extract","jsonb_group_array","jsonb_group_object","jsonb_insert","jsonb_object","jsonb_patch","jsonb_remove","jsonb_replace","jsonb_set","julianday","lag","last_insert_rowid","last_value","lead","length","like","likelihood","likely","ln","load_extension","log","log10","log2","lower","ltrim","match","matchinfo","max","min","mod","nth_value","ntile","nullif","octet_length","offsets","optimize","percent_rank","pi","pow","power","printf","quote","radians","random","randomblob","rank","replace","round","row_number","rtreecheck","rtreedepth","rtreenode","rtrim","sign","sin","sinh","snippet","soundex","sqlite_compileoption_get","sqlite_compileoption_used","sqlite_log","sqlite_offset","sqlite_source_id","sqlite_version","sqrt","strftime","string_agg","substr","substring","subtype","sum","tan","tanh","time","timediff","total","total_changes","trim","trunc","typeof","unhex","unicode","unixepoch","unknown","unlikely","upper","zeroblob"],a=e=>{const t=new Set([""]);for(const n of e){const e=[...t];t.clear();for(const i of"string"==typeof n?[n]:n)for(const n of e)t.add(n+i)}return t},o=e=>{const t=[];let n=0,i=0;for(let a=0;a<e.length;a++)switch(e[a]){case"(":0===i&&(t.push(e.slice(n,a)),n=a+1),i++;break;case")":i--,0===i&&(t.push(e.slice(n,a)),n=a+1)}return t.push(e.slice(n)),t},r=e=>{const t=new Set,n=(e=>{const t=[];let n=0,i=0;for(let a=0;a<e.length;a++)switch(e[a]){case"(":i++;break;case")":i--;break;case"|":0===i&&(t.push(e.slice(n,a)),n=a+1)}return t.push(e.slice(n)),t})(e);for(const i of n){const e=a(o(i).map((e=>e.includes("(")||e.includes("|")?r(e):e)));for(const n of e)t.add(n)}return t},s=new Map;for(const l of e)s.set(l,{syntax:new Set});const d=(e,t,n={expand:!0})=>{for(const i of n.expand?r(t):[t]){s.has(i)||s.set(i,{syntax:new Set});for(const t of Array.isArray(e)?e:[e])s.get(i).syntax.add(t)}};d("sql-stmt","EXPLAIN(| QUERY PLAN)"),d("alter-table-stmt","ALTER TABLE"),d("alter-table-stmt","RENAME TO"),d("alter-table-stmt","RENAME COLUMN"),d("alter-table-stmt","ADD COLUMN"),d("alter-table-stmt","DROP COLUMN"),d("column-def","(INTEGER|REAL|TEXT|BLOB) NOT NULL(| PRIMARY KEY(| AUTOINCREMENT)(| ASC| DESC))(| REFERENCES)"),d("column-def","(INTEGER|REAL|TEXT|BLOB) PRIMARY KEY(| AUTOINCREMENT)(| ASC| DESC)(| NOT NULL)(| REFERENCES)"),d("column-def","(INTEGER|REAL|TEXT|BLOB) REFERENCES"),d("column-def","(INTEGER|REAL|TEXT|BLOB) UNIQUE NOT NULL(| PRIMARY KEY(| AUTOINCREMENT)(| ASC| DESC))(| REFERENCES)"),d("column-def","(INTEGER|REAL|TEXT|BLOB) UNIQUE PRIMARY KEY(| AUTOINCREMENT)(| ASC| DESC)(| NOT NULL)(| REFERENCES)"),d("column-def","(INTEGER|REAL|TEXT|BLOB) UNIQUE REFERENCES"),d("column-def","(INTEGER|REAL|TEXT|BLOB) NOT NULL UNIQUE(| PRIMARY KEY(| AUTOINCREMENT)(| ASC| DESC))(| REFERENCES)"),d("column-def","(INTEGER|REAL|TEXT|BLOB) PRIMARY KEY(| AUTOINCREMENT)(| ASC| DESC)(| NOT NULL UNIQUE)(| REFERENCES)"),d("column-def","(INTEGER|REAL|TEXT|BLOB) REFERENCES"),d("column-def","INTEGER|REAL|TEXT|BLOB"),d("column-constraint","PRIMARY KEY(| ASC| DESC)"),d("column-constraint","NOT NULL"),d("column-constraint","GENERATED ALWAYS AS"),d("conflict-clause","ON CONFLICT (ROLLBACK|ABORT|FAIL|IGNORE|REPLACE)"),d("expr","NOT (LIKE|GLOB|REGEXP|MATCH|NULL)"),d("expr","IS NOT DISTINCT FROM"),d("expr","IS DISTINCT FROM"),d("expr","DISTINCT FROM"),d("expr","IS NOT"),d("expr","NOT BETWEEN"),d("expr","NOT IN"),d("expr","NOT EXISTS"),d("filter-clause","FILTER"),d("filter-clause","FILTER(WHERE",{expand:!1}),d("over-clause","PARTITION BY"),d("over-clause","ORDER BY"),d("frame-spec","BETWEEN UNBOUNDED PRECEDING AND"),d("frame-spec","PRECEDING"),d("frame-spec","BETWEEN CURRENT ROW"),d("frame-spec","FOLLOWING"),d("frame-spec","UNBOUNDED (FOLLOWING|PRECEDING)"),d("frame-spec","EXCLUDE (ROW|NO OTHERS|CURRENT ROW|GROUP|TIES)"),d("ordering-term","NULLS (FIRST|LAST)"),d("ordering-term","RAISE(IGNORE)",{expand:!1}),d("ordering-term","RAISE(ROLLBACK,",{expand:!1}),d("ordering-term","RAISE(ABORT,",{expand:!1}),d("ordering-term","RAISE(FAIL,",{expand:!1}),d("select-stmt","SELECT"),d("select-stmt","WITH RECURSIVE"),d("select-stmt","SELECT DISTINCT"),d("select-stmt","GROUP BY"),d("select-stmt","ORDER BY"),d("common-table-expression","AS NOT MATERIALIZED"),d("common-table-expression","AS MATERIALIZED"),d("compound-operator","UNION ALL"),d("join-operator","(|NATURAL )LEFT JOIN"),d("join-operator","(|NATURAL )RIGHT JOIN"),d("join-operator","(|NATURAL )FULL JOIN"),d("join-operator","(|NATURAL )INNER JOIN"),d("join-operator","(|NATURAL )LEFT OUTER JOIN"),d("join-operator","(|NATURAL )RIGHT OUTER JOIN"),d("join-operator","(|NATURAL )FULL OUTER JOIN"),d("join-operator","CROSS JOIN"),d("join-operator","NATURAL JOIN"),d("table-or-subquery","INDEXED BY"),d("table-or-subquery","NOT INDEXED"),d("window-defn","PARTITION BY"),d("window-defn","ORDER BY"),d("foreign-key-clause","ON DELETE"),d("foreign-key-clause","ON UPDATE"),d("foreign-key-clause","SET NULL"),d("foreign-key-clause","SET DEFAULT"),d("foreign-key-clause","CASCADE"),d("foreign-key-clause","RESTRICT"),d("foreign-key-clause","NO ACTION"),d("foreign-key-clause","ON (DELETE|UPDATE) (SET NULL|SET DEFAULT|CASCADE|RESTRICT|NO ACTION)"),d("foreign-key-clause","NOT DEFERRABLE"),d("foreign-key-clause","INITIALLY (DEFERRED|IMMEDIATE)"),d("foreign-key-clause","(|NOT )DEFERRABLE INITIALLY (DEFERRED|IMMEDIATE)"),d("literal-value","NULL"),d("literal-value","TRUE"),d("literal-value","FALSE"),d("literal-value","CURRENT_TIME"),d("literal-value","CURRENT_DATE"),d("literal-value","CURRENT_TIMESTAMP"),d("analyze-stmt","ANALYZE"),d("attach-stmt","ATTACH DATABASE"),d("begin-stmt","BEGIN TRANSACTION"),d("begin-stmt","BEGIN (DEFERRED|IMMEDIATE|EXCLUSIVE)(| TRANSACTION)"),d("commit-stmt","COMMIT TRANSACTION"),d("commit-stmt","END TRANSACTION"),d("rollback-stmt","ROLLBACK TRANSACTION TO SAVEPOINT"),d("rollback-stmt","ROLLBACK TRANSACTION TO"),d("rollback-stmt","ROLLBACK TO SAVEPOINT"),d("rollback-stmt","ROLLBACK TO"),d("rollback-stmt","ROLLBACK TRANSACTION"),d("create-index-stmt","CREATE INDEX"),d("create-index-stmt","CREATE UNIQUE INDEX"),d("create-index-stmt","CREATE INDEX IF NOT EXISTS"),d("create-index-stmt","CREATE UNIQUE INDEX IF NOT EXISTS"),d("create-index-stmt","IF NOT EXISTS"),d("create-table-stmt","CREATE TABLE"),d("create-table-stmt","CREATE TABLE IF NOT EXISTS"),d("create-table-stmt","CREATE TEMP TABLE"),d("create-table-stmt","CREATE TEMPORARY TABLE"),d("create-table-stmt","CREATE TEMP TABLE IF NOT EXISTS"),d("create-table-stmt","CREATE TEMPORARY TABLE IF NOT EXISTS"),d("table-constraint","PRIMARY KEY"),d("table-constraint","FOREIGN KEY"),d("table-constraint","PRIMARY KEY AUTOINCREMENT"),d("table-options","WITHOUT ROWID"),d("table-options","STRICT"),d("create-trigger-stmt","CREATE TRIGGER"),d("create-trigger-stmt","CREATE TRIGGER IF NOT EXISTS"),d("create-trigger-stmt","CREATE TEMP TRIGGER"),d("create-trigger-stmt","CREATE TEMP TRIGGER IF NOT EXISTS"),d("create-trigger-stmt","CREATE TEMPORARY TRIGGER"),d("create-trigger-stmt","CREATE TEMPORARY TRIGGER IF NOT EXISTS"),d("create-trigger-stmt","IF NOT EXISTS"),d("create-trigger-stmt","INSTEAD OF"),d("create-trigger-stmt","(DELETE ON|INSERT ON|UPDATE ON|UPDATE OF)"),d("create-trigger-stmt","BEFORE (DELETE ON|INSERT ON|UPDATE ON|UPDATE OF)"),d("create-trigger-stmt","AFTER (DELETE ON|INSERT ON|UPDATE ON|UPDATE OF)"),d("create-trigger-stmt","INSTEAD OF (DELETE ON|INSERT ON|UPDATE ON|UPDATE OF)"),d("create-trigger-stmt","FOR EACH ROW"),d("delete-stmt","WITH RECURSIVE"),d("delete-stmt","DELETE FROM"),d("qualified-table-name","INDEXED BY"),d("qualified-table-name","NOT INDEXED"),d("returning-clause","RETURNING"),d("insert-stmt","WITH RECURSIVE"),d("insert-stmt","REPLACE INTO"),d("insert-stmt","INSERT INTO"),d("insert-stmt","INSERT OR (ABORT INTO|FAIL INTO|IGNORE INTO|REPLACE INTO|ROLLBACK INTO)"),d("insert-stmt","DEFAULT VALUES"),d("upsert-clause","ON CONFLICT"),d("upsert-clause","DO NOTHING"),d("upsert-clause","DO UPDATE SET"),d("update-stmt","WITH RECURSIVE"),d("update-stmt","UPDATE OR (ABORT|FAIL|IGNORE|REPLACE|ROLLBACK)"),d("join-constraint","ON"),d("join-constraint","USING"),d("table-or-subquery","INDEXED BY"),d("table-or-subquery","NOT INDEXED"),d("create-view-stmt","CREATE VIEW"),d("create-view-stmt","CREATE VIEW IF NOT EXISTS"),d("create-view-stmt","CREATE TEMP VIEW"),d("create-view-stmt","CREATE TEMP VIEW IF NOT EXISTS"),d("create-view-stmt","CREATE TEMPORARY VIEW"),d("create-view-stmt","CREATE TEMPORARY VIEW IF NOT EXISTS"),d("create-virtual-table-stmt","CREATE VIRTUAL TABLE"),d("create-virtual-table-stmt","CREATE VIRTUAL TABLE IF NOT EXISTS"),d("delete-stmt","WITH RECURSIVE"),d("delete-stmt","DELETE FROM"),d("delete-stmt","WITH RECURSIVE"),d("delete-stmt","DELETE FROM"),d("delete-stmt","ORDER BY"),d("detach-stmt","DETACH DATABASE"),d("drop-index-stmt","DROP INDEX"),d("drop-index-stmt","DROP INDEX IF EXISTS"),d("drop-index-stmt","IF EXISTS"),d("drop-table-stmt","DROP TABLE"),d("drop-table-stmt","DROP TABLE IF EXISTS"),d("drop-table-stmt","IF EXISTS"),d("drop-trigger-stmt","DROP TRIGGER"),d("drop-trigger-stmt","DROP TRIGGER IF EXISTS"),d("drop-trigger-stmt","IF EXISTS"),d("drop-view-stmt","DROP VIEW"),d("drop-view-stmt","DROP VIEW IF EXISTS"),d("drop-view-stmt","IF EXISTS"),d("release-stmt","SAVEPOINT"),d("release-stmt","RELEASE(| SAVEPOINT)"),d("vacuum-stmt","VACUUM INTO"),d("with-clause","WITH"),d("with-clause","WITH RECURSIVE"),d("with-clause","AS NOT MATERIALIZED"),d("with-clause","AS MATERIALIZED"),d([],"STORED"),d([],"NEW"),d([],"OLD"),d([],"IS NULL"),d([],"IS NOT NULL");const h=(e,a,o,r,d)=>({functionNameItems:i.map((t=>{const i=n[t];return e&&(t=t.toUpperCase()),{label:t,kind:o.Function,detail:t+(i?.args??""),documentation:r(i?.docs)}})),joinedKeywordItems:[...s.entries()].flatMap((([e,{syntax:n}])=>{if("NOTNULL"===e||"ISNULL"===e)return[];if(a&&d){let i="";for(const e of n)i+=`### ${t(e)}\n![${t(e)}](${t(d(`syntax/${e}.svg`))})\n`;return[{label:e,kind:o.Keyword,documentation:i?r(i+`\n\n---\nSQLite ${t("version-3.48.0")}`):void 0}]}return[{label:e,kind:o.Keyword}]})),dataTypeItems:["INT","INTEGER","REAL","TEXT","BLOB"].map((e=>({label:e,kind:o.EnumMember})))});export{h as offlineCompletions};
