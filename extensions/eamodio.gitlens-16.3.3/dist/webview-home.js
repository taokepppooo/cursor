exports.id=928,exports.ids=[928],exports.modules={1018:(e,t,i)=>{i.d(t,{HomeWebviewProvider:()=>HomeWebviewProvider});var s=i(1398),r=i(4692),n=i(5811),o=i(2251),a=i(1646),h=i(2710),l=i(9268),c=i(8085),u=i(5416),d=i(5302),p=i(4931),g=i(3494),v=i(6447),w=i(7628),m=i(1762),b=i(594),f=i(7023),y=i(8049),C=i(7747),R=i(892),S=i(3758),P=i(369),_=i(4143),B=i(9011);async function D(e){let t=await e.launchpad.getCategorizedItems();if(null!=t.error)return{error:t.error};let i=_.H.get("launchpad.indicator.groups")??[];return(0,B.a)(t.items,i)}var O=i(4424),k=i(156),I=i(7686),L=i(5487),q=i(4007),W=i(124),T=i(5270),F=i(471),E=i(3503);let A="home",z=new E.Oz(A,"launchpad/summary"),M=new E.Oz(A,"overview/active"),$=new E.Oz(A,"overview/inactive"),x=new E.Oz(A,"overviewFilter"),H=new E.Q2(A,"overview/repository/change"),U=new E.C1(A,"overview/repository/didChange"),Z=new E.Q2(A,"previewEnabled/toggle"),G=new E.Q2(A,"section/collapse"),N=new E.Q2(A,"walkthrough/dismiss"),Q=new E.Q2(A,"overview/filter/set"),j=new E.Q2(A,"openInGraph"),Y=new E.C1(A,"repositories/didCompleteDiscovering"),K=new E.C1(A,"previewEnabled/didChange"),V=new E.C1(A,"repository/wip/didChange"),X=new E.C1(A,"repositories/didChange"),J=new E.C1(A,"walkthroughProgress/didChange"),ee=new E.C1(A,"integrations/didChange"),et=new E.C1(A,"launchpad/didChange"),ei=new E.C1(A,"subscription/didChange"),es=new E.C1(A,"org/settings/didChange"),er=new E.C1(A,"home/ownerFilter/didChange"),en=new E.C1(A,"account/didFocus");var eo=Object.defineProperty,ea=Object.getOwnPropertyDescriptor,eh=(e,t,i,s)=>{for(var r,n=s>1?void 0:s?ea(t,i):t,o=e.length-1;o>=0;o--)(r=e[o])&&(n=(s?r(t,i,n):r(n))||n);return s&&n&&eo(t,i,n),n};let el=Object.freeze({dispose:()=>{}}),ec={OneDay:864e5,OneWeek:6048e5,OneMonth:2592e6,OneYear:31536e6};let HomeWebviewProvider=class HomeWebviewProvider{constructor(e,t){this.container=e,this.host=t,this._disposable=s.Disposable.from(this.container.git.onDidChangeRepositories(this.onRepositoriesChanged,this),s.workspace.isTrusted?el:s.workspace.onDidGrantWorkspaceTrust(()=>this.notifyDidChangeRepositories(),this),this.container.subscription.onDidChange(this.onSubscriptionChanged,this),(0,I.wt)(this.onContextChanged,this),this.container.integrations.onDidChangeConfiguredIntegrations(this.onChangeConnectionState,this),this.container.walkthrough.onProgressChanged(this.onWalkthroughChanged,this),_.H.onDidChange(this.onDidChangeConfig,this),this.container.launchpad.onDidChange(this.onDidLaunchpadChange,this))}_disposable;_discovering;_etag;_etagFileSystem;_etagRepository;_etagSubscription;_pendingFocusAccount=!1;dispose(){this._disposable.dispose()}getTelemetryContext(){return{...this.host.getTelemetryContext(),"context.preview":this.getPreviewEnabled()?"v16":void 0}}_overviewBranchFilter={recent:{threshold:"OneWeek"},stale:{threshold:"OneYear",show:!1,limit:9}};onShowing(e,t,...i){this._etag=this.container.git.etag,this.ensureRepoDiscovery();let[s]=i;if(s?.focusAccount===!0){if(!e&&this.host.ready&&this.host.visible)return queueMicrotask(()=>void this.host.notify(en,void 0)),[!0,void 0];this._pendingFocusAccount=!0}return[!0,void 0]}async ensureRepoDiscovery(){this.container.git.isDiscoveringRepositories&&(this._discovering=this.container.git.isDiscoveringRepositories,this._discovering.finally(()=>this._discovering=void 0),this._etag=await this._discovering,this.notifyDidCompleteDiscoveringRepositories())}onChangeConnectionState(e){this.notifyDidChangeIntegrations()}async onChooseRepository(){let e=this.getSelectedRepository(),t=this.container.git.openRepositories.sort((t,i)=>(t===e?1:-1)-(i===e?1:-1)||(t.starred?-1:1)-(i.starred?-1:1)||t.index-i.index),i=await (0,O.oe)(`Switch Repository ${n.EO.Dot} ${e?.name}`,"Choose a repository to switch to",t);if(null!=i&&i!==e)return this.selectRepository(i.path)}onRepositoriesChanged(){null==this._discovering&&this._etag!==this.container.git.etag&&this.notifyDidChangeRepositories()}onWalkthroughChanged(){this.notifyDidChangeProgress()}onDidChangeConfig(e){_.H.changed(e,"home.preview.enabled")&&this.notifyDidChangeConfig()}onDidLaunchpadChange(){this.notifyDidChangeLaunchpad()}async push(e=!1){let t=this.getSelectedRepository();return t?(0,h.b)({command:"push",state:{repos:[t],flags:e?["--force"]:void 0}}):Promise.resolve()}async pull(){let e=this.getSelectedRepository();return e?(0,h.b)({command:"pull",state:{repos:[e]}}):Promise.resolve()}registerCommands(){return[(0,k.Lb)(`${this.host.id}.pull`,this.pull,this),(0,k.Lb)(`${this.host.id}.push`,e=>{this.push(e.force)},this),(0,k.Lb)(`${this.host.id}.publishBranch`,this.push,this),(0,k.Lb)(`${this.host.id}.refresh`,()=>this.host.refresh(!0),this),(0,k.Lb)(`${this.host.id}.disablePreview`,()=>this.onTogglePreviewEnabled(!1),this),(0,k.Lb)(`${this.host.id}.enablePreview`,()=>this.onTogglePreviewEnabled(!0),this),(0,k.Lb)(`${this.host.id}.previewFeedback`,()=>(0,L.CZ)("https://github.com/gitkraken/vscode-gitlens/discussions/3721"),this),(0,k.Lb)(`${this.host.id}.whatsNew`,()=>(0,L.CZ)(n.DS.releaseNotes),this),(0,k.Lb)(`${this.host.id}.help`,()=>(0,L.CZ)(n.DS.helpCenter),this),(0,k.Lb)(`${this.host.id}.issues`,()=>(0,L.CZ)(n.DS.githubIssues),this),(0,k.Lb)(`${this.host.id}.info`,()=>(0,L.CZ)(n.DS.helpCenterHome),this),(0,k.Lb)(`${this.host.id}.discussions`,()=>(0,L.CZ)(n.DS.githubDiscussions),this),(0,k.Lb)(`${this.host.id}.account.resync`,e=>this.container.subscription.validate({force:!0},e),this),(0,k.Lb)("gitlens.home.openMergeTargetComparison",this.mergeTargetCompare,this),(0,k.Lb)("gitlens.home.openPullRequestChanges",this.pullRequestChanges,this),(0,k.Lb)("gitlens.home.openPullRequestComparison",this.pullRequestCompare,this),(0,k.Lb)("gitlens.home.openPullRequestOnRemote",this.pullRequestViewOnRemote,this),(0,k.Lb)("gitlens.home.openPullRequestDetails",this.pullRequestDetails,this),(0,k.Lb)("gitlens.home.createPullRequest",this.pullRequestCreate,this),(0,k.Lb)("gitlens.home.openWorktree",this.worktreeOpen,this),(0,k.Lb)("gitlens.home.switchToBranch",this.switchToBranch,this),(0,k.Lb)("gitlens.home.fetch",this.fetch,this),(0,k.Lb)("gitlens.home.openInGraph",this.openInGraph,this),(0,k.Lb)("gitlens.home.createBranch",this.createBranch,this),(0,k.Lb)("gitlens.home.mergeIntoCurrent",this.mergeIntoCurrent,this),(0,k.Lb)("gitlens.home.rebaseCurrentOnto",this.rebaseCurrentOnto,this),(0,k.Lb)("gitlens.home.startWork",this.startWork,this),(0,k.Lb)("gitlens.home.createCloudPatch",this.createCloudPatch,this),(0,k.Lb)("gitlens.home.skipPausedOperation",this.skipPausedOperation,this),(0,k.Lb)("gitlens.home.continuePausedOperation",this.continuePausedOperation,this),(0,k.Lb)("gitlens.home.abortPausedOperation",this.abortPausedOperation,this),(0,k.Lb)("gitlens.home.openRebaseEditor",this.openRebaseEditor,this)]}setOverviewFilter(e){this._overviewBranchFilter=e,this.host.notify(er,{filter:this._overviewBranchFilter})}async onMessageReceived(e){switch(!0){case G.is(e):this.onCollapseSection(e.params);break;case N.is(e):this.dismissWalkthrough();break;case Q.is(e):this.setOverviewFilter(e.params);break;case z.is(e):this.host.respond(z,e,await D(this.container));break;case x.is(e):this.host.respond(x,e,this._overviewBranchFilter);break;case H.is(e):if(await this.onChooseRepository()==null)return;this.host.notify(U,void 0);break;case Z.is(e):this.onTogglePreviewEnabled();break;case j.is(e):this.openInGraph(e.params);break;case M.is(e):this.host.respond(M,e,await this.getActiveBranchOverview());break;case $.is(e):this.host.respond($,e,await this.getInactiveBranchOverview())}}includeBootstrap(){return this.getState()}onRefresh(){this.resetBranchOverview(),this.notifyDidChangeRepositories()}onReloaded(){this.onRefresh(),this.notifyDidChangeProgress()}onReady(){!0===this._pendingFocusAccount&&(this._pendingFocusAccount=!1,this.host.notify(en,void 0))}hasRepositoryChanged(){if(this._repositorySubscription?.repo!=null){if(this._repositorySubscription.repo.etag!==this._etagRepository||this._repositorySubscription.repo.etagFileSystem!==this._etagFileSystem)return!0}else if(this._etag!==this.container.git.etag)return!0;return!1}onVisibilityChanged(e){if(!e){this.stopRepositorySubscription();return}this.resumeRepositorySubscription(),null==this._discovering&&(this.container.subscription.etag!==this._etagSubscription||this.hasRepositoryChanged())&&this.notifyDidChangeRepositories(!0)}openInGraph(e){let t;if(e?.type==="branch"){let t=this._repositoryBranches.get(e.repoPath);if(null==t)return;let i=t.branches.find(t=>t.id===e.branchId);if(null==i)return;let s=(0,w.iw)(i);if(null==s)return;(0,k.RS)(o.d.ShowInCommitGraph,{ref:s});return}if(null==e)t=this.getSelectedRepository();else{let i=this._repositoryBranches.get(e.repoPath);t=i?.repo}null!=t&&(0,k.RS)(o.d.ShowGraph,t)}createBranch(){this.container.telemetry.sendEvent("home/createBranch"),(0,k.RS)(o.d.GitCommands,{command:"branch",state:{subcommand:"create",suggestNameOnly:!0,suggestRepoOnly:!0,confirmOptions:["--switch","--worktree"]}})}async mergeIntoCurrent(e){let t=this._repositoryBranches.get(e.repoPath),i=t?.branches.find(t=>t.id===e.branchId);(null!=i||null!=(i=await t?.repo?.git.branches().getBranch(e.branchName)))&&c.h1(t.repo,(0,w.iw)(i))}async rebaseCurrentOnto(e){let t=this._repositoryBranches.get(e.repoPath),i=t?.branches.find(t=>t.id===e.branchId);(null!=i||null!=(i=await t?.repo?.git.branches().getBranch(e.branchName)))&&c.RU(t.repo,(0,w.iw)(i))}startWork(){this.container.telemetry.sendEvent("home/startWork"),(0,k.RS)(o.d.StartWork,{command:"startWork",source:"home"})}async abortPausedOperation(e){let t=this.container.git.status(e.repoPath).abortPausedOperation;if(null!=t)try{await t()}catch(e){s.window.showErrorMessage(e.message)}}async continuePausedOperation(e){if("revert"===e.type)return;let t=this.container.git.status(e.repoPath).continuePausedOperation;if(null!=t)try{await t()}catch(e){s.window.showErrorMessage(e.message)}}async skipPausedOperation(e){let t=this.container.git.status(e.repoPath).continuePausedOperation;if(null!=t)try{await t({skip:!0})}catch(e){s.window.showErrorMessage(e.message)}}async openRebaseEditor(e){if("rebase"!==e.type)return;let t=await this.container.git.getGitDir(e.repoPath);if(null==t)return;let i=s.Uri.joinPath(t.uri,"rebase-merge","git-rebase-todo");(0,k.S4)("vscode.openWith",i,"gitlens.rebase",{preview:!1})}async createCloudPatch(e){let t=await this.container.git.status(e.repoPath).getStatus();if(null==t)return;let i=[];for(let e of t.files){let t={repoPath:e.repoPath,path:e.path,status:e.status,originalPath:e.originalPath,staged:e.staged};i.push(t),e.staged&&e.wip&&i.push({...t,staged:!1})}let{repo:s}=this._repositoryBranches.get(e.repoPath),r={type:"wip",repository:{name:s.name,path:s.path,uri:s.uri.toString()},files:i,revision:{to:p.SU,from:"HEAD"}};(0,C.X)({mode:"create",create:{changes:[r]}})}onTogglePreviewEnabled(e){void 0===e&&(e=!this.getPreviewEnabled()),this.getPreviewCollapsed()||this.onCollapseSection({section:"newHomePreview",collapsed:!0}),this.container.telemetry.sendEvent("home/preview/toggled",{enabled:e,version:"v16"}),_.H.updateEffective("home.preview.enabled",e)}onCollapseSection(e){let t=this.container.storage.get("home:sections:collapsed");if(null==t){!0===e.collapsed&&this.container.storage.store("home:sections:collapsed",[e.section]).catch();return}let i=t.indexOf(e.section);if(!0===e.collapsed){-1===i&&this.container.storage.store("home:sections:collapsed",[...t,e.section]).catch();return}-1!==i&&(t.splice(i,1),this.container.storage.store("home:sections:collapsed",t).catch())}dismissWalkthrough(){this.container.storage.get("home:walkthrough:dismissed")||(this.container.storage.store("home:walkthrough:dismissed",!0).catch(),this.container.usage.track("home:walkthrough:dismissed").catch())}getWalkthroughDismissed(){return this.container.storage.get("home:walkthrough:dismissed")??!1}getPreviewCollapsed(){return this.container.storage.get("home:sections:collapsed")?.includes("newHomePreview")??!1}getAmaBannerCollapsed(){return Date.now()>=new Date("2025-02-13T13:00:00-05:00").getTime()||(this.container.storage.get("home:sections:collapsed")?.includes("feb2025AmaBanner")??!1)}getIntegrationBannerCollapsed(){return this.container.storage.get("home:sections:collapsed")?.includes("integrationBanner")??!1}getOrgSettings(){return{drafts:(0,I.SD)("gitlens:gk:organization:drafts:enabled",!1)}}onContextChanged(e){"gitlens:gk:organization:drafts:enabled"===e&&this.notifyDidChangeOrgSettings()}async onSubscriptionChanged(e){e.etag!==this._etagSubscription&&(await this.notifyDidChangeSubscription(e.current),(0,R.k0)(e.current.state)!==(0,R.k0)(e.previous.state)&&this.onOverviewRepoChanged())}async getState(e){let[t,i]=await Promise.allSettled([this.getSubscriptionState(e),this.getIntegrationStates(!0)]);if("rejected"===t.status)throw t.reason;let s=(0,F.Ro)(i)??[],r=s.some(e=>e.connected);return{...this.host.baseWebviewState,discovering:null!=this._discovering,repositories:this.getRepositoriesState(),webroot:this.host.getWebRoot(),subscription:t.value.subscription,avatar:t.value.avatar,organizationsCount:t.value.organizationsCount,orgSettings:this.getOrgSettings(),previewCollapsed:this.getPreviewCollapsed(),integrationBannerCollapsed:this.getIntegrationBannerCollapsed(),integrations:s,hasAnyIntegrationConnected:r,walkthroughProgress:this.getWalkthroughDismissed()?void 0:{allCount:this.container.walkthrough.walkthroughSize,doneCount:this.container.walkthrough.doneCount,progress:this.container.walkthrough.progress},previewEnabled:this.getPreviewEnabled(),newInstall:(0,I.SD)("gitlens:install:new",!1),amaBannerCollapsed:this.getAmaBannerCollapsed()}}getPreviewEnabled(){return _.H.get("home.preview.enabled")}getRepositoriesState(){return{count:this.container.git.repositoryCount,openCount:this.container.git.openRepositoryCount,hasUnsafe:this.container.git.hasUnsafeRepositories(),trusted:s.workspace.isTrusted}}async getActiveBranchOverview(){null!=this._discovering&&await this._discovering;let e=this.getSelectedRepository();if(null==e)return;let t="repo"===this._invalidateOverview,i="wip"===this._invalidateOverview,s=await this.getBranchesData(e,t),{branches:r,worktreesByBranch:n}=s,o=r.find(e=>"active"===this.getBranchOverviewType(e,n)),a=await this.isSubscriptionPro(),[h]=eu([o],s.worktreesByBranch,a,this.container,{isActive:!0,forceStatus:!!t||!!i||void 0});return i&&(this._invalidateOverview=void 0),this._etagFileSystem=e.etagFileSystem,{repository:await this.formatRepository(e),active:h}}async getInactiveBranchOverview(){let e;null!=this._discovering&&await this._discovering;let t=this.getSelectedRepository();if(null==t)return;let i="repo"===this._invalidateOverview,s=await this.getBranchesData(t,i),r=s.branches.filter(e=>"recent"===this.getBranchOverviewType(e,s.worktreesByBranch));if(this._overviewBranchFilter.stale.show)for(let t of((0,m.Xn)(s.branches,{missingUpstream:!0,orderBy:"date:asc"}),s.branches)){if(null!=e&&e.length>this._overviewBranchFilter.stale.limit)break;r.some(e=>e.id===t.id)||"stale"!==this.getBranchOverviewType(t,s.worktreesByBranch)||(e??=[]).push(t)}let n=await this.isSubscriptionPro(),o=eu(r,s.worktreesByBranch,n,this.container),a=null==e?void 0:eu(e,s.worktreesByBranch,n,this.container);return i||(this._invalidateOverview=void 0),{repository:await this.formatRepository(t),recent:o,stale:a}}async formatRepository(e){let t=await e.git.remotes().getBestRemotesWithProviders(),i=t.find(e=>e.hasIntegration())??t[0];return{name:e.commonRepositoryName??e.name,path:e.path,provider:i?.provider?{name:i.provider.name,icon:"remote"===i.provider.icon?"cloud":i.provider.icon,url:i.provider.url({type:u.J.Repo})}:void 0}}_repositorySubscription;selectRepository(e){let t;return null!=e?t=this.container.git.getRepository(e):null==(t=this.container.git.highlander)&&(t=this.container.git.getBestRepositoryOrFirst()),null!=this._repositorySubscription&&(this._repositorySubscription.subscription?.dispose(),this._repositorySubscription=void 0),null!=t&&(this._repositorySubscription={repo:t,subscription:this.subscribeToRepository(t)}),t}stopRepositorySubscription(){null!=this._repositorySubscription&&(this._repositorySubscription.subscription?.dispose(),this._repositorySubscription.subscription=void 0)}resumeRepositorySubscription(e=!1){null!=this._repositorySubscription&&(e||null==this._repositorySubscription.subscription)&&(this._repositorySubscription.subscription?.dispose(),this._repositorySubscription.subscription=void 0,this._repositorySubscription.subscription=this.subscribeToRepository(this._repositorySubscription.repo))}resetBranchOverview(){if(this._repositoryBranches.clear(),!this.host.visible){this.stopRepositorySubscription();return}this.resumeRepositorySubscription(!0)}subscribeToRepository(e){return s.Disposable.from(e.watchFileSystem(1e3),e.onDidChangeFileSystem(t=>this.onOverviewWipChanged(t,e)),e.onDidChange(t=>{t.changed(d.Z_.Config,d.Z_.Head,d.Z_.Heads,d.Z_.Remotes,d.Z_.PausedOperationStatus,d.Z_.Unknown,d.Ti.Any)&&this.onOverviewRepoChanged(e)}))}onOverviewWipChanged(e,t){e.repository?.path===t.path&&this._etagFileSystem!==t.etagFileSystem&&("repo"!==this._invalidateOverview&&(this._invalidateOverview="wip"),this.host.visible&&this.host.notify(V,void 0))}onOverviewRepoChanged(e){if(null!=e){if(this._etagRepository===e.etag)return}else if(this._etag===this.container.git.etag)return;this._invalidateOverview="repo",this.host.visible&&this.notifyDidChangeRepositories()}getSelectedRepository(){return null==this._repositorySubscription&&this.selectRepository(),this._repositorySubscription?.repo}_invalidateOverview;_repositoryBranches=new Map;async getBranchesData(e,t=!1){if(t||!this._repositoryBranches.has(e.path)||e.etag!==this._etagRepository){let t=await e.git.worktrees()?.getWorktrees()??[],i=(0,b.PU)(t,{includeDefault:!0}),[s]=await Promise.allSettled([e.git.branches().getBranches({filter:e=>!e.remote,sort:{current:!0,openedWorktreesByBranch:(0,b.vJ)(i)}})]),r=F.Ro(s)?.values??[];this._etagRepository=e.etag,this._repositoryBranches.set(e.path,{repo:e,branches:r,worktreesByBranch:i})}return this._repositoryBranches.get(e.path)}_integrationStates;_defaultSupportedCloudIntegrations;async getIntegrationStates(e=!1){if(e||null==this._integrationStates){let e=(0,T.x1)(await this.container.integrations.getConfigured(),e=>(0,a.LT)(e.integrationId)?{id:e.integrationId,name:S.Mt[e.integrationId].name,icon:`gl-provider-${S.Mt[e.integrationId].iconKey}`,connected:!0,supports:"hosting"===S.Mt[e.integrationId].type?["prs","issues"]:"issues"===S.Mt[e.integrationId].type?["issues"]:[],requiresPro:a.U4.find(t=>t.id===e.integrationId)?.requiresPro??!1}:void 0),t=await Promise.allSettled(e),i=[...(0,T.x1)(t,e=>(0,F.Ro)(e))];this._defaultSupportedCloudIntegrations??=a.U4.map(e=>({...e,connected:!1})),this._defaultSupportedCloudIntegrations.forEach(e=>{let t=i.find(t=>t.id===e.id);null==t?i.push(e):t.icon!==e.icon&&(t.icon=e.icon)}),i.sort((e,t)=>a.rK.indexOf(e.id)-a.rK.indexOf(t.id)),this._integrationStates=i}return this._integrationStates}_subscription;async getSubscription(e){return null!=e?this._subscription=e:null!=this._subscription?e=this._subscription:this._subscription=e=await this.container.subscription.getSubscription(!0),this._subscription}async isSubscriptionPro(){let e=await this.getSubscription();return null!=e&&(0,R.k0)(e.state)}async getSubscriptionState(e){let t;return e=await this.getSubscription(e),this._etagSubscription=this.container.subscription.etag,t=e.account?.email?(0,r.ML)(e.account.email,34).toString():`${this.host.getWebRoot()??""}/media/gitlens-logo.webp`,{subscription:e,avatar:t,organizationsCount:null!=e?(await this.container.organizations.getOrganizations()??[]).length:0}}notifyDidCompleteDiscoveringRepositories(){this.host.notify(Y,{discovering:null!=this._discovering,repositories:this.getRepositoriesState()})}notifyDidChangeRepositoriesCore(){this.host.notify(X,this.getRepositoriesState())}_notifyDidChangeRepositoriesDebounced=void 0;notifyDidChangeRepositories(e=!1){if(null==this._discovering){if(e){this.notifyDidChangeRepositoriesCore();return}null==this._notifyDidChangeRepositoriesDebounced&&(this._notifyDidChangeRepositoriesDebounced=(0,W.sg)(this.notifyDidChangeRepositoriesCore.bind(this),500)),this._notifyDidChangeRepositoriesDebounced()}}notifyDidChangeProgress(){this.host.notify(J,{allCount:this.container.walkthrough.walkthroughSize,doneCount:this.container.walkthrough.doneCount,progress:this.container.walkthrough.progress})}notifyDidChangeConfig(){this.host.notify(K,{previewEnabled:this.getPreviewEnabled(),previewCollapsed:this.getPreviewCollapsed()})}notifyDidChangeLaunchpad(){this.host.notify(et,void 0)}async notifyDidChangeIntegrations(){let e=await this.getIntegrationStates(!0),t=e.some(e=>e.connected);t&&this.onCollapseSection({section:"integrationBanner",collapsed:!0}),this.host.notify(ee,{hasAnyIntegrationConnected:t,integrations:e})}async notifyDidChangeSubscription(e){let t=await this.getSubscriptionState(e);this.host.notify(ei,{subscription:t.subscription,avatar:t.avatar,organizationsCount:t.organizationsCount})}notifyDidChangeOrgSettings(){this.host.notify(es,{orgSettings:this.getOrgSettings()})}mergeTargetCompare(e){return this.container.views.searchAndCompare.compare(e.repoPath,e.branchName,e.mergeTargetName)}async pullRequestCompare(e){let t=await this.findPullRequest(e);if(t?.refs?.base==null||null==t.refs.head)return;let i=(0,f.tI)(e.repoPath,t.refs);return this.container.views.searchAndCompare.compare(i.repoPath,i.head,i.base)}async pullRequestChanges(e){let t=await this.findPullRequest(e);if(t?.refs?.base==null||null==t.refs.head)return;let i=(0,f.tI)(e.repoPath,t.refs);return(0,l.$5)(this.container,{repoPath:i.repoPath,lhs:i.base.ref,rhs:i.head.ref},{title:`Changes in Pull Request #${t.id}`})}async pullRequestViewOnRemote(e,t){let i=await this.findPullRequest(e);null!=i&&(0,k.RS)(o.d.OpenPullRequestOnRemote,{pr:{url:i.url},clipboard:t})}async pullRequestDetails(e){let t=await this.findPullRequest(e);null!=t&&this.container.views.pullRequest.showPullRequest(t,e.repoPath)}async pullRequestCreate(e){let t=this._repositoryBranches.get(e.repoPath),i=t?.branches.find(t=>t.id===e.branchId);if(null==i)return;let s=await i.getRemote();null!=s&&(0,k.ph)("createPullRequest",{repoPath:e.repoPath,remote:null!=s?{name:s.name,provider:null!=s.provider?{id:s.provider.id,name:s.provider.name,domain:s.provider.domain}:void 0,url:s.url}:void 0,branch:{name:i.name,upstream:i.upstream?.name,isRemote:i.remote}})}worktreeOpen(e){let t=this.findWorktree(e);null!=t&&(0,L.OH)(t.uri)}switchToBranch(e){let t=this._repositoryBranches.get(e.repoPath),i=t?.branches.find(t=>t.id===e.branchId);null!=i&&c.S_(t.repo,(0,w.iw)(i))}async fetch(e){if(null==e){let e=this.getSelectedRepository();c.hd(e);return}let t=this._repositoryBranches.get(e.repoPath);if(null==t)return;let i=t.branches.find(t=>t.id===e.branchId);null==i&&(i=await t.repo.git.branches().getBranch(e.branchId)),null!=i&&c.hd(t.repo,(0,w.iw)(i))}findBranch(e){let t=this._repositoryBranches.get(e.repoPath)?.branches;return t?.find(t=>t.id===e.branchId)}findWorktree(e){let t=this._repositoryBranches.get(e.repoPath);if(null==t)return;let i=t.branches.find(t=>t.id===e.branchId);if(null!=i)return t.worktreesByBranch.get(i.id)}async findPullRequest(e){let t=this.findBranch(e);if(null!=t)return t.getAssociatedPullRequest()}getBranchOverviewType(e,t){if(e.current||t.get(e.id)?.opened)return"active";let i=e.date?.getTime();if(null!=i){let e=Date.now();if(i>e-ec[this._overviewBranchFilter.recent.threshold])return"recent";if(i<e-ec[this._overviewBranchFilter.stale.threshold])return"stale"}if(e.upstream?.missing)return"stale"}};function eu(e,t,i,s,r){let n,o;if(0===e.length)return[];let a=r?.isActive??!1,h=r?.forceStatus?{force:!0}:void 0,l=new Map,c=new Map,u=new Map,d=new Map,p=new Map,v=new Map,m=[];for(let r of e){let e=t.get(r.id),b=r.date?.getTime();!0===i&&(l.set(r.id,ew(s,r,n)),c.set(r.id,r.getEnrichedAutolinks()),u.set(r.id,(0,g.GI)(s,r).then(e=>e.value)),p.set(r.id,s.git.branches(r.repoPath).getBranchContributionsOverview(r.ref)),r.current&&v.set(r.id,eg(s,r))),null!=e?d.set(r.id,e.getStatus(h)):!0===a&&(void 0===o&&(o=s.git.status(r.repoPath).getStatus()),d.set(r.id,o)),m.push({reference:(0,w.iw)(r),repoPath:r.repoPath,id:r.id,name:r.name,opened:a,timestamp:b,state:r.state,status:r.status,upstream:r.upstream,worktree:e?{name:e.name,uri:e.uri.toString()}:void 0})}return m.length>0&&function(e,t,i,s,r,n,o,a,h){for(let l of e){l.pr=i.get(l.id);let e=s.get(l.id);l.autolinks=e?.then(e=>ed(e));let c=r.get(l.id);l.issues=c?.then(e=>e?.map(e=>({id:e.id,title:e.title,state:e.state,url:e.url}))??[]),l.wip=em(h,l,n.get(l.id),t);let u=o.get(l.id);l.contributors=ep(h,u),l.mergeTarget=a.get(l.id)}}(m,a,l,c,u,d,p,v,s),m}async function ed(e){return null==e?[]:(await Promise.allSettled((0,T.x1)([...e.values()],async e=>{let t=e?.[0];if(null==t)return;let i=await t;if(null!=i)return{id:i.id,title:i.title,url:i.url,state:i.state}}))).map(e=>"fulfilled"===e.status?e.value:void 0).filter(e=>null!=e)}async function ep(e,t){if(null==t)return[];let i=await t;return i?.contributors==null?[]:(await Promise.allSettled(i.contributors.map(async e=>({name:e.name??"",email:e.email??"",current:e.current,timestamp:e.latestCommitDate?.getTime(),count:e.commits,stats:e.stats,avatarUrl:(await e.getAvatarUri())?.toString()})))).map(e=>"fulfilled"===e.status?e.value:void 0).filter(e=>null!=e)}async function eg(e,t){let i;let s=await (0,v.y1)(e,t,{associatedPullRequest:t.getAssociatedPullRequest()});!s.targetBranch.paused&&s.targetBranch.value&&(i=s.targetBranch.value);let r=i??s.baseBranch??s.defaultBranch;if(null==r)return;let n=e.git.branches(t.repoPath),o=await n.getBranch(r);if(null==o)return;let[a,h,l]=await Promise.allSettled([e.git.commits(t.repoPath).getLeftRightCommitCount((0,y.Xn)(o.name,t.ref,"..."),{excludeMerges:!0}),n.getPotentialMergeOrRebaseConflict?.(t.name,o.name),n.getBranchMergedStatus?.(t,o)]),c=(0,F.Ro)(a),u=null!=c?{ahead:c.right,behind:c.left}:void 0,d=(0,F.Ro)(l);return{repoPath:t.repoPath,id:o.id,name:o.name,status:u,mergedStatus:d,potentialConflicts:(0,F.Ro)(h),targetBranch:o.name,baseBranch:s.baseBranch,defaultBranch:s.defaultBranch}}async function ev(e,t,i){i??=e.launchpad.getCategorizedItems();let s=await i;if(null!=s.error)return;let r=s.items.find(e=>e.url===t.url);if(null==r){if(null!=(s=await e.launchpad.getCategorizedItems({search:[{pullRequest:t,reasons:[]}]})).error)return;r=s.items.find(e=>e.url===t.url)}if(null!=r)return{uuid:r.uuid,category:r.actionableCategory,groups:(0,P._v)(r),suggestedActions:r.suggestedActions,failingCI:r.failingCI,hasConflicts:r.hasConflicts,review:{decision:r.reviewDecision,reviews:r.reviews??[],counts:{approval:r.approvalReviewCount,changeRequest:r.changeRequestReviewCount,comment:r.commentReviewCount,codeSuggest:r.codeSuggestionsCount}},author:r.author,createdDate:r.createdDate,viewer:{...r.viewer,enrichedItems:void 0}}}async function ew(e,t,i){let s=await t.getAssociatedPullRequest({avatarSize:64});if(null!=s)return{id:s.id,url:s.url,state:s.state,title:s.title,draft:s.isDraft,launchpad:ev(e,s,i)}}async function em(e,t,i,s){if(null==i)return;let[r,n]=await Promise.allSettled([i,s?e.git.status(t.repoPath).getPausedOperationStatus?.():void 0]),o=(0,F.Ro)(r),a=(0,F.Ro)(n);return{workingTreeState:o?.getDiffStatus(),hasConflicts:o?.hasConflicts,conflictsCount:o?.conflicts.length,pausedOpStatus:a}}eh([(0,q.Yz)()],HomeWebviewProvider.prototype,"onOverviewWipChanged",1),eh([(0,q.Yz)()],HomeWebviewProvider.prototype,"onOverviewRepoChanged",1)}};