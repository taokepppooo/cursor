"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _chunkYAHR3ES4cjs = require('./chunk-YAHR3ES4.cjs');
require('./chunk-JRN2XB6P.cjs');









var _chunkTR37ZOITcjs = require('./chunk-TR37ZOIT.cjs');
require('./chunk-CDGJIMJG.cjs');











var _chunk42PBKAQTcjs = require('./chunk-42PBKAQT.cjs');

// ../../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/constants.js
var require_constants = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/constants.js"(exports, module) {
    "use strict";
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var SEP = "/";
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR,
      SEP
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,
      SEP: "\\"
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars2) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars2.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// ../../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/utils.js
var require_utils = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/utils.js"(exports) {
    "use strict";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
    exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports.isWindows = () => {
      if (typeof navigator !== "undefined" && navigator.platform) {
        const platform = navigator.platform.toLowerCase();
        return platform === "win32" || platform === "windows";
      }
      if (typeof process !== "undefined" && process.platform) {
        return process.platform === "win32";
      }
      return false;
    };
    exports.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1) return input;
      if (input[idx - 1] === "\\") return exports.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
    exports.basename = (path7, { windows } = {}) => {
      const segs = path7.split(windows ? /[\\/]/ : "/");
      const last = segs[segs.length - 1];
      if (last === "") {
        return segs[segs.length - 2];
      }
      return last;
    };
  }
});

// ../../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/scan.js
var require_scan = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/scan.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true) continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob) glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n2 = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n2, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module.exports = scan;
  }
});

// ../../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/parse.js
var require_parse = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/parse.js"(exports, module) {
    "use strict";
    var constants2 = require_constants();
    var utils = require_utils();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants2;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse2 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const PLATFORM_CHARS = constants2.globChars(opts.windows);
      const EXTGLOB_CHARS = constants2.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n2 = 1) => input[state.index + n2];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output) append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.output = (prev.output || prev.value) + tok.value;
          prev.value += tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse2(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars2, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars2.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars2.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".") prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse2.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants2.globChars(opts.windows);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true) return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match) return;
            const source2 = create(match[1]);
            if (!source2) return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module.exports = parse2;
  }
});

// ../../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/picomatch.js
var require_picomatch = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/picomatch.js"(exports, module) {
    "use strict";
    var scan = require_scan();
    var parse2 = require_parse();
    var utils = require_utils();
    var constants2 = require_constants();
    var isObject3 = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns2 = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns2) {
            const state2 = isMatch(str);
            if (state2) return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject3(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = opts.windows;
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob, options) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(utils.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern)) return pattern.map((p) => picomatch.parse(p, options));
      return parse2(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse2.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse2(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true) throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants2;
    module.exports = picomatch;
  }
});

// ../../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/index.js
var require_picomatch2 = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/index.js"(exports, module) {
    "use strict";
    var pico = require_picomatch();
    var utils = require_utils();
    function picomatch(glob, options, returnState = false) {
      if (options && (options.windows === null || options.windows === void 0)) {
        options = { ...options, windows: utils.isWindows() };
      }
      return pico(glob, options, returnState);
    }
    Object.assign(picomatch, pico);
    module.exports = picomatch;
  }
});

// ../../node_modules/.pnpm/universalify@2.0.1/node_modules/universalify/index.js
var require_universalify = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/universalify@2.0.1/node_modules/universalify/index.js"(exports) {
    "use strict";
    exports.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] === "function") fn.apply(this, args);
        else {
          return new Promise((resolve4, reject) => {
            args.push((err, res) => err != null ? reject(err) : resolve4(res));
            fn.apply(this, args);
          });
        }
      }, "name", { value: fn.name });
    };
    exports.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== "function") return fn.apply(this, args);
        else {
          args.pop();
          fn.apply(this, args).then((r) => cb(null, r), cb);
        }
      }, "name", { value: fn.name });
    };
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/polyfills.js
var require_polyfills = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/polyfills.js"(exports, module) {
    "use strict";
    var constants2 = _chunk42PBKAQTcjs.__require.call(void 0, "constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module.exports = patch;
    function patch(fs5) {
      if (constants2.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs5);
      }
      if (!fs5.lutimes) {
        patchLutimes(fs5);
      }
      fs5.chown = chownFix(fs5.chown);
      fs5.fchown = chownFix(fs5.fchown);
      fs5.lchown = chownFix(fs5.lchown);
      fs5.chmod = chmodFix(fs5.chmod);
      fs5.fchmod = chmodFix(fs5.fchmod);
      fs5.lchmod = chmodFix(fs5.lchmod);
      fs5.chownSync = chownFixSync(fs5.chownSync);
      fs5.fchownSync = chownFixSync(fs5.fchownSync);
      fs5.lchownSync = chownFixSync(fs5.lchownSync);
      fs5.chmodSync = chmodFixSync(fs5.chmodSync);
      fs5.fchmodSync = chmodFixSync(fs5.fchmodSync);
      fs5.lchmodSync = chmodFixSync(fs5.lchmodSync);
      fs5.stat = statFix(fs5.stat);
      fs5.fstat = statFix(fs5.fstat);
      fs5.lstat = statFix(fs5.lstat);
      fs5.statSync = statFixSync(fs5.statSync);
      fs5.fstatSync = statFixSync(fs5.fstatSync);
      fs5.lstatSync = statFixSync(fs5.lstatSync);
      if (fs5.chmod && !fs5.lchmod) {
        fs5.lchmod = function(path7, mode, cb) {
          if (cb) process.nextTick(cb);
        };
        fs5.lchmodSync = function() {
        };
      }
      if (fs5.chown && !fs5.lchown) {
        fs5.lchown = function(path7, uid, gid, cb) {
          if (cb) process.nextTick(cb);
        };
        fs5.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs5.rename = typeof fs5.rename !== "function" ? fs5.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs5.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb) cb(er);
            });
          }
          if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs5.rename);
      }
      fs5.read = typeof fs5.read !== "function" ? fs5.read : function(fs$read) {
        function read(fd, buffer, offset, length, position3, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs5, fd, buffer, offset, length, position3, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs5, fd, buffer, offset, length, position3, callback);
        }
        if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs5.read);
      fs5.readSync = typeof fs5.readSync !== "function" ? fs5.readSync : /* @__PURE__ */ function(fs$readSync) {
        return function(fd, buffer, offset, length, position3) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs5, fd, buffer, offset, length, position3);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs5.readSync);
      function patchLchmod(fs6) {
        fs6.lchmod = function(path7, mode, callback) {
          fs6.open(
            path7,
            constants2.O_WRONLY | constants2.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback) callback(err);
                return;
              }
              fs6.fchmod(fd, mode, function(err2) {
                fs6.close(fd, function(err22) {
                  if (callback) callback(err2 || err22);
                });
              });
            }
          );
        };
        fs6.lchmodSync = function(path7, mode) {
          var fd = fs6.openSync(path7, constants2.O_WRONLY | constants2.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs6.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs6.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs6.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs6) {
        if (constants2.hasOwnProperty("O_SYMLINK") && fs6.futimes) {
          fs6.lutimes = function(path7, at, mt, cb) {
            fs6.open(path7, constants2.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb) cb(er);
                return;
              }
              fs6.futimes(fd, at, mt, function(er2) {
                fs6.close(fd, function(er22) {
                  if (cb) cb(er2 || er22);
                });
              });
            });
          };
          fs6.lutimesSync = function(path7, at, mt) {
            var fd = fs6.openSync(path7, constants2.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs6.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs6.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs6.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs6.futimes) {
          fs6.lutimes = function(_a3, _b2, _c, cb) {
            if (cb) process.nextTick(cb);
          };
          fs6.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig) return orig;
        return function(target, mode, cb) {
          return orig.call(fs5, target, mode, function(er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig) return orig;
        return function(target, mode) {
          try {
            return orig.call(fs5, target, mode);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig) return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs5, target, uid, gid, function(er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig) return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs5, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig) return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0) stats.uid += 4294967296;
              if (stats.gid < 0) stats.gid += 4294967296;
            }
            if (cb) cb.apply(this, arguments);
          }
          return options ? orig.call(fs5, target, options, callback) : orig.call(fs5, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig) return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs5, target, options) : orig.call(fs5, target);
          if (stats) {
            if (stats.uid < 0) stats.uid += 4294967296;
            if (stats.gid < 0) stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/legacy-streams.js"(exports, module) {
    "use strict";
    var Stream = _chunk42PBKAQTcjs.__require.call(void 0, "stream").Stream;
    module.exports = legacy;
    function legacy(fs5) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path7, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path7, options);
        Stream.call(this);
        var self2 = this;
        this.path = path7;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding) this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs5.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path7, options) {
        if (!(this instanceof WriteStream)) return new WriteStream(path7, options);
        Stream.call(this);
        this.path = path7;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs5.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/clone.js
var require_clone = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/clone.js"(exports, module) {
    "use strict";
    module.exports = clone2;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone2(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js"(exports, module) {
    "use strict";
    var fs5 = _chunk42PBKAQTcjs.__require.call(void 0, "fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone2 = require_clone();
    var util = _chunk42PBKAQTcjs.__require.call(void 0, "util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop2() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop2;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs5[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs5, queue);
      fs5.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs5, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs5.close);
      fs5.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs5, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs5.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs5[gracefulQueue]);
          _chunk42PBKAQTcjs.__require.call(void 0, "assert").equal(fs5[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs5[gracefulQueue]);
    }
    module.exports = patch(clone2(fs5));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs5.__patched) {
      module.exports = patch(fs5);
      fs5.__patched = true;
    }
    function patch(fs6) {
      polyfills(fs6);
      fs6.gracefulify = patch;
      fs6.createReadStream = createReadStream;
      fs6.createWriteStream = createWriteStream;
      var fs$readFile = fs6.readFile;
      fs6.readFile = readFile;
      function readFile(path7, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path7, options, cb);
        function go$readFile(path8, options2, cb2, startTime) {
          return fs$readFile(path8, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path8, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs6.writeFile;
      fs6.writeFile = writeFile;
      function writeFile(path7, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path7, data, options, cb);
        function go$writeFile(path8, data2, options2, cb2, startTime) {
          return fs$writeFile(path8, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path8, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs6.appendFile;
      if (fs$appendFile)
        fs6.appendFile = appendFile;
      function appendFile(path7, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path7, data, options, cb);
        function go$appendFile(path8, data2, options2, cb2, startTime) {
          return fs$appendFile(path8, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path8, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs6.copyFile;
      if (fs$copyFile)
        fs6.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs6.readdir;
      fs6.readdir = readdir2;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir2(path7, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path8, options2, cb2, startTime) {
          return fs$readdir(path8, fs$readdirCallback(
            path8,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path8, options2, cb2, startTime) {
          return fs$readdir(path8, options2, fs$readdirCallback(
            path8,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path7, options, cb);
        function fs$readdirCallback(path8, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path8, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs6);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs6.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs6.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs6, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs6, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs6, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs6, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path7, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path7, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path7, options) {
        return new fs6.ReadStream(path7, options);
      }
      function createWriteStream(path7, options) {
        return new fs6.WriteStream(path7, options);
      }
      var fs$open = fs6.open;
      fs6.open = open;
      function open(path7, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path7, flags, mode, cb);
        function go$open(path8, flags2, mode2, cb2, startTime) {
          return fs$open(path8, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path8, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs6;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs5[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs5[gracefulQueue].length; ++i) {
        if (fs5[gracefulQueue][i].length > 2) {
          fs5[gracefulQueue][i][3] = now;
          fs5[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs5[gracefulQueue].length === 0)
        return;
      var elem = fs5[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs5[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/fs/index.js
var require_fs = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/fs/index.js"(exports) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs5 = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "cp",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "glob",
      "lchmod",
      "lchown",
      "lutimes",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "statfs",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs5[key] === "function";
    });
    Object.assign(exports, fs5);
    api.forEach((method) => {
      exports[method] = u(fs5[method]);
    });
    exports.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs5.exists(filename, callback);
      }
      return new Promise((resolve4) => {
        return fs5.exists(filename, resolve4);
      });
    };
    exports.read = function(fd, buffer, offset, length, position3, callback) {
      if (typeof callback === "function") {
        return fs5.read(fd, buffer, offset, length, position3, callback);
      }
      return new Promise((resolve4, reject) => {
        fs5.read(fd, buffer, offset, length, position3, (err, bytesRead, buffer2) => {
          if (err) return reject(err);
          resolve4({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs5.write(fd, buffer, ...args);
      }
      return new Promise((resolve4, reject) => {
        fs5.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err) return reject(err);
          resolve4({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    exports.readv = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs5.readv(fd, buffers, ...args);
      }
      return new Promise((resolve4, reject) => {
        fs5.readv(fd, buffers, ...args, (err, bytesRead, buffers2) => {
          if (err) return reject(err);
          resolve4({ bytesRead, buffers: buffers2 });
        });
      });
    };
    exports.writev = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs5.writev(fd, buffers, ...args);
      }
      return new Promise((resolve4, reject) => {
        fs5.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err) return reject(err);
          resolve4({ bytesWritten, buffers: buffers2 });
        });
      });
    };
    if (typeof fs5.realpath.native === "function") {
      exports.realpath.native = u(fs5.realpath.native);
    } else {
      process.emitWarning(
        "fs.realpath.native is not a function. Is fs being monkey-patched?",
        "Warning",
        "fs-extra-WARN0003"
      );
    }
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils2 = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/mkdirs/utils.js"(exports, module) {
    "use strict";
    var path7 = _chunk42PBKAQTcjs.__require.call(void 0, "path");
    module.exports.checkPath = function checkPath(pth) {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path7.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports, module) {
    "use strict";
    var fs5 = require_fs();
    var { checkPath } = require_utils2();
    var getMode = (options) => {
      const defaults = { mode: 511 };
      if (typeof options === "number") return options;
      return { ...defaults, ...options }.mode;
    };
    module.exports.makeDir = async (dir, options) => {
      checkPath(dir);
      return fs5.mkdir(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
    module.exports.makeDirSync = (dir, options) => {
      checkPath(dir);
      return fs5.mkdirSync(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/mkdirs/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var { makeDir: _makeDir, makeDirSync } = require_make_dir();
    var makeDir = u(_makeDir);
    module.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      // alias
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/path-exists/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs5 = require_fs();
    function pathExists2(path7) {
      return fs5.access(path7).then(() => true).catch(() => false);
    }
    module.exports = {
      pathExists: u(pathExists2),
      pathExistsSync: fs5.existsSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/util/utimes.js
var require_utimes = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/util/utimes.js"(exports, module) {
    "use strict";
    var fs5 = require_fs();
    var u = require_universalify().fromPromise;
    async function utimesMillis(path7, atime, mtime) {
      const fd = await fs5.open(path7, "r+");
      let closeErr = null;
      try {
        await fs5.futimes(fd, atime, mtime);
      } finally {
        try {
          await fs5.close(fd);
        } catch (e2) {
          closeErr = e2;
        }
      }
      if (closeErr) {
        throw closeErr;
      }
    }
    function utimesMillisSync(path7, atime, mtime) {
      const fd = fs5.openSync(path7, "r+");
      fs5.futimesSync(fd, atime, mtime);
      return fs5.closeSync(fd);
    }
    module.exports = {
      utimesMillis: u(utimesMillis),
      utimesMillisSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/util/stat.js
var require_stat = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/util/stat.js"(exports, module) {
    "use strict";
    var fs5 = require_fs();
    var path7 = _chunk42PBKAQTcjs.__require.call(void 0, "path");
    var u = require_universalify().fromPromise;
    function getStats(src, dest, opts) {
      const statFunc = opts.dereference ? (file) => fs5.stat(file, { bigint: true }) : (file) => fs5.lstat(file, { bigint: true });
      return Promise.all([
        statFunc(src),
        statFunc(dest).catch((err) => {
          if (err.code === "ENOENT") return null;
          throw err;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest, opts) {
      let destStat;
      const statFunc = opts.dereference ? (file) => fs5.statSync(file, { bigint: true }) : (file) => fs5.lstatSync(file, { bigint: true });
      const srcStat = statFunc(src);
      try {
        destStat = statFunc(dest);
      } catch (err) {
        if (err.code === "ENOENT") return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    async function checkPaths(src, dest, funcName, opts) {
      const { srcStat, destStat } = await getStats(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path7.basename(src);
          const destBaseName = path7.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    function checkPathsSync(src, dest, funcName, opts) {
      const { srcStat, destStat } = getStatsSync(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path7.basename(src);
          const destBaseName = path7.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    async function checkParentPaths(src, srcStat, dest, funcName) {
      const srcParent = path7.resolve(path7.dirname(src));
      const destParent = path7.resolve(path7.dirname(dest));
      if (destParent === srcParent || destParent === path7.parse(destParent).root) return;
      let destStat;
      try {
        destStat = await fs5.stat(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT") return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPaths(src, srcStat, destParent, funcName);
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path7.resolve(path7.dirname(src));
      const destParent = path7.resolve(path7.dirname(dest));
      if (destParent === srcParent || destParent === path7.parse(destParent).root) return;
      let destStat;
      try {
        destStat = fs5.statSync(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT") return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
    }
    function isSrcSubdir(src, dest) {
      const srcArr = path7.resolve(src).split(path7.sep).filter((i) => i);
      const destArr = path7.resolve(dest).split(path7.sep).filter((i) => i);
      return srcArr.every((cur, i) => destArr[i] === cur);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module.exports = {
      // checkPaths
      checkPaths: u(checkPaths),
      checkPathsSync,
      // checkParent
      checkParentPaths: u(checkParentPaths),
      checkParentPathsSync,
      // Misc
      isSrcSubdir,
      areIdentical
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/copy/copy.js
var require_copy = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/copy/copy.js"(exports, module) {
    "use strict";
    var fs5 = require_fs();
    var path7 = _chunk42PBKAQTcjs.__require.call(void 0, "path");
    var { mkdirs } = require_mkdirs();
    var { pathExists: pathExists2 } = require_path_exists();
    var { utimesMillis } = require_utimes();
    var stat = require_stat();
    async function copy(src, dest, opts = {}) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0001"
        );
      }
      const { srcStat, destStat } = await stat.checkPaths(src, dest, "copy", opts);
      await stat.checkParentPaths(src, srcStat, dest, "copy");
      const include = await runFilter(src, dest, opts);
      if (!include) return;
      const destParent = path7.dirname(dest);
      const dirExists = await pathExists2(destParent);
      if (!dirExists) {
        await mkdirs(destParent);
      }
      await getStatsAndPerformCopy(destStat, src, dest, opts);
    }
    async function runFilter(src, dest, opts) {
      if (!opts.filter) return true;
      return opts.filter(src, dest);
    }
    async function getStatsAndPerformCopy(destStat, src, dest, opts) {
      const statFn = opts.dereference ? fs5.stat : fs5.lstat;
      const srcStat = await statFn(src);
      if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);
      if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);
      if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);
      if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`);
      if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    async function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat) return copyFile(srcStat, src, dest, opts);
      if (opts.overwrite) {
        await fs5.unlink(dest);
        return copyFile(srcStat, src, dest, opts);
      }
      if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    async function copyFile(srcStat, src, dest, opts) {
      await fs5.copyFile(src, dest);
      if (opts.preserveTimestamps) {
        if (fileIsNotWritable(srcStat.mode)) {
          await makeFileWritable(dest, srcStat.mode);
        }
        const updatedSrcStat = await fs5.stat(src);
        await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
      }
      return fs5.chmod(dest, srcStat.mode);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return fs5.chmod(dest, srcMode | 128);
    }
    async function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat) {
        await fs5.mkdir(dest);
      }
      const promises2 = [];
      for await (const item of await fs5.opendir(src)) {
        const srcItem = path7.join(src, item.name);
        const destItem = path7.join(dest, item.name);
        promises2.push(
          runFilter(srcItem, destItem, opts).then((include) => {
            if (include) {
              return stat.checkPaths(srcItem, destItem, "copy", opts).then(({ destStat: destStat2 }) => {
                return getStatsAndPerformCopy(destStat2, srcItem, destItem, opts);
              });
            }
          })
        );
      }
      await Promise.all(promises2);
      if (!destStat) {
        await fs5.chmod(dest, srcStat.mode);
      }
    }
    async function onLink(destStat, src, dest, opts) {
      let resolvedSrc = await fs5.readlink(src);
      if (opts.dereference) {
        resolvedSrc = path7.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs5.symlink(resolvedSrc, dest);
      }
      let resolvedDest = null;
      try {
        resolvedDest = await fs5.readlink(dest);
      } catch (e2) {
        if (e2.code === "EINVAL" || e2.code === "UNKNOWN") return fs5.symlink(resolvedSrc, dest);
        throw e2;
      }
      if (opts.dereference) {
        resolvedDest = path7.resolve(process.cwd(), resolvedDest);
      }
      if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
      }
      if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
      }
      await fs5.unlink(dest);
      return fs5.symlink(resolvedSrc, dest);
    }
    module.exports = copy;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/copy/copy-sync.js"(exports, module) {
    "use strict";
    var fs5 = require_graceful_fs();
    var path7 = _chunk42PBKAQTcjs.__require.call(void 0, "path");
    var mkdirsSync = require_mkdirs().mkdirsSync;
    var utimesMillisSync = require_utimes().utimesMillisSync;
    var stat = require_stat();
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0002"
        );
      }
      const { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy", opts);
      stat.checkParentPathsSync(src, srcStat, dest, "copy");
      if (opts.filter && !opts.filter(src, dest)) return;
      const destParent = path7.dirname(dest);
      if (!fs5.existsSync(destParent)) mkdirsSync(destParent);
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync = opts.dereference ? fs5.statSync : fs5.lstatSync;
      const srcStat = statSync(src);
      if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);
      else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`);
      else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat) return copyFile(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs5.unlinkSync(dest);
        return copyFile(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile(srcStat, src, dest, opts) {
      fs5.copyFileSync(src, dest);
      if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);
      return setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);
      return setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs5.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      const updatedSrcStat = fs5.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts);
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
      fs5.mkdirSync(dest);
      copyDir(src, dest, opts);
      return setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
      const dir = fs5.opendirSync(src);
      try {
        let dirent;
        while ((dirent = dir.readSync()) !== null) {
          copyDirItem(dirent.name, src, dest, opts);
        }
      } finally {
        dir.closeSync();
      }
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path7.join(src, item);
      const destItem = path7.join(dest, item);
      if (opts.filter && !opts.filter(srcItem, destItem)) return;
      const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy", opts);
      return getStats(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs5.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path7.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs5.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs5.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN") return fs5.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path7.resolve(process.cwd(), resolvedDest);
        }
        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs5.unlinkSync(dest);
      return fs5.symlinkSync(resolvedSrc, dest);
    }
    module.exports = copySync;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/copy/index.js
var require_copy2 = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/copy/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    module.exports = {
      copy: u(require_copy()),
      copySync: require_copy_sync()
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/remove/index.js
var require_remove = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/remove/index.js"(exports, module) {
    "use strict";
    var fs5 = require_graceful_fs();
    var u = require_universalify().fromCallback;
    function remove(path7, callback) {
      fs5.rm(path7, { recursive: true, force: true }, callback);
    }
    function removeSync(path7) {
      fs5.rmSync(path7, { recursive: true, force: true });
    }
    module.exports = {
      remove: u(remove),
      removeSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/empty/index.js
var require_empty = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/empty/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs5 = require_fs();
    var path7 = _chunk42PBKAQTcjs.__require.call(void 0, "path");
    var mkdir = require_mkdirs();
    var remove = require_remove();
    var emptyDir = u(async function emptyDir2(dir) {
      let items;
      try {
        items = await fs5.readdir(dir);
      } catch (e2) {
        return mkdir.mkdirs(dir);
      }
      return Promise.all(items.map((item) => remove.remove(path7.join(dir, item))));
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs5.readdirSync(dir);
      } catch (e2) {
        return mkdir.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path7.join(dir, item);
        remove.removeSync(item);
      });
    }
    module.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/file.js
var require_file = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/file.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var path7 = _chunk42PBKAQTcjs.__require.call(void 0, "path");
    var fs5 = require_fs();
    var mkdir = require_mkdirs();
    async function createFile(file) {
      let stats;
      try {
        stats = await fs5.stat(file);
      } catch (e2) {
      }
      if (stats && stats.isFile()) return;
      const dir = path7.dirname(file);
      let dirStats = null;
      try {
        dirStats = await fs5.stat(dir);
      } catch (err) {
        if (err.code === "ENOENT") {
          await mkdir.mkdirs(dir);
          await fs5.writeFile(file, "");
          return;
        } else {
          throw err;
        }
      }
      if (dirStats.isDirectory()) {
        await fs5.writeFile(file, "");
      } else {
        await fs5.readdir(dir);
      }
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs5.statSync(file);
      } catch (e2) {
      }
      if (stats && stats.isFile()) return;
      const dir = path7.dirname(file);
      try {
        if (!fs5.statSync(dir).isDirectory()) {
          fs5.readdirSync(dir);
        }
      } catch (err) {
        if (err && err.code === "ENOENT") mkdir.mkdirsSync(dir);
        else throw err;
      }
      fs5.writeFileSync(file, "");
    }
    module.exports = {
      createFile: u(createFile),
      createFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/link.js
var require_link = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/link.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var path7 = _chunk42PBKAQTcjs.__require.call(void 0, "path");
    var fs5 = require_fs();
    var mkdir = require_mkdirs();
    var { pathExists: pathExists2 } = require_path_exists();
    var { areIdentical } = require_stat();
    async function createLink(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = await fs5.lstat(dstpath);
      } catch (e2) {
      }
      let srcStat;
      try {
        srcStat = await fs5.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      if (dstStat && areIdentical(srcStat, dstStat)) return;
      const dir = path7.dirname(dstpath);
      const dirExists = await pathExists2(dir);
      if (!dirExists) {
        await mkdir.mkdirs(dir);
      }
      await fs5.link(srcpath, dstpath);
    }
    function createLinkSync(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = fs5.lstatSync(dstpath);
      } catch (e2) {
      }
      try {
        const srcStat = fs5.lstatSync(srcpath);
        if (dstStat && areIdentical(srcStat, dstStat)) return;
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path7.dirname(dstpath);
      const dirExists = fs5.existsSync(dir);
      if (dirExists) return fs5.linkSync(srcpath, dstpath);
      mkdir.mkdirsSync(dir);
      return fs5.linkSync(srcpath, dstpath);
    }
    module.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports, module) {
    "use strict";
    var path7 = _chunk42PBKAQTcjs.__require.call(void 0, "path");
    var fs5 = require_fs();
    var { pathExists: pathExists2 } = require_path_exists();
    var u = require_universalify().fromPromise;
    async function symlinkPaths(srcpath, dstpath) {
      if (path7.isAbsolute(srcpath)) {
        try {
          await fs5.lstat(srcpath);
        } catch (err) {
          err.message = err.message.replace("lstat", "ensureSymlink");
          throw err;
        }
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      }
      const dstdir = path7.dirname(dstpath);
      const relativeToDst = path7.join(dstdir, srcpath);
      const exists2 = await pathExists2(relativeToDst);
      if (exists2) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      }
      try {
        await fs5.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureSymlink");
        throw err;
      }
      return {
        toCwd: srcpath,
        toDst: path7.relative(dstdir, srcpath)
      };
    }
    function symlinkPathsSync(srcpath, dstpath) {
      if (path7.isAbsolute(srcpath)) {
        const exists3 = fs5.existsSync(srcpath);
        if (!exists3) throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      }
      const dstdir = path7.dirname(dstpath);
      const relativeToDst = path7.join(dstdir, srcpath);
      const exists2 = fs5.existsSync(relativeToDst);
      if (exists2) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      }
      const srcExists = fs5.existsSync(srcpath);
      if (!srcExists) throw new Error("relative srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: path7.relative(dstdir, srcpath)
      };
    }
    module.exports = {
      symlinkPaths: u(symlinkPaths),
      symlinkPathsSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/symlink-type.js"(exports, module) {
    "use strict";
    var fs5 = require_fs();
    var u = require_universalify().fromPromise;
    async function symlinkType(srcpath, type) {
      if (type) return type;
      let stats;
      try {
        stats = await fs5.lstat(srcpath);
      } catch (e2) {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    function symlinkTypeSync(srcpath, type) {
      if (type) return type;
      let stats;
      try {
        stats = fs5.lstatSync(srcpath);
      } catch (e2) {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module.exports = {
      symlinkType: u(symlinkType),
      symlinkTypeSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/symlink.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var path7 = _chunk42PBKAQTcjs.__require.call(void 0, "path");
    var fs5 = require_fs();
    var { mkdirs, mkdirsSync } = require_mkdirs();
    var { symlinkPaths, symlinkPathsSync } = require_symlink_paths();
    var { symlinkType, symlinkTypeSync } = require_symlink_type();
    var { pathExists: pathExists2 } = require_path_exists();
    var { areIdentical } = require_stat();
    async function createSymlink(srcpath, dstpath, type) {
      let stats;
      try {
        stats = await fs5.lstat(dstpath);
      } catch (e2) {
      }
      if (stats && stats.isSymbolicLink()) {
        const [srcStat, dstStat] = await Promise.all([
          fs5.stat(srcpath),
          fs5.stat(dstpath)
        ]);
        if (areIdentical(srcStat, dstStat)) return;
      }
      const relative = await symlinkPaths(srcpath, dstpath);
      srcpath = relative.toDst;
      const toType = await symlinkType(relative.toCwd, type);
      const dir = path7.dirname(dstpath);
      if (!await pathExists2(dir)) {
        await mkdirs(dir);
      }
      return fs5.symlink(srcpath, dstpath, toType);
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      let stats;
      try {
        stats = fs5.lstatSync(dstpath);
      } catch (e2) {
      }
      if (stats && stats.isSymbolicLink()) {
        const srcStat = fs5.statSync(srcpath);
        const dstStat = fs5.statSync(dstpath);
        if (areIdentical(srcStat, dstStat)) return;
      }
      const relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst;
      type = symlinkTypeSync(relative.toCwd, type);
      const dir = path7.dirname(dstpath);
      const exists2 = fs5.existsSync(dir);
      if (exists2) return fs5.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs5.symlinkSync(srcpath, dstpath, type);
    }
    module.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/index.js
var require_ensure = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/index.js"(exports, module) {
    "use strict";
    var { createFile, createFileSync } = require_file();
    var { createLink, createLinkSync } = require_link();
    var { createSymlink, createSymlinkSync } = require_symlink();
    module.exports = {
      // file
      createFile,
      createFileSync,
      ensureFile: createFile,
      ensureFileSync: createFileSync,
      // link
      createLink,
      createLinkSync,
      ensureLink: createLink,
      ensureLinkSync: createLinkSync,
      // symlink
      createSymlink,
      createSymlinkSync,
      ensureSymlink: createSymlink,
      ensureSymlinkSync: createSymlinkSync
    };
  }
});

// ../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/utils.js
var require_utils3 = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/utils.js"(exports, module) {
    "use strict";
    function stringify(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces: spaces2 } = {}) {
      const EOF = finalEOL ? EOL : "";
      const str = JSON.stringify(obj, replacer, spaces2);
      return str.replace(/\n/g, EOL) + EOF;
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content)) content = content.toString("utf8");
      return content.replace(/^\uFEFF/, "");
    }
    module.exports = { stringify, stripBom };
  }
});

// ../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/index.js
var require_jsonfile = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/index.js"(exports, module) {
    "use strict";
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_) {
      _fs = _chunk42PBKAQTcjs.__require.call(void 0, "fs");
    }
    var universalify = require_universalify();
    var { stringify, stripBom } = require_utils3();
    async function _readFile(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs5 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      let data = await universalify.fromCallback(fs5.readFile)(file, options);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
      return obj;
    }
    var readFile = universalify.fromPromise(_readFile);
    function readFileSync(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs5 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      try {
        let content = fs5.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
    }
    async function _writeFile(file, obj, options = {}) {
      const fs5 = options.fs || _fs;
      const str = stringify(obj, options);
      await universalify.fromCallback(fs5.writeFile)(file, str, options);
    }
    var writeFile = universalify.fromPromise(_writeFile);
    function writeFileSync(file, obj, options = {}) {
      const fs5 = options.fs || _fs;
      const str = stringify(obj, options);
      return fs5.writeFileSync(file, str, options);
    }
    var jsonfile = {
      readFile,
      readFileSync,
      writeFile,
      writeFileSync
    };
    module.exports = jsonfile;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/json/jsonfile.js"(exports, module) {
    "use strict";
    var jsonFile = require_jsonfile();
    module.exports = {
      // jsonfile exports
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/output-file/index.js
var require_output_file = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/output-file/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs5 = require_fs();
    var path7 = _chunk42PBKAQTcjs.__require.call(void 0, "path");
    var mkdir = require_mkdirs();
    var pathExists2 = require_path_exists().pathExists;
    async function outputFile(file, data, encoding = "utf-8") {
      const dir = path7.dirname(file);
      if (!await pathExists2(dir)) {
        await mkdir.mkdirs(dir);
      }
      return fs5.writeFile(file, data, encoding);
    }
    function outputFileSync(file, ...args) {
      const dir = path7.dirname(file);
      if (!fs5.existsSync(dir)) {
        mkdir.mkdirsSync(dir);
      }
      fs5.writeFileSync(file, ...args);
    }
    module.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/json/output-json.js
var require_output_json = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/json/output-json.js"(exports, module) {
    "use strict";
    var { stringify } = require_utils3();
    var { outputFile } = require_output_file();
    async function outputJson(file, data, options = {}) {
      const str = stringify(data, options);
      await outputFile(file, str, options);
    }
    module.exports = outputJson;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/json/output-json-sync.js"(exports, module) {
    "use strict";
    var { stringify } = require_utils3();
    var { outputFileSync } = require_output_file();
    function outputJsonSync(file, data, options) {
      const str = stringify(data, options);
      outputFileSync(file, str, options);
    }
    module.exports = outputJsonSync;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/json/index.js
var require_json = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/json/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var jsonFile = require_jsonfile2();
    jsonFile.outputJson = u(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module.exports = jsonFile;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/move/move.js
var require_move = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/move/move.js"(exports, module) {
    "use strict";
    var fs5 = require_fs();
    var path7 = _chunk42PBKAQTcjs.__require.call(void 0, "path");
    var { copy } = require_copy2();
    var { remove } = require_remove();
    var { mkdirp } = require_mkdirs();
    var { pathExists: pathExists2 } = require_path_exists();
    var stat = require_stat();
    async function move(src, dest, opts = {}) {
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = await stat.checkPaths(src, dest, "move", opts);
      await stat.checkParentPaths(src, srcStat, dest, "move");
      const destParent = path7.dirname(dest);
      const parsedParentPath = path7.parse(destParent);
      if (parsedParentPath.root !== destParent) {
        await mkdirp(destParent);
      }
      return doRename(src, dest, overwrite, isChangingCase);
    }
    async function doRename(src, dest, overwrite, isChangingCase) {
      if (!isChangingCase) {
        if (overwrite) {
          await remove(dest);
        } else if (await pathExists2(dest)) {
          throw new Error("dest already exists.");
        }
      }
      try {
        await fs5.rename(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV") {
          throw err;
        }
        await moveAcrossDevice(src, dest, overwrite);
      }
    }
    async function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      await copy(src, dest, opts);
      return remove(src);
    }
    module.exports = move;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/move/move-sync.js"(exports, module) {
    "use strict";
    var fs5 = require_graceful_fs();
    var path7 = _chunk42PBKAQTcjs.__require.call(void 0, "path");
    var copySync = require_copy2().copySync;
    var removeSync = require_remove().removeSync;
    var mkdirpSync = require_mkdirs().mkdirpSync;
    var stat = require_stat();
    function moveSync(src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, "move", opts);
      stat.checkParentPathsSync(src, srcStat, dest, "move");
      if (!isParentRoot(dest)) mkdirpSync(path7.dirname(dest));
      return doRename(src, dest, overwrite, isChangingCase);
    }
    function isParentRoot(dest) {
      const parent = path7.dirname(dest);
      const parsedPath = path7.parse(parent);
      return parsedPath.root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase) {
      if (isChangingCase) return rename(src, dest, overwrite);
      if (overwrite) {
        removeSync(dest);
        return rename(src, dest, overwrite);
      }
      if (fs5.existsSync(dest)) throw new Error("dest already exists.");
      return rename(src, dest, overwrite);
    }
    function rename(src, dest, overwrite) {
      try {
        fs5.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV") throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      copySync(src, dest, opts);
      return removeSync(src);
    }
    module.exports = moveSync;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/move/index.js
var require_move2 = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/move/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    module.exports = {
      move: u(require_move()),
      moveSync: require_move_sync()
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/index.js
var require_lib = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/index.js"(exports, module) {
    "use strict";
    module.exports = {
      // Export promiseified graceful-fs:
      ...require_fs(),
      // Export extra methods:
      ...require_copy2(),
      ...require_empty(),
      ...require_ensure(),
      ...require_json(),
      ...require_mkdirs(),
      ...require_move2(),
      ...require_output_file(),
      ...require_path_exists(),
      ...require_remove()
    };
  }
});

// ../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/icon/defaults.cjs
var require_defaults = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/icon/defaults.cjs"(exports) {
    "use strict";
    var defaultIconDimensions = Object.freeze(
      {
        left: 0,
        top: 0,
        width: 16,
        height: 16
      }
    );
    var defaultIconTransformations = Object.freeze({
      rotate: 0,
      vFlip: false,
      hFlip: false
    });
    var defaultIconProps = Object.freeze({
      ...defaultIconDimensions,
      ...defaultIconTransformations
    });
    var defaultExtendedIconProps = Object.freeze({
      ...defaultIconProps,
      body: "",
      hidden: false
    });
    exports.defaultExtendedIconProps = defaultExtendedIconProps;
    exports.defaultIconDimensions = defaultIconDimensions;
    exports.defaultIconProps = defaultIconProps;
    exports.defaultIconTransformations = defaultIconTransformations;
  }
});

// ../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/customisations/defaults.cjs
var require_defaults2 = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/customisations/defaults.cjs"(exports) {
    "use strict";
    var icon_defaults = require_defaults();
    var defaultIconSizeCustomisations = Object.freeze({
      width: null,
      height: null
    });
    var defaultIconCustomisations = Object.freeze({
      // Dimensions
      ...defaultIconSizeCustomisations,
      // Transformations
      ...icon_defaults.defaultIconTransformations
    });
    exports.defaultIconCustomisations = defaultIconCustomisations;
    exports.defaultIconSizeCustomisations = defaultIconSizeCustomisations;
  }
});

// ../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/svg/size.cjs
var require_size = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/svg/size.cjs"(exports) {
    "use strict";
    var unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
    var unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
    function calculateSize(size, ratio, precision) {
      if (ratio === 1) {
        return size;
      }
      precision = precision || 100;
      if (typeof size === "number") {
        return Math.ceil(size * ratio * precision) / precision;
      }
      if (typeof size !== "string") {
        return size;
      }
      const oldParts = size.split(unitsSplit);
      if (oldParts === null || !oldParts.length) {
        return size;
      }
      const newParts = [];
      let code = oldParts.shift();
      let isNumber = unitsTest.test(code);
      while (true) {
        if (isNumber) {
          const num = parseFloat(code);
          if (isNaN(num)) {
            newParts.push(code);
          } else {
            newParts.push(Math.ceil(num * ratio * precision) / precision);
          }
        } else {
          newParts.push(code);
        }
        code = oldParts.shift();
        if (code === void 0) {
          return newParts.join("");
        }
        isNumber = !isNumber;
      }
    }
    exports.calculateSize = calculateSize;
  }
});

// ../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/svg/defs.cjs
var require_defs = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/svg/defs.cjs"(exports) {
    "use strict";
    function splitSVGDefs(content, tag = "defs") {
      let defs = "";
      const index = content.indexOf("<" + tag);
      while (index >= 0) {
        const start = content.indexOf(">", index);
        const end = content.indexOf("</" + tag);
        if (start === -1 || end === -1) {
          break;
        }
        const endEnd = content.indexOf(">", end);
        if (endEnd === -1) {
          break;
        }
        defs += content.slice(start + 1, end).trim();
        content = content.slice(0, index).trim() + content.slice(endEnd + 1);
      }
      return {
        defs,
        content
      };
    }
    function mergeDefsAndContent(defs, content) {
      return defs ? "<defs>" + defs + "</defs>" + content : content;
    }
    function wrapSVGContent(body, start, end) {
      const split = splitSVGDefs(body);
      return mergeDefsAndContent(split.defs, start + split.content + end);
    }
    exports.mergeDefsAndContent = mergeDefsAndContent;
    exports.splitSVGDefs = splitSVGDefs;
    exports.wrapSVGContent = wrapSVGContent;
  }
});

// ../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/svg/build.cjs
var require_build = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/svg/build.cjs"(exports) {
    "use strict";
    var icon_defaults = require_defaults();
    var customisations_defaults = require_defaults2();
    var svg_size = require_size();
    var svg_defs = require_defs();
    var isUnsetKeyword = (value) => value === "unset" || value === "undefined" || value === "none";
    function iconToSVG(icon, customisations) {
      const fullIcon = {
        ...icon_defaults.defaultIconProps,
        ...icon
      };
      const fullCustomisations = {
        ...customisations_defaults.defaultIconCustomisations,
        ...customisations
      };
      const box = {
        left: fullIcon.left,
        top: fullIcon.top,
        width: fullIcon.width,
        height: fullIcon.height
      };
      let body = fullIcon.body;
      [fullIcon, fullCustomisations].forEach((props) => {
        const transformations = [];
        const hFlip = props.hFlip;
        const vFlip = props.vFlip;
        let rotation = props.rotate;
        if (hFlip) {
          if (vFlip) {
            rotation += 2;
          } else {
            transformations.push(
              "translate(" + (box.width + box.left).toString() + " " + (0 - box.top).toString() + ")"
            );
            transformations.push("scale(-1 1)");
            box.top = box.left = 0;
          }
        } else if (vFlip) {
          transformations.push(
            "translate(" + (0 - box.left).toString() + " " + (box.height + box.top).toString() + ")"
          );
          transformations.push("scale(1 -1)");
          box.top = box.left = 0;
        }
        let tempValue;
        if (rotation < 0) {
          rotation -= Math.floor(rotation / 4) * 4;
        }
        rotation = rotation % 4;
        switch (rotation) {
          case 1:
            tempValue = box.height / 2 + box.top;
            transformations.unshift(
              "rotate(90 " + tempValue.toString() + " " + tempValue.toString() + ")"
            );
            break;
          case 2:
            transformations.unshift(
              "rotate(180 " + (box.width / 2 + box.left).toString() + " " + (box.height / 2 + box.top).toString() + ")"
            );
            break;
          case 3:
            tempValue = box.width / 2 + box.left;
            transformations.unshift(
              "rotate(-90 " + tempValue.toString() + " " + tempValue.toString() + ")"
            );
            break;
        }
        if (rotation % 2 === 1) {
          if (box.left !== box.top) {
            tempValue = box.left;
            box.left = box.top;
            box.top = tempValue;
          }
          if (box.width !== box.height) {
            tempValue = box.width;
            box.width = box.height;
            box.height = tempValue;
          }
        }
        if (transformations.length) {
          body = svg_defs.wrapSVGContent(
            body,
            '<g transform="' + transformations.join(" ") + '">',
            "</g>"
          );
        }
      });
      const customisationsWidth = fullCustomisations.width;
      const customisationsHeight = fullCustomisations.height;
      const boxWidth = box.width;
      const boxHeight = box.height;
      let width3;
      let height3;
      if (customisationsWidth === null) {
        height3 = customisationsHeight === null ? "1em" : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
        width3 = svg_size.calculateSize(height3, boxWidth / boxHeight);
      } else {
        width3 = customisationsWidth === "auto" ? boxWidth : customisationsWidth;
        height3 = customisationsHeight === null ? svg_size.calculateSize(width3, boxHeight / boxWidth) : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
      }
      const attributes = {};
      const setAttr = (prop, value) => {
        if (!isUnsetKeyword(value)) {
          attributes[prop] = value.toString();
        }
      };
      setAttr("width", width3);
      setAttr("height", height3);
      const viewBox = [box.left, box.top, boxWidth, boxHeight];
      attributes.viewBox = viewBox.join(" ");
      return {
        attributes,
        viewBox,
        body
      };
    }
    exports.iconToSVG = iconToSVG;
    exports.isUnsetKeyword = isUnsetKeyword;
  }
});

// ../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/icon/transformations.cjs
var require_transformations = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/icon/transformations.cjs"(exports) {
    "use strict";
    function mergeIconTransformations(obj1, obj2) {
      const result = {};
      if (!obj1.hFlip !== !obj2.hFlip) {
        result.hFlip = true;
      }
      if (!obj1.vFlip !== !obj2.vFlip) {
        result.vFlip = true;
      }
      const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;
      if (rotate) {
        result.rotate = rotate;
      }
      return result;
    }
    exports.mergeIconTransformations = mergeIconTransformations;
  }
});

// ../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/icon/merge.cjs
var require_merge = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/icon/merge.cjs"(exports) {
    "use strict";
    var icon_defaults = require_defaults();
    var icon_transformations = require_transformations();
    function mergeIconData(parent, child) {
      const result = icon_transformations.mergeIconTransformations(parent, child);
      for (const key in icon_defaults.defaultExtendedIconProps) {
        if (key in icon_defaults.defaultIconTransformations) {
          if (key in parent && !(key in result)) {
            result[key] = icon_defaults.defaultIconTransformations[key];
          }
        } else if (key in child) {
          result[key] = child[key];
        } else if (key in parent) {
          result[key] = parent[key];
        }
      }
      return result;
    }
    exports.mergeIconData = mergeIconData;
  }
});

// ../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/icon-set/tree.cjs
var require_tree = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/icon-set/tree.cjs"(exports) {
    "use strict";
    function getIconsTree(data, names) {
      const icons = data.icons;
      const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
      const resolved = /* @__PURE__ */ Object.create(null);
      function resolve4(name2) {
        if (icons[name2]) {
          return resolved[name2] = [];
        }
        if (!(name2 in resolved)) {
          resolved[name2] = null;
          const parent = aliases[name2] && aliases[name2].parent;
          const value = parent && resolve4(parent);
          if (value) {
            resolved[name2] = [parent].concat(value);
          }
        }
        return resolved[name2];
      }
      (names || Object.keys(icons).concat(Object.keys(aliases))).forEach(resolve4);
      return resolved;
    }
    exports.getIconsTree = getIconsTree;
  }
});

// ../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/icon-set/get-icon.cjs
var require_get_icon = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/icon-set/get-icon.cjs"(exports) {
    "use strict";
    var icon_merge = require_merge();
    var iconSet_tree = require_tree();
    require_defaults();
    require_transformations();
    function internalGetIconData(data, name2, tree) {
      const icons = data.icons;
      const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
      let currentProps = {};
      function parse2(name22) {
        currentProps = icon_merge.mergeIconData(
          icons[name22] || aliases[name22],
          currentProps
        );
      }
      parse2(name2);
      tree.forEach(parse2);
      return icon_merge.mergeIconData(data, currentProps);
    }
    function getIconData(data, name2) {
      if (data.icons[name2]) {
        return internalGetIconData(data, name2, []);
      }
      const tree = iconSet_tree.getIconsTree(data, [name2])[name2];
      return tree ? internalGetIconData(data, name2, tree) : null;
    }
    exports.getIconData = getIconData;
    exports.internalGetIconData = internalGetIconData;
  }
});

// ../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/loader/utils.cjs
var require_utils4 = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/loader/utils.cjs"(exports) {
    "use strict";
    var svg_build = require_build();
    var svg_size = require_size();
    require_defaults();
    require_defaults2();
    require_defs();
    var svgWidthRegex = /\swidth\s*=\s*["']([\w.]+)["']/;
    var svgHeightRegex = /\sheight\s*=\s*["']([\w.]+)["']/;
    var svgTagRegex = /<svg\s+/;
    function configureSvgSize(svg, props, scale) {
      const svgNode = svg.slice(0, svg.indexOf(">"));
      const check = (prop, regex) => {
        var _a3;
        const result = regex.exec(svgNode);
        const isSet = result != null;
        const propValue = props[prop];
        if (!propValue && !svg_build.isUnsetKeyword(propValue)) {
          if (typeof scale === "number") {
            if (scale > 0) {
              props[prop] = svg_size.calculateSize(
                // Base on result from iconToSVG() or 1em
                (_a3 = result == null ? void 0 : result[1]) != null ? _a3 : "1em",
                scale
              );
            }
          } else if (result) {
            props[prop] = result[1];
          }
        }
        return isSet;
      };
      return [check("width", svgWidthRegex), check("height", svgHeightRegex)];
    }
    async function mergeIconProps(svg, collection, icon, options, propsProvider, afterCustomizations) {
      var _a3, _b2;
      const { scale, addXmlNs = false } = options != null ? options : {};
      const { additionalProps = {}, iconCustomizer } = (_a3 = options == null ? void 0 : options.customizations) != null ? _a3 : {};
      const props = (_b2 = await (propsProvider == null ? void 0 : propsProvider())) != null ? _b2 : {};
      await (iconCustomizer == null ? void 0 : iconCustomizer(collection, icon, props));
      Object.keys(additionalProps).forEach((p) => {
        const v = additionalProps[p];
        if (v !== void 0 && v !== null)
          props[p] = v;
      });
      afterCustomizations == null ? void 0 : afterCustomizations(props);
      const [widthOnSvg, heightOnSvg] = configureSvgSize(svg, props, scale);
      if (addXmlNs) {
        if (!svg.includes("xmlns=") && !props["xmlns"]) {
          props["xmlns"] = "http://www.w3.org/2000/svg";
        }
        if (!svg.includes("xmlns:xlink=") && svg.includes("xlink:") && !props["xmlns:xlink"]) {
          props["xmlns:xlink"] = "http://www.w3.org/1999/xlink";
        }
      }
      const propsToAdd = Object.keys(props).map(
        (p) => p === "width" && widthOnSvg || p === "height" && heightOnSvg ? null : `${p}="${props[p]}"`
      ).filter((p) => p != null);
      if (propsToAdd.length) {
        svg = svg.replace(svgTagRegex, `<svg ${propsToAdd.join(" ")} `);
      }
      if (options) {
        const { defaultStyle, defaultClass } = options;
        if (defaultClass && !svg.includes("class=")) {
          svg = svg.replace(svgTagRegex, `<svg class="${defaultClass}" `);
        }
        if (defaultStyle && !svg.includes("style=")) {
          svg = svg.replace(svgTagRegex, `<svg style="${defaultStyle}" `);
        }
      }
      const usedProps = options == null ? void 0 : options.usedProps;
      if (usedProps) {
        Object.keys(additionalProps).forEach((p) => {
          const v = props[p];
          if (v !== void 0 && v !== null)
            usedProps[p] = v;
        });
        if (typeof props.width !== "undefined" && props.width !== null) {
          usedProps.width = props.width;
        }
        if (typeof props.height !== "undefined" && props.height !== null) {
          usedProps.height = props.height;
        }
      }
      return svg;
    }
    function getPossibleIconNames(icon) {
      return [
        icon,
        icon.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
        icon.replace(/([a-z])(\d+)/g, "$1-$2")
      ];
    }
    exports.getPossibleIconNames = getPossibleIconNames;
    exports.mergeIconProps = mergeIconProps;
  }
});

// ../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/loader/modern.cjs
var require_modern = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/loader/modern.cjs"(exports) {
    "use strict";
    var svg_build = require_build();
    var iconSet_getIcon = require_get_icon();
    var svg_size = require_size();
    var loader_utils = require_utils4();
    var createDebugger = _chunkTR37ZOITcjs.require_src.call(void 0, );
    var customisations_defaults = require_defaults2();
    require_defaults();
    require_defs();
    require_merge();
    require_transformations();
    require_tree();
    function _interopDefaultCompat(e2) {
      return e2 && typeof e2 === "object" && "default" in e2 ? e2.default : e2;
    }
    var createDebugger__default = /* @__PURE__ */ _interopDefaultCompat(createDebugger);
    var debug = createDebugger__default("@iconify-loader:icon");
    async function searchForIcon2(iconSet, collection, ids, options) {
      var _a3, _b2;
      let iconData;
      const { customize } = (_a3 = options == null ? void 0 : options.customizations) != null ? _a3 : {};
      for (const id of ids) {
        iconData = iconSet_getIcon.getIconData(iconSet, id);
        if (iconData) {
          debug(`${collection}:${id}`);
          let defaultCustomizations = {
            ...customisations_defaults.defaultIconCustomisations
          };
          if (typeof customize === "function") {
            iconData = Object.assign({}, iconData);
            defaultCustomizations = (_b2 = customize(
              defaultCustomizations,
              iconData,
              `${collection}:${id}`
            )) != null ? _b2 : defaultCustomizations;
          }
          const {
            attributes: { width: width3, height: height3, ...restAttributes },
            body
          } = svg_build.iconToSVG(iconData, defaultCustomizations);
          const scale = options == null ? void 0 : options.scale;
          return await loader_utils.mergeIconProps(
            // DON'T remove space on <svg >
            `<svg >${body}</svg>`,
            collection,
            id,
            options,
            () => {
              return { ...restAttributes };
            },
            (props) => {
              const check = (prop, defaultValue) => {
                const propValue = props[prop];
                let value;
                if (!svg_build.isUnsetKeyword(propValue)) {
                  if (propValue) {
                    return;
                  }
                  if (typeof scale === "number") {
                    if (scale) {
                      value = svg_size.calculateSize(
                        // Base on result from iconToSVG() or 1em
                        defaultValue != null ? defaultValue : "1em",
                        scale
                      );
                    }
                  } else {
                    value = defaultValue;
                  }
                }
                if (!value) {
                  delete props[prop];
                } else {
                  props[prop] = value;
                }
              };
              check("width", width3);
              check("height", height3);
            }
          );
        }
      }
    }
    exports.searchForIcon = searchForIcon2;
  }
});

// ../../node_modules/.pnpm/acorn@8.14.0/node_modules/acorn/dist/acorn.js
var require_acorn = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/acorn@8.14.0/node_modules/acorn/dist/acorn.js"(exports, module) {
    "use strict";
    (function(global4, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global4 = typeof globalThis !== "undefined" ? globalThis : global4 || self, factory(global4.acorn = {}));
    })(exports, function(exports2) {
      "use strict";
      var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
      var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
      var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
      var reservedWords = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      };
      var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
      var keywords$1 = {
        5: ecma5AndLessKeywords,
        "5module": ecma5AndLessKeywords + " export import",
        6: ecma5AndLessKeywords + " const class extends export import super"
      };
      var keywordRelationalOperator = /^in(stanceof)?$/;
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      function isInAstralSet(code, set) {
        var pos = 65536;
        for (var i2 = 0; i2 < set.length; i2 += 2) {
          pos += set[i2];
          if (pos > code) {
            return false;
          }
          pos += set[i2 + 1];
          if (pos >= code) {
            return true;
          }
        }
        return false;
      }
      function isIdentifierStart(code, astral) {
        if (code < 65) {
          return code === 36;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes);
      }
      function isIdentifierChar(code, astral) {
        if (code < 48) {
          return code === 36;
        }
        if (code < 58) {
          return true;
        }
        if (code < 65) {
          return false;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
      }
      var TokenType = function TokenType2(label, conf) {
        if (conf === void 0) conf = {};
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
      };
      function binop(name2, prec) {
        return new TokenType(name2, { beforeExpr: true, binop: prec });
      }
      var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
      var keywords = {};
      function kw(name2, options) {
        if (options === void 0) options = {};
        options.keyword = name2;
        return keywords[name2] = new TokenType(name2, options);
      }
      var types$1 = {
        num: new TokenType("num", startsExpr),
        regexp: new TokenType("regexp", startsExpr),
        string: new TokenType("string", startsExpr),
        name: new TokenType("name", startsExpr),
        privateId: new TokenType("privateId", startsExpr),
        eof: new TokenType("eof"),
        // Punctuation token types.
        bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
        bracketR: new TokenType("]"),
        braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
        braceR: new TokenType("}"),
        parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
        parenR: new TokenType(")"),
        comma: new TokenType(",", beforeExpr),
        semi: new TokenType(";", beforeExpr),
        colon: new TokenType(":", beforeExpr),
        dot: new TokenType("."),
        question: new TokenType("?", beforeExpr),
        questionDot: new TokenType("?."),
        arrow: new TokenType("=>", beforeExpr),
        template: new TokenType("template"),
        invalidTemplate: new TokenType("invalidTemplate"),
        ellipsis: new TokenType("...", beforeExpr),
        backQuote: new TokenType("`", startsExpr),
        dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
        // Operators. These carry several kinds of properties to help the
        // parser use them properly (the presence of these properties is
        // what categorizes them as operators).
        //
        // `binop`, when present, specifies that this operator is a binary
        // operator, and will refer to its precedence.
        //
        // `prefix` and `postfix` mark the operator as a prefix or postfix
        // unary operator.
        //
        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
        // binary operators with a very low precedence, that should result
        // in AssignmentExpression nodes.
        eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
        assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
        incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
        prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
        logicalOR: binop("||", 1),
        logicalAND: binop("&&", 2),
        bitwiseOR: binop("|", 3),
        bitwiseXOR: binop("^", 4),
        bitwiseAND: binop("&", 5),
        equality: binop("==/!=/===/!==", 6),
        relational: binop("</>/<=/>=", 7),
        bitShift: binop("<</>>/>>>", 8),
        plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
        modulo: binop("%", 10),
        star: binop("*", 10),
        slash: binop("/", 10),
        starstar: new TokenType("**", { beforeExpr: true }),
        coalesce: binop("??", 1),
        // Keyword token types.
        _break: kw("break"),
        _case: kw("case", beforeExpr),
        _catch: kw("catch"),
        _continue: kw("continue"),
        _debugger: kw("debugger"),
        _default: kw("default", beforeExpr),
        _do: kw("do", { isLoop: true, beforeExpr: true }),
        _else: kw("else", beforeExpr),
        _finally: kw("finally"),
        _for: kw("for", { isLoop: true }),
        _function: kw("function", startsExpr),
        _if: kw("if"),
        _return: kw("return", beforeExpr),
        _switch: kw("switch"),
        _throw: kw("throw", beforeExpr),
        _try: kw("try"),
        _var: kw("var"),
        _const: kw("const"),
        _while: kw("while", { isLoop: true }),
        _with: kw("with"),
        _new: kw("new", { beforeExpr: true, startsExpr: true }),
        _this: kw("this", startsExpr),
        _super: kw("super", startsExpr),
        _class: kw("class", startsExpr),
        _extends: kw("extends", beforeExpr),
        _export: kw("export"),
        _import: kw("import", startsExpr),
        _null: kw("null", startsExpr),
        _true: kw("true", startsExpr),
        _false: kw("false", startsExpr),
        _in: kw("in", { beforeExpr: true, binop: 7 }),
        _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
        _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
        _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
        _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
      };
      var lineBreak = /\r\n?|\n|\u2028|\u2029/;
      var lineBreakG = new RegExp(lineBreak.source, "g");
      function isNewLine(code) {
        return code === 10 || code === 13 || code === 8232 || code === 8233;
      }
      function nextLineBreak(code, from, end) {
        if (end === void 0) end = code.length;
        for (var i2 = from; i2 < end; i2++) {
          var next = code.charCodeAt(i2);
          if (isNewLine(next)) {
            return i2 < end - 1 && next === 13 && code.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
          }
        }
        return -1;
      }
      var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
      var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var ref = Object.prototype;
      var hasOwnProperty = ref.hasOwnProperty;
      var toString2 = ref.toString;
      var hasOwn = Object.hasOwn || function(obj, propName) {
        return hasOwnProperty.call(obj, propName);
      };
      var isArray2 = Array.isArray || function(obj) {
        return toString2.call(obj) === "[object Array]";
      };
      var regexpCache = /* @__PURE__ */ Object.create(null);
      function wordsRegexp(words) {
        return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
      }
      function codePointToString(code) {
        if (code <= 65535) {
          return String.fromCharCode(code);
        }
        code -= 65536;
        return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
      }
      var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
      var Position3 = function Position4(line, col) {
        this.line = line;
        this.column = col;
      };
      Position3.prototype.offset = function offset(n2) {
        return new Position3(this.line, this.column + n2);
      };
      var SourceLocation = function SourceLocation2(p, start, end) {
        this.start = start;
        this.end = end;
        if (p.sourceFile !== null) {
          this.source = p.sourceFile;
        }
      };
      function getLineInfo(input, offset) {
        for (var line = 1, cur = 0; ; ) {
          var nextBreak = nextLineBreak(input, cur, offset);
          if (nextBreak < 0) {
            return new Position3(line, offset - cur);
          }
          ++line;
          cur = nextBreak;
        }
      }
      var defaultOptions = {
        // `ecmaVersion` indicates the ECMAScript version to parse. Must be
        // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
        // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
        // (the latest version the library supports). This influences
        // support for strict mode, the set of reserved words, and support
        // for new syntax features.
        ecmaVersion: null,
        // `sourceType` indicates the mode the code should be parsed in.
        // Can be either `"script"` or `"module"`. This influences global
        // strict mode and parsing of `import` and `export` declarations.
        sourceType: "script",
        // `onInsertedSemicolon` can be a callback that will be called when
        // a semicolon is automatically inserted. It will be passed the
        // position of the inserted semicolon as an offset, and if
        // `locations` is enabled, it is given the location as a `{line,
        // column}` object as second argument.
        onInsertedSemicolon: null,
        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
        // trailing commas.
        onTrailingComma: null,
        // By default, reserved words are only enforced if ecmaVersion >= 5.
        // Set `allowReserved` to a boolean value to explicitly turn this on
        // an off. When this option has the value "never", reserved words
        // and keywords can also not be used as property names.
        allowReserved: null,
        // When enabled, a return at the top level is not considered an
        // error.
        allowReturnOutsideFunction: false,
        // When enabled, import/export statements are not constrained to
        // appearing at the top of the program, and an import.meta expression
        // in a script isn't considered an error.
        allowImportExportEverywhere: false,
        // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
        // When enabled, await identifiers are allowed to appear at the top-level scope,
        // but they are still not allowed in non-async functions.
        allowAwaitOutsideFunction: null,
        // When enabled, super identifiers are not constrained to
        // appearing in methods and do not raise an error when they appear elsewhere.
        allowSuperOutsideMethod: null,
        // When enabled, hashbang directive in the beginning of file is
        // allowed and treated as a line comment. Enabled by default when
        // `ecmaVersion` >= 2023.
        allowHashBang: false,
        // By default, the parser will verify that private properties are
        // only used in places where they are valid and have been declared.
        // Set this to false to turn such checks off.
        checkPrivateFields: true,
        // When `locations` is on, `loc` properties holding objects with
        // `start` and `end` properties in `{line, column}` form (with
        // line being 1-based and column 0-based) will be attached to the
        // nodes.
        locations: false,
        // A function can be passed as `onToken` option, which will
        // cause Acorn to call that function with object in the same
        // format as tokens returned from `tokenizer().getToken()`. Note
        // that you are not allowed to call the parser from the
        // callbackthat will corrupt its internal state.
        onToken: null,
        // A function can be passed as `onComment` option, which will
        // cause Acorn to call that function with `(block, text, start,
        // end)` parameters whenever a comment is skipped. `block` is a
        // boolean indicating whether this is a block (`/* */`) comment,
        // `text` is the content of the comment, and `start` and `end` are
        // character offsets that denote the start and end of the comment.
        // When the `locations` option is on, two more parameters are
        // passed, the full `{line, column}` locations of the start and
        // end of the comments. Note that you are not allowed to call the
        // parser from the callbackthat will corrupt its internal state.
        // When this option has an array as value, objects representing the
        // comments are pushed to it.
        onComment: null,
        // Nodes have their start and end characters offsets recorded in
        // `start` and `end` properties (directly on the node, rather than
        // the `loc` object, which holds line/column data. To also add a
        // [semi-standardized][range] `range` property holding a `[start,
        // end]` array with the same numbers, set the `ranges` option to
        // `true`.
        //
        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
        ranges: false,
        // It is possible to parse multiple files into a single AST by
        // passing the tree produced by parsing the first file as
        // `program` option in subsequent parses. This will add the
        // toplevel forms of the parsed file to the `Program` (top) node
        // of an existing parse tree.
        program: null,
        // When `locations` is on, you can pass this to record the source
        // file in every node's `loc` object.
        sourceFile: null,
        // This value, if given, is stored in every node, whether
        // `locations` is on or off.
        directSourceFile: null,
        // When enabled, parenthesized expressions are represented by
        // (non-standard) ParenthesizedExpression nodes
        preserveParens: false
      };
      var warnedAboutEcmaVersion = false;
      function getOptions(opts) {
        var options = {};
        for (var opt in defaultOptions) {
          options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
        }
        if (options.ecmaVersion === "latest") {
          options.ecmaVersion = 1e8;
        } else if (options.ecmaVersion == null) {
          if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
            warnedAboutEcmaVersion = true;
            console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
          }
          options.ecmaVersion = 11;
        } else if (options.ecmaVersion >= 2015) {
          options.ecmaVersion -= 2009;
        }
        if (options.allowReserved == null) {
          options.allowReserved = options.ecmaVersion < 5;
        }
        if (!opts || opts.allowHashBang == null) {
          options.allowHashBang = options.ecmaVersion >= 14;
        }
        if (isArray2(options.onToken)) {
          var tokens = options.onToken;
          options.onToken = function(token) {
            return tokens.push(token);
          };
        }
        if (isArray2(options.onComment)) {
          options.onComment = pushComment(options, options.onComment);
        }
        return options;
      }
      function pushComment(options, array) {
        return function(block, text, start, end, startLoc, endLoc) {
          var comment = {
            type: block ? "Block" : "Line",
            value: text,
            start,
            end
          };
          if (options.locations) {
            comment.loc = new SourceLocation(this, startLoc, endLoc);
          }
          if (options.ranges) {
            comment.range = [start, end];
          }
          array.push(comment);
        };
      }
      var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
      function functionFlags(async, generator) {
        return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
      }
      var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
      var Parser = function Parser2(options, input, startPos) {
        this.options = options = getOptions(options);
        this.sourceFile = options.sourceFile;
        this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
        var reserved = "";
        if (options.allowReserved !== true) {
          reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
          if (options.sourceType === "module") {
            reserved += " await";
          }
        }
        this.reservedWords = wordsRegexp(reserved);
        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
        this.reservedWordsStrict = wordsRegexp(reservedStrict);
        this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
        this.input = String(input);
        this.containsEsc = false;
        if (startPos) {
          this.pos = startPos;
          this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
          this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
        } else {
          this.pos = this.lineStart = 0;
          this.curLine = 1;
        }
        this.type = types$1.eof;
        this.value = null;
        this.start = this.end = this.pos;
        this.startLoc = this.endLoc = this.curPosition();
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
        this.context = this.initialContext();
        this.exprAllowed = true;
        this.inModule = options.sourceType === "module";
        this.strict = this.inModule || this.strictDirective(this.pos);
        this.potentialArrowAt = -1;
        this.potentialArrowInForAwait = false;
        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
        this.labels = [];
        this.undefinedExports = /* @__PURE__ */ Object.create(null);
        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
          this.skipLineComment(2);
        }
        this.scopeStack = [];
        this.enterScope(SCOPE_TOP);
        this.regexpState = null;
        this.privateNameStack = [];
      };
      var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
      Parser.prototype.parse = function parse3() {
        var node = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node);
      };
      prototypeAccessors.inFunction.get = function() {
        return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
      };
      prototypeAccessors.inGenerator.get = function() {
        return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
      };
      prototypeAccessors.inAsync.get = function() {
        return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
      };
      prototypeAccessors.canAwait.get = function() {
        for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
            return false;
          }
          if (scope.flags & SCOPE_FUNCTION) {
            return (scope.flags & SCOPE_ASYNC) > 0;
          }
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
      };
      prototypeAccessors.allowSuper.get = function() {
        var ref2 = this.currentThisScope();
        var flags = ref2.flags;
        var inClassFieldInit = ref2.inClassFieldInit;
        return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
      };
      prototypeAccessors.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
      };
      prototypeAccessors.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      };
      prototypeAccessors.allowNewDotTarget.get = function() {
        var ref2 = this.currentThisScope();
        var flags = ref2.flags;
        var inClassFieldInit = ref2.inClassFieldInit;
        return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
      };
      prototypeAccessors.inClassStaticBlock.get = function() {
        return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
      };
      Parser.extend = function extend() {
        var plugins = [], len = arguments.length;
        while (len--) plugins[len] = arguments[len];
        var cls = this;
        for (var i2 = 0; i2 < plugins.length; i2++) {
          cls = plugins[i2](cls);
        }
        return cls;
      };
      Parser.parse = function parse3(input, options) {
        return new this(options, input).parse();
      };
      Parser.parseExpressionAt = function parseExpressionAt2(input, pos, options) {
        var parser = new this(options, input, pos);
        parser.nextToken();
        return parser.parseExpression();
      };
      Parser.tokenizer = function tokenizer2(input, options) {
        return new this(options, input);
      };
      Object.defineProperties(Parser.prototype, prototypeAccessors);
      var pp$9 = Parser.prototype;
      var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
      pp$9.strictDirective = function(start) {
        if (this.options.ecmaVersion < 5) {
          return false;
        }
        for (; ; ) {
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          var match = literal.exec(this.input.slice(start));
          if (!match) {
            return false;
          }
          if ((match[1] || match[2]) === "use strict") {
            skipWhiteSpace.lastIndex = start + match[0].length;
            var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
            var next = this.input.charAt(end);
            return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
          }
          start += match[0].length;
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          if (this.input[start] === ";") {
            start++;
          }
        }
      };
      pp$9.eat = function(type) {
        if (this.type === type) {
          this.next();
          return true;
        } else {
          return false;
        }
      };
      pp$9.isContextual = function(name2) {
        return this.type === types$1.name && this.value === name2 && !this.containsEsc;
      };
      pp$9.eatContextual = function(name2) {
        if (!this.isContextual(name2)) {
          return false;
        }
        this.next();
        return true;
      };
      pp$9.expectContextual = function(name2) {
        if (!this.eatContextual(name2)) {
          this.unexpected();
        }
      };
      pp$9.canInsertSemicolon = function() {
        return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$9.insertSemicolon = function() {
        if (this.canInsertSemicolon()) {
          if (this.options.onInsertedSemicolon) {
            this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
          }
          return true;
        }
      };
      pp$9.semicolon = function() {
        if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
          this.unexpected();
        }
      };
      pp$9.afterTrailingComma = function(tokType, notNext) {
        if (this.type === tokType) {
          if (this.options.onTrailingComma) {
            this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
          }
          if (!notNext) {
            this.next();
          }
          return true;
        }
      };
      pp$9.expect = function(type) {
        this.eat(type) || this.unexpected();
      };
      pp$9.unexpected = function(pos) {
        this.raise(pos != null ? pos : this.start, "Unexpected token");
      };
      var DestructuringErrors = function DestructuringErrors2() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      };
      pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
        if (!refDestructuringErrors) {
          return;
        }
        if (refDestructuringErrors.trailingComma > -1) {
          this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
        }
        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
        if (parens > -1) {
          this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
        }
      };
      pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors) {
          return false;
        }
        var shorthandAssign = refDestructuringErrors.shorthandAssign;
        var doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow) {
          return shorthandAssign >= 0 || doubleProto >= 0;
        }
        if (shorthandAssign >= 0) {
          this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
        }
        if (doubleProto >= 0) {
          this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
        }
      };
      pp$9.checkYieldAwaitInDefaultParams = function() {
        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
          this.raise(this.yieldPos, "Yield expression cannot be a default value");
        }
        if (this.awaitPos) {
          this.raise(this.awaitPos, "Await expression cannot be a default value");
        }
      };
      pp$9.isSimpleAssignTarget = function(expr) {
        if (expr.type === "ParenthesizedExpression") {
          return this.isSimpleAssignTarget(expr.expression);
        }
        return expr.type === "Identifier" || expr.type === "MemberExpression";
      };
      var pp$8 = Parser.prototype;
      pp$8.parseTopLevel = function(node) {
        var exports3 = /* @__PURE__ */ Object.create(null);
        if (!node.body) {
          node.body = [];
        }
        while (this.type !== types$1.eof) {
          var stmt = this.parseStatement(null, true, exports3);
          node.body.push(stmt);
        }
        if (this.inModule) {
          for (var i2 = 0, list2 = Object.keys(this.undefinedExports); i2 < list2.length; i2 += 1) {
            var name2 = list2[i2];
            this.raiseRecoverable(this.undefinedExports[name2].start, "Export '" + name2 + "' is not defined");
          }
        }
        this.adaptDirectivePrologue(node.body);
        this.next();
        node.sourceType = this.options.sourceType;
        return this.finishNode(node, "Program");
      };
      var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
      pp$8.isLet = function(context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 91 || nextCh === 92) {
          return true;
        }
        if (context) {
          return false;
        }
        if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
          return true;
        }
        if (isIdentifierStart(nextCh, true)) {
          var pos = next + 1;
          while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
            ++pos;
          }
          if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
            return true;
          }
          var ident = this.input.slice(next, pos);
          if (!keywordRelationalOperator.test(ident)) {
            return true;
          }
        }
        return false;
      };
      pp$8.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, after;
        return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
      };
      pp$8.parseStatement = function(context, topLevel, exports3) {
        var starttype = this.type, node = this.startNode(), kind;
        if (this.isLet(context)) {
          starttype = types$1._var;
          kind = "let";
        }
        switch (starttype) {
          case types$1._break:
          case types$1._continue:
            return this.parseBreakContinueStatement(node, starttype.keyword);
          case types$1._debugger:
            return this.parseDebuggerStatement(node);
          case types$1._do:
            return this.parseDoStatement(node);
          case types$1._for:
            return this.parseForStatement(node);
          case types$1._function:
            if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
              this.unexpected();
            }
            return this.parseFunctionStatement(node, false, !context);
          case types$1._class:
            if (context) {
              this.unexpected();
            }
            return this.parseClass(node, true);
          case types$1._if:
            return this.parseIfStatement(node);
          case types$1._return:
            return this.parseReturnStatement(node);
          case types$1._switch:
            return this.parseSwitchStatement(node);
          case types$1._throw:
            return this.parseThrowStatement(node);
          case types$1._try:
            return this.parseTryStatement(node);
          case types$1._const:
          case types$1._var:
            kind = kind || this.value;
            if (context && kind !== "var") {
              this.unexpected();
            }
            return this.parseVarStatement(node, kind);
          case types$1._while:
            return this.parseWhileStatement(node);
          case types$1._with:
            return this.parseWithStatement(node);
          case types$1.braceL:
            return this.parseBlock(true, node);
          case types$1.semi:
            return this.parseEmptyStatement(node);
          case types$1._export:
          case types$1._import:
            if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
              skipWhiteSpace.lastIndex = this.pos;
              var skip = skipWhiteSpace.exec(this.input);
              var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
              if (nextCh === 40 || nextCh === 46) {
                return this.parseExpressionStatement(node, this.parseExpression());
              }
            }
            if (!this.options.allowImportExportEverywhere) {
              if (!topLevel) {
                this.raise(this.start, "'import' and 'export' may only appear at the top level");
              }
              if (!this.inModule) {
                this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
              }
            }
            return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports3);
          // If the statement does not start with a statement keyword or a
          // brace, it's an ExpressionStatement or LabeledStatement. We
          // simply start parsing an expression, and afterwards, if the
          // next token is a colon and the expression was a simple
          // Identifier node, we switch to interpreting it as a label.
          default:
            if (this.isAsyncFunction()) {
              if (context) {
                this.unexpected();
              }
              this.next();
              return this.parseFunctionStatement(node, true, !context);
            }
            var maybeName = this.value, expr = this.parseExpression();
            if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
              return this.parseLabeledStatement(node, maybeName, expr, context);
            } else {
              return this.parseExpressionStatement(node, expr);
            }
        }
      };
      pp$8.parseBreakContinueStatement = function(node, keyword) {
        var isBreak = keyword === "break";
        this.next();
        if (this.eat(types$1.semi) || this.insertSemicolon()) {
          node.label = null;
        } else if (this.type !== types$1.name) {
          this.unexpected();
        } else {
          node.label = this.parseIdent();
          this.semicolon();
        }
        var i2 = 0;
        for (; i2 < this.labels.length; ++i2) {
          var lab = this.labels[i2];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) {
              break;
            }
            if (node.label && isBreak) {
              break;
            }
          }
        }
        if (i2 === this.labels.length) {
          this.raise(node.start, "Unsyntactic " + keyword);
        }
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      };
      pp$8.parseDebuggerStatement = function(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      };
      pp$8.parseDoStatement = function(node) {
        this.next();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("do");
        this.labels.pop();
        this.expect(types$1._while);
        node.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6) {
          this.eat(types$1.semi);
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "DoWhileStatement");
      };
      pp$8.parseForStatement = function(node) {
        this.next();
        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        this.labels.push(loopLabel);
        this.enterScope(0);
        this.expect(types$1.parenL);
        if (this.type === types$1.semi) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, null);
        }
        var isLet = this.isLet();
        if (this.type === types$1._var || this.type === types$1._const || isLet) {
          var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
          this.next();
          this.parseVar(init$1, true, kind);
          this.finishNode(init$1, "VariableDeclaration");
          if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
            if (this.options.ecmaVersion >= 9) {
              if (this.type === types$1._in) {
                if (awaitAt > -1) {
                  this.unexpected(awaitAt);
                }
              } else {
                node.await = awaitAt > -1;
              }
            }
            return this.parseForIn(node, init$1);
          }
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, init$1);
        }
        var startsWithLet = this.isContextual("let"), isForOf = false;
        var containsEsc = this.containsEsc;
        var refDestructuringErrors = new DestructuringErrors();
        var initPos = this.start;
        var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
        if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          if (awaitAt > -1) {
            if (this.type === types$1._in) {
              this.unexpected(awaitAt);
            }
            node.await = true;
          } else if (isForOf && this.options.ecmaVersion >= 8) {
            if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") {
              this.unexpected();
            } else if (this.options.ecmaVersion >= 9) {
              node.await = false;
            }
          }
          if (startsWithLet && isForOf) {
            this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
          }
          this.toAssignable(init, false, refDestructuringErrors);
          this.checkLValPattern(init);
          return this.parseForIn(node, init);
        } else {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init);
      };
      pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
      };
      pp$8.parseIfStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        node.consequent = this.parseStatement("if");
        node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
        return this.finishNode(node, "IfStatement");
      };
      pp$8.parseReturnStatement = function(node) {
        if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
          this.raise(this.start, "'return' outside of function");
        }
        this.next();
        if (this.eat(types$1.semi) || this.insertSemicolon()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      };
      pp$8.parseSwitchStatement = function(node) {
        this.next();
        node.discriminant = this.parseParenExpression();
        node.cases = [];
        this.expect(types$1.braceL);
        this.labels.push(switchLabel);
        this.enterScope(0);
        var cur;
        for (var sawDefault = false; this.type !== types$1.braceR; ) {
          if (this.type === types$1._case || this.type === types$1._default) {
            var isCase = this.type === types$1._case;
            if (cur) {
              this.finishNode(cur, "SwitchCase");
            }
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(types$1.colon);
          } else {
            if (!cur) {
              this.unexpected();
            }
            cur.consequent.push(this.parseStatement(null));
          }
        }
        this.exitScope();
        if (cur) {
          this.finishNode(cur, "SwitchCase");
        }
        this.next();
        this.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      };
      pp$8.parseThrowStatement = function(node) {
        this.next();
        if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
          this.raise(this.lastTokEnd, "Illegal newline after throw");
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      };
      var empty$1 = [];
      pp$8.parseCatchClauseParam = function() {
        var param = this.parseBindingAtom();
        var simple = param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types$1.parenR);
        return param;
      };
      pp$8.parseTryStatement = function(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.type === types$1._catch) {
          var clause = this.startNode();
          this.next();
          if (this.eat(types$1.parenL)) {
            clause.param = this.parseCatchClauseParam();
          } else {
            if (this.options.ecmaVersion < 10) {
              this.unexpected();
            }
            clause.param = null;
            this.enterScope(0);
          }
          clause.body = this.parseBlock(false);
          this.exitScope();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          this.raise(node.start, "Missing catch or finally clause");
        }
        return this.finishNode(node, "TryStatement");
      };
      pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
        this.next();
        this.parseVar(node, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      };
      pp$8.parseWhileStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("while");
        this.labels.pop();
        return this.finishNode(node, "WhileStatement");
      };
      pp$8.parseWithStatement = function(node) {
        if (this.strict) {
          this.raise(this.start, "'with' in strict mode");
        }
        this.next();
        node.object = this.parseParenExpression();
        node.body = this.parseStatement("with");
        return this.finishNode(node, "WithStatement");
      };
      pp$8.parseEmptyStatement = function(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      };
      pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
        for (var i$1 = 0, list2 = this.labels; i$1 < list2.length; i$1 += 1) {
          var label = list2[i$1];
          if (label.name === maybeName) {
            this.raise(expr.start, "Label '" + maybeName + "' is already declared");
          }
        }
        var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
        for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
          var label$1 = this.labels[i2];
          if (label$1.statementStart === node.start) {
            label$1.statementStart = this.start;
            label$1.kind = kind;
          } else {
            break;
          }
        }
        this.labels.push({ name: maybeName, kind, statementStart: this.start });
        node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      };
      pp$8.parseExpressionStatement = function(node, expr) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      };
      pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
        if (createNewLexicalScope === void 0) createNewLexicalScope = true;
        if (node === void 0) node = this.startNode();
        node.body = [];
        this.expect(types$1.braceL);
        if (createNewLexicalScope) {
          this.enterScope(0);
        }
        while (this.type !== types$1.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        if (exitStrict) {
          this.strict = false;
        }
        this.next();
        if (createNewLexicalScope) {
          this.exitScope();
        }
        return this.finishNode(node, "BlockStatement");
      };
      pp$8.parseFor = function(node, init) {
        node.init = init;
        this.expect(types$1.semi);
        node.test = this.type === types$1.semi ? null : this.parseExpression();
        this.expect(types$1.semi);
        node.update = this.type === types$1.parenR ? null : this.parseExpression();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, "ForStatement");
      };
      pp$8.parseForIn = function(node, init) {
        var isForIn = this.type === types$1._in;
        this.next();
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
          this.raise(
            init.start,
            (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
          );
        }
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      };
      pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
        node.declarations = [];
        node.kind = kind;
        for (; ; ) {
          var decl = this.startNode();
          this.parseVarId(decl, kind);
          if (this.eat(types$1.eq)) {
            decl.init = this.parseMaybeAssign(isFor);
          } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            this.unexpected();
          } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
            this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
          } else {
            decl.init = null;
          }
          node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(types$1.comma)) {
            break;
          }
        }
        return node;
      };
      pp$8.parseVarId = function(decl, kind) {
        decl.id = this.parseBindingAtom();
        this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
      };
      var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
      pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
        this.initFunction(node);
        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
          if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
            this.unexpected();
          }
          node.generator = this.eat(types$1.star);
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT) {
          node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
          if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
            this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
          }
        }
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(node.async, node.generator));
        if (!(statement & FUNC_STATEMENT)) {
          node.id = this.type === types$1.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node);
        this.parseFunctionBody(node, allowExpressionBody, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
      };
      pp$8.parseFunctionParams = function(node) {
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
      };
      pp$8.parseClass = function(node, isStatement) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node, isStatement);
        this.parseClassSuper(node);
        var privateNameMap = this.enterClassBody();
        var classBody = this.startNode();
        var hadConstructor = false;
        classBody.body = [];
        this.expect(types$1.braceL);
        while (this.type !== types$1.braceR) {
          var element = this.parseClassElement(node.superClass !== null);
          if (element) {
            classBody.body.push(element);
            if (element.type === "MethodDefinition" && element.kind === "constructor") {
              if (hadConstructor) {
                this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
              }
              hadConstructor = true;
            } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
              this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
            }
          }
        }
        this.strict = oldStrict;
        this.next();
        node.body = this.finishNode(classBody, "ClassBody");
        this.exitClassBody();
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      };
      pp$8.parseClassElement = function(constructorAllowsSuper) {
        if (this.eat(types$1.semi)) {
          return null;
        }
        var ecmaVersion2 = this.options.ecmaVersion;
        var node = this.startNode();
        var keyName = "";
        var isGenerator = false;
        var isAsync = false;
        var kind = "method";
        var isStatic = false;
        if (this.eatContextual("static")) {
          if (ecmaVersion2 >= 13 && this.eat(types$1.braceL)) {
            this.parseClassStaticBlock(node);
            return node;
          }
          if (this.isClassElementNameStart() || this.type === types$1.star) {
            isStatic = true;
          } else {
            keyName = "static";
          }
        }
        node.static = isStatic;
        if (!keyName && ecmaVersion2 >= 8 && this.eatContextual("async")) {
          if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
            isAsync = true;
          } else {
            keyName = "async";
          }
        }
        if (!keyName && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$1.star)) {
          isGenerator = true;
        }
        if (!keyName && !isAsync && !isGenerator) {
          var lastValue = this.value;
          if (this.eatContextual("get") || this.eatContextual("set")) {
            if (this.isClassElementNameStart()) {
              kind = lastValue;
            } else {
              keyName = lastValue;
            }
          }
        }
        if (keyName) {
          node.computed = false;
          node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
          node.key.name = keyName;
          this.finishNode(node.key, "Identifier");
        } else {
          this.parseClassElementName(node);
        }
        if (ecmaVersion2 < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
          var isConstructor = !node.static && checkKeyName(node, "constructor");
          var allowsDirectSuper = isConstructor && constructorAllowsSuper;
          if (isConstructor && kind !== "method") {
            this.raise(node.key.start, "Constructor can't have get/set modifier");
          }
          node.kind = isConstructor ? "constructor" : kind;
          this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
        } else {
          this.parseClassField(node);
        }
        return node;
      };
      pp$8.isClassElementNameStart = function() {
        return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
      };
      pp$8.parseClassElementName = function(element) {
        if (this.type === types$1.privateId) {
          if (this.value === "constructor") {
            this.raise(this.start, "Classes can't have an element named '#constructor'");
          }
          element.computed = false;
          element.key = this.parsePrivateIdent();
        } else {
          this.parsePropertyName(element);
        }
      };
      pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
        var key = method.key;
        if (method.kind === "constructor") {
          if (isGenerator) {
            this.raise(key.start, "Constructor can't be a generator");
          }
          if (isAsync) {
            this.raise(key.start, "Constructor can't be an async method");
          }
        } else if (method.static && checkKeyName(method, "prototype")) {
          this.raise(key.start, "Classes may not have a static property named prototype");
        }
        var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
        if (method.kind === "get" && value.params.length !== 0) {
          this.raiseRecoverable(value.start, "getter should have no params");
        }
        if (method.kind === "set" && value.params.length !== 1) {
          this.raiseRecoverable(value.start, "setter should have exactly one param");
        }
        if (method.kind === "set" && value.params[0].type === "RestElement") {
          this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
        }
        return this.finishNode(method, "MethodDefinition");
      };
      pp$8.parseClassField = function(field) {
        if (checkKeyName(field, "constructor")) {
          this.raise(field.key.start, "Classes can't have a field named 'constructor'");
        } else if (field.static && checkKeyName(field, "prototype")) {
          this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
        }
        if (this.eat(types$1.eq)) {
          var scope = this.currentThisScope();
          var inClassFieldInit = scope.inClassFieldInit;
          scope.inClassFieldInit = true;
          field.value = this.parseMaybeAssign();
          scope.inClassFieldInit = inClassFieldInit;
        } else {
          field.value = null;
        }
        this.semicolon();
        return this.finishNode(field, "PropertyDefinition");
      };
      pp$8.parseClassStaticBlock = function(node) {
        node.body = [];
        var oldLabels = this.labels;
        this.labels = [];
        this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
        while (this.type !== types$1.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        this.next();
        this.exitScope();
        this.labels = oldLabels;
        return this.finishNode(node, "StaticBlock");
      };
      pp$8.parseClassId = function(node, isStatement) {
        if (this.type === types$1.name) {
          node.id = this.parseIdent();
          if (isStatement) {
            this.checkLValSimple(node.id, BIND_LEXICAL, false);
          }
        } else {
          if (isStatement === true) {
            this.unexpected();
          }
          node.id = null;
        }
      };
      pp$8.parseClassSuper = function(node) {
        node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
      };
      pp$8.enterClassBody = function() {
        var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
        this.privateNameStack.push(element);
        return element.declared;
      };
      pp$8.exitClassBody = function() {
        var ref2 = this.privateNameStack.pop();
        var declared = ref2.declared;
        var used = ref2.used;
        if (!this.options.checkPrivateFields) {
          return;
        }
        var len = this.privateNameStack.length;
        var parent = len === 0 ? null : this.privateNameStack[len - 1];
        for (var i2 = 0; i2 < used.length; ++i2) {
          var id = used[i2];
          if (!hasOwn(declared, id.name)) {
            if (parent) {
              parent.used.push(id);
            } else {
              this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
            }
          }
        }
      };
      function isPrivateNameConflicted(privateNameMap, element) {
        var name2 = element.key.name;
        var curr = privateNameMap[name2];
        var next = "true";
        if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
          next = (element.static ? "s" : "i") + element.kind;
        }
        if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
          privateNameMap[name2] = "true";
          return false;
        } else if (!curr) {
          privateNameMap[name2] = next;
          return false;
        } else {
          return true;
        }
      }
      function checkKeyName(node, name2) {
        var computed = node.computed;
        var key = node.key;
        return !computed && (key.type === "Identifier" && key.name === name2 || key.type === "Literal" && key.value === name2);
      }
      pp$8.parseExportAllDeclaration = function(node, exports3) {
        if (this.options.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node.exported = this.parseModuleExportName();
            this.checkExport(exports3, node.exported, this.lastTokStart);
          } else {
            node.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== types$1.string) {
          this.unexpected();
        }
        node.source = this.parseExprAtom();
        if (this.options.ecmaVersion >= 16) {
          node.attributes = this.parseWithClause();
        }
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
      };
      pp$8.parseExport = function(node, exports3) {
        this.next();
        if (this.eat(types$1.star)) {
          return this.parseExportAllDeclaration(node, exports3);
        }
        if (this.eat(types$1._default)) {
          this.checkExport(exports3, "default", this.lastTokStart);
          node.declaration = this.parseExportDefaultDeclaration();
          return this.finishNode(node, "ExportDefaultDeclaration");
        }
        if (this.shouldParseExportStatement()) {
          node.declaration = this.parseExportDeclaration(node);
          if (node.declaration.type === "VariableDeclaration") {
            this.checkVariableExport(exports3, node.declaration.declarations);
          } else {
            this.checkExport(exports3, node.declaration.id, node.declaration.id.start);
          }
          node.specifiers = [];
          node.source = null;
        } else {
          node.declaration = null;
          node.specifiers = this.parseExportSpecifiers(exports3);
          if (this.eatContextual("from")) {
            if (this.type !== types$1.string) {
              this.unexpected();
            }
            node.source = this.parseExprAtom();
            if (this.options.ecmaVersion >= 16) {
              node.attributes = this.parseWithClause();
            }
          } else {
            for (var i2 = 0, list2 = node.specifiers; i2 < list2.length; i2 += 1) {
              var spec = list2[i2];
              this.checkUnreserved(spec.local);
              this.checkLocalExport(spec.local);
              if (spec.local.type === "Literal") {
                this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
              }
            }
            node.source = null;
          }
          this.semicolon();
        }
        return this.finishNode(node, "ExportNamedDeclaration");
      };
      pp$8.parseExportDeclaration = function(node) {
        return this.parseStatement(null);
      };
      pp$8.parseExportDefaultDeclaration = function() {
        var isAsync;
        if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) {
            this.next();
          }
          return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
        } else if (this.type === types$1._class) {
          var cNode = this.startNode();
          return this.parseClass(cNode, "nullableID");
        } else {
          var declaration = this.parseMaybeAssign();
          this.semicolon();
          return declaration;
        }
      };
      pp$8.checkExport = function(exports3, name2, pos) {
        if (!exports3) {
          return;
        }
        if (typeof name2 !== "string") {
          name2 = name2.type === "Identifier" ? name2.name : name2.value;
        }
        if (hasOwn(exports3, name2)) {
          this.raiseRecoverable(pos, "Duplicate export '" + name2 + "'");
        }
        exports3[name2] = true;
      };
      pp$8.checkPatternExport = function(exports3, pat) {
        var type = pat.type;
        if (type === "Identifier") {
          this.checkExport(exports3, pat, pat.start);
        } else if (type === "ObjectPattern") {
          for (var i2 = 0, list2 = pat.properties; i2 < list2.length; i2 += 1) {
            var prop = list2[i2];
            this.checkPatternExport(exports3, prop);
          }
        } else if (type === "ArrayPattern") {
          for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
            var elt = list$1[i$1];
            if (elt) {
              this.checkPatternExport(exports3, elt);
            }
          }
        } else if (type === "Property") {
          this.checkPatternExport(exports3, pat.value);
        } else if (type === "AssignmentPattern") {
          this.checkPatternExport(exports3, pat.left);
        } else if (type === "RestElement") {
          this.checkPatternExport(exports3, pat.argument);
        }
      };
      pp$8.checkVariableExport = function(exports3, decls) {
        if (!exports3) {
          return;
        }
        for (var i2 = 0, list2 = decls; i2 < list2.length; i2 += 1) {
          var decl = list2[i2];
          this.checkPatternExport(exports3, decl.id);
        }
      };
      pp$8.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      };
      pp$8.parseExportSpecifier = function(exports3) {
        var node = this.startNode();
        node.local = this.parseModuleExportName();
        node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
        this.checkExport(
          exports3,
          node.exported,
          node.exported.start
        );
        return this.finishNode(node, "ExportSpecifier");
      };
      pp$8.parseExportSpecifiers = function(exports3) {
        var nodes = [], first = true;
        this.expect(types$1.braceL);
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseExportSpecifier(exports3));
        }
        return nodes;
      };
      pp$8.parseImport = function(node) {
        this.next();
        if (this.type === types$1.string) {
          node.specifiers = empty$1;
          node.source = this.parseExprAtom();
        } else {
          node.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
        }
        if (this.options.ecmaVersion >= 16) {
          node.attributes = this.parseWithClause();
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      };
      pp$8.parseImportSpecifier = function() {
        var node = this.startNode();
        node.imported = this.parseModuleExportName();
        if (this.eatContextual("as")) {
          node.local = this.parseIdent();
        } else {
          this.checkUnreserved(node.imported);
          node.local = node.imported;
        }
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportSpecifier");
      };
      pp$8.parseImportDefaultSpecifier = function() {
        var node = this.startNode();
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportDefaultSpecifier");
      };
      pp$8.parseImportNamespaceSpecifier = function() {
        var node = this.startNode();
        this.next();
        this.expectContextual("as");
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportNamespaceSpecifier");
      };
      pp$8.parseImportSpecifiers = function() {
        var nodes = [], first = true;
        if (this.type === types$1.name) {
          nodes.push(this.parseImportDefaultSpecifier());
          if (!this.eat(types$1.comma)) {
            return nodes;
          }
        }
        if (this.type === types$1.star) {
          nodes.push(this.parseImportNamespaceSpecifier());
          return nodes;
        }
        this.expect(types$1.braceL);
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseImportSpecifier());
        }
        return nodes;
      };
      pp$8.parseWithClause = function() {
        var nodes = [];
        if (!this.eat(types$1._with)) {
          return nodes;
        }
        this.expect(types$1.braceL);
        var attributeKeys = {};
        var first = true;
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var attr = this.parseImportAttribute();
          var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
          if (hasOwn(attributeKeys, keyName)) {
            this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
          }
          attributeKeys[keyName] = true;
          nodes.push(attr);
        }
        return nodes;
      };
      pp$8.parseImportAttribute = function() {
        var node = this.startNode();
        node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
        this.expect(types$1.colon);
        if (this.type !== types$1.string) {
          this.unexpected();
        }
        node.value = this.parseExprAtom();
        return this.finishNode(node, "ImportAttribute");
      };
      pp$8.parseModuleExportName = function() {
        if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
          var stringLiteral = this.parseLiteral(this.value);
          if (loneSurrogate.test(stringLiteral.value)) {
            this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
          }
          return stringLiteral;
        }
        return this.parseIdent(true);
      };
      pp$8.adaptDirectivePrologue = function(statements) {
        for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2) {
          statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
        }
      };
      pp$8.isDirectiveCandidate = function(statement) {
        return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
        (this.input[statement.start] === '"' || this.input[statement.start] === "'");
      };
      var pp$7 = Parser.prototype;
      pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node) {
          switch (node.type) {
            case "Identifier":
              if (this.inAsync && node.name === "await") {
                this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
              }
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              node.type = "ObjectPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              for (var i2 = 0, list2 = node.properties; i2 < list2.length; i2 += 1) {
                var prop = list2[i2];
                this.toAssignable(prop, isBinding);
                if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                  this.raise(prop.argument.start, "Unexpected token");
                }
              }
              break;
            case "Property":
              if (node.kind !== "init") {
                this.raise(node.key.start, "Object pattern can't contain getter or setter");
              }
              this.toAssignable(node.value, isBinding);
              break;
            case "ArrayExpression":
              node.type = "ArrayPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              this.toAssignableList(node.elements, isBinding);
              break;
            case "SpreadElement":
              node.type = "RestElement";
              this.toAssignable(node.argument, isBinding);
              if (node.argument.type === "AssignmentPattern") {
                this.raise(node.argument.start, "Rest elements cannot have a default value");
              }
              break;
            case "AssignmentExpression":
              if (node.operator !== "=") {
                this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
              }
              node.type = "AssignmentPattern";
              delete node.operator;
              this.toAssignable(node.left, isBinding);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(node.expression, isBinding, refDestructuringErrors);
              break;
            case "ChainExpression":
              this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!isBinding) {
                break;
              }
            default:
              this.raise(node.start, "Assigning to rvalue");
          }
        } else if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        return node;
      };
      pp$7.toAssignableList = function(exprList, isBinding) {
        var end = exprList.length;
        for (var i2 = 0; i2 < end; i2++) {
          var elt = exprList[i2];
          if (elt) {
            this.toAssignable(elt, isBinding);
          }
        }
        if (end) {
          var last = exprList[end - 1];
          if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
            this.unexpected(last.argument.start);
          }
        }
        return exprList;
      };
      pp$7.parseSpread = function(refDestructuringErrors) {
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        return this.finishNode(node, "SpreadElement");
      };
      pp$7.parseRestBinding = function() {
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
          this.unexpected();
        }
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
      };
      pp$7.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6) {
          switch (this.type) {
            case types$1.bracketL:
              var node = this.startNode();
              this.next();
              node.elements = this.parseBindingList(types$1.bracketR, true, true);
              return this.finishNode(node, "ArrayPattern");
            case types$1.braceL:
              return this.parseObj(true);
          }
        }
        return this.parseIdent();
      };
      pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types$1.comma);
          }
          if (allowEmpty && this.type === types$1.comma) {
            elts.push(null);
          } else if (allowTrailingComma && this.afterTrailingComma(close)) {
            break;
          } else if (this.type === types$1.ellipsis) {
            var rest = this.parseRestBinding();
            this.parseBindingListItem(rest);
            elts.push(rest);
            if (this.type === types$1.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            this.expect(close);
            break;
          } else {
            elts.push(this.parseAssignableListItem(allowModifiers));
          }
        }
        return elts;
      };
      pp$7.parseAssignableListItem = function(allowModifiers) {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        return elem;
      };
      pp$7.parseBindingListItem = function(param) {
        return param;
      };
      pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
        left = left || this.parseBindingAtom();
        if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
          return left;
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentPattern");
      };
      pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE;
        var isBind = bindingType !== BIND_NONE;
        switch (expr.type) {
          case "Identifier":
            if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
              this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
            }
            if (isBind) {
              if (bindingType === BIND_LEXICAL && expr.name === "let") {
                this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
              }
              if (checkClashes) {
                if (hasOwn(checkClashes, expr.name)) {
                  this.raiseRecoverable(expr.start, "Argument name clash");
                }
                checkClashes[expr.name] = true;
              }
              if (bindingType !== BIND_OUTSIDE) {
                this.declareName(expr.name, bindingType, expr.start);
              }
            }
            break;
          case "ChainExpression":
            this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding member expression");
            }
            break;
          case "ParenthesizedExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding parenthesized expression");
            }
            return this.checkLValSimple(expr.expression, bindingType, checkClashes);
          default:
            this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
        }
      };
      pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE;
        switch (expr.type) {
          case "ObjectPattern":
            for (var i2 = 0, list2 = expr.properties; i2 < list2.length; i2 += 1) {
              var prop = list2[i2];
              this.checkLValInnerPattern(prop, bindingType, checkClashes);
            }
            break;
          case "ArrayPattern":
            for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
              var elem = list$1[i$1];
              if (elem) {
                this.checkLValInnerPattern(elem, bindingType, checkClashes);
              }
            }
            break;
          default:
            this.checkLValSimple(expr, bindingType, checkClashes);
        }
      };
      pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE;
        switch (expr.type) {
          case "Property":
            this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
            break;
          case "AssignmentPattern":
            this.checkLValPattern(expr.left, bindingType, checkClashes);
            break;
          case "RestElement":
            this.checkLValPattern(expr.argument, bindingType, checkClashes);
            break;
          default:
            this.checkLValPattern(expr, bindingType, checkClashes);
        }
      };
      var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
        this.token = token;
        this.isExpr = !!isExpr;
        this.preserveSpace = !!preserveSpace;
        this.override = override;
        this.generator = !!generator;
      };
      var types = {
        b_stat: new TokContext("{", false),
        b_expr: new TokContext("{", true),
        b_tmpl: new TokContext("${", false),
        p_stat: new TokContext("(", false),
        p_expr: new TokContext("(", true),
        q_tmpl: new TokContext("`", true, true, function(p) {
          return p.tryReadTemplateToken();
        }),
        f_stat: new TokContext("function", false),
        f_expr: new TokContext("function", true),
        f_expr_gen: new TokContext("function", true, false, null, true),
        f_gen: new TokContext("function", false, false, null, true)
      };
      var pp$6 = Parser.prototype;
      pp$6.initialContext = function() {
        return [types.b_stat];
      };
      pp$6.curContext = function() {
        return this.context[this.context.length - 1];
      };
      pp$6.braceIsBlock = function(prevType) {
        var parent = this.curContext();
        if (parent === types.f_expr || parent === types.f_stat) {
          return true;
        }
        if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
          return !parent.isExpr;
        }
        if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
          return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
        }
        if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
          return true;
        }
        if (prevType === types$1.braceL) {
          return parent === types.b_stat;
        }
        if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
          return false;
        }
        return !this.exprAllowed;
      };
      pp$6.inGeneratorContext = function() {
        for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
          var context = this.context[i2];
          if (context.token === "function") {
            return context.generator;
          }
        }
        return false;
      };
      pp$6.updateContext = function(prevType) {
        var update, type = this.type;
        if (type.keyword && prevType === types$1.dot) {
          this.exprAllowed = false;
        } else if (update = type.updateContext) {
          update.call(this, prevType);
        } else {
          this.exprAllowed = type.beforeExpr;
        }
      };
      pp$6.overrideContext = function(tokenCtx) {
        if (this.curContext() !== tokenCtx) {
          this.context[this.context.length - 1] = tokenCtx;
        }
      };
      types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
        if (this.context.length === 1) {
          this.exprAllowed = true;
          return;
        }
        var out = this.context.pop();
        if (out === types.b_stat && this.curContext().token === "function") {
          out = this.context.pop();
        }
        this.exprAllowed = !out.isExpr;
      };
      types$1.braceL.updateContext = function(prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
        this.exprAllowed = true;
      };
      types$1.dollarBraceL.updateContext = function() {
        this.context.push(types.b_tmpl);
        this.exprAllowed = true;
      };
      types$1.parenL.updateContext = function(prevType) {
        var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
        this.context.push(statementParens ? types.p_stat : types.p_expr);
        this.exprAllowed = true;
      };
      types$1.incDec.updateContext = function() {
      };
      types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
        if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
          this.context.push(types.f_expr);
        } else {
          this.context.push(types.f_stat);
        }
        this.exprAllowed = false;
      };
      types$1.colon.updateContext = function() {
        if (this.curContext().token === "function") {
          this.context.pop();
        }
        this.exprAllowed = true;
      };
      types$1.backQuote.updateContext = function() {
        if (this.curContext() === types.q_tmpl) {
          this.context.pop();
        } else {
          this.context.push(types.q_tmpl);
        }
        this.exprAllowed = false;
      };
      types$1.star.updateContext = function(prevType) {
        if (prevType === types$1._function) {
          var index = this.context.length - 1;
          if (this.context[index] === types.f_expr) {
            this.context[index] = types.f_expr_gen;
          } else {
            this.context[index] = types.f_gen;
          }
        }
        this.exprAllowed = true;
      };
      types$1.name.updateContext = function(prevType) {
        var allowed = false;
        if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
          if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
            allowed = true;
          }
        }
        this.exprAllowed = allowed;
      };
      var pp$5 = Parser.prototype;
      pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
          return;
        }
        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
          return;
        }
        var key = prop.key;
        var name2;
        switch (key.type) {
          case "Identifier":
            name2 = key.name;
            break;
          case "Literal":
            name2 = String(key.value);
            break;
          default:
            return;
        }
        var kind = prop.kind;
        if (this.options.ecmaVersion >= 6) {
          if (name2 === "__proto__" && kind === "init") {
            if (propHash.proto) {
              if (refDestructuringErrors) {
                if (refDestructuringErrors.doubleProto < 0) {
                  refDestructuringErrors.doubleProto = key.start;
                }
              } else {
                this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
              }
            }
            propHash.proto = true;
          }
          return;
        }
        name2 = "$" + name2;
        var other = propHash[name2];
        if (other) {
          var redefinition;
          if (kind === "init") {
            redefinition = this.strict && other.init || other.get || other.set;
          } else {
            redefinition = other.init || other[kind];
          }
          if (redefinition) {
            this.raiseRecoverable(key.start, "Redefinition of property");
          }
        } else {
          other = propHash[name2] = {
            init: false,
            get: false,
            set: false
          };
        }
        other[kind] = true;
      };
      pp$5.parseExpression = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
        if (this.type === types$1.comma) {
          var node = this.startNodeAt(startPos, startLoc);
          node.expressions = [expr];
          while (this.eat(types$1.comma)) {
            node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
          }
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      };
      pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) {
            return this.parseYield(forInit);
          } else {
            this.exprAllowed = false;
          }
        }
        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          oldDoubleProto = refDestructuringErrors.doubleProto;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors();
          ownDestructuringErrors = true;
        }
        var startPos = this.start, startLoc = this.startLoc;
        if (this.type === types$1.parenL || this.type === types$1.name) {
          this.potentialArrowAt = this.start;
          this.potentialArrowInForAwait = forInit === "await";
        }
        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }
        if (this.type.isAssign) {
          var node = this.startNodeAt(startPos, startLoc);
          node.operator = this.value;
          if (this.type === types$1.eq) {
            left = this.toAssignable(left, false, refDestructuringErrors);
          }
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= left.start) {
            refDestructuringErrors.shorthandAssign = -1;
          }
          if (this.type === types$1.eq) {
            this.checkLValPattern(left);
          } else {
            this.checkLValSimple(left);
          }
          node.left = left;
          this.next();
          node.right = this.parseMaybeAssign(forInit);
          if (oldDoubleProto > -1) {
            refDestructuringErrors.doubleProto = oldDoubleProto;
          }
          return this.finishNode(node, "AssignmentExpression");
        } else {
          if (ownDestructuringErrors) {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
        }
        if (oldParenAssign > -1) {
          refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        }
        if (oldTrailingComma > -1) {
          refDestructuringErrors.trailingComma = oldTrailingComma;
        }
        return left;
      };
      pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        if (this.eat(types$1.question)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          this.expect(types$1.colon);
          node.alternate = this.parseMaybeAssign(forInit);
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      };
      pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
      };
      pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
        var prec = this.type.binop;
        if (prec != null && (!forInit || this.type !== types$1._in)) {
          if (prec > minPrec) {
            var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
            var coalesce = this.type === types$1.coalesce;
            if (coalesce) {
              prec = types$1.logicalAND.binop;
            }
            var op = this.value;
            this.next();
            var startPos = this.start, startLoc = this.startLoc;
            var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
            var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
            if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
              this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
            }
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
          }
        }
        return left;
      };
      pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
        if (right.type === "PrivateIdentifier") {
          this.raise(right.start, "Private identifier can only be left side of binary expression");
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.operator = op;
        node.right = right;
        return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
      };
      pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && this.canAwait) {
          expr = this.parseAwait(forInit);
          sawUnary = true;
        } else if (this.type.prefix) {
          var node = this.startNode(), update = this.type === types$1.incDec;
          node.operator = this.value;
          node.prefix = true;
          this.next();
          node.argument = this.parseMaybeUnary(null, true, update, forInit);
          this.checkExpressionErrors(refDestructuringErrors, true);
          if (update) {
            this.checkLValSimple(node.argument);
          } else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument)) {
            this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
          } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
            this.raiseRecoverable(node.start, "Private fields can not be deleted");
          } else {
            sawUnary = true;
          }
          expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
        } else if (!sawUnary && this.type === types$1.privateId) {
          if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
            this.unexpected();
          }
          expr = this.parsePrivateIdent();
          if (this.type !== types$1._in) {
            this.unexpected();
          }
        } else {
          expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          while (this.type.postfix && !this.canInsertSemicolon()) {
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.operator = this.value;
            node$1.prefix = false;
            node$1.argument = expr;
            this.checkLValSimple(expr);
            this.next();
            expr = this.finishNode(node$1, "UpdateExpression");
          }
        }
        if (!incDec && this.eat(types$1.starstar)) {
          if (sawUnary) {
            this.unexpected(this.lastTokStart);
          } else {
            return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
          }
        } else {
          return expr;
        }
      };
      function isLocalVariableAccess(node) {
        return node.type === "Identifier" || node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression);
      }
      function isPrivateFieldAccess(node) {
        return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) || node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression);
      }
      pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprAtom(refDestructuringErrors, forInit);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
          return expr;
        }
        var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
        if (refDestructuringErrors && result.type === "MemberExpression") {
          if (refDestructuringErrors.parenthesizedAssign >= result.start) {
            refDestructuringErrors.parenthesizedAssign = -1;
          }
          if (refDestructuringErrors.parenthesizedBind >= result.start) {
            refDestructuringErrors.parenthesizedBind = -1;
          }
          if (refDestructuringErrors.trailingComma >= result.start) {
            refDestructuringErrors.trailingComma = -1;
          }
        }
        return result;
      };
      pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
        var optionalChained = false;
        while (true) {
          var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
          if (element.optional) {
            optionalChained = true;
          }
          if (element === base || element.type === "ArrowFunctionExpression") {
            if (optionalChained) {
              var chainNode = this.startNodeAt(startPos, startLoc);
              chainNode.expression = element;
              element = this.finishNode(chainNode, "ChainExpression");
            }
            return element;
          }
          base = element;
        }
      };
      pp$5.shouldParseAsyncArrow = function() {
        return !this.canInsertSemicolon() && this.eat(types$1.arrow);
      };
      pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
      };
      pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
        var optionalSupported = this.options.ecmaVersion >= 11;
        var optional = optionalSupported && this.eat(types$1.questionDot);
        if (noCalls && optional) {
          this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        }
        var computed = this.eat(types$1.bracketL);
        if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          if (computed) {
            node.property = this.parseExpression();
            this.expect(types$1.bracketR);
          } else if (this.type === types$1.privateId && base.type !== "Super") {
            node.property = this.parsePrivateIdent();
          } else {
            node.property = this.parseIdent(this.options.allowReserved !== "never");
          }
          node.computed = !!computed;
          if (optionalSupported) {
            node.optional = optional;
          }
          base = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(types$1.parenL)) {
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
          if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0) {
              this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
            }
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.callee = base;
          node$1.arguments = exprList;
          if (optionalSupported) {
            node$1.optional = optional;
          }
          base = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types$1.backQuote) {
          if (optional || optionalChained) {
            this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          }
          var node$2 = this.startNodeAt(startPos, startLoc);
          node$2.tag = base;
          node$2.quasi = this.parseTemplate({ isTagged: true });
          base = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base;
      };
      pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
        if (this.type === types$1.slash) {
          this.readRegexp();
        }
        var node, canBeArrow = this.potentialArrowAt === this.start;
        switch (this.type) {
          case types$1._super:
            if (!this.allowSuper) {
              this.raise(this.start, "'super' keyword outside a method");
            }
            node = this.startNode();
            this.next();
            if (this.type === types$1.parenL && !this.allowDirectSuper) {
              this.raise(node.start, "super() call outside constructor of a subclass");
            }
            if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
              this.unexpected();
            }
            return this.finishNode(node, "Super");
          case types$1._this:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression");
          case types$1.name:
            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
            var id = this.parseIdent(false);
            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
              this.overrideContext(types.f_expr);
              return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
            }
            if (canBeArrow && !this.canInsertSemicolon()) {
              if (this.eat(types$1.arrow)) {
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
              }
              if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
                id = this.parseIdent(false);
                if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
                  this.unexpected();
                }
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
              }
            }
            return id;
          case types$1.regexp:
            var value = this.value;
            node = this.parseLiteral(value.value);
            node.regex = { pattern: value.pattern, flags: value.flags };
            return node;
          case types$1.num:
          case types$1.string:
            return this.parseLiteral(this.value);
          case types$1._null:
          case types$1._true:
          case types$1._false:
            node = this.startNode();
            node.value = this.type === types$1._null ? null : this.type === types$1._true;
            node.raw = this.type.keyword;
            this.next();
            return this.finishNode(node, "Literal");
          case types$1.parenL:
            var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
            if (refDestructuringErrors) {
              if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
                refDestructuringErrors.parenthesizedAssign = start;
              }
              if (refDestructuringErrors.parenthesizedBind < 0) {
                refDestructuringErrors.parenthesizedBind = start;
              }
            }
            return expr;
          case types$1.bracketL:
            node = this.startNode();
            this.next();
            node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
            return this.finishNode(node, "ArrayExpression");
          case types$1.braceL:
            this.overrideContext(types.b_expr);
            return this.parseObj(false, refDestructuringErrors);
          case types$1._function:
            node = this.startNode();
            this.next();
            return this.parseFunction(node, 0);
          case types$1._class:
            return this.parseClass(this.startNode(), false);
          case types$1._new:
            return this.parseNew();
          case types$1.backQuote:
            return this.parseTemplate();
          case types$1._import:
            if (this.options.ecmaVersion >= 11) {
              return this.parseExprImport(forNew);
            } else {
              return this.unexpected();
            }
          default:
            return this.parseExprAtomDefault();
        }
      };
      pp$5.parseExprAtomDefault = function() {
        this.unexpected();
      };
      pp$5.parseExprImport = function(forNew) {
        var node = this.startNode();
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        }
        this.next();
        if (this.type === types$1.parenL && !forNew) {
          return this.parseDynamicImport(node);
        } else if (this.type === types$1.dot) {
          var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
          meta.name = "import";
          node.meta = this.finishNode(meta, "Identifier");
          return this.parseImportMeta(node);
        } else {
          this.unexpected();
        }
      };
      pp$5.parseDynamicImport = function(node) {
        this.next();
        node.source = this.parseMaybeAssign();
        if (this.options.ecmaVersion >= 16) {
          if (!this.eat(types$1.parenR)) {
            this.expect(types$1.comma);
            if (!this.afterTrailingComma(types$1.parenR)) {
              node.options = this.parseMaybeAssign();
              if (!this.eat(types$1.parenR)) {
                this.expect(types$1.comma);
                if (!this.afterTrailingComma(types$1.parenR)) {
                  this.unexpected();
                }
              }
            } else {
              node.options = null;
            }
          } else {
            node.options = null;
          }
        } else {
          if (!this.eat(types$1.parenR)) {
            var errorPos = this.start;
            if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
              this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
            } else {
              this.unexpected(errorPos);
            }
          }
        }
        return this.finishNode(node, "ImportExpression");
      };
      pp$5.parseImportMeta = function(node) {
        this.next();
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "meta") {
          this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
        }
        if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
          this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
        }
        return this.finishNode(node, "MetaProperty");
      };
      pp$5.parseLiteral = function(value) {
        var node = this.startNode();
        node.value = value;
        node.raw = this.input.slice(this.start, this.end);
        if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
          node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
        }
        this.next();
        return this.finishNode(node, "Literal");
      };
      pp$5.parseParenExpression = function() {
        this.expect(types$1.parenL);
        var val = this.parseExpression();
        this.expect(types$1.parenR);
        return val;
      };
      pp$5.shouldParseArrow = function(exprList) {
        return !this.canInsertSemicolon();
      };
      pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var innerStartPos = this.start, innerStartLoc = this.startLoc;
          var exprList = [], first = true, lastIsComma = false;
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== types$1.parenR) {
            first ? first = false : this.expect(types$1.comma);
            if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === types$1.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === types$1.comma) {
                this.raiseRecoverable(
                  this.start,
                  "Comma is not permitted after the rest element"
                );
              }
              break;
            } else {
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
          }
          var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
          this.expect(types$1.parenR);
          if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
          }
          if (!exprList.length || lastIsComma) {
            this.unexpected(this.lastTokStart);
          }
          if (spreadStart) {
            this.unexpected(spreadStart);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
          var par = this.startNodeAt(startPos, startLoc);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression");
        } else {
          return val;
        }
      };
      pp$5.parseParenItem = function(item) {
        return item;
      };
      pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
      };
      var empty = [];
      pp$5.parseNew = function() {
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        }
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
          var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
          meta.name = "new";
          node.meta = this.finishNode(meta, "Identifier");
          this.next();
          var containsEsc = this.containsEsc;
          node.property = this.parseIdent(true);
          if (node.property.name !== "target") {
            this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
          }
          if (!this.allowNewDotTarget) {
            this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
          }
          return this.finishNode(node, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc;
        node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
        if (this.eat(types$1.parenL)) {
          node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
        } else {
          node.arguments = empty;
        }
        return this.finishNode(node, "NewExpression");
      };
      pp$5.parseTemplateElement = function(ref2) {
        var isTagged = ref2.isTagged;
        var elem = this.startNode();
        if (this.type === types$1.invalidTemplate) {
          if (!isTagged) {
            this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
          }
          elem.value = {
            raw: this.value.replace(/\r\n?/g, "\n"),
            cooked: null
          };
        } else {
          elem.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
            cooked: this.value
          };
        }
        this.next();
        elem.tail = this.type === types$1.backQuote;
        return this.finishNode(elem, "TemplateElement");
      };
      pp$5.parseTemplate = function(ref2) {
        if (ref2 === void 0) ref2 = {};
        var isTagged = ref2.isTagged;
        if (isTagged === void 0) isTagged = false;
        var node = this.startNode();
        this.next();
        node.expressions = [];
        var curElt = this.parseTemplateElement({ isTagged });
        node.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === types$1.eof) {
            this.raise(this.pos, "Unterminated template literal");
          }
          this.expect(types$1.dollarBraceL);
          node.expressions.push(this.parseExpression());
          this.expect(types$1.braceR);
          node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
      };
      pp$5.isAsyncProp = function(prop) {
        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$5.parseObj = function(isPattern, refDestructuringErrors) {
        var node = this.startNode(), first = true, propHash = {};
        node.properties = [];
        this.next();
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var prop = this.parseProperty(isPattern, refDestructuringErrors);
          if (!isPattern) {
            this.checkPropClash(prop, propHash, refDestructuringErrors);
          }
          node.properties.push(prop);
        }
        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
      };
      pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
          if (isPattern) {
            prop.argument = this.parseIdent(false);
            if (this.type === types$1.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            return this.finishNode(prop, "RestElement");
          }
          prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
          return this.finishNode(prop, "SpreadElement");
        }
        if (this.options.ecmaVersion >= 6) {
          prop.method = false;
          prop.shorthand = false;
          if (isPattern || refDestructuringErrors) {
            startPos = this.start;
            startLoc = this.startLoc;
          }
          if (!isPattern) {
            isGenerator = this.eat(types$1.star);
          }
        }
        var containsEsc = this.containsEsc;
        this.parsePropertyName(prop);
        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
          this.parsePropertyName(prop);
        } else {
          isAsync = false;
        }
        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        return this.finishNode(prop, "Property");
      };
      pp$5.parseGetterSetter = function(prop) {
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
          var start = prop.value.start;
          if (prop.kind === "get") {
            this.raiseRecoverable(start, "getter should have no params");
          } else {
            this.raiseRecoverable(start, "setter should have exactly one param");
          }
        } else {
          if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
            this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
          }
        }
      };
      pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types$1.colon) {
          this.unexpected();
        }
        if (this.eat(types$1.colon)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
          prop.kind = "init";
        } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
          if (isPattern) {
            this.unexpected();
          }
          prop.kind = "init";
          prop.method = true;
          prop.value = this.parseMethod(isGenerator, isAsync);
        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.parseGetterSetter(prop);
        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.checkUnreserved(prop.key);
          if (prop.key.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = startPos;
          }
          prop.kind = "init";
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else if (this.type === types$1.eq && refDestructuringErrors) {
            if (refDestructuringErrors.shorthandAssign < 0) {
              refDestructuringErrors.shorthandAssign = this.start;
            }
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else {
            prop.value = this.copyNode(prop.key);
          }
          prop.shorthand = true;
        } else {
          this.unexpected();
        }
      };
      pp$5.parsePropertyName = function(prop) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(types$1.bracketL)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssign();
            this.expect(types$1.bracketR);
            return prop.key;
          } else {
            prop.computed = false;
          }
        }
        return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      };
      pp$5.initFunction = function(node) {
        node.id = null;
        if (this.options.ecmaVersion >= 6) {
          node.generator = node.expression = false;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = false;
        }
      };
      pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
        var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node);
        if (this.options.ecmaVersion >= 6) {
          node.generator = isGenerator;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node, false, true, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "FunctionExpression");
      };
      pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
        this.initFunction(node);
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        node.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node, true, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "ArrowFunctionExpression");
      };
      pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
        var isExpression = isArrowFunction && this.type !== types$1.braceL;
        var oldStrict = this.strict, useStrict = false;
        if (isExpression) {
          node.body = this.parseMaybeAssign(forInit);
          node.expression = true;
          this.checkParams(node, false);
        } else {
          var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
          if (!oldStrict || nonSimple) {
            useStrict = this.strictDirective(this.end);
            if (useStrict && nonSimple) {
              this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            }
          }
          var oldLabels = this.labels;
          this.labels = [];
          if (useStrict) {
            this.strict = true;
          }
          this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
          if (this.strict && node.id) {
            this.checkLValSimple(node.id, BIND_OUTSIDE);
          }
          node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
          node.expression = false;
          this.adaptDirectivePrologue(node.body.body);
          this.labels = oldLabels;
        }
        this.exitScope();
      };
      pp$5.isSimpleParamList = function(params) {
        for (var i2 = 0, list2 = params; i2 < list2.length; i2 += 1) {
          var param = list2[i2];
          if (param.type !== "Identifier") {
            return false;
          }
        }
        return true;
      };
      pp$5.checkParams = function(node, allowDuplicates) {
        var nameHash = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0, list2 = node.params; i2 < list2.length; i2 += 1) {
          var param = list2[i2];
          this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
        }
      };
      pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (!first) {
            this.expect(types$1.comma);
            if (allowTrailingComma && this.afterTrailingComma(close)) {
              break;
            }
          } else {
            first = false;
          }
          var elt = void 0;
          if (allowEmpty && this.type === types$1.comma) {
            elt = null;
          } else if (this.type === types$1.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = this.start;
            }
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors);
          }
          elts.push(elt);
        }
        return elts;
      };
      pp$5.checkUnreserved = function(ref2) {
        var start = ref2.start;
        var end = ref2.end;
        var name2 = ref2.name;
        if (this.inGenerator && name2 === "yield") {
          this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
        }
        if (this.inAsync && name2 === "await") {
          this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
        }
        if (this.currentThisScope().inClassFieldInit && name2 === "arguments") {
          this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
        }
        if (this.inClassStaticBlock && (name2 === "arguments" || name2 === "await")) {
          this.raise(start, "Cannot use " + name2 + " in class static initialization block");
        }
        if (this.keywords.test(name2)) {
          this.raise(start, "Unexpected keyword '" + name2 + "'");
        }
        if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
          return;
        }
        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
        if (re.test(name2)) {
          if (!this.inAsync && name2 === "await") {
            this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
          }
          this.raiseRecoverable(start, "The keyword '" + name2 + "' is reserved");
        }
      };
      pp$5.parseIdent = function(liberal) {
        var node = this.parseIdentNode();
        this.next(!!liberal);
        this.finishNode(node, "Identifier");
        if (!liberal) {
          this.checkUnreserved(node);
          if (node.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = node.start;
          }
        }
        return node;
      };
      pp$5.parseIdentNode = function() {
        var node = this.startNode();
        if (this.type === types$1.name) {
          node.name = this.value;
        } else if (this.type.keyword) {
          node.name = this.type.keyword;
          if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
            this.context.pop();
          }
          this.type = types$1.name;
        } else {
          this.unexpected();
        }
        return node;
      };
      pp$5.parsePrivateIdent = function() {
        var node = this.startNode();
        if (this.type === types$1.privateId) {
          node.name = this.value;
        } else {
          this.unexpected();
        }
        this.next();
        this.finishNode(node, "PrivateIdentifier");
        if (this.options.checkPrivateFields) {
          if (this.privateNameStack.length === 0) {
            this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
          } else {
            this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
          }
        }
        return node;
      };
      pp$5.parseYield = function(forInit) {
        if (!this.yieldPos) {
          this.yieldPos = this.start;
        }
        var node = this.startNode();
        this.next();
        if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
          node.delegate = false;
          node.argument = null;
        } else {
          node.delegate = this.eat(types$1.star);
          node.argument = this.parseMaybeAssign(forInit);
        }
        return this.finishNode(node, "YieldExpression");
      };
      pp$5.parseAwait = function(forInit) {
        if (!this.awaitPos) {
          this.awaitPos = this.start;
        }
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeUnary(null, true, false, forInit);
        return this.finishNode(node, "AwaitExpression");
      };
      var pp$4 = Parser.prototype;
      pp$4.raise = function(pos, message) {
        var loc = getLineInfo(this.input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        var err = new SyntaxError(message);
        err.pos = pos;
        err.loc = loc;
        err.raisedAt = this.pos;
        throw err;
      };
      pp$4.raiseRecoverable = pp$4.raise;
      pp$4.curPosition = function() {
        if (this.options.locations) {
          return new Position3(this.curLine, this.pos - this.lineStart);
        }
      };
      var pp$3 = Parser.prototype;
      var Scope = function Scope2(flags) {
        this.flags = flags;
        this.var = [];
        this.lexical = [];
        this.functions = [];
        this.inClassFieldInit = false;
      };
      pp$3.enterScope = function(flags) {
        this.scopeStack.push(new Scope(flags));
      };
      pp$3.exitScope = function() {
        this.scopeStack.pop();
      };
      pp$3.treatFunctionsAsVarInScope = function(scope) {
        return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
      };
      pp$3.declareName = function(name2, bindingType, pos) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL) {
          var scope = this.currentScope();
          redeclared = scope.lexical.indexOf(name2) > -1 || scope.functions.indexOf(name2) > -1 || scope.var.indexOf(name2) > -1;
          scope.lexical.push(name2);
          if (this.inModule && scope.flags & SCOPE_TOP) {
            delete this.undefinedExports[name2];
          }
        } else if (bindingType === BIND_SIMPLE_CATCH) {
          var scope$1 = this.currentScope();
          scope$1.lexical.push(name2);
        } else if (bindingType === BIND_FUNCTION) {
          var scope$2 = this.currentScope();
          if (this.treatFunctionsAsVar) {
            redeclared = scope$2.lexical.indexOf(name2) > -1;
          } else {
            redeclared = scope$2.lexical.indexOf(name2) > -1 || scope$2.var.indexOf(name2) > -1;
          }
          scope$2.functions.push(name2);
        } else {
          for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
            var scope$3 = this.scopeStack[i2];
            if (scope$3.lexical.indexOf(name2) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name2) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name2) > -1) {
              redeclared = true;
              break;
            }
            scope$3.var.push(name2);
            if (this.inModule && scope$3.flags & SCOPE_TOP) {
              delete this.undefinedExports[name2];
            }
            if (scope$3.flags & SCOPE_VAR) {
              break;
            }
          }
        }
        if (redeclared) {
          this.raiseRecoverable(pos, "Identifier '" + name2 + "' has already been declared");
        }
      };
      pp$3.checkLocalExport = function(id) {
        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
          this.undefinedExports[id.name] = id;
        }
      };
      pp$3.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
      };
      pp$3.currentVarScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.flags & SCOPE_VAR) {
            return scope;
          }
        }
      };
      pp$3.currentThisScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
            return scope;
          }
        }
      };
      var Node2 = function Node3(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        if (parser.options.locations) {
          this.loc = new SourceLocation(parser, loc);
        }
        if (parser.options.directSourceFile) {
          this.sourceFile = parser.options.directSourceFile;
        }
        if (parser.options.ranges) {
          this.range = [pos, 0];
        }
      };
      var pp$2 = Parser.prototype;
      pp$2.startNode = function() {
        return new Node2(this, this.start, this.startLoc);
      };
      pp$2.startNodeAt = function(pos, loc) {
        return new Node2(this, pos, loc);
      };
      function finishNodeAt(node, type, pos, loc) {
        node.type = type;
        node.end = pos;
        if (this.options.locations) {
          node.loc.end = loc;
        }
        if (this.options.ranges) {
          node.range[1] = pos;
        }
        return node;
      }
      pp$2.finishNode = function(node, type) {
        return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
      };
      pp$2.finishNodeAt = function(node, type, pos, loc) {
        return finishNodeAt.call(this, node, type, pos, loc);
      };
      pp$2.copyNode = function(node) {
        var newNode = new Node2(this, node.start, this.startLoc);
        for (var prop in node) {
          newNode[prop] = node[prop];
        }
        return newNode;
      };
      var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
      var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
      var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
      var ecma11BinaryProperties = ecma10BinaryProperties;
      var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
      var ecma13BinaryProperties = ecma12BinaryProperties;
      var ecma14BinaryProperties = ecma13BinaryProperties;
      var unicodeBinaryProperties = {
        9: ecma9BinaryProperties,
        10: ecma10BinaryProperties,
        11: ecma11BinaryProperties,
        12: ecma12BinaryProperties,
        13: ecma13BinaryProperties,
        14: ecma14BinaryProperties
      };
      var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
      var unicodeBinaryPropertiesOfStrings = {
        9: "",
        10: "",
        11: "",
        12: "",
        13: "",
        14: ecma14BinaryPropertiesOfStrings
      };
      var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
      var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
      var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
      var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
      var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
      var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
      var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
      var unicodeScriptValues = {
        9: ecma9ScriptValues,
        10: ecma10ScriptValues,
        11: ecma11ScriptValues,
        12: ecma12ScriptValues,
        13: ecma13ScriptValues,
        14: ecma14ScriptValues
      };
      var data = {};
      function buildUnicodeData(ecmaVersion2) {
        var d = data[ecmaVersion2] = {
          binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion2] + " " + unicodeGeneralCategoryValues),
          binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion2]),
          nonBinary: {
            General_Category: wordsRegexp(unicodeGeneralCategoryValues),
            Script: wordsRegexp(unicodeScriptValues[ecmaVersion2])
          }
        };
        d.nonBinary.Script_Extensions = d.nonBinary.Script;
        d.nonBinary.gc = d.nonBinary.General_Category;
        d.nonBinary.sc = d.nonBinary.Script;
        d.nonBinary.scx = d.nonBinary.Script_Extensions;
      }
      for (var i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {
        var ecmaVersion = list[i];
        buildUnicodeData(ecmaVersion);
      }
      var pp$1 = Parser.prototype;
      var BranchID = function BranchID2(parent, base) {
        this.parent = parent;
        this.base = base || this;
      };
      BranchID.prototype.separatedFrom = function separatedFrom(alt) {
        for (var self2 = this; self2; self2 = self2.parent) {
          for (var other = alt; other; other = other.parent) {
            if (self2.base === other.base && self2 !== other) {
              return true;
            }
          }
        }
        return false;
      };
      BranchID.prototype.sibling = function sibling() {
        return new BranchID(this.parent, this.base);
      };
      var RegExpValidationState = function RegExpValidationState2(parser) {
        this.parser = parser;
        this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
        this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
        this.source = "";
        this.flags = "";
        this.start = 0;
        this.switchU = false;
        this.switchV = false;
        this.switchN = false;
        this.pos = 0;
        this.lastIntValue = 0;
        this.lastStringValue = "";
        this.lastAssertionIsQuantifiable = false;
        this.numCapturingParens = 0;
        this.maxBackReference = 0;
        this.groupNames = /* @__PURE__ */ Object.create(null);
        this.backReferenceNames = [];
        this.branchID = null;
      };
      RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
        var unicodeSets = flags.indexOf("v") !== -1;
        var unicode = flags.indexOf("u") !== -1;
        this.start = start | 0;
        this.source = pattern + "";
        this.flags = flags;
        if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
          this.switchU = true;
          this.switchV = true;
          this.switchN = true;
        } else {
          this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
          this.switchV = false;
          this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
        }
      };
      RegExpValidationState.prototype.raise = function raise(message) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
      };
      RegExpValidationState.prototype.at = function at(i2, forceU) {
        if (forceU === void 0) forceU = false;
        var s = this.source;
        var l = s.length;
        if (i2 >= l) {
          return -1;
        }
        var c = s.charCodeAt(i2);
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l) {
          return c;
        }
        var next = s.charCodeAt(i2 + 1);
        return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
      };
      RegExpValidationState.prototype.nextIndex = function nextIndex(i2, forceU) {
        if (forceU === void 0) forceU = false;
        var s = this.source;
        var l = s.length;
        if (i2 >= l) {
          return l;
        }
        var c = s.charCodeAt(i2), next;
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l || (next = s.charCodeAt(i2 + 1)) < 56320 || next > 57343) {
          return i2 + 1;
        }
        return i2 + 2;
      };
      RegExpValidationState.prototype.current = function current(forceU) {
        if (forceU === void 0) forceU = false;
        return this.at(this.pos, forceU);
      };
      RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
        if (forceU === void 0) forceU = false;
        return this.at(this.nextIndex(this.pos, forceU), forceU);
      };
      RegExpValidationState.prototype.advance = function advance(forceU) {
        if (forceU === void 0) forceU = false;
        this.pos = this.nextIndex(this.pos, forceU);
      };
      RegExpValidationState.prototype.eat = function eat(ch, forceU) {
        if (forceU === void 0) forceU = false;
        if (this.current(forceU) === ch) {
          this.advance(forceU);
          return true;
        }
        return false;
      };
      RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
        if (forceU === void 0) forceU = false;
        var pos = this.pos;
        for (var i2 = 0, list2 = chs; i2 < list2.length; i2 += 1) {
          var ch = list2[i2];
          var current = this.at(pos, forceU);
          if (current === -1 || current !== ch) {
            return false;
          }
          pos = this.nextIndex(pos, forceU);
        }
        this.pos = pos;
        return true;
      };
      pp$1.validateRegExpFlags = function(state) {
        var validFlags = state.validFlags;
        var flags = state.flags;
        var u = false;
        var v = false;
        for (var i2 = 0; i2 < flags.length; i2++) {
          var flag = flags.charAt(i2);
          if (validFlags.indexOf(flag) === -1) {
            this.raise(state.start, "Invalid regular expression flag");
          }
          if (flags.indexOf(flag, i2 + 1) > -1) {
            this.raise(state.start, "Duplicate regular expression flag");
          }
          if (flag === "u") {
            u = true;
          }
          if (flag === "v") {
            v = true;
          }
        }
        if (this.options.ecmaVersion >= 15 && u && v) {
          this.raise(state.start, "Invalid regular expression flag");
        }
      };
      function hasProp(obj) {
        for (var _ in obj) {
          return true;
        }
        return false;
      }
      pp$1.validateRegExpPattern = function(state) {
        this.regexp_pattern(state);
        if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
          state.switchN = true;
          this.regexp_pattern(state);
        }
      };
      pp$1.regexp_pattern = function(state) {
        state.pos = 0;
        state.lastIntValue = 0;
        state.lastStringValue = "";
        state.lastAssertionIsQuantifiable = false;
        state.numCapturingParens = 0;
        state.maxBackReference = 0;
        state.groupNames = /* @__PURE__ */ Object.create(null);
        state.backReferenceNames.length = 0;
        state.branchID = null;
        this.regexp_disjunction(state);
        if (state.pos !== state.source.length) {
          if (state.eat(
            41
            /* ) */
          )) {
            state.raise("Unmatched ')'");
          }
          if (state.eat(
            93
            /* ] */
          ) || state.eat(
            125
            /* } */
          )) {
            state.raise("Lone quantifier brackets");
          }
        }
        if (state.maxBackReference > state.numCapturingParens) {
          state.raise("Invalid escape");
        }
        for (var i2 = 0, list2 = state.backReferenceNames; i2 < list2.length; i2 += 1) {
          var name2 = list2[i2];
          if (!state.groupNames[name2]) {
            state.raise("Invalid named capture referenced");
          }
        }
      };
      pp$1.regexp_disjunction = function(state) {
        var trackDisjunction = this.options.ecmaVersion >= 16;
        if (trackDisjunction) {
          state.branchID = new BranchID(state.branchID, null);
        }
        this.regexp_alternative(state);
        while (state.eat(
          124
          /* | */
        )) {
          if (trackDisjunction) {
            state.branchID = state.branchID.sibling();
          }
          this.regexp_alternative(state);
        }
        if (trackDisjunction) {
          state.branchID = state.branchID.parent;
        }
        if (this.regexp_eatQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        if (state.eat(
          123
          /* { */
        )) {
          state.raise("Lone quantifier brackets");
        }
      };
      pp$1.regexp_alternative = function(state) {
        while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
        }
      };
      pp$1.regexp_eatTerm = function(state) {
        if (this.regexp_eatAssertion(state)) {
          if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
            if (state.switchU) {
              state.raise("Invalid quantifier");
            }
          }
          return true;
        }
        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
          this.regexp_eatQuantifier(state);
          return true;
        }
        return false;
      };
      pp$1.regexp_eatAssertion = function(state) {
        var start = state.pos;
        state.lastAssertionIsQuantifiable = false;
        if (state.eat(
          94
          /* ^ */
        ) || state.eat(
          36
          /* $ */
        )) {
          return true;
        }
        if (state.eat(
          92
          /* \ */
        )) {
          if (state.eat(
            66
            /* B */
          ) || state.eat(
            98
            /* b */
          )) {
            return true;
          }
          state.pos = start;
        }
        if (state.eat(
          40
          /* ( */
        ) && state.eat(
          63
          /* ? */
        )) {
          var lookbehind = false;
          if (this.options.ecmaVersion >= 9) {
            lookbehind = state.eat(
              60
              /* < */
            );
          }
          if (state.eat(
            61
            /* = */
          ) || state.eat(
            33
            /* ! */
          )) {
            this.regexp_disjunction(state);
            if (!state.eat(
              41
              /* ) */
            )) {
              state.raise("Unterminated group");
            }
            state.lastAssertionIsQuantifiable = !lookbehind;
            return true;
          }
        }
        state.pos = start;
        return false;
      };
      pp$1.regexp_eatQuantifier = function(state, noError) {
        if (noError === void 0) noError = false;
        if (this.regexp_eatQuantifierPrefix(state, noError)) {
          state.eat(
            63
            /* ? */
          );
          return true;
        }
        return false;
      };
      pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
        return state.eat(
          42
          /* * */
        ) || state.eat(
          43
          /* + */
        ) || state.eat(
          63
          /* ? */
        ) || this.regexp_eatBracedQuantifier(state, noError);
      };
      pp$1.regexp_eatBracedQuantifier = function(state, noError) {
        var start = state.pos;
        if (state.eat(
          123
          /* { */
        )) {
          var min = 0, max = -1;
          if (this.regexp_eatDecimalDigits(state)) {
            min = state.lastIntValue;
            if (state.eat(
              44
              /* , */
            ) && this.regexp_eatDecimalDigits(state)) {
              max = state.lastIntValue;
            }
            if (state.eat(
              125
              /* } */
            )) {
              if (max !== -1 && max < min && !noError) {
                state.raise("numbers out of order in {} quantifier");
              }
              return true;
            }
          }
          if (state.switchU && !noError) {
            state.raise("Incomplete quantifier");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatAtom = function(state) {
        return this.regexp_eatPatternCharacters(state) || state.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
      };
      pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatAtomEscape(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatUncapturingGroup = function(state) {
        var start = state.pos;
        if (state.eat(
          40
          /* ( */
        )) {
          if (state.eat(
            63
            /* ? */
          )) {
            if (this.options.ecmaVersion >= 16) {
              var addModifiers = this.regexp_eatModifiers(state);
              var hasHyphen = state.eat(
                45
                /* - */
              );
              if (addModifiers || hasHyphen) {
                for (var i2 = 0; i2 < addModifiers.length; i2++) {
                  var modifier = addModifiers.charAt(i2);
                  if (addModifiers.indexOf(modifier, i2 + 1) > -1) {
                    state.raise("Duplicate regular expression modifiers");
                  }
                }
                if (hasHyphen) {
                  var removeModifiers = this.regexp_eatModifiers(state);
                  if (!addModifiers && !removeModifiers && state.current() === 58) {
                    state.raise("Invalid regular expression modifiers");
                  }
                  for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
                    var modifier$1 = removeModifiers.charAt(i$1);
                    if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {
                      state.raise("Duplicate regular expression modifiers");
                    }
                  }
                }
              }
            }
            if (state.eat(
              58
              /* : */
            )) {
              this.regexp_disjunction(state);
              if (state.eat(
                41
                /* ) */
              )) {
                return true;
              }
              state.raise("Unterminated group");
            }
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatCapturingGroup = function(state) {
        if (state.eat(
          40
          /* ( */
        )) {
          if (this.options.ecmaVersion >= 9) {
            this.regexp_groupSpecifier(state);
          } else if (state.current() === 63) {
            state.raise("Invalid group");
          }
          this.regexp_disjunction(state);
          if (state.eat(
            41
            /* ) */
          )) {
            state.numCapturingParens += 1;
            return true;
          }
          state.raise("Unterminated group");
        }
        return false;
      };
      pp$1.regexp_eatModifiers = function(state) {
        var modifiers2 = "";
        var ch = 0;
        while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
          modifiers2 += codePointToString(ch);
          state.advance();
        }
        return modifiers2;
      };
      function isRegularExpressionModifier(ch) {
        return ch === 105 || ch === 109 || ch === 115;
      }
      pp$1.regexp_eatExtendedAtom = function(state) {
        return state.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
      };
      pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
        if (this.regexp_eatBracedQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        return false;
      };
      pp$1.regexp_eatSyntaxCharacter = function(state) {
        var ch = state.current();
        if (isSyntaxCharacter(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isSyntaxCharacter(ch) {
        return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
      }
      pp$1.regexp_eatPatternCharacters = function(state) {
        var start = state.pos;
        var ch = 0;
        while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
          state.advance();
        }
        return state.pos !== start;
      };
      pp$1.regexp_eatExtendedPatternCharacter = function(state) {
        var ch = state.current();
        if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_groupSpecifier = function(state) {
        if (state.eat(
          63
          /* ? */
        )) {
          if (!this.regexp_eatGroupName(state)) {
            state.raise("Invalid group");
          }
          var trackDisjunction = this.options.ecmaVersion >= 16;
          var known = state.groupNames[state.lastStringValue];
          if (known) {
            if (trackDisjunction) {
              for (var i2 = 0, list2 = known; i2 < list2.length; i2 += 1) {
                var altID = list2[i2];
                if (!altID.separatedFrom(state.branchID)) {
                  state.raise("Duplicate capture group name");
                }
              }
            } else {
              state.raise("Duplicate capture group name");
            }
          }
          if (trackDisjunction) {
            (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
          } else {
            state.groupNames[state.lastStringValue] = true;
          }
        }
      };
      pp$1.regexp_eatGroupName = function(state) {
        state.lastStringValue = "";
        if (state.eat(
          60
          /* < */
        )) {
          if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
            62
            /* > */
          )) {
            return true;
          }
          state.raise("Invalid capture group name");
        }
        return false;
      };
      pp$1.regexp_eatRegExpIdentifierName = function(state) {
        state.lastStringValue = "";
        if (this.regexp_eatRegExpIdentifierStart(state)) {
          state.lastStringValue += codePointToString(state.lastIntValue);
          while (this.regexp_eatRegExpIdentifierPart(state)) {
            state.lastStringValue += codePointToString(state.lastIntValue);
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_eatRegExpIdentifierStart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierStart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierStart(ch) {
        return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
      }
      pp$1.regexp_eatRegExpIdentifierPart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierPart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierPart(ch) {
        return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
      }
      pp$1.regexp_eatAtomEscape = function(state) {
        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
          return true;
        }
        if (state.switchU) {
          if (state.current() === 99) {
            state.raise("Invalid unicode escape");
          }
          state.raise("Invalid escape");
        }
        return false;
      };
      pp$1.regexp_eatBackReference = function(state) {
        var start = state.pos;
        if (this.regexp_eatDecimalEscape(state)) {
          var n2 = state.lastIntValue;
          if (state.switchU) {
            if (n2 > state.maxBackReference) {
              state.maxBackReference = n2;
            }
            return true;
          }
          if (n2 <= state.numCapturingParens) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatKGroupName = function(state) {
        if (state.eat(
          107
          /* k */
        )) {
          if (this.regexp_eatGroupName(state)) {
            state.backReferenceNames.push(state.lastStringValue);
            return true;
          }
          state.raise("Invalid named reference");
        }
        return false;
      };
      pp$1.regexp_eatCharacterEscape = function(state) {
        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
      };
      pp$1.regexp_eatCControlLetter = function(state) {
        var start = state.pos;
        if (state.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatZero = function(state) {
        if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
          state.lastIntValue = 0;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatControlEscape = function(state) {
        var ch = state.current();
        if (ch === 116) {
          state.lastIntValue = 9;
          state.advance();
          return true;
        }
        if (ch === 110) {
          state.lastIntValue = 10;
          state.advance();
          return true;
        }
        if (ch === 118) {
          state.lastIntValue = 11;
          state.advance();
          return true;
        }
        if (ch === 102) {
          state.lastIntValue = 12;
          state.advance();
          return true;
        }
        if (ch === 114) {
          state.lastIntValue = 13;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatControlLetter = function(state) {
        var ch = state.current();
        if (isControlLetter(ch)) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      function isControlLetter(ch) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
      }
      pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
        if (forceU === void 0) forceU = false;
        var start = state.pos;
        var switchU = forceU || state.switchU;
        if (state.eat(
          117
          /* u */
        )) {
          if (this.regexp_eatFixedHexDigits(state, 4)) {
            var lead = state.lastIntValue;
            if (switchU && lead >= 55296 && lead <= 56319) {
              var leadSurrogateEnd = state.pos;
              if (state.eat(
                92
                /* \ */
              ) && state.eat(
                117
                /* u */
              ) && this.regexp_eatFixedHexDigits(state, 4)) {
                var trail = state.lastIntValue;
                if (trail >= 56320 && trail <= 57343) {
                  state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                  return true;
                }
              }
              state.pos = leadSurrogateEnd;
              state.lastIntValue = lead;
            }
            return true;
          }
          if (switchU && state.eat(
            123
            /* { */
          ) && this.regexp_eatHexDigits(state) && state.eat(
            125
            /* } */
          ) && isValidUnicode(state.lastIntValue)) {
            return true;
          }
          if (switchU) {
            state.raise("Invalid unicode escape");
          }
          state.pos = start;
        }
        return false;
      };
      function isValidUnicode(ch) {
        return ch >= 0 && ch <= 1114111;
      }
      pp$1.regexp_eatIdentityEscape = function(state) {
        if (state.switchU) {
          if (this.regexp_eatSyntaxCharacter(state)) {
            return true;
          }
          if (state.eat(
            47
            /* / */
          )) {
            state.lastIntValue = 47;
            return true;
          }
          return false;
        }
        var ch = state.current();
        if (ch !== 99 && (!state.switchN || ch !== 107)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatDecimalEscape = function(state) {
        state.lastIntValue = 0;
        var ch = state.current();
        if (ch >= 49 && ch <= 57) {
          do {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
            state.advance();
          } while ((ch = state.current()) >= 48 && ch <= 57);
          return true;
        }
        return false;
      };
      var CharSetNone = 0;
      var CharSetOk = 1;
      var CharSetString = 2;
      pp$1.regexp_eatCharacterClassEscape = function(state) {
        var ch = state.current();
        if (isCharacterClassEscape(ch)) {
          state.lastIntValue = -1;
          state.advance();
          return CharSetOk;
        }
        var negate = false;
        if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
          state.lastIntValue = -1;
          state.advance();
          var result;
          if (state.eat(
            123
            /* { */
          ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
            125
            /* } */
          )) {
            if (negate && result === CharSetString) {
              state.raise("Invalid property name");
            }
            return result;
          }
          state.raise("Invalid property name");
        }
        return CharSetNone;
      };
      function isCharacterClassEscape(ch) {
        return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
      }
      pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
        var start = state.pos;
        if (this.regexp_eatUnicodePropertyName(state) && state.eat(
          61
          /* = */
        )) {
          var name2 = state.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(state)) {
            var value = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameAndValue(state, name2, value);
            return CharSetOk;
          }
        }
        state.pos = start;
        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
          var nameOrValue = state.lastStringValue;
          return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        }
        return CharSetNone;
      };
      pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name2, value) {
        if (!hasOwn(state.unicodeProperties.nonBinary, name2)) {
          state.raise("Invalid property name");
        }
        if (!state.unicodeProperties.nonBinary[name2].test(value)) {
          state.raise("Invalid property value");
        }
      };
      pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
        if (state.unicodeProperties.binary.test(nameOrValue)) {
          return CharSetOk;
        }
        if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
          return CharSetString;
        }
        state.raise("Invalid property name");
      };
      pp$1.regexp_eatUnicodePropertyName = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyNameCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyNameCharacter(ch) {
        return isControlLetter(ch) || ch === 95;
      }
      pp$1.regexp_eatUnicodePropertyValue = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyValueCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyValueCharacter(ch) {
        return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
      }
      pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
        return this.regexp_eatUnicodePropertyValue(state);
      };
      pp$1.regexp_eatCharacterClass = function(state) {
        if (state.eat(
          91
          /* [ */
        )) {
          var negate = state.eat(
            94
            /* ^ */
          );
          var result = this.regexp_classContents(state);
          if (!state.eat(
            93
            /* ] */
          )) {
            state.raise("Unterminated character class");
          }
          if (negate && result === CharSetString) {
            state.raise("Negated character class may contain strings");
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_classContents = function(state) {
        if (state.current() === 93) {
          return CharSetOk;
        }
        if (state.switchV) {
          return this.regexp_classSetExpression(state);
        }
        this.regexp_nonEmptyClassRanges(state);
        return CharSetOk;
      };
      pp$1.regexp_nonEmptyClassRanges = function(state) {
        while (this.regexp_eatClassAtom(state)) {
          var left = state.lastIntValue;
          if (state.eat(
            45
            /* - */
          ) && this.regexp_eatClassAtom(state)) {
            var right = state.lastIntValue;
            if (state.switchU && (left === -1 || right === -1)) {
              state.raise("Invalid character class");
            }
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
          }
        }
      };
      pp$1.regexp_eatClassAtom = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatClassEscape(state)) {
            return true;
          }
          if (state.switchU) {
            var ch$1 = state.current();
            if (ch$1 === 99 || isOctalDigit(ch$1)) {
              state.raise("Invalid class escape");
            }
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        var ch = state.current();
        if (ch !== 93) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatClassEscape = function(state) {
        var start = state.pos;
        if (state.eat(
          98
          /* b */
        )) {
          state.lastIntValue = 8;
          return true;
        }
        if (state.switchU && state.eat(
          45
          /* - */
        )) {
          state.lastIntValue = 45;
          return true;
        }
        if (!state.switchU && state.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatClassControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
      };
      pp$1.regexp_classSetExpression = function(state) {
        var result = CharSetOk, subResult;
        if (this.regexp_eatClassSetRange(state)) ;
        else if (subResult = this.regexp_eatClassSetOperand(state)) {
          if (subResult === CharSetString) {
            result = CharSetString;
          }
          var start = state.pos;
          while (state.eatChars(
            [38, 38]
            /* && */
          )) {
            if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
              if (subResult !== CharSetString) {
                result = CharSetOk;
              }
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start !== state.pos) {
            return result;
          }
          while (state.eatChars(
            [45, 45]
            /* -- */
          )) {
            if (this.regexp_eatClassSetOperand(state)) {
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start !== state.pos) {
            return result;
          }
        } else {
          state.raise("Invalid character in character class");
        }
        for (; ; ) {
          if (this.regexp_eatClassSetRange(state)) {
            continue;
          }
          subResult = this.regexp_eatClassSetOperand(state);
          if (!subResult) {
            return result;
          }
          if (subResult === CharSetString) {
            result = CharSetString;
          }
        }
      };
      pp$1.regexp_eatClassSetRange = function(state) {
        var start = state.pos;
        if (this.regexp_eatClassSetCharacter(state)) {
          var left = state.lastIntValue;
          if (state.eat(
            45
            /* - */
          ) && this.regexp_eatClassSetCharacter(state)) {
            var right = state.lastIntValue;
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatClassSetOperand = function(state) {
        if (this.regexp_eatClassSetCharacter(state)) {
          return CharSetOk;
        }
        return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
      };
      pp$1.regexp_eatNestedClass = function(state) {
        var start = state.pos;
        if (state.eat(
          91
          /* [ */
        )) {
          var negate = state.eat(
            94
            /* ^ */
          );
          var result = this.regexp_classContents(state);
          if (state.eat(
            93
            /* ] */
          )) {
            if (negate && result === CharSetString) {
              state.raise("Negated character class may contain strings");
            }
            return result;
          }
          state.pos = start;
        }
        if (state.eat(
          92
          /* \ */
        )) {
          var result$1 = this.regexp_eatCharacterClassEscape(state);
          if (result$1) {
            return result$1;
          }
          state.pos = start;
        }
        return null;
      };
      pp$1.regexp_eatClassStringDisjunction = function(state) {
        var start = state.pos;
        if (state.eatChars(
          [92, 113]
          /* \q */
        )) {
          if (state.eat(
            123
            /* { */
          )) {
            var result = this.regexp_classStringDisjunctionContents(state);
            if (state.eat(
              125
              /* } */
            )) {
              return result;
            }
          } else {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return null;
      };
      pp$1.regexp_classStringDisjunctionContents = function(state) {
        var result = this.regexp_classString(state);
        while (state.eat(
          124
          /* | */
        )) {
          if (this.regexp_classString(state) === CharSetString) {
            result = CharSetString;
          }
        }
        return result;
      };
      pp$1.regexp_classString = function(state) {
        var count = 0;
        while (this.regexp_eatClassSetCharacter(state)) {
          count++;
        }
        return count === 1 ? CharSetOk : CharSetString;
      };
      pp$1.regexp_eatClassSetCharacter = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
            return true;
          }
          if (state.eat(
            98
            /* b */
          )) {
            state.lastIntValue = 8;
            return true;
          }
          state.pos = start;
          return false;
        }
        var ch = state.current();
        if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
          return false;
        }
        if (isClassSetSyntaxCharacter(ch)) {
          return false;
        }
        state.advance();
        state.lastIntValue = ch;
        return true;
      };
      function isClassSetReservedDoublePunctuatorCharacter(ch) {
        return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
      }
      function isClassSetSyntaxCharacter(ch) {
        return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
      }
      pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
        var ch = state.current();
        if (isClassSetReservedPunctuator(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isClassSetReservedPunctuator(ch) {
        return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
      }
      pp$1.regexp_eatClassControlLetter = function(state) {
        var ch = state.current();
        if (isDecimalDigit(ch) || ch === 95) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatHexEscapeSequence = function(state) {
        var start = state.pos;
        if (state.eat(
          120
          /* x */
        )) {
          if (this.regexp_eatFixedHexDigits(state, 2)) {
            return true;
          }
          if (state.switchU) {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatDecimalDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isDecimalDigit(ch = state.current())) {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        }
        return state.pos !== start;
      };
      function isDecimalDigit(ch) {
        return ch >= 48 && ch <= 57;
      }
      pp$1.regexp_eatHexDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isHexDigit(ch = state.current())) {
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return state.pos !== start;
      };
      function isHexDigit(ch) {
        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
      }
      function hexToInt(ch) {
        if (ch >= 65 && ch <= 70) {
          return 10 + (ch - 65);
        }
        if (ch >= 97 && ch <= 102) {
          return 10 + (ch - 97);
        }
        return ch - 48;
      }
      pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
        if (this.regexp_eatOctalDigit(state)) {
          var n1 = state.lastIntValue;
          if (this.regexp_eatOctalDigit(state)) {
            var n2 = state.lastIntValue;
            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
              state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
            } else {
              state.lastIntValue = n1 * 8 + n2;
            }
          } else {
            state.lastIntValue = n1;
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_eatOctalDigit = function(state) {
        var ch = state.current();
        if (isOctalDigit(ch)) {
          state.lastIntValue = ch - 48;
          state.advance();
          return true;
        }
        state.lastIntValue = 0;
        return false;
      };
      function isOctalDigit(ch) {
        return ch >= 48 && ch <= 55;
      }
      pp$1.regexp_eatFixedHexDigits = function(state, length) {
        var start = state.pos;
        state.lastIntValue = 0;
        for (var i2 = 0; i2 < length; ++i2) {
          var ch = state.current();
          if (!isHexDigit(ch)) {
            state.pos = start;
            return false;
          }
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return true;
      };
      var Token = function Token2(p) {
        this.type = p.type;
        this.value = p.value;
        this.start = p.start;
        this.end = p.end;
        if (p.options.locations) {
          this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
        }
        if (p.options.ranges) {
          this.range = [p.start, p.end];
        }
      };
      var pp = Parser.prototype;
      pp.next = function(ignoreEscapeSequenceInKeyword) {
        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
        }
        if (this.options.onToken) {
          this.options.onToken(new Token(this));
        }
        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
      };
      pp.getToken = function() {
        this.next();
        return new Token(this);
      };
      if (typeof Symbol !== "undefined") {
        pp[Symbol.iterator] = function() {
          var this$1$1 = this;
          return {
            next: function() {
              var token = this$1$1.getToken();
              return {
                done: token.type === types$1.eof,
                value: token
              };
            }
          };
        };
      }
      pp.nextToken = function() {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) {
          this.skipSpace();
        }
        this.start = this.pos;
        if (this.options.locations) {
          this.startLoc = this.curPosition();
        }
        if (this.pos >= this.input.length) {
          return this.finishToken(types$1.eof);
        }
        if (curContext.override) {
          return curContext.override(this);
        } else {
          this.readToken(this.fullCharCodeAtPos());
        }
      };
      pp.readToken = function(code) {
        if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
          return this.readWord();
        }
        return this.getTokenFromCode(code);
      };
      pp.fullCharCodeAtPos = function() {
        var code = this.input.charCodeAt(this.pos);
        if (code <= 55295 || code >= 56320) {
          return code;
        }
        var next = this.input.charCodeAt(this.pos + 1);
        return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
      };
      pp.skipBlockComment = function() {
        var startLoc = this.options.onComment && this.curPosition();
        var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) {
          this.raise(this.pos - 2, "Unterminated comment");
        }
        this.pos = end + 2;
        if (this.options.locations) {
          for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
            ++this.curLine;
            pos = this.lineStart = nextBreak;
          }
        }
        if (this.options.onComment) {
          this.options.onComment(
            true,
            this.input.slice(start + 2, end),
            start,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      };
      pp.skipLineComment = function(startSkip) {
        var start = this.pos;
        var startLoc = this.options.onComment && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.options.onComment) {
          this.options.onComment(
            false,
            this.input.slice(start + startSkip, this.pos),
            start,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      };
      pp.skipSpace = function() {
        loop: while (this.pos < this.input.length) {
          var ch = this.input.charCodeAt(this.pos);
          switch (ch) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.pos + 1) === 10) {
                ++this.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.pos;
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break loop;
              }
              break;
            default:
              if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                ++this.pos;
              } else {
                break loop;
              }
          }
        }
      };
      pp.finishToken = function(type, val) {
        this.end = this.pos;
        if (this.options.locations) {
          this.endLoc = this.curPosition();
        }
        var prevType = this.type;
        this.type = type;
        this.value = val;
        this.updateContext(prevType);
      };
      pp.readToken_dot = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) {
          return this.readNumber(true);
        }
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
          this.pos += 3;
          return this.finishToken(types$1.ellipsis);
        } else {
          ++this.pos;
          return this.finishToken(types$1.dot);
        }
      };
      pp.readToken_slash = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) {
          ++this.pos;
          return this.readRegexp();
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.slash, 1);
      };
      pp.readToken_mult_modulo_exp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        var tokentype = code === 42 ? types$1.star : types$1.modulo;
        if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
          ++size;
          tokentype = types$1.starstar;
          next = this.input.charCodeAt(this.pos + 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, size + 1);
        }
        return this.finishOp(tokentype, size);
      };
      pp.readToken_pipe_amp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (this.options.ecmaVersion >= 12) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 === 61) {
              return this.finishOp(types$1.assign, 3);
            }
          }
          return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
      };
      pp.readToken_caret = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.bitwiseXOR, 1);
      };
      pp.readToken_plus_min = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken();
          }
          return this.finishOp(types$1.incDec, 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.plusMin, 1);
      };
      pp.readToken_lt_gt = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        if (next === code) {
          size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(this.pos + size) === 61) {
            return this.finishOp(types$1.assign, size + 1);
          }
          return this.finishOp(types$1.bitShift, size);
        }
        if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
          this.skipLineComment(4);
          this.skipSpace();
          return this.nextToken();
        }
        if (next === 61) {
          size = 2;
        }
        return this.finishOp(types$1.relational, size);
      };
      pp.readToken_eq_excl = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
        }
        if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
          this.pos += 2;
          return this.finishToken(types$1.arrow);
        }
        return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
      };
      pp.readToken_question = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        if (ecmaVersion2 >= 11) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 46) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 < 48 || next2 > 57) {
              return this.finishOp(types$1.questionDot, 2);
            }
          }
          if (next === 63) {
            if (ecmaVersion2 >= 12) {
              var next2$1 = this.input.charCodeAt(this.pos + 2);
              if (next2$1 === 61) {
                return this.finishOp(types$1.assign, 3);
              }
            }
            return this.finishOp(types$1.coalesce, 2);
          }
        }
        return this.finishOp(types$1.question, 1);
      };
      pp.readToken_numberSign = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        var code = 35;
        if (ecmaVersion2 >= 13) {
          ++this.pos;
          code = this.fullCharCodeAtPos();
          if (isIdentifierStart(code, true) || code === 92) {
            return this.finishToken(types$1.privateId, this.readWord1());
          }
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
      };
      pp.getTokenFromCode = function(code) {
        switch (code) {
          // The interpretation of a dot depends on whether it is followed
          // by a digit or another two dots.
          case 46:
            return this.readToken_dot();
          // Punctuation tokens.
          case 40:
            ++this.pos;
            return this.finishToken(types$1.parenL);
          case 41:
            ++this.pos;
            return this.finishToken(types$1.parenR);
          case 59:
            ++this.pos;
            return this.finishToken(types$1.semi);
          case 44:
            ++this.pos;
            return this.finishToken(types$1.comma);
          case 91:
            ++this.pos;
            return this.finishToken(types$1.bracketL);
          case 93:
            ++this.pos;
            return this.finishToken(types$1.bracketR);
          case 123:
            ++this.pos;
            return this.finishToken(types$1.braceL);
          case 125:
            ++this.pos;
            return this.finishToken(types$1.braceR);
          case 58:
            ++this.pos;
            return this.finishToken(types$1.colon);
          case 96:
            if (this.options.ecmaVersion < 6) {
              break;
            }
            ++this.pos;
            return this.finishToken(types$1.backQuote);
          case 48:
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 120 || next === 88) {
              return this.readRadixNumber(16);
            }
            if (this.options.ecmaVersion >= 6) {
              if (next === 111 || next === 79) {
                return this.readRadixNumber(8);
              }
              if (next === 98 || next === 66) {
                return this.readRadixNumber(2);
              }
            }
          // Anything else beginning with a digit is an integer, octal
          // number, or float.
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(false);
          // Quotes produce strings.
          case 34:
          case 39:
            return this.readString(code);
          // Operators are parsed inline in tiny state machines. '=' (61) is
          // often referred to. `finishOp` simply skips the amount of
          // characters it is given as second argument, and returns a token
          // of the type given by its first argument.
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo_exp(code);
          case 124:
          case 38:
            return this.readToken_pipe_amp(code);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(code);
          case 60:
          case 62:
            return this.readToken_lt_gt(code);
          case 61:
          case 33:
            return this.readToken_eq_excl(code);
          case 63:
            return this.readToken_question();
          case 126:
            return this.finishOp(types$1.prefix, 1);
          case 35:
            return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
      };
      pp.finishOp = function(type, size) {
        var str = this.input.slice(this.pos, this.pos + size);
        this.pos += size;
        return this.finishToken(type, str);
      };
      pp.readRegexp = function() {
        var escaped, inClass, start = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(start, "Unterminated regular expression");
          }
          var ch = this.input.charAt(this.pos);
          if (lineBreak.test(ch)) {
            this.raise(start, "Unterminated regular expression");
          }
          if (!escaped) {
            if (ch === "[") {
              inClass = true;
            } else if (ch === "]" && inClass) {
              inClass = false;
            } else if (ch === "/" && !inClass) {
              break;
            }
            escaped = ch === "\\";
          } else {
            escaped = false;
          }
          ++this.pos;
        }
        var pattern = this.input.slice(start, this.pos);
        ++this.pos;
        var flagsStart = this.pos;
        var flags = this.readWord1();
        if (this.containsEsc) {
          this.unexpected(flagsStart);
        }
        var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
        state.reset(start, pattern, flags);
        this.validateRegExpFlags(state);
        this.validateRegExpPattern(state);
        var value = null;
        try {
          value = new RegExp(pattern, flags);
        } catch (e2) {
        }
        return this.finishToken(types$1.regexp, { pattern, flags, value });
      };
      pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
        var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
        var start = this.pos, total = 0, lastCode = 0;
        for (var i2 = 0, e2 = len == null ? Infinity : len; i2 < e2; ++i2, ++this.pos) {
          var code = this.input.charCodeAt(this.pos), val = void 0;
          if (allowSeparators && code === 95) {
            if (isLegacyOctalNumericLiteral) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
            }
            if (lastCode === 95) {
              this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
            }
            if (i2 === 0) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
            }
            lastCode = code;
            continue;
          }
          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (code >= 48 && code <= 57) {
            val = code - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            break;
          }
          lastCode = code;
          total = total * radix + val;
        }
        if (allowSeparators && lastCode === 95) {
          this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
        }
        if (this.pos === start || len != null && this.pos - start !== len) {
          return null;
        }
        return total;
      };
      function stringToNumber(str, isLegacyOctalNumericLiteral) {
        if (isLegacyOctalNumericLiteral) {
          return parseInt(str, 8);
        }
        return parseFloat(str.replace(/_/g, ""));
      }
      function stringToBigInt(str) {
        if (typeof BigInt !== "function") {
          return null;
        }
        return BigInt(str.replace(/_/g, ""));
      }
      pp.readRadixNumber = function(radix) {
        var start = this.pos;
        this.pos += 2;
        var val = this.readInt(radix);
        if (val == null) {
          this.raise(this.start + 2, "Expected number in radix " + radix);
        }
        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
          val = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
        } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types$1.num, val);
      };
      pp.readNumber = function(startsWithDot) {
        var start = this.pos;
        if (!startsWithDot && this.readInt(10, void 0, true) === null) {
          this.raise(start, "Invalid number");
        }
        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (octal && this.strict) {
          this.raise(start, "Invalid number");
        }
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
          var val$1 = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
          if (isIdentifierStart(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          return this.finishToken(types$1.num, val$1);
        }
        if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
          octal = false;
        }
        if (next === 46 && !octal) {
          ++this.pos;
          this.readInt(10);
          next = this.input.charCodeAt(this.pos);
        }
        if ((next === 69 || next === 101) && !octal) {
          next = this.input.charCodeAt(++this.pos);
          if (next === 43 || next === 45) {
            ++this.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(start, "Invalid number");
          }
        }
        if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        var val = stringToNumber(this.input.slice(start, this.pos), octal);
        return this.finishToken(types$1.num, val);
      };
      pp.readCodePoint = function() {
        var ch = this.input.charCodeAt(this.pos), code;
        if (ch === 123) {
          if (this.options.ecmaVersion < 6) {
            this.unexpected();
          }
          var codePos = ++this.pos;
          code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
          ++this.pos;
          if (code > 1114111) {
            this.invalidStringToken(codePos, "Code point out of bounds");
          }
        } else {
          code = this.readHexChar(4);
        }
        return code;
      };
      pp.readString = function(quote) {
        var out = "", chunkStart = ++this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated string constant");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === quote) {
            break;
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.pos;
          } else if (ch === 8232 || ch === 8233) {
            if (this.options.ecmaVersion < 10) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
            if (this.options.locations) {
              this.curLine++;
              this.lineStart = this.pos;
            }
          } else {
            if (isNewLine(ch)) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
          }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(types$1.string, out);
      };
      var INVALID_TEMPLATE_ESCAPE_ERROR = {};
      pp.tryReadTemplateToken = function() {
        this.inTemplateElement = true;
        try {
          this.readTmplToken();
        } catch (err) {
          if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
            this.readInvalidTemplateToken();
          } else {
            throw err;
          }
        }
        this.inTemplateElement = false;
      };
      pp.invalidStringToken = function(position3, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
          throw INVALID_TEMPLATE_ESCAPE_ERROR;
        } else {
          this.raise(position3, message);
        }
      };
      pp.readTmplToken = function() {
        var out = "", chunkStart = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated template");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
            if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
              if (ch === 36) {
                this.pos += 2;
                return this.finishToken(types$1.dollarBraceL);
              } else {
                ++this.pos;
                return this.finishToken(types$1.backQuote);
              }
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(types$1.template, out);
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(true);
            chunkStart = this.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            ++this.pos;
            switch (ch) {
              case 13:
                if (this.input.charCodeAt(this.pos) === 10) {
                  ++this.pos;
                }
              case 10:
                out += "\n";
                break;
              default:
                out += String.fromCharCode(ch);
                break;
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            chunkStart = this.pos;
          } else {
            ++this.pos;
          }
        }
      };
      pp.readInvalidTemplateToken = function() {
        for (; this.pos < this.input.length; this.pos++) {
          switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if (this.input[this.pos + 1] !== "{") {
                break;
              }
            // fall through
            case "`":
              return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
            case "\r":
              if (this.input[this.pos + 1] === "\n") {
                ++this.pos;
              }
            // fall through
            case "\n":
            case "\u2028":
            case "\u2029":
              ++this.curLine;
              this.lineStart = this.pos + 1;
              break;
          }
        }
        this.raise(this.start, "Unterminated template");
      };
      pp.readEscapedChar = function(inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        ++this.pos;
        switch (ch) {
          case 110:
            return "\n";
          // 'n' -> '\n'
          case 114:
            return "\r";
          // 'r' -> '\r'
          case 120:
            return String.fromCharCode(this.readHexChar(2));
          // 'x'
          case 117:
            return codePointToString(this.readCodePoint());
          // 'u'
          case 116:
            return "	";
          // 't' -> '\t'
          case 98:
            return "\b";
          // 'b' -> '\b'
          case 118:
            return "\v";
          // 'v' -> '\u000b'
          case 102:
            return "\f";
          // 'f' -> '\f'
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) {
              ++this.pos;
            }
          // '\r\n'
          case 10:
            if (this.options.locations) {
              this.lineStart = this.pos;
              ++this.curLine;
            }
            return "";
          case 56:
          case 57:
            if (this.strict) {
              this.invalidStringToken(
                this.pos - 1,
                "Invalid escape sequence"
              );
            }
            if (inTemplate) {
              var codePos = this.pos - 1;
              this.invalidStringToken(
                codePos,
                "Invalid escape sequence in template string"
              );
            }
          default:
            if (ch >= 48 && ch <= 55) {
              var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
              var octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              this.pos += octalStr.length - 1;
              ch = this.input.charCodeAt(this.pos);
              if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
                this.invalidStringToken(
                  this.pos - 1 - octalStr.length,
                  inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
                );
              }
              return String.fromCharCode(octal);
            }
            if (isNewLine(ch)) {
              if (this.options.locations) {
                this.lineStart = this.pos;
                ++this.curLine;
              }
              return "";
            }
            return String.fromCharCode(ch);
        }
      };
      pp.readHexChar = function(len) {
        var codePos = this.pos;
        var n2 = this.readInt(16, len);
        if (n2 === null) {
          this.invalidStringToken(codePos, "Bad character escape sequence");
        }
        return n2;
      };
      pp.readWord1 = function() {
        this.containsEsc = false;
        var word = "", first = true, chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while (this.pos < this.input.length) {
          var ch = this.fullCharCodeAtPos();
          if (isIdentifierChar(ch, astral)) {
            this.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.containsEsc = true;
            word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            if (this.input.charCodeAt(++this.pos) !== 117) {
              this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
            }
            ++this.pos;
            var esc = this.readCodePoint();
            if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
              this.invalidStringToken(escStart, "Invalid Unicode escape");
            }
            word += codePointToString(esc);
            chunkStart = this.pos;
          } else {
            break;
          }
          first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
      };
      pp.readWord = function() {
        var word = this.readWord1();
        var type = types$1.name;
        if (this.keywords.test(word)) {
          type = keywords[word];
        }
        return this.finishToken(type, word);
      };
      var version3 = "8.14.0";
      Parser.acorn = {
        Parser,
        version: version3,
        defaultOptions,
        Position: Position3,
        SourceLocation,
        getLineInfo,
        Node: Node2,
        TokenType,
        tokTypes: types$1,
        keywordTypes: keywords,
        TokContext,
        tokContexts: types,
        isIdentifierChar,
        isIdentifierStart,
        Token,
        isNewLine,
        lineBreak,
        lineBreakG,
        nonASCIIwhitespace
      };
      function parse2(input, options) {
        return Parser.parse(input, options);
      }
      function parseExpressionAt(input, pos, options) {
        return Parser.parseExpressionAt(input, pos, options);
      }
      function tokenizer(input, options) {
        return Parser.tokenizer(input, options);
      }
      exports2.Node = Node2;
      exports2.Parser = Parser;
      exports2.Position = Position3;
      exports2.SourceLocation = SourceLocation;
      exports2.TokContext = TokContext;
      exports2.Token = Token;
      exports2.TokenType = TokenType;
      exports2.defaultOptions = defaultOptions;
      exports2.getLineInfo = getLineInfo;
      exports2.isIdentifierChar = isIdentifierChar;
      exports2.isIdentifierStart = isIdentifierStart;
      exports2.isNewLine = isNewLine;
      exports2.keywordTypes = keywords;
      exports2.lineBreak = lineBreak;
      exports2.lineBreakG = lineBreakG;
      exports2.nonASCIIwhitespace = nonASCIIwhitespace;
      exports2.parse = parse2;
      exports2.parseExpressionAt = parseExpressionAt;
      exports2.tokContexts = types;
      exports2.tokTypes = types$1;
      exports2.tokenizer = tokenizer;
      exports2.version = version3;
    });
  }
});

// ../../node_modules/.pnpm/ufo@1.5.4/node_modules/ufo/dist/index.cjs
var require_dist = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/ufo@1.5.4/node_modules/ufo/dist/index.cjs"(exports) {
    "use strict";
    var n2 = /[^\0-\x7E]/;
    var t = /[\x2E\u3002\uFF0E\uFF61]/g;
    var o = {
      overflow: "Overflow Error",
      "not-basic": "Illegal Input",
      "invalid-input": "Invalid Input"
    };
    var e2 = Math.floor;
    var r = String.fromCharCode;
    function s(n22) {
      throw new RangeError(o[n22]);
    }
    var c = function(n22, t2) {
      return n22 + 22 + 75 * (n22 < 26) - ((t2 != 0) << 5);
    };
    var u = function(n22, t2, o2) {
      let r2 = 0;
      for (n22 = o2 ? e2(n22 / 700) : n22 >> 1, n22 += e2(n22 / t2); n22 > 455; r2 += 36) {
        n22 = e2(n22 / 35);
      }
      return e2(r2 + 36 * n22 / (n22 + 38));
    };
    function toASCII(o2) {
      return function(n22, o3) {
        const e22 = n22.split("@");
        let r2 = "";
        e22.length > 1 && (r2 = e22[0] + "@", n22 = e22[1]);
        const s2 = function(n3, t2) {
          const o4 = [];
          let e3 = n3.length;
          for (; e3--; ) {
            o4[e3] = t2(n3[e3]);
          }
          return o4;
        }((n22 = n22.replace(t, ".")).split("."), o3).join(".");
        return r2 + s2;
      }(o2, function(t2) {
        return n2.test(t2) ? "xn--" + function(n22) {
          const t3 = [];
          const o3 = (n22 = function(n3) {
            const t4 = [];
            let o4 = 0;
            const e22 = n3.length;
            for (; o4 < e22; ) {
              const r2 = n3.charCodeAt(o4++);
              if (r2 >= 55296 && r2 <= 56319 && o4 < e22) {
                const e3 = n3.charCodeAt(o4++);
                (64512 & e3) == 56320 ? t4.push(((1023 & r2) << 10) + (1023 & e3) + 65536) : (t4.push(r2), o4--);
              } else {
                t4.push(r2);
              }
            }
            return t4;
          }(n22)).length;
          let f = 128;
          let i = 0;
          let l = 72;
          for (const o4 of n22) {
            o4 < 128 && t3.push(r(o4));
          }
          const h3 = t3.length;
          let p = h3;
          for (h3 && t3.push("-"); p < o3; ) {
            let o4 = 2147483647;
            for (const t4 of n22) {
              t4 >= f && t4 < o4 && (o4 = t4);
            }
            const a = p + 1;
            o4 - f > e2((2147483647 - i) / a) && s("overflow"), i += (o4 - f) * a, f = o4;
            for (const o5 of n22) {
              if (o5 < f && ++i > 2147483647 && s("overflow"), o5 == f) {
                let n3 = i;
                for (let o6 = 36; ; o6 += 36) {
                  const s2 = o6 <= l ? 1 : o6 >= l + 26 ? 26 : o6 - l;
                  if (n3 < s2) {
                    break;
                  }
                  const u2 = n3 - s2;
                  const f2 = 36 - s2;
                  t3.push(r(c(s2 + u2 % f2, 0))), n3 = e2(u2 / f2);
                }
                t3.push(r(c(n3, 0))), l = u(i, a, p == h3), i = 0, ++p;
              }
            }
            ++i, ++f;
          }
          return t3.join("");
        }(t2) : t2;
      });
    }
    var HASH_RE = /#/g;
    var AMPERSAND_RE = /&/g;
    var SLASH_RE = /\//g;
    var EQUAL_RE = /=/g;
    var IM_RE = /\?/g;
    var PLUS_RE = /\+/g;
    var ENC_CARET_RE = /%5e/gi;
    var ENC_BACKTICK_RE = /%60/gi;
    var ENC_CURLY_OPEN_RE = /%7b/gi;
    var ENC_PIPE_RE = /%7c/gi;
    var ENC_CURLY_CLOSE_RE = /%7d/gi;
    var ENC_SPACE_RE = /%20/gi;
    var ENC_SLASH_RE = /%2f/gi;
    var ENC_ENC_SLASH_RE = /%252f/gi;
    function encode2(text) {
      return encodeURI("" + text).replace(ENC_PIPE_RE, "|");
    }
    function encodeHash(text) {
      return encode2(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
    }
    function encodeQueryValue(input) {
      return encode2(typeof input === "string" ? input : JSON.stringify(input)).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CARET_RE, "^").replace(SLASH_RE, "%2F");
    }
    function encodeQueryKey(text) {
      return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
    }
    function encodePath(text) {
      return encode2(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F").replace(ENC_ENC_SLASH_RE, "%2F").replace(AMPERSAND_RE, "%26").replace(PLUS_RE, "%2B");
    }
    function encodeParam(text) {
      return encodePath(text).replace(SLASH_RE, "%2F");
    }
    function decode(text = "") {
      try {
        return decodeURIComponent("" + text);
      } catch (e3) {
        return "" + text;
      }
    }
    function decodePath(text) {
      return decode(text.replace(ENC_SLASH_RE, "%252F"));
    }
    function decodeQueryKey(text) {
      return decode(text.replace(PLUS_RE, " "));
    }
    function decodeQueryValue(text) {
      return decode(text.replace(PLUS_RE, " "));
    }
    function encodeHost(name2 = "") {
      return toASCII(name2);
    }
    function parseQuery(parametersString = "") {
      const object = {};
      if (parametersString[0] === "?") {
        parametersString = parametersString.slice(1);
      }
      for (const parameter of parametersString.split("&")) {
        const s2 = parameter.match(/([^=]+)=?(.*)/) || [];
        if (s2.length < 2) {
          continue;
        }
        const key = decodeQueryKey(s2[1]);
        if (key === "__proto__" || key === "constructor") {
          continue;
        }
        const value = decodeQueryValue(s2[2] || "");
        if (object[key] === void 0) {
          object[key] = value;
        } else if (Array.isArray(object[key])) {
          object[key].push(value);
        } else {
          object[key] = [object[key], value];
        }
      }
      return object;
    }
    function encodeQueryItem(key, value) {
      if (typeof value === "number" || typeof value === "boolean") {
        value = String(value);
      }
      if (!value) {
        return encodeQueryKey(key);
      }
      if (Array.isArray(value)) {
        return value.map((_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`).join("&");
      }
      return `${encodeQueryKey(key)}=${encodeQueryValue(value)}`;
    }
    function stringifyQuery(query) {
      return Object.keys(query).filter((k) => query[k] !== void 0).map((k) => encodeQueryItem(k, query[k])).filter(Boolean).join("&");
    }
    var PROTOCOL_STRICT_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/;
    var PROTOCOL_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{2})?/;
    var PROTOCOL_RELATIVE_REGEX = /^([/\\]\s*){2,}[^/\\]/;
    var PROTOCOL_SCRIPT_RE = /^[\s\0]*(blob|data|javascript|vbscript):$/i;
    var TRAILING_SLASH_RE = /\/$|\/\?|\/#/;
    var JOIN_LEADING_SLASH_RE = /^\.?\//;
    function isRelative(inputString) {
      return ["./", "../"].some((string_) => inputString.startsWith(string_));
    }
    function hasProtocol(inputString, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { acceptRelative: opts };
      }
      if (opts.strict) {
        return PROTOCOL_STRICT_REGEX.test(inputString);
      }
      return PROTOCOL_REGEX.test(inputString) || (opts.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(inputString) : false);
    }
    function isScriptProtocol(protocol) {
      return !!protocol && PROTOCOL_SCRIPT_RE.test(protocol);
    }
    function hasTrailingSlash(input = "", respectQueryAndFragment) {
      if (!respectQueryAndFragment) {
        return input.endsWith("/");
      }
      return TRAILING_SLASH_RE.test(input);
    }
    function withoutTrailingSlash(input = "", respectQueryAndFragment) {
      if (!respectQueryAndFragment) {
        return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || "/";
      }
      if (!hasTrailingSlash(input, true)) {
        return input || "/";
      }
      let path7 = input;
      let fragment = "";
      const fragmentIndex = input.indexOf("#");
      if (fragmentIndex >= 0) {
        path7 = input.slice(0, fragmentIndex);
        fragment = input.slice(fragmentIndex);
      }
      const [s0, ...s2] = path7.split("?");
      const cleanPath = s0.endsWith("/") ? s0.slice(0, -1) : s0;
      return (cleanPath || "/") + (s2.length > 0 ? `?${s2.join("?")}` : "") + fragment;
    }
    function withTrailingSlash(input = "", respectQueryAndFragment) {
      if (!respectQueryAndFragment) {
        return input.endsWith("/") ? input : input + "/";
      }
      if (hasTrailingSlash(input, true)) {
        return input || "/";
      }
      let path7 = input;
      let fragment = "";
      const fragmentIndex = input.indexOf("#");
      if (fragmentIndex >= 0) {
        path7 = input.slice(0, fragmentIndex);
        fragment = input.slice(fragmentIndex);
        if (!path7) {
          return fragment;
        }
      }
      const [s0, ...s2] = path7.split("?");
      return s0 + "/" + (s2.length > 0 ? `?${s2.join("?")}` : "") + fragment;
    }
    function hasLeadingSlash(input = "") {
      return input.startsWith("/");
    }
    function withoutLeadingSlash(input = "") {
      return (hasLeadingSlash(input) ? input.slice(1) : input) || "/";
    }
    function withLeadingSlash(input = "") {
      return hasLeadingSlash(input) ? input : "/" + input;
    }
    function cleanDoubleSlashes(input = "") {
      return input.split("://").map((string_) => string_.replace(/\/{2,}/g, "/")).join("://");
    }
    function withBase(input, base) {
      if (isEmptyURL(base) || hasProtocol(input)) {
        return input;
      }
      const _base = withoutTrailingSlash(base);
      if (input.startsWith(_base)) {
        return input;
      }
      return joinURL(_base, input);
    }
    function withoutBase(input, base) {
      if (isEmptyURL(base)) {
        return input;
      }
      const _base = withoutTrailingSlash(base);
      if (!input.startsWith(_base)) {
        return input;
      }
      const trimmed = input.slice(_base.length);
      return trimmed[0] === "/" ? trimmed : "/" + trimmed;
    }
    function withQuery(input, query) {
      const parsed = parseURL(input);
      const mergedQuery = { ...parseQuery(parsed.search), ...query };
      parsed.search = stringifyQuery(mergedQuery);
      return stringifyParsedURL(parsed);
    }
    function getQuery(input) {
      return parseQuery(parseURL(input).search);
    }
    function isEmptyURL(url) {
      return !url || url === "/";
    }
    function isNonEmptyURL(url) {
      return url && url !== "/";
    }
    function joinURL(base, ...input) {
      let url = base || "";
      for (const segment of input.filter((url2) => isNonEmptyURL(url2))) {
        if (url) {
          const _segment = segment.replace(JOIN_LEADING_SLASH_RE, "");
          url = withTrailingSlash(url) + _segment;
        } else {
          url = segment;
        }
      }
      return url;
    }
    function joinRelativeURL(..._input) {
      var _a3, _b2, _c, _d;
      const JOIN_SEGMENT_SPLIT_RE = /\/(?!\/)/;
      const input = _input.filter(Boolean);
      const segments = [];
      let segmentsDepth = 0;
      for (const i of input) {
        if (!i || i === "/") {
          continue;
        }
        for (const [sindex, s2] of i.split(JOIN_SEGMENT_SPLIT_RE).entries()) {
          if (!s2 || s2 === ".") {
            continue;
          }
          if (s2 === "..") {
            if (segments.length === 1 && hasProtocol(segments[0])) {
              continue;
            }
            segments.pop();
            segmentsDepth--;
            continue;
          }
          if (sindex === 1 && ((_a3 = segments[segments.length - 1]) == null ? void 0 : _a3.endsWith(":/"))) {
            segments[segments.length - 1] += "/" + s2;
            continue;
          }
          segments.push(s2);
          segmentsDepth++;
        }
      }
      let url = segments.join("/");
      if (segmentsDepth >= 0) {
        if (((_b2 = input[0]) == null ? void 0 : _b2.startsWith("/")) && !url.startsWith("/")) {
          url = "/" + url;
        } else if (((_c = input[0]) == null ? void 0 : _c.startsWith("./")) && !url.startsWith("./")) {
          url = "./" + url;
        }
      } else {
        url = "../".repeat(-1 * segmentsDepth) + url;
      }
      if (((_d = input[input.length - 1]) == null ? void 0 : _d.endsWith("/")) && !url.endsWith("/")) {
        url += "/";
      }
      return url;
    }
    function withHttp(input) {
      return withProtocol(input, "http://");
    }
    function withHttps(input) {
      return withProtocol(input, "https://");
    }
    function withoutProtocol(input) {
      return withProtocol(input, "");
    }
    function withProtocol(input, protocol) {
      let match = input.match(PROTOCOL_REGEX);
      if (!match) {
        match = input.match(/^\/{2,}/);
      }
      if (!match) {
        return protocol + input;
      }
      return protocol + input.slice(match[0].length);
    }
    function normalizeURL(input) {
      const parsed = parseURL(input);
      parsed.pathname = encodePath(decodePath(parsed.pathname));
      parsed.hash = encodeHash(decode(parsed.hash));
      parsed.host = encodeHost(decode(parsed.host));
      parsed.search = stringifyQuery(parseQuery(parsed.search));
      return stringifyParsedURL(parsed);
    }
    function resolveURL(base = "", ...inputs) {
      if (typeof base !== "string") {
        throw new TypeError(
          `URL input should be string received ${typeof base} (${base})`
        );
      }
      const filteredInputs = inputs.filter((input) => isNonEmptyURL(input));
      if (filteredInputs.length === 0) {
        return base;
      }
      const url = parseURL(base);
      for (const inputSegment of filteredInputs) {
        const urlSegment = parseURL(inputSegment);
        if (urlSegment.pathname) {
          url.pathname = withTrailingSlash(url.pathname) + withoutLeadingSlash(urlSegment.pathname);
        }
        if (urlSegment.hash && urlSegment.hash !== "#") {
          url.hash = urlSegment.hash;
        }
        if (urlSegment.search && urlSegment.search !== "?") {
          if (url.search && url.search !== "?") {
            const queryString = stringifyQuery({
              ...parseQuery(url.search),
              ...parseQuery(urlSegment.search)
            });
            url.search = queryString.length > 0 ? "?" + queryString : "";
          } else {
            url.search = urlSegment.search;
          }
        }
      }
      return stringifyParsedURL(url);
    }
    function isSamePath(p1, p2) {
      return decode(withoutTrailingSlash(p1)) === decode(withoutTrailingSlash(p2));
    }
    function isEqual(a, b, options = {}) {
      if (!options.trailingSlash) {
        a = withTrailingSlash(a);
        b = withTrailingSlash(b);
      }
      if (!options.leadingSlash) {
        a = withLeadingSlash(a);
        b = withLeadingSlash(b);
      }
      if (!options.encoding) {
        a = decode(a);
        b = decode(b);
      }
      return a === b;
    }
    function withFragment(input, hash2) {
      if (!hash2 || hash2 === "#") {
        return input;
      }
      const parsed = parseURL(input);
      parsed.hash = hash2 === "" ? "" : "#" + encodeHash(hash2);
      return stringifyParsedURL(parsed);
    }
    function withoutFragment(input) {
      return stringifyParsedURL({ ...parseURL(input), hash: "" });
    }
    function withoutHost(input) {
      const parsed = parseURL(input);
      return (parsed.pathname || "/") + parsed.search + parsed.hash;
    }
    var protocolRelative = Symbol.for("ufo:protocolRelative");
    function parseURL(input = "", defaultProto) {
      const _specialProtoMatch = input.match(
        /^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i
      );
      if (_specialProtoMatch) {
        const [, _proto, _pathname = ""] = _specialProtoMatch;
        return {
          protocol: _proto.toLowerCase(),
          pathname: _pathname,
          href: _proto + _pathname,
          auth: "",
          host: "",
          search: "",
          hash: ""
        };
      }
      if (!hasProtocol(input, { acceptRelative: true })) {
        return defaultProto ? parseURL(defaultProto + input) : parsePath(input);
      }
      const [, protocol = "", auth, hostAndPath = ""] = input.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [];
      let [, host = "", path7 = ""] = hostAndPath.match(/([^#/?]*)(.*)?/) || [];
      if (protocol === "file:") {
        path7 = path7.replace(/\/(?=[A-Za-z]:)/, "");
      }
      const { pathname, search, hash: hash2 } = parsePath(path7);
      return {
        protocol: protocol.toLowerCase(),
        auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : "",
        host,
        pathname,
        search,
        hash: hash2,
        [protocolRelative]: !protocol
      };
    }
    function parsePath(input = "") {
      const [pathname = "", search = "", hash2 = ""] = (input.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
      return {
        pathname,
        search,
        hash: hash2
      };
    }
    function parseAuth(input = "") {
      const [username, password] = input.split(":");
      return {
        username: decode(username),
        password: decode(password)
      };
    }
    function parseHost(input = "") {
      const [hostname, port] = (input.match(/([^/:]*):?(\d+)?/) || []).splice(1);
      return {
        hostname: decode(hostname),
        port
      };
    }
    function stringifyParsedURL(parsed) {
      const pathname = parsed.pathname || "";
      const search = parsed.search ? (parsed.search.startsWith("?") ? "" : "?") + parsed.search : "";
      const hash2 = parsed.hash || "";
      const auth = parsed.auth ? parsed.auth + "@" : "";
      const host = parsed.host || "";
      const proto = parsed.protocol || parsed[protocolRelative] ? (parsed.protocol || "") + "//" : "";
      return proto + auth + host + pathname + search + hash2;
    }
    var FILENAME_STRICT_REGEX = /\/([^/]+\.[^/]+)$/;
    var FILENAME_REGEX = /\/([^/]+)$/;
    function parseFilename(input = "", { strict }) {
      const { pathname } = parseURL(input);
      const matches = strict ? pathname.match(FILENAME_STRICT_REGEX) : pathname.match(FILENAME_REGEX);
      return matches ? matches[1] : void 0;
    }
    var __defProp = Object.defineProperty;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __publicField2 = (obj, key, value) => {
      __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    var $URL = class {
      constructor(input = "") {
        __publicField2(this, "protocol");
        __publicField2(this, "host");
        __publicField2(this, "auth");
        __publicField2(this, "pathname");
        __publicField2(this, "query", {});
        __publicField2(this, "hash");
        if (typeof input !== "string") {
          throw new TypeError(
            `URL input should be string received ${typeof input} (${input})`
          );
        }
        const parsed = parseURL(input);
        this.protocol = decode(parsed.protocol);
        this.host = decode(parsed.host);
        this.auth = decode(parsed.auth);
        this.pathname = decodePath(parsed.pathname);
        this.query = parseQuery(parsed.search);
        this.hash = decode(parsed.hash);
      }
      get hostname() {
        return parseHost(this.host).hostname;
      }
      get port() {
        return parseHost(this.host).port || "";
      }
      get username() {
        return parseAuth(this.auth).username;
      }
      get password() {
        return parseAuth(this.auth).password || "";
      }
      get hasProtocol() {
        return this.protocol.length;
      }
      get isAbsolute() {
        return this.hasProtocol || this.pathname[0] === "/";
      }
      get search() {
        const q = stringifyQuery(this.query);
        return q.length > 0 ? "?" + q : "";
      }
      get searchParams() {
        const p = new URLSearchParams();
        for (const name2 in this.query) {
          const value = this.query[name2];
          if (Array.isArray(value)) {
            for (const v of value) {
              p.append(name2, v);
            }
          } else {
            p.append(
              name2,
              typeof value === "string" ? value : JSON.stringify(value)
            );
          }
        }
        return p;
      }
      get origin() {
        return (this.protocol ? this.protocol + "//" : "") + encodeHost(this.host);
      }
      get fullpath() {
        return encodePath(this.pathname) + this.search + encodeHash(this.hash);
      }
      get encodedAuth() {
        if (!this.auth) {
          return "";
        }
        const { username, password } = parseAuth(this.auth);
        return encodeURIComponent(username) + (password ? ":" + encodeURIComponent(password) : "");
      }
      get href() {
        const auth = this.encodedAuth;
        const originWithAuth = (this.protocol ? this.protocol + "//" : "") + (auth ? auth + "@" : "") + encodeHost(this.host);
        return this.hasProtocol && this.isAbsolute ? originWithAuth + this.fullpath : this.fullpath;
      }
      append(url) {
        if (url.hasProtocol) {
          throw new Error("Cannot append a URL with protocol");
        }
        Object.assign(this.query, url.query);
        if (url.pathname) {
          this.pathname = withTrailingSlash(this.pathname) + withoutLeadingSlash(url.pathname);
        }
        if (url.hash) {
          this.hash = url.hash;
        }
      }
      toJSON() {
        return this.href;
      }
      toString() {
        return this.href;
      }
    };
    function createURL(input) {
      return new $URL(input);
    }
    exports.$URL = $URL;
    exports.cleanDoubleSlashes = cleanDoubleSlashes;
    exports.createURL = createURL;
    exports.decode = decode;
    exports.decodePath = decodePath;
    exports.decodeQueryKey = decodeQueryKey;
    exports.decodeQueryValue = decodeQueryValue;
    exports.encode = encode2;
    exports.encodeHash = encodeHash;
    exports.encodeHost = encodeHost;
    exports.encodeParam = encodeParam;
    exports.encodePath = encodePath;
    exports.encodeQueryItem = encodeQueryItem;
    exports.encodeQueryKey = encodeQueryKey;
    exports.encodeQueryValue = encodeQueryValue;
    exports.getQuery = getQuery;
    exports.hasLeadingSlash = hasLeadingSlash;
    exports.hasProtocol = hasProtocol;
    exports.hasTrailingSlash = hasTrailingSlash;
    exports.isEmptyURL = isEmptyURL;
    exports.isEqual = isEqual;
    exports.isNonEmptyURL = isNonEmptyURL;
    exports.isRelative = isRelative;
    exports.isSamePath = isSamePath;
    exports.isScriptProtocol = isScriptProtocol;
    exports.joinRelativeURL = joinRelativeURL;
    exports.joinURL = joinURL;
    exports.normalizeURL = normalizeURL;
    exports.parseAuth = parseAuth;
    exports.parseFilename = parseFilename;
    exports.parseHost = parseHost;
    exports.parsePath = parsePath;
    exports.parseQuery = parseQuery;
    exports.parseURL = parseURL;
    exports.resolveURL = resolveURL;
    exports.stringifyParsedURL = stringifyParsedURL;
    exports.stringifyQuery = stringifyQuery;
    exports.withBase = withBase;
    exports.withFragment = withFragment;
    exports.withHttp = withHttp;
    exports.withHttps = withHttps;
    exports.withLeadingSlash = withLeadingSlash;
    exports.withProtocol = withProtocol;
    exports.withQuery = withQuery;
    exports.withTrailingSlash = withTrailingSlash;
    exports.withoutBase = withoutBase;
    exports.withoutFragment = withoutFragment;
    exports.withoutHost = withoutHost;
    exports.withoutLeadingSlash = withoutLeadingSlash;
    exports.withoutProtocol = withoutProtocol;
    exports.withoutTrailingSlash = withoutTrailingSlash;
  }
});

// ../../node_modules/.pnpm/pathe@2.0.3/node_modules/pathe/dist/shared/pathe.BSlhyZSM.cjs
var require_pathe_BSlhyZSM = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/pathe@2.0.3/node_modules/pathe/dist/shared/pathe.BSlhyZSM.cjs"(exports) {
    "use strict";
    var _lazyMatch = () => {
      var __lib__ = (() => {
        var m = Object.defineProperty, V = Object.getOwnPropertyDescriptor, G = Object.getOwnPropertyNames, T = Object.prototype.hasOwnProperty, q = (r, e2) => {
          for (var n2 in e2) m(r, n2, { get: e2[n2], enumerable: true });
        }, H = (r, e2, n2, a) => {
          if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let t of G(e2)) !T.call(r, t) && t !== n2 && m(r, t, { get: () => e2[t], enumerable: !(a = V(e2, t)) || a.enumerable });
          return r;
        }, J = (r) => H(m({}, "__esModule", { value: true }), r), w = {};
        q(w, { default: () => re });
        var A = (r) => Array.isArray(r), d = (r) => typeof r == "function", Q = (r) => r.length === 0, W = (r) => typeof r == "number", K = (r) => typeof r == "object" && r !== null, X = (r) => r instanceof RegExp, b = (r) => typeof r == "string", h3 = (r) => r === void 0, Y = (r) => {
          const e2 = /* @__PURE__ */ new Map();
          return (n2) => {
            const a = e2.get(n2);
            if (a) return a;
            const t = r(n2);
            return e2.set(n2, t), t;
          };
        }, rr = (r, e2, n2 = {}) => {
          const a = { cache: {}, input: r, index: 0, indexMax: 0, options: n2, output: [] };
          if (v(e2)(a) && a.index === r.length) return a.output;
          throw new Error(`Failed to parse at index ${a.indexMax}`);
        }, i = (r, e2) => A(r) ? er(r, e2) : b(r) ? ar(r, e2) : nr(r, e2), er = (r, e2) => {
          const n2 = {};
          for (const a of r) {
            if (a.length !== 1) throw new Error(`Invalid character: "${a}"`);
            const t = a.charCodeAt(0);
            n2[t] = true;
          }
          return (a) => {
            const t = a.index, o = a.input;
            for (; a.index < o.length && o.charCodeAt(a.index) in n2; ) a.index += 1;
            const u = a.index;
            if (u > t) {
              if (!h3(e2) && !a.options.silent) {
                const s = a.input.slice(t, u), c = d(e2) ? e2(s, o, String(t)) : e2;
                h3(c) || a.output.push(c);
              }
              a.indexMax = Math.max(a.indexMax, a.index);
            }
            return true;
          };
        }, nr = (r, e2) => {
          const n2 = r.source, a = r.flags.replace(/y|$/, "y"), t = new RegExp(n2, a);
          return g((o) => {
            t.lastIndex = o.index;
            const u = t.exec(o.input);
            if (u) {
              if (!h3(e2) && !o.options.silent) {
                const s = d(e2) ? e2(...u, o.input, String(o.index)) : e2;
                h3(s) || o.output.push(s);
              }
              return o.index += u[0].length, o.indexMax = Math.max(o.indexMax, o.index), true;
            } else return false;
          });
        }, ar = (r, e2) => (n2) => {
          if (n2.input.startsWith(r, n2.index)) {
            if (!h3(e2) && !n2.options.silent) {
              const t = d(e2) ? e2(r, n2.input, String(n2.index)) : e2;
              h3(t) || n2.output.push(t);
            }
            return n2.index += r.length, n2.indexMax = Math.max(n2.indexMax, n2.index), true;
          } else return false;
        }, C = (r, e2, n2, a) => {
          const t = v(r);
          return g(_(M((o) => {
            let u = 0;
            for (; u < n2; ) {
              const s = o.index;
              if (!t(o) || (u += 1, o.index === s)) break;
            }
            return u >= e2;
          })));
        }, tr = (r, e2) => C(r, 0, 1), f = (r, e2) => C(r, 0, 1 / 0), x2 = (r, e2) => {
          const n2 = r.map(v);
          return g(_(M((a) => {
            for (let t = 0, o = n2.length; t < o; t++) if (!n2[t](a)) return false;
            return true;
          })));
        }, l = (r, e2) => {
          const n2 = r.map(v);
          return g(_((a) => {
            for (let t = 0, o = n2.length; t < o; t++) if (n2[t](a)) return true;
            return false;
          }));
        }, M = (r, e2 = false) => {
          const n2 = v(r);
          return (a) => {
            const t = a.index, o = a.output.length, u = n2(a);
            return (!u || e2) && (a.index = t, a.output.length !== o && (a.output.length = o)), u;
          };
        }, _ = (r, e2) => {
          const n2 = v(r);
          return n2;
        }, g = /* @__PURE__ */ (() => {
          let r = 0;
          return (e2) => {
            const n2 = v(e2), a = r += 1;
            return (t) => {
              var _a3;
              var o;
              if (t.options.memoization === false) return n2(t);
              const u = t.index, s = (o = t.cache)[a] || (o[a] = /* @__PURE__ */ new Map()), c = s.get(u);
              if (c === false) return false;
              if (W(c)) return t.index = c, true;
              if (c) return t.index = c.index, ((_a3 = c.output) == null ? void 0 : _a3.length) && t.output.push(...c.output), true;
              {
                const Z = t.output.length;
                if (n2(t)) {
                  const D = t.index, U = t.output.length;
                  if (U > Z) {
                    const ee = t.output.slice(Z, U);
                    s.set(u, { index: D, output: ee });
                  } else s.set(u, D);
                  return true;
                } else return s.set(u, false), false;
              }
            };
          };
        })(), E = (r) => {
          let e2;
          return (n2) => (e2 || (e2 = v(r())), e2(n2));
        }, v = Y((r) => {
          if (d(r)) return Q(r) ? E(r) : r;
          if (b(r) || X(r)) return i(r);
          if (A(r)) return x2(r);
          if (K(r)) return l(Object.values(r));
          throw new Error("Invalid rule");
        }), P = "abcdefghijklmnopqrstuvwxyz", ir = (r) => {
          let e2 = "";
          for (; r > 0; ) {
            const n2 = (r - 1) % 26;
            e2 = P[n2] + e2, r = Math.floor((r - 1) / 26);
          }
          return e2;
        }, O = (r) => {
          let e2 = 0;
          for (let n2 = 0, a = r.length; n2 < a; n2++) e2 = e2 * 26 + P.indexOf(r[n2]) + 1;
          return e2;
        }, S = (r, e2) => {
          if (e2 < r) return S(e2, r);
          const n2 = [];
          for (; r <= e2; ) n2.push(r++);
          return n2;
        }, or = (r, e2, n2) => S(r, e2).map((a) => String(a).padStart(n2, "0")), R = (r, e2) => S(O(r), O(e2)).map(ir), p = (r) => r, z = (r) => ur((e2) => rr(e2, r, { memoization: false }).join("")), ur = (r) => {
          const e2 = {};
          return (n2) => {
            var _a3;
            return (_a3 = e2[n2]) != null ? _a3 : e2[n2] = r(n2);
          };
        }, sr = i(/^\*\*\/\*$/, ".*"), cr = i(/^\*\*\/(\*)?([ a-zA-Z0-9._-]+)$/, (r, e2, n2) => `.*${e2 ? "" : "(?:^|/)"}${n2.replaceAll(".", "\\.")}`), lr = i(/^\*\*\/(\*)?([ a-zA-Z0-9._-]*)\{([ a-zA-Z0-9._-]+(?:,[ a-zA-Z0-9._-]+)*)\}$/, (r, e2, n2, a) => `.*${e2 ? "" : "(?:^|/)"}${n2.replaceAll(".", "\\.")}(?:${a.replaceAll(",", "|").replaceAll(".", "\\.")})`), y = i(/\\./, p), pr = i(/[$.*+?^(){}[\]\|]/, (r) => `\\${r}`), vr = i(/./, p), hr = i(/^(?:!!)*!(.*)$/, (r, e2) => `(?!^${L(e2)}$).*?`), dr = i(/^(!!)+/, ""), fr = l([hr, dr]), xr = i(/\/(\*\*\/)+/, "(?:/.+/|/)"), gr = i(/^(\*\*\/)+/, "(?:^|.*/)"), mr = i(/\/(\*\*)$/, "(?:/.*|$)"), _r = i(/\*\*/, ".*"), j = l([xr, gr, mr, _r]), Sr = i(/\*\/(?!\*\*\/)/, "[^/]*/"), yr = i(/\*/, "[^/]*"), N = l([Sr, yr]), k = i("?", "[^/]"), $r = i("[", p), wr = i("]", p), Ar = i(/[!^]/, "^/"), br = i(/[a-z]-[a-z]|[0-9]-[0-9]/i, p), Cr = i(/[$.*+?^(){}[\|]/, (r) => `\\${r}`), Mr = i(/[^\]]/, p), Er = l([y, Cr, br, Mr]), B = x2([$r, tr(Ar), f(Er), wr]), Pr = i("{", "(?:"), Or = i("}", ")"), Rr = i(/(\d+)\.\.(\d+)/, (r, e2, n2) => or(+e2, +n2, Math.min(e2.length, n2.length)).join("|")), zr = i(/([a-z]+)\.\.([a-z]+)/, (r, e2, n2) => R(e2, n2).join("|")), jr = i(/([A-Z]+)\.\.([A-Z]+)/, (r, e2, n2) => R(e2.toLowerCase(), n2.toLowerCase()).join("|").toUpperCase()), Nr = l([Rr, zr, jr]), I = x2([Pr, Nr, Or]), kr = i("{", "(?:"), Br = i("}", ")"), Ir = i(",", "|"), Fr = i(/[$.*+?^(){[\]\|]/, (r) => `\\${r}`), Lr = i(/[^}]/, p), Zr = E(() => F), Dr = l([j, N, k, B, I, Zr, y, Fr, Ir, Lr]), F = x2([kr, f(Dr), Br]), Ur = f(l([sr, cr, lr, fr, j, N, k, B, I, F, y, pr, vr])), Vr = Ur, Gr = z(Vr), L = Gr, Tr = i(/\\./, p), qr = i(/./, p), Hr = i(/\*\*\*+/, "*"), Jr = i(/([^/{[(!])\*\*/, (r, e2) => `${e2}*`), Qr = i(/(^|.)\*\*(?=[^*/)\]}])/, (r, e2) => `${e2}*`), Wr = f(l([Tr, Hr, Jr, Qr, qr])), Kr = Wr, Xr = z(Kr), Yr = Xr, $ = (r, e2) => {
          const n2 = Array.isArray(r) ? r : [r];
          if (!n2.length) return false;
          const a = n2.map($.compile), t = n2.every((s) => /(\/(?:\*\*)?|\[\/\])$/.test(s)), o = e2.replace(/[\\\/]+/g, "/").replace(/\/$/, t ? "/" : "");
          return a.some((s) => s.test(o));
        };
        $.compile = (r) => new RegExp(`^${L(Yr(r))}$`, "s");
        var re = $;
        return J(w);
      })();
      return __lib__.default || __lib__;
    };
    var _match;
    var zeptomatch = (path7, pattern) => {
      if (!_match) {
        _match = _lazyMatch();
        _lazyMatch = null;
      }
      return _match(path7, pattern);
    };
    var _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
    function normalizeWindowsPath(input = "") {
      if (!input) {
        return input;
      }
      return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());
    }
    var _UNC_REGEX = /^[/\\]{2}/;
    var _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
    var _DRIVE_LETTER_RE = /^[A-Za-z]:$/;
    var _ROOT_FOLDER_RE = /^\/([A-Za-z]:)?$/;
    var _EXTNAME_RE = /.(\.[^./]+|\.)$/;
    var _PATH_ROOT_RE = /^[/\\]|^[a-zA-Z]:[/\\]/;
    var sep = "/";
    var normalize = function(path7) {
      if (path7.length === 0) {
        return ".";
      }
      path7 = normalizeWindowsPath(path7);
      const isUNCPath = path7.match(_UNC_REGEX);
      const isPathAbsolute = isAbsolute2(path7);
      const trailingSeparator = path7[path7.length - 1] === "/";
      path7 = normalizeString(path7, !isPathAbsolute);
      if (path7.length === 0) {
        if (isPathAbsolute) {
          return "/";
        }
        return trailingSeparator ? "./" : ".";
      }
      if (trailingSeparator) {
        path7 += "/";
      }
      if (_DRIVE_LETTER_RE.test(path7)) {
        path7 += "/";
      }
      if (isUNCPath) {
        if (!isPathAbsolute) {
          return `//./${path7}`;
        }
        return `//${path7}`;
      }
      return isPathAbsolute && !isAbsolute2(path7) ? `/${path7}` : path7;
    };
    var join3 = function(...segments) {
      let path7 = "";
      for (const seg of segments) {
        if (!seg) {
          continue;
        }
        if (path7.length > 0) {
          const pathTrailing = path7[path7.length - 1] === "/";
          const segLeading = seg[0] === "/";
          const both = pathTrailing && segLeading;
          if (both) {
            path7 += seg.slice(1);
          } else {
            path7 += pathTrailing || segLeading ? seg : `/${seg}`;
          }
        } else {
          path7 += seg;
        }
      }
      return normalize(path7);
    };
    function cwd() {
      if (typeof process !== "undefined" && typeof process.cwd === "function") {
        return process.cwd().replace(/\\/g, "/");
      }
      return "/";
    }
    var resolve4 = function(...arguments_) {
      arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));
      let resolvedPath = "";
      let resolvedAbsolute = false;
      for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {
        const path7 = index >= 0 ? arguments_[index] : cwd();
        if (!path7 || path7.length === 0) {
          continue;
        }
        resolvedPath = `${path7}/${resolvedPath}`;
        resolvedAbsolute = isAbsolute2(path7);
      }
      resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute && !isAbsolute2(resolvedPath)) {
        return `/${resolvedPath}`;
      }
      return resolvedPath.length > 0 ? resolvedPath : ".";
    };
    function normalizeString(path7, allowAboveRoot) {
      let res = "";
      let lastSegmentLength = 0;
      let lastSlash = -1;
      let dots = 0;
      let char = null;
      for (let index = 0; index <= path7.length; ++index) {
        if (index < path7.length) {
          char = path7[index];
        } else if (char === "/") {
          break;
        } else {
          char = "/";
        }
        if (char === "/") {
          if (lastSlash === index - 1 || dots === 1) ;
          else if (dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
              if (res.length > 2) {
                const lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = index;
                dots = 0;
                continue;
              } else if (res.length > 0) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = index;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              res += res.length > 0 ? "/.." : "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0) {
              res += `/${path7.slice(lastSlash + 1, index)}`;
            } else {
              res = path7.slice(lastSlash + 1, index);
            }
            lastSegmentLength = index - lastSlash - 1;
          }
          lastSlash = index;
          dots = 0;
        } else if (char === "." && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    var isAbsolute2 = function(p) {
      return _IS_ABSOLUTE_RE.test(p);
    };
    var toNamespacedPath = function(p) {
      return normalizeWindowsPath(p);
    };
    var extname = function(p) {
      if (p === "..") return "";
      const match = _EXTNAME_RE.exec(normalizeWindowsPath(p));
      return match && match[1] || "";
    };
    var relative = function(from, to) {
      const _from = resolve4(from).replace(_ROOT_FOLDER_RE, "$1").split("/");
      const _to = resolve4(to).replace(_ROOT_FOLDER_RE, "$1").split("/");
      if (_to[0][1] === ":" && _from[0][1] === ":" && _from[0] !== _to[0]) {
        return _to.join("/");
      }
      const _fromCopy = [..._from];
      for (const segment of _fromCopy) {
        if (_to[0] !== segment) {
          break;
        }
        _from.shift();
        _to.shift();
      }
      return [..._from.map(() => ".."), ..._to].join("/");
    };
    var dirname4 = function(p) {
      const segments = normalizeWindowsPath(p).replace(/\/$/, "").split("/").slice(0, -1);
      if (segments.length === 1 && _DRIVE_LETTER_RE.test(segments[0])) {
        segments[0] += "/";
      }
      return segments.join("/") || (isAbsolute2(p) ? "/" : ".");
    };
    var format = function(p) {
      var _a3, _b2;
      const ext = p.ext ? p.ext.startsWith(".") ? p.ext : `.${p.ext}` : "";
      const segments = [p.root, p.dir, (_b2 = p.base) != null ? _b2 : ((_a3 = p.name) != null ? _a3 : "") + ext].filter(
        Boolean
      );
      return normalizeWindowsPath(
        p.root ? resolve4(...segments) : segments.join("/")
      );
    };
    var basename2 = function(p, extension) {
      const segments = normalizeWindowsPath(p).split("/");
      let lastSegment = "";
      for (let i = segments.length - 1; i >= 0; i--) {
        const val = segments[i];
        if (val) {
          lastSegment = val;
          break;
        }
      }
      return extension && lastSegment.endsWith(extension) ? lastSegment.slice(0, -extension.length) : lastSegment;
    };
    var parse2 = function(p) {
      var _a3, _b2;
      const root = ((_b2 = (_a3 = _PATH_ROOT_RE.exec(p)) == null ? void 0 : _a3[0]) == null ? void 0 : _b2.replace(/\\/g, "/")) || "";
      const base = basename2(p);
      const extension = extname(base);
      return {
        root,
        dir: dirname4(p),
        base,
        ext: extension,
        name: base.slice(0, base.length - extension.length)
      };
    };
    var matchesGlob = (path7, pattern) => {
      return zeptomatch(pattern, normalize(path7));
    };
    var _path = {
      __proto__: null,
      basename: basename2,
      dirname: dirname4,
      extname,
      format,
      isAbsolute: isAbsolute2,
      join: join3,
      matchesGlob,
      normalize,
      normalizeString,
      parse: parse2,
      relative,
      resolve: resolve4,
      sep,
      toNamespacedPath
    };
    exports._path = _path;
    exports.basename = basename2;
    exports.dirname = dirname4;
    exports.extname = extname;
    exports.format = format;
    exports.isAbsolute = isAbsolute2;
    exports.join = join3;
    exports.matchesGlob = matchesGlob;
    exports.normalize = normalize;
    exports.normalizeString = normalizeString;
    exports.normalizeWindowsPath = normalizeWindowsPath;
    exports.parse = parse2;
    exports.relative = relative;
    exports.resolve = resolve4;
    exports.sep = sep;
    exports.toNamespacedPath = toNamespacedPath;
  }
});

// ../../node_modules/.pnpm/pathe@2.0.3/node_modules/pathe/dist/index.cjs
var require_dist2 = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/pathe@2.0.3/node_modules/pathe/dist/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _path = require_pathe_BSlhyZSM();
    var delimiter = /* @__PURE__ */ (() => {
      var _a3;
      return ((_a3 = globalThis.process) == null ? void 0 : _a3.platform) === "win32" ? ";" : ":";
    })();
    var _platforms = { posix: void 0, win32: void 0 };
    var mix = (del = delimiter) => {
      return new Proxy(_path._path, {
        get(_, prop) {
          if (prop === "delimiter") return del;
          if (prop === "posix") return posix;
          if (prop === "win32") return win32;
          return _platforms[prop] || _path._path[prop];
        }
      });
    };
    var posix = /* @__PURE__ */ mix(":");
    var win32 = /* @__PURE__ */ mix(";");
    exports.basename = _path.basename;
    exports.dirname = _path.dirname;
    exports.extname = _path.extname;
    exports.format = _path.format;
    exports.isAbsolute = _path.isAbsolute;
    exports.join = _path.join;
    exports.matchesGlob = _path.matchesGlob;
    exports.normalize = _path.normalize;
    exports.normalizeString = _path.normalizeString;
    exports.parse = _path.parse;
    exports.relative = _path.relative;
    exports.resolve = _path.resolve;
    exports.sep = _path.sep;
    exports.toNamespacedPath = _path.toNamespacedPath;
    exports.default = posix;
    exports.delimiter = delimiter;
    exports.posix = posix;
    exports.win32 = win32;
  }
});

// ../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/shared/confbox.3768c7e9.cjs
var require_confbox_3768c7e9 = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/shared/confbox.3768c7e9.cjs"(exports) {
    "use strict";
    var INDENT_REGEX = /^(?:( )+|\t+)/;
    var INDENT_TYPE_SPACE = "space";
    var INDENT_TYPE_TAB = "tab";
    function makeIndentsMap(e2, t) {
      const n2 = /* @__PURE__ */ new Map();
      let i = 0, a, c;
      for (const f of e2.split(/\n/g)) {
        if (!f) continue;
        let l, u, y, m, d;
        const h3 = f.match(INDENT_REGEX);
        if (h3 === null) i = 0, a = "";
        else {
          if (l = h3[0].length, u = h3[1] ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB, t && u === INDENT_TYPE_SPACE && l === 1) continue;
          u !== a && (i = 0), a = u, y = 1, m = 0;
          const p = l - i;
          if (i = l, p === 0) y = 0, m = 1;
          else {
            const g = p > 0 ? p : -p;
            c = encodeIndentsKey(u, g);
          }
          d = n2.get(c), d = d === void 0 ? [1, 0] : [d[0] + y, d[1] + m], n2.set(c, d);
        }
      }
      return n2;
    }
    function encodeIndentsKey(e2, t) {
      return (e2 === INDENT_TYPE_SPACE ? "s" : "t") + String(t);
    }
    function decodeIndentsKey(e2) {
      const n2 = e2[0] === "s" ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB, i = Number(e2.slice(1));
      return { type: n2, amount: i };
    }
    function getMostUsedKey(e2) {
      let t, n2 = 0, i = 0;
      for (const [a, [c, f]] of e2) (c > n2 || c === n2 && f > i) && (n2 = c, i = f, t = a);
      return t;
    }
    function makeIndentString(e2, t) {
      return (e2 === INDENT_TYPE_SPACE ? " " : "	").repeat(t);
    }
    function detectIndent(e2) {
      if (typeof e2 != "string") throw new TypeError("Expected a string");
      let t = makeIndentsMap(e2, true);
      t.size === 0 && (t = makeIndentsMap(e2, false));
      const n2 = getMostUsedKey(t);
      let i, a = 0, c = "";
      return n2 !== void 0 && ({ type: i, amount: a } = decodeIndentsKey(n2), c = makeIndentString(i, a)), { amount: a, type: i, indent: c };
    }
    var r = Symbol.for("__confbox_fmt__");
    var o = /^(\s+)/;
    var s = /(\s+)$/;
    function detectFormat(e2, t = {}) {
      var _a3, _b2;
      const n2 = t.indent === void 0 && t.preserveIndentation !== false && e2.slice(0, (t == null ? void 0 : t.sampleSize) || 1024), i = t.preserveWhitespace === false ? void 0 : { start: ((_a3 = o.exec(e2)) == null ? void 0 : _a3[0]) || "", end: ((_b2 = s.exec(e2)) == null ? void 0 : _b2[0]) || "" };
      return { sample: n2, whiteSpace: i };
    }
    function storeFormat(e2, t, n2) {
      !t || typeof t != "object" || Object.defineProperty(t, r, { enumerable: false, configurable: true, writable: true, value: detectFormat(e2, n2) });
    }
    function getFormat(e2, t) {
      if (!e2 || typeof e2 != "object" || !(r in e2)) return { indent: t == null ? void 0 : t.indent, whitespace: { start: "", end: "" } };
      const n2 = e2[r];
      return { indent: (t == null ? void 0 : t.indent) || detectIndent(n2.sample || "").indent, whitespace: n2.whiteSpace || { start: "", end: "" } };
    }
    exports.getFormat = getFormat, exports.storeFormat = storeFormat;
  }
});

// ../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/json5.cjs
var require_json5 = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/json5.cjs"(exports) {
    "use strict";
    var _format = require_confbox_3768c7e9();
    function getDefaultExportFromCjs(u) {
      return u && u.__esModule && Object.prototype.hasOwnProperty.call(u, "default") ? u.default : u;
    }
    var unicode$1 = {};
    unicode$1.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/, unicode$1.ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/, unicode$1.ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
    var unicode = unicode$1;
    var util$2 = { isSpaceSeparator(u) {
      return typeof u == "string" && unicode.Space_Separator.test(u);
    }, isIdStartChar(u) {
      return typeof u == "string" && (u >= "a" && u <= "z" || u >= "A" && u <= "Z" || u === "$" || u === "_" || unicode.ID_Start.test(u));
    }, isIdContinueChar(u) {
      return typeof u == "string" && (u >= "a" && u <= "z" || u >= "A" && u <= "Z" || u >= "0" && u <= "9" || u === "$" || u === "_" || u === "\u200C" || u === "\u200D" || unicode.ID_Continue.test(u));
    }, isDigit(u) {
      return typeof u == "string" && /[0-9]/.test(u);
    }, isHexDigit(u) {
      return typeof u == "string" && /[0-9A-Fa-f]/.test(u);
    } };
    var util$1 = util$2;
    var source;
    var parseState;
    var stack;
    var pos;
    var line;
    var column;
    var token;
    var key;
    var root;
    var parse2 = function(e2, t) {
      source = String(e2), parseState = "start", stack = [], pos = 0, line = 1, column = 0, token = void 0, key = void 0, root = void 0;
      do
        token = lex(), parseStates[parseState]();
      while (token.type !== "eof");
      return typeof t == "function" ? internalize({ "": root }, "", t) : root;
    };
    function internalize(u, e2, t) {
      const C = u[e2];
      if (C != null && typeof C == "object") if (Array.isArray(C)) for (let s = 0; s < C.length; s++) {
        const E = String(s), f = internalize(C, E, t);
        f === void 0 ? delete C[E] : Object.defineProperty(C, E, { value: f, writable: true, enumerable: true, configurable: true });
      }
      else for (const s in C) {
        const E = internalize(C, s, t);
        E === void 0 ? delete C[s] : Object.defineProperty(C, s, { value: E, writable: true, enumerable: true, configurable: true });
      }
      return t.call(u, e2, C);
    }
    var lexState;
    var buffer;
    var doubleQuote;
    var sign;
    var c;
    function lex() {
      for (lexState = "default", buffer = "", doubleQuote = false, sign = 1; ; ) {
        c = peek();
        const u = lexStates[lexState]();
        if (u) return u;
      }
    }
    function peek() {
      if (source[pos]) return String.fromCodePoint(source.codePointAt(pos));
    }
    function read() {
      const u = peek();
      return u === `
` ? (line++, column = 0) : u ? column += u.length : column++, u && (pos += u.length), u;
    }
    var lexStates = { default() {
      switch (c) {
        case "	":
        case "\v":
        case "\f":
        case " ":
        case "\xA0":
        case "\uFEFF":
        case `
`:
        case "\r":
        case "\u2028":
        case "\u2029":
          read();
          return;
        case "/":
          read(), lexState = "comment";
          return;
        case void 0:
          return read(), newToken("eof");
      }
      if (util$1.isSpaceSeparator(c)) {
        read();
        return;
      }
      return lexStates[parseState]();
    }, comment() {
      switch (c) {
        case "*":
          read(), lexState = "multiLineComment";
          return;
        case "/":
          read(), lexState = "singleLineComment";
          return;
      }
      throw invalidChar(read());
    }, multiLineComment() {
      switch (c) {
        case "*":
          read(), lexState = "multiLineCommentAsterisk";
          return;
        case void 0:
          throw invalidChar(read());
      }
      read();
    }, multiLineCommentAsterisk() {
      switch (c) {
        case "*":
          read();
          return;
        case "/":
          read(), lexState = "default";
          return;
        case void 0:
          throw invalidChar(read());
      }
      read(), lexState = "multiLineComment";
    }, singleLineComment() {
      switch (c) {
        case `
`:
        case "\r":
        case "\u2028":
        case "\u2029":
          read(), lexState = "default";
          return;
        case void 0:
          return read(), newToken("eof");
      }
      read();
    }, value() {
      switch (c) {
        case "{":
        case "[":
          return newToken("punctuator", read());
        case "n":
          return read(), literal("ull"), newToken("null", null);
        case "t":
          return read(), literal("rue"), newToken("boolean", true);
        case "f":
          return read(), literal("alse"), newToken("boolean", false);
        case "-":
        case "+":
          read() === "-" && (sign = -1), lexState = "sign";
          return;
        case ".":
          buffer = read(), lexState = "decimalPointLeading";
          return;
        case "0":
          buffer = read(), lexState = "zero";
          return;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          buffer = read(), lexState = "decimalInteger";
          return;
        case "I":
          return read(), literal("nfinity"), newToken("numeric", 1 / 0);
        case "N":
          return read(), literal("aN"), newToken("numeric", NaN);
        case '"':
        case "'":
          doubleQuote = read() === '"', buffer = "", lexState = "string";
          return;
      }
      throw invalidChar(read());
    }, identifierNameStartEscape() {
      if (c !== "u") throw invalidChar(read());
      read();
      const u = unicodeEscape();
      switch (u) {
        case "$":
        case "_":
          break;
        default:
          if (!util$1.isIdStartChar(u)) throw invalidIdentifier();
          break;
      }
      buffer += u, lexState = "identifierName";
    }, identifierName() {
      switch (c) {
        case "$":
        case "_":
        case "\u200C":
        case "\u200D":
          buffer += read();
          return;
        case "\\":
          read(), lexState = "identifierNameEscape";
          return;
      }
      if (util$1.isIdContinueChar(c)) {
        buffer += read();
        return;
      }
      return newToken("identifier", buffer);
    }, identifierNameEscape() {
      if (c !== "u") throw invalidChar(read());
      read();
      const u = unicodeEscape();
      switch (u) {
        case "$":
        case "_":
        case "\u200C":
        case "\u200D":
          break;
        default:
          if (!util$1.isIdContinueChar(u)) throw invalidIdentifier();
          break;
      }
      buffer += u, lexState = "identifierName";
    }, sign() {
      switch (c) {
        case ".":
          buffer = read(), lexState = "decimalPointLeading";
          return;
        case "0":
          buffer = read(), lexState = "zero";
          return;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          buffer = read(), lexState = "decimalInteger";
          return;
        case "I":
          return read(), literal("nfinity"), newToken("numeric", sign * (1 / 0));
        case "N":
          return read(), literal("aN"), newToken("numeric", NaN);
      }
      throw invalidChar(read());
    }, zero() {
      switch (c) {
        case ".":
          buffer += read(), lexState = "decimalPoint";
          return;
        case "e":
        case "E":
          buffer += read(), lexState = "decimalExponent";
          return;
        case "x":
        case "X":
          buffer += read(), lexState = "hexadecimal";
          return;
      }
      return newToken("numeric", sign * 0);
    }, decimalInteger() {
      switch (c) {
        case ".":
          buffer += read(), lexState = "decimalPoint";
          return;
        case "e":
        case "E":
          buffer += read(), lexState = "decimalExponent";
          return;
      }
      if (util$1.isDigit(c)) {
        buffer += read();
        return;
      }
      return newToken("numeric", sign * Number(buffer));
    }, decimalPointLeading() {
      if (util$1.isDigit(c)) {
        buffer += read(), lexState = "decimalFraction";
        return;
      }
      throw invalidChar(read());
    }, decimalPoint() {
      switch (c) {
        case "e":
        case "E":
          buffer += read(), lexState = "decimalExponent";
          return;
      }
      if (util$1.isDigit(c)) {
        buffer += read(), lexState = "decimalFraction";
        return;
      }
      return newToken("numeric", sign * Number(buffer));
    }, decimalFraction() {
      switch (c) {
        case "e":
        case "E":
          buffer += read(), lexState = "decimalExponent";
          return;
      }
      if (util$1.isDigit(c)) {
        buffer += read();
        return;
      }
      return newToken("numeric", sign * Number(buffer));
    }, decimalExponent() {
      switch (c) {
        case "+":
        case "-":
          buffer += read(), lexState = "decimalExponentSign";
          return;
      }
      if (util$1.isDigit(c)) {
        buffer += read(), lexState = "decimalExponentInteger";
        return;
      }
      throw invalidChar(read());
    }, decimalExponentSign() {
      if (util$1.isDigit(c)) {
        buffer += read(), lexState = "decimalExponentInteger";
        return;
      }
      throw invalidChar(read());
    }, decimalExponentInteger() {
      if (util$1.isDigit(c)) {
        buffer += read();
        return;
      }
      return newToken("numeric", sign * Number(buffer));
    }, hexadecimal() {
      if (util$1.isHexDigit(c)) {
        buffer += read(), lexState = "hexadecimalInteger";
        return;
      }
      throw invalidChar(read());
    }, hexadecimalInteger() {
      if (util$1.isHexDigit(c)) {
        buffer += read();
        return;
      }
      return newToken("numeric", sign * Number(buffer));
    }, string() {
      switch (c) {
        case "\\":
          read(), buffer += escape();
          return;
        case '"':
          if (doubleQuote) return read(), newToken("string", buffer);
          buffer += read();
          return;
        case "'":
          if (!doubleQuote) return read(), newToken("string", buffer);
          buffer += read();
          return;
        case `
`:
        case "\r":
          throw invalidChar(read());
        case "\u2028":
        case "\u2029":
          separatorChar(c);
          break;
        case void 0:
          throw invalidChar(read());
      }
      buffer += read();
    }, start() {
      switch (c) {
        case "{":
        case "[":
          return newToken("punctuator", read());
      }
      lexState = "value";
    }, beforePropertyName() {
      switch (c) {
        case "$":
        case "_":
          buffer = read(), lexState = "identifierName";
          return;
        case "\\":
          read(), lexState = "identifierNameStartEscape";
          return;
        case "}":
          return newToken("punctuator", read());
        case '"':
        case "'":
          doubleQuote = read() === '"', lexState = "string";
          return;
      }
      if (util$1.isIdStartChar(c)) {
        buffer += read(), lexState = "identifierName";
        return;
      }
      throw invalidChar(read());
    }, afterPropertyName() {
      if (c === ":") return newToken("punctuator", read());
      throw invalidChar(read());
    }, beforePropertyValue() {
      lexState = "value";
    }, afterPropertyValue() {
      switch (c) {
        case ",":
        case "}":
          return newToken("punctuator", read());
      }
      throw invalidChar(read());
    }, beforeArrayValue() {
      if (c === "]") return newToken("punctuator", read());
      lexState = "value";
    }, afterArrayValue() {
      switch (c) {
        case ",":
        case "]":
          return newToken("punctuator", read());
      }
      throw invalidChar(read());
    }, end() {
      throw invalidChar(read());
    } };
    function newToken(u, e2) {
      return { type: u, value: e2, line, column };
    }
    function literal(u) {
      for (const e2 of u) {
        if (peek() !== e2) throw invalidChar(read());
        read();
      }
    }
    function escape() {
      switch (peek()) {
        case "b":
          return read(), "\b";
        case "f":
          return read(), "\f";
        case "n":
          return read(), `
`;
        case "r":
          return read(), "\r";
        case "t":
          return read(), "	";
        case "v":
          return read(), "\v";
        case "0":
          if (read(), util$1.isDigit(peek())) throw invalidChar(read());
          return "\0";
        case "x":
          return read(), hexEscape();
        case "u":
          return read(), unicodeEscape();
        case `
`:
        case "\u2028":
        case "\u2029":
          return read(), "";
        case "\r":
          return read(), peek() === `
` && read(), "";
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          throw invalidChar(read());
        case void 0:
          throw invalidChar(read());
      }
      return read();
    }
    function hexEscape() {
      let u = "", e2 = peek();
      if (!util$1.isHexDigit(e2) || (u += read(), e2 = peek(), !util$1.isHexDigit(e2))) throw invalidChar(read());
      return u += read(), String.fromCodePoint(parseInt(u, 16));
    }
    function unicodeEscape() {
      let u = "", e2 = 4;
      for (; e2-- > 0; ) {
        const t = peek();
        if (!util$1.isHexDigit(t)) throw invalidChar(read());
        u += read();
      }
      return String.fromCodePoint(parseInt(u, 16));
    }
    var parseStates = { start() {
      if (token.type === "eof") throw invalidEOF();
      push();
    }, beforePropertyName() {
      switch (token.type) {
        case "identifier":
        case "string":
          key = token.value, parseState = "afterPropertyName";
          return;
        case "punctuator":
          pop();
          return;
        case "eof":
          throw invalidEOF();
      }
    }, afterPropertyName() {
      if (token.type === "eof") throw invalidEOF();
      parseState = "beforePropertyValue";
    }, beforePropertyValue() {
      if (token.type === "eof") throw invalidEOF();
      push();
    }, beforeArrayValue() {
      if (token.type === "eof") throw invalidEOF();
      if (token.type === "punctuator" && token.value === "]") {
        pop();
        return;
      }
      push();
    }, afterPropertyValue() {
      if (token.type === "eof") throw invalidEOF();
      switch (token.value) {
        case ",":
          parseState = "beforePropertyName";
          return;
        case "}":
          pop();
      }
    }, afterArrayValue() {
      if (token.type === "eof") throw invalidEOF();
      switch (token.value) {
        case ",":
          parseState = "beforeArrayValue";
          return;
        case "]":
          pop();
      }
    }, end() {
    } };
    function push() {
      let u;
      switch (token.type) {
        case "punctuator":
          switch (token.value) {
            case "{":
              u = {};
              break;
            case "[":
              u = [];
              break;
          }
          break;
        case "null":
        case "boolean":
        case "numeric":
        case "string":
          u = token.value;
          break;
      }
      if (root === void 0) root = u;
      else {
        const e2 = stack[stack.length - 1];
        Array.isArray(e2) ? e2.push(u) : Object.defineProperty(e2, key, { value: u, writable: true, enumerable: true, configurable: true });
      }
      if (u !== null && typeof u == "object") stack.push(u), Array.isArray(u) ? parseState = "beforeArrayValue" : parseState = "beforePropertyName";
      else {
        const e2 = stack[stack.length - 1];
        e2 == null ? parseState = "end" : Array.isArray(e2) ? parseState = "afterArrayValue" : parseState = "afterPropertyValue";
      }
    }
    function pop() {
      stack.pop();
      const u = stack[stack.length - 1];
      u == null ? parseState = "end" : Array.isArray(u) ? parseState = "afterArrayValue" : parseState = "afterPropertyValue";
    }
    function invalidChar(u) {
      return syntaxError(u === void 0 ? `JSON5: invalid end of input at ${line}:${column}` : `JSON5: invalid character '${formatChar(u)}' at ${line}:${column}`);
    }
    function invalidEOF() {
      return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
    }
    function invalidIdentifier() {
      return column -= 5, syntaxError(`JSON5: invalid identifier character at ${line}:${column}`);
    }
    function separatorChar(u) {
      console.warn(`JSON5: '${formatChar(u)}' in strings is not valid ECMAScript; consider escaping`);
    }
    function formatChar(u) {
      const e2 = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" };
      if (e2[u]) return e2[u];
      if (u < " ") {
        const t = u.charCodeAt(0).toString(16);
        return "\\x" + ("00" + t).substring(t.length);
      }
      return u;
    }
    function syntaxError(u) {
      const e2 = new SyntaxError(u);
      return e2.lineNumber = line, e2.columnNumber = column, e2;
    }
    var o = getDefaultExportFromCjs(parse2);
    var util = util$2;
    var stringify = function(e2, t, C) {
      const s = [];
      let E = "", f, h3, l = "", g;
      if (t != null && typeof t == "object" && !Array.isArray(t) && (C = t.space, g = t.quote, t = t.replacer), typeof t == "function") h3 = t;
      else if (Array.isArray(t)) {
        f = [];
        for (const F of t) {
          let r;
          typeof F == "string" ? r = F : (typeof F == "number" || F instanceof String || F instanceof Number) && (r = String(F)), r !== void 0 && f.indexOf(r) < 0 && f.push(r);
        }
      }
      return C instanceof Number ? C = Number(C) : C instanceof String && (C = String(C)), typeof C == "number" ? C > 0 && (C = Math.min(10, Math.floor(C)), l = "          ".substr(0, C)) : typeof C == "string" && (l = C.substr(0, 10)), m("", { "": e2 });
      function m(F, r) {
        let D = r[F];
        switch (D != null && (typeof D.toJSON5 == "function" ? D = D.toJSON5(F) : typeof D.toJSON == "function" && (D = D.toJSON(F))), h3 && (D = h3.call(r, F, D)), D instanceof Number ? D = Number(D) : D instanceof String ? D = String(D) : D instanceof Boolean && (D = D.valueOf()), D) {
          case null:
            return "null";
          case true:
            return "true";
          case false:
            return "false";
        }
        if (typeof D == "string") return p(D);
        if (typeof D == "number") return String(D);
        if (typeof D == "object") return Array.isArray(D) ? b(D) : y(D);
      }
      function p(F) {
        const r = { "'": 0.1, '"': 0.2 }, D = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" };
        let n2 = "";
        for (let A = 0; A < F.length; A++) {
          const B = F[A];
          switch (B) {
            case "'":
            case '"':
              r[B]++, n2 += B;
              continue;
            case "\0":
              if (util.isDigit(F[A + 1])) {
                n2 += "\\x00";
                continue;
              }
          }
          if (D[B]) {
            n2 += D[B];
            continue;
          }
          if (B < " ") {
            let d = B.charCodeAt(0).toString(16);
            n2 += "\\x" + ("00" + d).substring(d.length);
            continue;
          }
          n2 += B;
        }
        const i = g || Object.keys(r).reduce((A, B) => r[A] < r[B] ? A : B);
        return n2 = n2.replace(new RegExp(i, "g"), D[i]), i + n2 + i;
      }
      function y(F) {
        if (s.indexOf(F) >= 0) throw TypeError("Converting circular structure to JSON5");
        s.push(F);
        let r = E;
        E = E + l;
        let D = f || Object.keys(F), n2 = [];
        for (const A of D) {
          const B = m(A, F);
          if (B !== void 0) {
            let d = w(A) + ":";
            l !== "" && (d += " "), d += B, n2.push(d);
          }
        }
        let i;
        if (n2.length === 0) i = "{}";
        else {
          let A;
          if (l === "") A = n2.join(","), i = "{" + A + "}";
          else {
            let B = `,
` + E;
            A = n2.join(B), i = `{
` + E + A + `,
` + r + "}";
          }
        }
        return s.pop(), E = r, i;
      }
      function w(F) {
        if (F.length === 0) return p(F);
        const r = String.fromCodePoint(F.codePointAt(0));
        if (!util.isIdStartChar(r)) return p(F);
        for (let D = r.length; D < F.length; D++) if (!util.isIdContinueChar(String.fromCodePoint(F.codePointAt(D)))) return p(F);
        return F;
      }
      function b(F) {
        if (s.indexOf(F) >= 0) throw TypeError("Converting circular structure to JSON5");
        s.push(F);
        let r = E;
        E = E + l;
        let D = [];
        for (let i = 0; i < F.length; i++) {
          const A = m(String(i), F);
          D.push(A !== void 0 ? A : "null");
        }
        let n2;
        if (D.length === 0) n2 = "[]";
        else if (l === "") n2 = "[" + D.join(",") + "]";
        else {
          let i = `,
` + E, A = D.join(i);
          n2 = `[
` + E + A + `,
` + r + "]";
        }
        return s.pop(), E = r, n2;
      }
    };
    var a = getDefaultExportFromCjs(stringify);
    function parseJSON5(u, e2) {
      const t = o(u, e2 == null ? void 0 : e2.reviver);
      return _format.storeFormat(u, t, e2), t;
    }
    function stringifyJSON5(u, e2) {
      const t = _format.getFormat(u, e2), C = a(u, e2 == null ? void 0 : e2.replacer, t.indent);
      return t.whitespace.start + C + t.whitespace.end;
    }
    exports.parseJSON5 = parseJSON5, exports.stringifyJSON5 = stringifyJSON5;
  }
});

// ../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/shared/confbox.6b479c78.cjs
var require_confbox_6b479c78 = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/shared/confbox.6b479c78.cjs"(exports) {
    "use strict";
    var _format = require_confbox_3768c7e9();
    function createScanner(n2, l = false) {
      const g = n2.length;
      let e2 = 0, u = "", p = 0, k = 16, A = 0, o = 0, O = 0, r = 0, T = 0;
      function L(t, s) {
        let b = 0, c = 0;
        for (; b < t || !s; ) {
          let i = n2.charCodeAt(e2);
          if (i >= 48 && i <= 57) c = c * 16 + i - 48;
          else if (i >= 65 && i <= 70) c = c * 16 + i - 65 + 10;
          else if (i >= 97 && i <= 102) c = c * 16 + i - 97 + 10;
          else break;
          e2++, b++;
        }
        return b < t && (c = -1), c;
      }
      function v(t) {
        e2 = t, u = "", p = 0, k = 16, T = 0;
      }
      function _() {
        let t = e2;
        if (n2.charCodeAt(e2) === 48) e2++;
        else for (e2++; e2 < n2.length && isDigit(n2.charCodeAt(e2)); ) e2++;
        if (e2 < n2.length && n2.charCodeAt(e2) === 46) if (e2++, e2 < n2.length && isDigit(n2.charCodeAt(e2))) for (e2++; e2 < n2.length && isDigit(n2.charCodeAt(e2)); ) e2++;
        else return T = 3, n2.substring(t, e2);
        let s = e2;
        if (e2 < n2.length && (n2.charCodeAt(e2) === 69 || n2.charCodeAt(e2) === 101)) if (e2++, (e2 < n2.length && n2.charCodeAt(e2) === 43 || n2.charCodeAt(e2) === 45) && e2++, e2 < n2.length && isDigit(n2.charCodeAt(e2))) {
          for (e2++; e2 < n2.length && isDigit(n2.charCodeAt(e2)); ) e2++;
          s = e2;
        } else T = 3;
        return n2.substring(t, s);
      }
      function U() {
        let t = "", s = e2;
        for (; ; ) {
          if (e2 >= g) {
            t += n2.substring(s, e2), T = 2;
            break;
          }
          const b = n2.charCodeAt(e2);
          if (b === 34) {
            t += n2.substring(s, e2), e2++;
            break;
          }
          if (b === 92) {
            if (t += n2.substring(s, e2), e2++, e2 >= g) {
              T = 2;
              break;
            }
            switch (n2.charCodeAt(e2++)) {
              case 34:
                t += '"';
                break;
              case 92:
                t += "\\";
                break;
              case 47:
                t += "/";
                break;
              case 98:
                t += "\b";
                break;
              case 102:
                t += "\f";
                break;
              case 110:
                t += `
`;
                break;
              case 114:
                t += "\r";
                break;
              case 116:
                t += "	";
                break;
              case 117:
                const i = L(4, true);
                i >= 0 ? t += String.fromCharCode(i) : T = 4;
                break;
              default:
                T = 5;
            }
            s = e2;
            continue;
          }
          if (b >= 0 && b <= 31) if (isLineBreak(b)) {
            t += n2.substring(s, e2), T = 2;
            break;
          } else T = 6;
          e2++;
        }
        return t;
      }
      function w() {
        if (u = "", T = 0, p = e2, o = A, r = O, e2 >= g) return p = g, k = 17;
        let t = n2.charCodeAt(e2);
        if (isWhiteSpace(t)) {
          do
            e2++, u += String.fromCharCode(t), t = n2.charCodeAt(e2);
          while (isWhiteSpace(t));
          return k = 15;
        }
        if (isLineBreak(t)) return e2++, u += String.fromCharCode(t), t === 13 && n2.charCodeAt(e2) === 10 && (e2++, u += `
`), A++, O = e2, k = 14;
        switch (t) {
          case 123:
            return e2++, k = 1;
          case 125:
            return e2++, k = 2;
          case 91:
            return e2++, k = 3;
          case 93:
            return e2++, k = 4;
          case 58:
            return e2++, k = 6;
          case 44:
            return e2++, k = 5;
          case 34:
            return e2++, u = U(), k = 10;
          case 47:
            const s = e2 - 1;
            if (n2.charCodeAt(e2 + 1) === 47) {
              for (e2 += 2; e2 < g && !isLineBreak(n2.charCodeAt(e2)); ) e2++;
              return u = n2.substring(s, e2), k = 12;
            }
            if (n2.charCodeAt(e2 + 1) === 42) {
              e2 += 2;
              const b = g - 1;
              let c = false;
              for (; e2 < b; ) {
                const i = n2.charCodeAt(e2);
                if (i === 42 && n2.charCodeAt(e2 + 1) === 47) {
                  e2 += 2, c = true;
                  break;
                }
                e2++, isLineBreak(i) && (i === 13 && n2.charCodeAt(e2) === 10 && e2++, A++, O = e2);
              }
              return c || (e2++, T = 1), u = n2.substring(s, e2), k = 13;
            }
            return u += String.fromCharCode(t), e2++, k = 16;
          case 45:
            if (u += String.fromCharCode(t), e2++, e2 === g || !isDigit(n2.charCodeAt(e2))) return k = 16;
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return u += _(), k = 11;
          default:
            for (; e2 < g && N(t); ) e2++, t = n2.charCodeAt(e2);
            if (p !== e2) {
              switch (u = n2.substring(p, e2), u) {
                case "true":
                  return k = 8;
                case "false":
                  return k = 9;
                case "null":
                  return k = 7;
              }
              return k = 16;
            }
            return u += String.fromCharCode(t), e2++, k = 16;
        }
      }
      function N(t) {
        if (isWhiteSpace(t) || isLineBreak(t)) return false;
        switch (t) {
          case 125:
          case 93:
          case 123:
          case 91:
          case 34:
          case 58:
          case 44:
          case 47:
            return false;
        }
        return true;
      }
      function I() {
        let t;
        do
          t = w();
        while (t >= 12 && t <= 15);
        return t;
      }
      return { setPosition: v, getPosition: () => e2, scan: l ? I : w, getToken: () => k, getTokenValue: () => u, getTokenOffset: () => p, getTokenLength: () => e2 - p, getTokenStartLine: () => o, getTokenStartCharacter: () => p - r, getTokenError: () => T };
    }
    function isWhiteSpace(n2) {
      return n2 === 32 || n2 === 9;
    }
    function isLineBreak(n2) {
      return n2 === 10 || n2 === 13;
    }
    function isDigit(n2) {
      return n2 >= 48 && n2 <= 57;
    }
    var CharacterCodes;
    (function(n2) {
      n2[n2.lineFeed = 10] = "lineFeed", n2[n2.carriageReturn = 13] = "carriageReturn", n2[n2.space = 32] = "space", n2[n2._0 = 48] = "_0", n2[n2._1 = 49] = "_1", n2[n2._2 = 50] = "_2", n2[n2._3 = 51] = "_3", n2[n2._4 = 52] = "_4", n2[n2._5 = 53] = "_5", n2[n2._6 = 54] = "_6", n2[n2._7 = 55] = "_7", n2[n2._8 = 56] = "_8", n2[n2._9 = 57] = "_9", n2[n2.a = 97] = "a", n2[n2.b = 98] = "b", n2[n2.c = 99] = "c", n2[n2.d = 100] = "d", n2[n2.e = 101] = "e", n2[n2.f = 102] = "f", n2[n2.g = 103] = "g", n2[n2.h = 104] = "h", n2[n2.i = 105] = "i", n2[n2.j = 106] = "j", n2[n2.k = 107] = "k", n2[n2.l = 108] = "l", n2[n2.m = 109] = "m", n2[n2.n = 110] = "n", n2[n2.o = 111] = "o", n2[n2.p = 112] = "p", n2[n2.q = 113] = "q", n2[n2.r = 114] = "r", n2[n2.s = 115] = "s", n2[n2.t = 116] = "t", n2[n2.u = 117] = "u", n2[n2.v = 118] = "v", n2[n2.w = 119] = "w", n2[n2.x = 120] = "x", n2[n2.y = 121] = "y", n2[n2.z = 122] = "z", n2[n2.A = 65] = "A", n2[n2.B = 66] = "B", n2[n2.C = 67] = "C", n2[n2.D = 68] = "D", n2[n2.E = 69] = "E", n2[n2.F = 70] = "F", n2[n2.G = 71] = "G", n2[n2.H = 72] = "H", n2[n2.I = 73] = "I", n2[n2.J = 74] = "J", n2[n2.K = 75] = "K", n2[n2.L = 76] = "L", n2[n2.M = 77] = "M", n2[n2.N = 78] = "N", n2[n2.O = 79] = "O", n2[n2.P = 80] = "P", n2[n2.Q = 81] = "Q", n2[n2.R = 82] = "R", n2[n2.S = 83] = "S", n2[n2.T = 84] = "T", n2[n2.U = 85] = "U", n2[n2.V = 86] = "V", n2[n2.W = 87] = "W", n2[n2.X = 88] = "X", n2[n2.Y = 89] = "Y", n2[n2.Z = 90] = "Z", n2[n2.asterisk = 42] = "asterisk", n2[n2.backslash = 92] = "backslash", n2[n2.closeBrace = 125] = "closeBrace", n2[n2.closeBracket = 93] = "closeBracket", n2[n2.colon = 58] = "colon", n2[n2.comma = 44] = "comma", n2[n2.dot = 46] = "dot", n2[n2.doubleQuote = 34] = "doubleQuote", n2[n2.minus = 45] = "minus", n2[n2.openBrace = 123] = "openBrace", n2[n2.openBracket = 91] = "openBracket", n2[n2.plus = 43] = "plus", n2[n2.slash = 47] = "slash", n2[n2.formFeed = 12] = "formFeed", n2[n2.tab = 9] = "tab";
    })(CharacterCodes || (CharacterCodes = {})), new Array(20).fill(0).map((n2, l) => " ".repeat(l));
    var maxCachedValues = 200;
    new Array(maxCachedValues).fill(0).map((n2, l) => `
` + " ".repeat(l)), new Array(maxCachedValues).fill(0).map((n2, l) => "\r" + " ".repeat(l)), new Array(maxCachedValues).fill(0).map((n2, l) => `\r
` + " ".repeat(l)), new Array(maxCachedValues).fill(0).map((n2, l) => `
` + "	".repeat(l)), new Array(maxCachedValues).fill(0).map((n2, l) => "\r" + "	".repeat(l)), new Array(maxCachedValues).fill(0).map((n2, l) => `\r
` + "	".repeat(l));
    var ParseOptions;
    (function(n2) {
      n2.DEFAULT = { allowTrailingComma: false };
    })(ParseOptions || (ParseOptions = {}));
    function parse$1(n2, l = [], g = ParseOptions.DEFAULT) {
      let e2 = null, u = [];
      const p = [];
      function k(o) {
        Array.isArray(u) ? u.push(o) : e2 !== null && (u[e2] = o);
      }
      return visit(n2, { onObjectBegin: () => {
        const o = {};
        k(o), p.push(u), u = o, e2 = null;
      }, onObjectProperty: (o) => {
        e2 = o;
      }, onObjectEnd: () => {
        u = p.pop();
      }, onArrayBegin: () => {
        const o = [];
        k(o), p.push(u), u = o, e2 = null;
      }, onArrayEnd: () => {
        u = p.pop();
      }, onLiteralValue: k, onError: (o, O, r) => {
        l.push({ error: o, offset: O, length: r });
      } }, g), u[0];
    }
    function visit(n2, l, g = ParseOptions.DEFAULT) {
      const e2 = createScanner(n2, false), u = [];
      let p = 0;
      function k(f) {
        return f ? () => p === 0 && f(e2.getTokenOffset(), e2.getTokenLength(), e2.getTokenStartLine(), e2.getTokenStartCharacter()) : () => true;
      }
      function A(f) {
        return f ? (m) => p === 0 && f(m, e2.getTokenOffset(), e2.getTokenLength(), e2.getTokenStartLine(), e2.getTokenStartCharacter()) : () => true;
      }
      function o(f) {
        return f ? (m) => p === 0 && f(m, e2.getTokenOffset(), e2.getTokenLength(), e2.getTokenStartLine(), e2.getTokenStartCharacter(), () => u.slice()) : () => true;
      }
      function O(f) {
        return f ? () => {
          p > 0 ? p++ : f(e2.getTokenOffset(), e2.getTokenLength(), e2.getTokenStartLine(), e2.getTokenStartCharacter(), () => u.slice()) === false && (p = 1);
        } : () => true;
      }
      function r(f) {
        return f ? () => {
          p > 0 && p--, p === 0 && f(e2.getTokenOffset(), e2.getTokenLength(), e2.getTokenStartLine(), e2.getTokenStartCharacter());
        } : () => true;
      }
      const T = O(l.onObjectBegin), L = o(l.onObjectProperty), v = r(l.onObjectEnd), _ = O(l.onArrayBegin), U = r(l.onArrayEnd), w = o(l.onLiteralValue), N = A(l.onSeparator), I = k(l.onComment), t = A(l.onError), s = g && g.disallowComments, b = g && g.allowTrailingComma;
      function c() {
        for (; ; ) {
          const f = e2.scan();
          switch (e2.getTokenError()) {
            case 4:
              i(14);
              break;
            case 5:
              i(15);
              break;
            case 3:
              i(13);
              break;
            case 1:
              s || i(11);
              break;
            case 2:
              i(12);
              break;
            case 6:
              i(16);
              break;
          }
          switch (f) {
            case 12:
            case 13:
              s ? i(10) : I();
              break;
            case 16:
              i(1);
              break;
            case 15:
            case 14:
              break;
            default:
              return f;
          }
        }
      }
      function i(f, m = [], j = []) {
        if (t(f), m.length + j.length > 0) {
          let B = e2.getToken();
          for (; B !== 17; ) {
            if (m.indexOf(B) !== -1) {
              c();
              break;
            } else if (j.indexOf(B) !== -1) break;
            B = c();
          }
        }
      }
      function F(f) {
        const m = e2.getTokenValue();
        return f ? w(m) : (L(m), u.push(m)), c(), true;
      }
      function E() {
        switch (e2.getToken()) {
          case 11:
            const f = e2.getTokenValue();
            let m = Number(f);
            isNaN(m) && (i(2), m = 0), w(m);
            break;
          case 7:
            w(null);
            break;
          case 8:
            w(true);
            break;
          case 9:
            w(false);
            break;
          default:
            return false;
        }
        return c(), true;
      }
      function J() {
        return e2.getToken() !== 10 ? (i(3, [], [2, 5]), false) : (F(false), e2.getToken() === 6 ? (N(":"), c(), V() || i(4, [], [2, 5])) : i(5, [], [2, 5]), u.pop(), true);
      }
      function a() {
        T(), c();
        let f = false;
        for (; e2.getToken() !== 2 && e2.getToken() !== 17; ) {
          if (e2.getToken() === 5) {
            if (f || i(4, [], []), N(","), c(), e2.getToken() === 2 && b) break;
          } else f && i(6, [], []);
          J() || i(4, [], [2, 5]), f = true;
        }
        return v(), e2.getToken() !== 2 ? i(7, [2], []) : c(), true;
      }
      function y() {
        _(), c();
        let f = true, m = false;
        for (; e2.getToken() !== 4 && e2.getToken() !== 17; ) {
          if (e2.getToken() === 5) {
            if (m || i(4, [], []), N(","), c(), e2.getToken() === 4 && b) break;
          } else m && i(6, [], []);
          f ? (u.push(0), f = false) : u[u.length - 1]++, V() || i(4, [], [4, 5]), m = true;
        }
        return U(), f || u.pop(), e2.getToken() !== 4 ? i(8, [4], []) : c(), true;
      }
      function V() {
        switch (e2.getToken()) {
          case 3:
            return y();
          case 1:
            return a();
          case 10:
            return F(true);
          default:
            return E();
        }
      }
      return c(), e2.getToken() === 17 ? g.allowEmptyContent ? true : (i(4, [], []), false) : V() ? (e2.getToken() !== 17 && i(9, [], []), true) : (i(4, [], []), false);
    }
    var ScanError;
    (function(n2) {
      n2[n2.None = 0] = "None", n2[n2.UnexpectedEndOfComment = 1] = "UnexpectedEndOfComment", n2[n2.UnexpectedEndOfString = 2] = "UnexpectedEndOfString", n2[n2.UnexpectedEndOfNumber = 3] = "UnexpectedEndOfNumber", n2[n2.InvalidUnicode = 4] = "InvalidUnicode", n2[n2.InvalidEscapeCharacter = 5] = "InvalidEscapeCharacter", n2[n2.InvalidCharacter = 6] = "InvalidCharacter";
    })(ScanError || (ScanError = {}));
    var SyntaxKind;
    (function(n2) {
      n2[n2.OpenBraceToken = 1] = "OpenBraceToken", n2[n2.CloseBraceToken = 2] = "CloseBraceToken", n2[n2.OpenBracketToken = 3] = "OpenBracketToken", n2[n2.CloseBracketToken = 4] = "CloseBracketToken", n2[n2.CommaToken = 5] = "CommaToken", n2[n2.ColonToken = 6] = "ColonToken", n2[n2.NullKeyword = 7] = "NullKeyword", n2[n2.TrueKeyword = 8] = "TrueKeyword", n2[n2.FalseKeyword = 9] = "FalseKeyword", n2[n2.StringLiteral = 10] = "StringLiteral", n2[n2.NumericLiteral = 11] = "NumericLiteral", n2[n2.LineCommentTrivia = 12] = "LineCommentTrivia", n2[n2.BlockCommentTrivia = 13] = "BlockCommentTrivia", n2[n2.LineBreakTrivia = 14] = "LineBreakTrivia", n2[n2.Trivia = 15] = "Trivia", n2[n2.Unknown = 16] = "Unknown", n2[n2.EOF = 17] = "EOF";
    })(SyntaxKind || (SyntaxKind = {}));
    var parse2 = parse$1;
    var ParseErrorCode;
    (function(n2) {
      n2[n2.InvalidSymbol = 1] = "InvalidSymbol", n2[n2.InvalidNumberFormat = 2] = "InvalidNumberFormat", n2[n2.PropertyNameExpected = 3] = "PropertyNameExpected", n2[n2.ValueExpected = 4] = "ValueExpected", n2[n2.ColonExpected = 5] = "ColonExpected", n2[n2.CommaExpected = 6] = "CommaExpected", n2[n2.CloseBraceExpected = 7] = "CloseBraceExpected", n2[n2.CloseBracketExpected = 8] = "CloseBracketExpected", n2[n2.EndOfFileExpected = 9] = "EndOfFileExpected", n2[n2.InvalidCommentToken = 10] = "InvalidCommentToken", n2[n2.UnexpectedEndOfComment = 11] = "UnexpectedEndOfComment", n2[n2.UnexpectedEndOfString = 12] = "UnexpectedEndOfString", n2[n2.UnexpectedEndOfNumber = 13] = "UnexpectedEndOfNumber", n2[n2.InvalidUnicode = 14] = "InvalidUnicode", n2[n2.InvalidEscapeCharacter = 15] = "InvalidEscapeCharacter", n2[n2.InvalidCharacter = 16] = "InvalidCharacter";
    })(ParseErrorCode || (ParseErrorCode = {}));
    function parseJSON(n2, l) {
      const g = JSON.parse(n2, l == null ? void 0 : l.reviver);
      return _format.storeFormat(n2, g, l), g;
    }
    function stringifyJSON(n2, l) {
      const g = _format.getFormat(n2, l), e2 = JSON.stringify(n2, l == null ? void 0 : l.replacer, g.indent);
      return g.whitespace.start + e2 + g.whitespace.end;
    }
    function parseJSONC(n2, l) {
      const g = parse2(n2, l == null ? void 0 : l.errors, l);
      return _format.storeFormat(n2, g, l), g;
    }
    function stringifyJSONC(n2, l) {
      return stringifyJSON(n2, l);
    }
    exports.parseJSON = parseJSON, exports.parseJSONC = parseJSONC, exports.stringifyJSON = stringifyJSON, exports.stringifyJSONC = stringifyJSONC;
  }
});

// ../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/yaml.cjs
var require_yaml = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/yaml.cjs"(exports) {
    "use strict";
    var _format = require_confbox_3768c7e9();
    function isNothing(e2) {
      return typeof e2 > "u" || e2 === null;
    }
    function isObject3(e2) {
      return typeof e2 == "object" && e2 !== null;
    }
    function toArray4(e2) {
      return Array.isArray(e2) ? e2 : isNothing(e2) ? [] : [e2];
    }
    function extend(e2, n2) {
      var r, o, l, f;
      if (n2) for (f = Object.keys(n2), r = 0, o = f.length; r < o; r += 1) l = f[r], e2[l] = n2[l];
      return e2;
    }
    function repeat(e2, n2) {
      var r = "", o;
      for (o = 0; o < n2; o += 1) r += e2;
      return r;
    }
    function isNegativeZero(e2) {
      return e2 === 0 && Number.NEGATIVE_INFINITY === 1 / e2;
    }
    var isNothing_1 = isNothing;
    var isObject_1 = isObject3;
    var toArray_1 = toArray4;
    var repeat_1 = repeat;
    var isNegativeZero_1 = isNegativeZero;
    var extend_1 = extend;
    var common = { isNothing: isNothing_1, isObject: isObject_1, toArray: toArray_1, repeat: repeat_1, isNegativeZero: isNegativeZero_1, extend: extend_1 };
    function formatError(e2, n2) {
      var r = "", o = e2.reason || "(unknown reason)";
      return e2.mark ? (e2.mark.name && (r += 'in "' + e2.mark.name + '" '), r += "(" + (e2.mark.line + 1) + ":" + (e2.mark.column + 1) + ")", !n2 && e2.mark.snippet && (r += `

` + e2.mark.snippet), o + " " + r) : o;
    }
    function YAMLException$1(e2, n2) {
      Error.call(this), this.name = "YAMLException", this.reason = e2, this.mark = n2, this.message = formatError(this, false), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
    }
    YAMLException$1.prototype = Object.create(Error.prototype), YAMLException$1.prototype.constructor = YAMLException$1, YAMLException$1.prototype.toString = function(n2) {
      return this.name + ": " + formatError(this, n2);
    };
    var exception = YAMLException$1;
    function getLine(e2, n2, r, o, l) {
      var f = "", u = "", c = Math.floor(l / 2) - 1;
      return o - n2 > c && (f = " ... ", n2 = o - c + f.length), r - o > c && (u = " ...", r = o + c - u.length), { str: f + e2.slice(n2, r).replace(/\t/g, "\u2192") + u, pos: o - n2 + f.length };
    }
    function padStart(e2, n2) {
      return common.repeat(" ", n2 - e2.length) + e2;
    }
    function makeSnippet(e2, n2) {
      if (n2 = Object.create(n2 || null), !e2.buffer) return null;
      n2.maxLength || (n2.maxLength = 79), typeof n2.indent != "number" && (n2.indent = 1), typeof n2.linesBefore != "number" && (n2.linesBefore = 3), typeof n2.linesAfter != "number" && (n2.linesAfter = 2);
      for (var r = /\r?\n|\r|\0/g, o = [0], l = [], f, u = -1; f = r.exec(e2.buffer); ) l.push(f.index), o.push(f.index + f[0].length), e2.position <= f.index && u < 0 && (u = o.length - 2);
      u < 0 && (u = o.length - 1);
      var c = "", a, p, h3 = Math.min(e2.line + n2.linesAfter, l.length).toString().length, t = n2.maxLength - (n2.indent + h3 + 3);
      for (a = 1; a <= n2.linesBefore && !(u - a < 0); a++) p = getLine(e2.buffer, o[u - a], l[u - a], e2.position - (o[u] - o[u - a]), t), c = common.repeat(" ", n2.indent) + padStart((e2.line - a + 1).toString(), h3) + " | " + p.str + `
` + c;
      for (p = getLine(e2.buffer, o[u], l[u], e2.position, t), c += common.repeat(" ", n2.indent) + padStart((e2.line + 1).toString(), h3) + " | " + p.str + `
`, c += common.repeat("-", n2.indent + h3 + 3 + p.pos) + `^
`, a = 1; a <= n2.linesAfter && !(u + a >= l.length); a++) p = getLine(e2.buffer, o[u + a], l[u + a], e2.position - (o[u] - o[u + a]), t), c += common.repeat(" ", n2.indent) + padStart((e2.line + a + 1).toString(), h3) + " | " + p.str + `
`;
      return c.replace(/\n$/, "");
    }
    var snippet = makeSnippet;
    var TYPE_CONSTRUCTOR_OPTIONS = ["kind", "multi", "resolve", "construct", "instanceOf", "predicate", "represent", "representName", "defaultStyle", "styleAliases"];
    var YAML_NODE_KINDS = ["scalar", "sequence", "mapping"];
    function compileStyleAliases(e2) {
      var n2 = {};
      return e2 !== null && Object.keys(e2).forEach(function(r) {
        e2[r].forEach(function(o) {
          n2[String(o)] = r;
        });
      }), n2;
    }
    function Type$1(e2, n2) {
      if (n2 = n2 || {}, Object.keys(n2).forEach(function(r) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(r) === -1) throw new exception('Unknown option "' + r + '" is met in definition of "' + e2 + '" YAML type.');
      }), this.options = n2, this.tag = e2, this.kind = n2.kind || null, this.resolve = n2.resolve || function() {
        return true;
      }, this.construct = n2.construct || function(r) {
        return r;
      }, this.instanceOf = n2.instanceOf || null, this.predicate = n2.predicate || null, this.represent = n2.represent || null, this.representName = n2.representName || null, this.defaultStyle = n2.defaultStyle || null, this.multi = n2.multi || false, this.styleAliases = compileStyleAliases(n2.styleAliases || null), YAML_NODE_KINDS.indexOf(this.kind) === -1) throw new exception('Unknown kind "' + this.kind + '" is specified for "' + e2 + '" YAML type.');
    }
    var type = Type$1;
    function compileList(e2, n2) {
      var r = [];
      return e2[n2].forEach(function(o) {
        var l = r.length;
        r.forEach(function(f, u) {
          f.tag === o.tag && f.kind === o.kind && f.multi === o.multi && (l = u);
        }), r[l] = o;
      }), r;
    }
    function compileMap() {
      var e2 = { scalar: {}, sequence: {}, mapping: {}, fallback: {}, multi: { scalar: [], sequence: [], mapping: [], fallback: [] } }, n2, r;
      function o(l) {
        l.multi ? (e2.multi[l.kind].push(l), e2.multi.fallback.push(l)) : e2[l.kind][l.tag] = e2.fallback[l.tag] = l;
      }
      for (n2 = 0, r = arguments.length; n2 < r; n2 += 1) arguments[n2].forEach(o);
      return e2;
    }
    function Schema$1(e2) {
      return this.extend(e2);
    }
    Schema$1.prototype.extend = function(n2) {
      var r = [], o = [];
      if (n2 instanceof type) o.push(n2);
      else if (Array.isArray(n2)) o = o.concat(n2);
      else if (n2 && (Array.isArray(n2.implicit) || Array.isArray(n2.explicit))) n2.implicit && (r = r.concat(n2.implicit)), n2.explicit && (o = o.concat(n2.explicit));
      else throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
      r.forEach(function(f) {
        if (!(f instanceof type)) throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        if (f.loadKind && f.loadKind !== "scalar") throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        if (f.multi) throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
      }), o.forEach(function(f) {
        if (!(f instanceof type)) throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      });
      var l = Object.create(Schema$1.prototype);
      return l.implicit = (this.implicit || []).concat(r), l.explicit = (this.explicit || []).concat(o), l.compiledImplicit = compileList(l, "implicit"), l.compiledExplicit = compileList(l, "explicit"), l.compiledTypeMap = compileMap(l.compiledImplicit, l.compiledExplicit), l;
    };
    var schema = Schema$1;
    var str = new type("tag:yaml.org,2002:str", { kind: "scalar", construct: function(e2) {
      return e2 !== null ? e2 : "";
    } });
    var seq = new type("tag:yaml.org,2002:seq", { kind: "sequence", construct: function(e2) {
      return e2 !== null ? e2 : [];
    } });
    var map = new type("tag:yaml.org,2002:map", { kind: "mapping", construct: function(e2) {
      return e2 !== null ? e2 : {};
    } });
    var failsafe = new schema({ explicit: [str, seq, map] });
    function resolveYamlNull(e2) {
      if (e2 === null) return true;
      var n2 = e2.length;
      return n2 === 1 && e2 === "~" || n2 === 4 && (e2 === "null" || e2 === "Null" || e2 === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull(e2) {
      return e2 === null;
    }
    var _null = new type("tag:yaml.org,2002:null", { kind: "scalar", resolve: resolveYamlNull, construct: constructYamlNull, predicate: isNull, represent: { canonical: function() {
      return "~";
    }, lowercase: function() {
      return "null";
    }, uppercase: function() {
      return "NULL";
    }, camelcase: function() {
      return "Null";
    }, empty: function() {
      return "";
    } }, defaultStyle: "lowercase" });
    function resolveYamlBoolean(e2) {
      if (e2 === null) return false;
      var n2 = e2.length;
      return n2 === 4 && (e2 === "true" || e2 === "True" || e2 === "TRUE") || n2 === 5 && (e2 === "false" || e2 === "False" || e2 === "FALSE");
    }
    function constructYamlBoolean(e2) {
      return e2 === "true" || e2 === "True" || e2 === "TRUE";
    }
    function isBoolean(e2) {
      return Object.prototype.toString.call(e2) === "[object Boolean]";
    }
    var bool = new type("tag:yaml.org,2002:bool", { kind: "scalar", resolve: resolveYamlBoolean, construct: constructYamlBoolean, predicate: isBoolean, represent: { lowercase: function(e2) {
      return e2 ? "true" : "false";
    }, uppercase: function(e2) {
      return e2 ? "TRUE" : "FALSE";
    }, camelcase: function(e2) {
      return e2 ? "True" : "False";
    } }, defaultStyle: "lowercase" });
    function isHexCode(e2) {
      return 48 <= e2 && e2 <= 57 || 65 <= e2 && e2 <= 70 || 97 <= e2 && e2 <= 102;
    }
    function isOctCode(e2) {
      return 48 <= e2 && e2 <= 55;
    }
    function isDecCode(e2) {
      return 48 <= e2 && e2 <= 57;
    }
    function resolveYamlInteger(e2) {
      if (e2 === null) return false;
      var n2 = e2.length, r = 0, o = false, l;
      if (!n2) return false;
      if (l = e2[r], (l === "-" || l === "+") && (l = e2[++r]), l === "0") {
        if (r + 1 === n2) return true;
        if (l = e2[++r], l === "b") {
          for (r++; r < n2; r++) if (l = e2[r], l !== "_") {
            if (l !== "0" && l !== "1") return false;
            o = true;
          }
          return o && l !== "_";
        }
        if (l === "x") {
          for (r++; r < n2; r++) if (l = e2[r], l !== "_") {
            if (!isHexCode(e2.charCodeAt(r))) return false;
            o = true;
          }
          return o && l !== "_";
        }
        if (l === "o") {
          for (r++; r < n2; r++) if (l = e2[r], l !== "_") {
            if (!isOctCode(e2.charCodeAt(r))) return false;
            o = true;
          }
          return o && l !== "_";
        }
      }
      if (l === "_") return false;
      for (; r < n2; r++) if (l = e2[r], l !== "_") {
        if (!isDecCode(e2.charCodeAt(r))) return false;
        o = true;
      }
      return !(!o || l === "_");
    }
    function constructYamlInteger(e2) {
      var n2 = e2, r = 1, o;
      if (n2.indexOf("_") !== -1 && (n2 = n2.replace(/_/g, "")), o = n2[0], (o === "-" || o === "+") && (o === "-" && (r = -1), n2 = n2.slice(1), o = n2[0]), n2 === "0") return 0;
      if (o === "0") {
        if (n2[1] === "b") return r * parseInt(n2.slice(2), 2);
        if (n2[1] === "x") return r * parseInt(n2.slice(2), 16);
        if (n2[1] === "o") return r * parseInt(n2.slice(2), 8);
      }
      return r * parseInt(n2, 10);
    }
    function isInteger(e2) {
      return Object.prototype.toString.call(e2) === "[object Number]" && e2 % 1 === 0 && !common.isNegativeZero(e2);
    }
    var int = new type("tag:yaml.org,2002:int", { kind: "scalar", resolve: resolveYamlInteger, construct: constructYamlInteger, predicate: isInteger, represent: { binary: function(e2) {
      return e2 >= 0 ? "0b" + e2.toString(2) : "-0b" + e2.toString(2).slice(1);
    }, octal: function(e2) {
      return e2 >= 0 ? "0o" + e2.toString(8) : "-0o" + e2.toString(8).slice(1);
    }, decimal: function(e2) {
      return e2.toString(10);
    }, hexadecimal: function(e2) {
      return e2 >= 0 ? "0x" + e2.toString(16).toUpperCase() : "-0x" + e2.toString(16).toUpperCase().slice(1);
    } }, defaultStyle: "decimal", styleAliases: { binary: [2, "bin"], octal: [8, "oct"], decimal: [10, "dec"], hexadecimal: [16, "hex"] } });
    var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
    function resolveYamlFloat(e2) {
      return !(e2 === null || !YAML_FLOAT_PATTERN.test(e2) || e2[e2.length - 1] === "_");
    }
    function constructYamlFloat(e2) {
      var n2, r;
      return n2 = e2.replace(/_/g, "").toLowerCase(), r = n2[0] === "-" ? -1 : 1, "+-".indexOf(n2[0]) >= 0 && (n2 = n2.slice(1)), n2 === ".inf" ? r === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : n2 === ".nan" ? NaN : r * parseFloat(n2, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(e2, n2) {
      var r;
      if (isNaN(e2)) switch (n2) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
      else if (Number.POSITIVE_INFINITY === e2) switch (n2) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
      else if (Number.NEGATIVE_INFINITY === e2) switch (n2) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
      else if (common.isNegativeZero(e2)) return "-0.0";
      return r = e2.toString(10), SCIENTIFIC_WITHOUT_DOT.test(r) ? r.replace("e", ".e") : r;
    }
    function isFloat(e2) {
      return Object.prototype.toString.call(e2) === "[object Number]" && (e2 % 1 !== 0 || common.isNegativeZero(e2));
    }
    var float = new type("tag:yaml.org,2002:float", { kind: "scalar", resolve: resolveYamlFloat, construct: constructYamlFloat, predicate: isFloat, represent: representYamlFloat, defaultStyle: "lowercase" });
    var json = failsafe.extend({ implicit: [_null, bool, int, float] });
    var core = json;
    var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
    var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
    function resolveYamlTimestamp(e2) {
      return e2 === null ? false : YAML_DATE_REGEXP.exec(e2) !== null || YAML_TIMESTAMP_REGEXP.exec(e2) !== null;
    }
    function constructYamlTimestamp(e2) {
      var n2, r, o, l, f, u, c, a = 0, p = null, h3, t, d;
      if (n2 = YAML_DATE_REGEXP.exec(e2), n2 === null && (n2 = YAML_TIMESTAMP_REGEXP.exec(e2)), n2 === null) throw new Error("Date resolve error");
      if (r = +n2[1], o = +n2[2] - 1, l = +n2[3], !n2[4]) return new Date(Date.UTC(r, o, l));
      if (f = +n2[4], u = +n2[5], c = +n2[6], n2[7]) {
        for (a = n2[7].slice(0, 3); a.length < 3; ) a += "0";
        a = +a;
      }
      return n2[9] && (h3 = +n2[10], t = +(n2[11] || 0), p = (h3 * 60 + t) * 6e4, n2[9] === "-" && (p = -p)), d = new Date(Date.UTC(r, o, l, f, u, c, a)), p && d.setTime(d.getTime() - p), d;
    }
    function representYamlTimestamp(e2) {
      return e2.toISOString();
    }
    var timestamp = new type("tag:yaml.org,2002:timestamp", { kind: "scalar", resolve: resolveYamlTimestamp, construct: constructYamlTimestamp, instanceOf: Date, represent: representYamlTimestamp });
    function resolveYamlMerge(e2) {
      return e2 === "<<" || e2 === null;
    }
    var merge = new type("tag:yaml.org,2002:merge", { kind: "scalar", resolve: resolveYamlMerge });
    var BASE64_MAP = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
    function resolveYamlBinary(e2) {
      if (e2 === null) return false;
      var n2, r, o = 0, l = e2.length, f = BASE64_MAP;
      for (r = 0; r < l; r++) if (n2 = f.indexOf(e2.charAt(r)), !(n2 > 64)) {
        if (n2 < 0) return false;
        o += 6;
      }
      return o % 8 === 0;
    }
    function constructYamlBinary(e2) {
      var n2, r, o = e2.replace(/[\r\n=]/g, ""), l = o.length, f = BASE64_MAP, u = 0, c = [];
      for (n2 = 0; n2 < l; n2++) n2 % 4 === 0 && n2 && (c.push(u >> 16 & 255), c.push(u >> 8 & 255), c.push(u & 255)), u = u << 6 | f.indexOf(o.charAt(n2));
      return r = l % 4 * 6, r === 0 ? (c.push(u >> 16 & 255), c.push(u >> 8 & 255), c.push(u & 255)) : r === 18 ? (c.push(u >> 10 & 255), c.push(u >> 2 & 255)) : r === 12 && c.push(u >> 4 & 255), new Uint8Array(c);
    }
    function representYamlBinary(e2) {
      var n2 = "", r = 0, o, l, f = e2.length, u = BASE64_MAP;
      for (o = 0; o < f; o++) o % 3 === 0 && o && (n2 += u[r >> 18 & 63], n2 += u[r >> 12 & 63], n2 += u[r >> 6 & 63], n2 += u[r & 63]), r = (r << 8) + e2[o];
      return l = f % 3, l === 0 ? (n2 += u[r >> 18 & 63], n2 += u[r >> 12 & 63], n2 += u[r >> 6 & 63], n2 += u[r & 63]) : l === 2 ? (n2 += u[r >> 10 & 63], n2 += u[r >> 4 & 63], n2 += u[r << 2 & 63], n2 += u[64]) : l === 1 && (n2 += u[r >> 2 & 63], n2 += u[r << 4 & 63], n2 += u[64], n2 += u[64]), n2;
    }
    function isBinary(e2) {
      return Object.prototype.toString.call(e2) === "[object Uint8Array]";
    }
    var binary = new type("tag:yaml.org,2002:binary", { kind: "scalar", resolve: resolveYamlBinary, construct: constructYamlBinary, predicate: isBinary, represent: representYamlBinary });
    var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
    var _toString$2 = Object.prototype.toString;
    function resolveYamlOmap(e2) {
      if (e2 === null) return true;
      var n2 = [], r, o, l, f, u, c = e2;
      for (r = 0, o = c.length; r < o; r += 1) {
        if (l = c[r], u = false, _toString$2.call(l) !== "[object Object]") return false;
        for (f in l) if (_hasOwnProperty$3.call(l, f)) if (!u) u = true;
        else return false;
        if (!u) return false;
        if (n2.indexOf(f) === -1) n2.push(f);
        else return false;
      }
      return true;
    }
    function constructYamlOmap(e2) {
      return e2 !== null ? e2 : [];
    }
    var omap = new type("tag:yaml.org,2002:omap", { kind: "sequence", resolve: resolveYamlOmap, construct: constructYamlOmap });
    var _toString$1 = Object.prototype.toString;
    function resolveYamlPairs(e2) {
      if (e2 === null) return true;
      var n2, r, o, l, f, u = e2;
      for (f = new Array(u.length), n2 = 0, r = u.length; n2 < r; n2 += 1) {
        if (o = u[n2], _toString$1.call(o) !== "[object Object]" || (l = Object.keys(o), l.length !== 1)) return false;
        f[n2] = [l[0], o[l[0]]];
      }
      return true;
    }
    function constructYamlPairs(e2) {
      if (e2 === null) return [];
      var n2, r, o, l, f, u = e2;
      for (f = new Array(u.length), n2 = 0, r = u.length; n2 < r; n2 += 1) o = u[n2], l = Object.keys(o), f[n2] = [l[0], o[l[0]]];
      return f;
    }
    var pairs = new type("tag:yaml.org,2002:pairs", { kind: "sequence", resolve: resolveYamlPairs, construct: constructYamlPairs });
    var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    function resolveYamlSet(e2) {
      if (e2 === null) return true;
      var n2, r = e2;
      for (n2 in r) if (_hasOwnProperty$2.call(r, n2) && r[n2] !== null) return false;
      return true;
    }
    function constructYamlSet(e2) {
      return e2 !== null ? e2 : {};
    }
    var set = new type("tag:yaml.org,2002:set", { kind: "mapping", resolve: resolveYamlSet, construct: constructYamlSet });
    var _default = core.extend({ implicit: [timestamp, merge], explicit: [binary, omap, pairs, set] });
    var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(e2) {
      return Object.prototype.toString.call(e2);
    }
    function is_EOL(e2) {
      return e2 === 10 || e2 === 13;
    }
    function is_WHITE_SPACE(e2) {
      return e2 === 9 || e2 === 32;
    }
    function is_WS_OR_EOL(e2) {
      return e2 === 9 || e2 === 32 || e2 === 10 || e2 === 13;
    }
    function is_FLOW_INDICATOR(e2) {
      return e2 === 44 || e2 === 91 || e2 === 93 || e2 === 123 || e2 === 125;
    }
    function fromHexCode(e2) {
      var n2;
      return 48 <= e2 && e2 <= 57 ? e2 - 48 : (n2 = e2 | 32, 97 <= n2 && n2 <= 102 ? n2 - 97 + 10 : -1);
    }
    function escapedHexLen(e2) {
      return e2 === 120 ? 2 : e2 === 117 ? 4 : e2 === 85 ? 8 : 0;
    }
    function fromDecimalCode(e2) {
      return 48 <= e2 && e2 <= 57 ? e2 - 48 : -1;
    }
    function simpleEscapeSequence(e2) {
      return e2 === 48 ? "\0" : e2 === 97 ? "\x07" : e2 === 98 ? "\b" : e2 === 116 || e2 === 9 ? "	" : e2 === 110 ? `
` : e2 === 118 ? "\v" : e2 === 102 ? "\f" : e2 === 114 ? "\r" : e2 === 101 ? "\x1B" : e2 === 32 ? " " : e2 === 34 ? '"' : e2 === 47 ? "/" : e2 === 92 ? "\\" : e2 === 78 ? "\x85" : e2 === 95 ? "\xA0" : e2 === 76 ? "\u2028" : e2 === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(e2) {
      return e2 <= 65535 ? String.fromCharCode(e2) : String.fromCharCode((e2 - 65536 >> 10) + 55296, (e2 - 65536 & 1023) + 56320);
    }
    for (simpleEscapeCheck = new Array(256), simpleEscapeMap = new Array(256), i = 0; i < 256; i++) simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0, simpleEscapeMap[i] = simpleEscapeSequence(i);
    var simpleEscapeCheck;
    var simpleEscapeMap;
    var i;
    function State$1(e2, n2) {
      this.input = e2, this.filename = n2.filename || null, this.schema = n2.schema || _default, this.onWarning = n2.onWarning || null, this.legacy = n2.legacy || false, this.json = n2.json || false, this.listener = n2.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e2.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
    }
    function generateError(e2, n2) {
      var r = { name: e2.filename, buffer: e2.input.slice(0, -1), position: e2.position, line: e2.line, column: e2.position - e2.lineStart };
      return r.snippet = snippet(r), new exception(n2, r);
    }
    function throwError(e2, n2) {
      throw generateError(e2, n2);
    }
    function throwWarning(e2, n2) {
      e2.onWarning && e2.onWarning.call(null, generateError(e2, n2));
    }
    var directiveHandlers = { YAML: function(n2, r, o) {
      var l, f, u;
      n2.version !== null && throwError(n2, "duplication of %YAML directive"), o.length !== 1 && throwError(n2, "YAML directive accepts exactly one argument"), l = /^([0-9]+)\.([0-9]+)$/.exec(o[0]), l === null && throwError(n2, "ill-formed argument of the YAML directive"), f = parseInt(l[1], 10), u = parseInt(l[2], 10), f !== 1 && throwError(n2, "unacceptable YAML version of the document"), n2.version = o[0], n2.checkLineBreaks = u < 2, u !== 1 && u !== 2 && throwWarning(n2, "unsupported YAML version of the document");
    }, TAG: function(n2, r, o) {
      var l, f;
      o.length !== 2 && throwError(n2, "TAG directive accepts exactly two arguments"), l = o[0], f = o[1], PATTERN_TAG_HANDLE.test(l) || throwError(n2, "ill-formed tag handle (first argument) of the TAG directive"), _hasOwnProperty$1.call(n2.tagMap, l) && throwError(n2, 'there is a previously declared suffix for "' + l + '" tag handle'), PATTERN_TAG_URI.test(f) || throwError(n2, "ill-formed tag prefix (second argument) of the TAG directive");
      try {
        f = decodeURIComponent(f);
      } catch (e2) {
        throwError(n2, "tag prefix is malformed: " + f);
      }
      n2.tagMap[l] = f;
    } };
    function captureSegment(e2, n2, r, o) {
      var l, f, u, c;
      if (n2 < r) {
        if (c = e2.input.slice(n2, r), o) for (l = 0, f = c.length; l < f; l += 1) u = c.charCodeAt(l), u === 9 || 32 <= u && u <= 1114111 || throwError(e2, "expected valid JSON character");
        else PATTERN_NON_PRINTABLE.test(c) && throwError(e2, "the stream contains non-printable characters");
        e2.result += c;
      }
    }
    function mergeMappings(e2, n2, r, o) {
      var l, f, u, c;
      for (common.isObject(r) || throwError(e2, "cannot merge mappings; the provided source object is unacceptable"), l = Object.keys(r), u = 0, c = l.length; u < c; u += 1) f = l[u], _hasOwnProperty$1.call(n2, f) || (n2[f] = r[f], o[f] = true);
    }
    function storeMappingPair(e2, n2, r, o, l, f, u, c, a) {
      var p, h3;
      if (Array.isArray(l)) for (l = Array.prototype.slice.call(l), p = 0, h3 = l.length; p < h3; p += 1) Array.isArray(l[p]) && throwError(e2, "nested arrays are not supported inside keys"), typeof l == "object" && _class(l[p]) === "[object Object]" && (l[p] = "[object Object]");
      if (typeof l == "object" && _class(l) === "[object Object]" && (l = "[object Object]"), l = String(l), n2 === null && (n2 = {}), o === "tag:yaml.org,2002:merge") if (Array.isArray(f)) for (p = 0, h3 = f.length; p < h3; p += 1) mergeMappings(e2, n2, f[p], r);
      else mergeMappings(e2, n2, f, r);
      else !e2.json && !_hasOwnProperty$1.call(r, l) && _hasOwnProperty$1.call(n2, l) && (e2.line = u || e2.line, e2.lineStart = c || e2.lineStart, e2.position = a || e2.position, throwError(e2, "duplicated mapping key")), l === "__proto__" ? Object.defineProperty(n2, l, { configurable: true, enumerable: true, writable: true, value: f }) : n2[l] = f, delete r[l];
      return n2;
    }
    function readLineBreak(e2) {
      var n2;
      n2 = e2.input.charCodeAt(e2.position), n2 === 10 ? e2.position++ : n2 === 13 ? (e2.position++, e2.input.charCodeAt(e2.position) === 10 && e2.position++) : throwError(e2, "a line break is expected"), e2.line += 1, e2.lineStart = e2.position, e2.firstTabInLine = -1;
    }
    function skipSeparationSpace(e2, n2, r) {
      for (var o = 0, l = e2.input.charCodeAt(e2.position); l !== 0; ) {
        for (; is_WHITE_SPACE(l); ) l === 9 && e2.firstTabInLine === -1 && (e2.firstTabInLine = e2.position), l = e2.input.charCodeAt(++e2.position);
        if (n2 && l === 35) do
          l = e2.input.charCodeAt(++e2.position);
        while (l !== 10 && l !== 13 && l !== 0);
        if (is_EOL(l)) for (readLineBreak(e2), l = e2.input.charCodeAt(e2.position), o++, e2.lineIndent = 0; l === 32; ) e2.lineIndent++, l = e2.input.charCodeAt(++e2.position);
        else break;
      }
      return r !== -1 && o !== 0 && e2.lineIndent < r && throwWarning(e2, "deficient indentation"), o;
    }
    function testDocumentSeparator(e2) {
      var n2 = e2.position, r;
      return r = e2.input.charCodeAt(n2), !!((r === 45 || r === 46) && r === e2.input.charCodeAt(n2 + 1) && r === e2.input.charCodeAt(n2 + 2) && (n2 += 3, r = e2.input.charCodeAt(n2), r === 0 || is_WS_OR_EOL(r)));
    }
    function writeFoldedLines(e2, n2) {
      n2 === 1 ? e2.result += " " : n2 > 1 && (e2.result += common.repeat(`
`, n2 - 1));
    }
    function readPlainScalar(e2, n2, r) {
      var o, l, f, u, c, a, p, h3, t = e2.kind, d = e2.result, s;
      if (s = e2.input.charCodeAt(e2.position), is_WS_OR_EOL(s) || is_FLOW_INDICATOR(s) || s === 35 || s === 38 || s === 42 || s === 33 || s === 124 || s === 62 || s === 39 || s === 34 || s === 37 || s === 64 || s === 96 || (s === 63 || s === 45) && (l = e2.input.charCodeAt(e2.position + 1), is_WS_OR_EOL(l) || r && is_FLOW_INDICATOR(l))) return false;
      for (e2.kind = "scalar", e2.result = "", f = u = e2.position, c = false; s !== 0; ) {
        if (s === 58) {
          if (l = e2.input.charCodeAt(e2.position + 1), is_WS_OR_EOL(l) || r && is_FLOW_INDICATOR(l)) break;
        } else if (s === 35) {
          if (o = e2.input.charCodeAt(e2.position - 1), is_WS_OR_EOL(o)) break;
        } else {
          if (e2.position === e2.lineStart && testDocumentSeparator(e2) || r && is_FLOW_INDICATOR(s)) break;
          if (is_EOL(s)) if (a = e2.line, p = e2.lineStart, h3 = e2.lineIndent, skipSeparationSpace(e2, false, -1), e2.lineIndent >= n2) {
            c = true, s = e2.input.charCodeAt(e2.position);
            continue;
          } else {
            e2.position = u, e2.line = a, e2.lineStart = p, e2.lineIndent = h3;
            break;
          }
        }
        c && (captureSegment(e2, f, u, false), writeFoldedLines(e2, e2.line - a), f = u = e2.position, c = false), is_WHITE_SPACE(s) || (u = e2.position + 1), s = e2.input.charCodeAt(++e2.position);
      }
      return captureSegment(e2, f, u, false), e2.result ? true : (e2.kind = t, e2.result = d, false);
    }
    function readSingleQuotedScalar(e2, n2) {
      var r, o, l;
      if (r = e2.input.charCodeAt(e2.position), r !== 39) return false;
      for (e2.kind = "scalar", e2.result = "", e2.position++, o = l = e2.position; (r = e2.input.charCodeAt(e2.position)) !== 0; ) if (r === 39) if (captureSegment(e2, o, e2.position, true), r = e2.input.charCodeAt(++e2.position), r === 39) o = e2.position, e2.position++, l = e2.position;
      else return true;
      else is_EOL(r) ? (captureSegment(e2, o, l, true), writeFoldedLines(e2, skipSeparationSpace(e2, false, n2)), o = l = e2.position) : e2.position === e2.lineStart && testDocumentSeparator(e2) ? throwError(e2, "unexpected end of the document within a single quoted scalar") : (e2.position++, l = e2.position);
      throwError(e2, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(e2, n2) {
      var r, o, l, f, u, c;
      if (c = e2.input.charCodeAt(e2.position), c !== 34) return false;
      for (e2.kind = "scalar", e2.result = "", e2.position++, r = o = e2.position; (c = e2.input.charCodeAt(e2.position)) !== 0; ) {
        if (c === 34) return captureSegment(e2, r, e2.position, true), e2.position++, true;
        if (c === 92) {
          if (captureSegment(e2, r, e2.position, true), c = e2.input.charCodeAt(++e2.position), is_EOL(c)) skipSeparationSpace(e2, false, n2);
          else if (c < 256 && simpleEscapeCheck[c]) e2.result += simpleEscapeMap[c], e2.position++;
          else if ((u = escapedHexLen(c)) > 0) {
            for (l = u, f = 0; l > 0; l--) c = e2.input.charCodeAt(++e2.position), (u = fromHexCode(c)) >= 0 ? f = (f << 4) + u : throwError(e2, "expected hexadecimal character");
            e2.result += charFromCodepoint(f), e2.position++;
          } else throwError(e2, "unknown escape sequence");
          r = o = e2.position;
        } else is_EOL(c) ? (captureSegment(e2, r, o, true), writeFoldedLines(e2, skipSeparationSpace(e2, false, n2)), r = o = e2.position) : e2.position === e2.lineStart && testDocumentSeparator(e2) ? throwError(e2, "unexpected end of the document within a double quoted scalar") : (e2.position++, o = e2.position);
      }
      throwError(e2, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(e2, n2) {
      var r = true, o, l, f, u = e2.tag, c, a = e2.anchor, p, h3, t, d, s, x2 = /* @__PURE__ */ Object.create(null), g, A, v, m;
      if (m = e2.input.charCodeAt(e2.position), m === 91) h3 = 93, s = false, c = [];
      else if (m === 123) h3 = 125, s = true, c = {};
      else return false;
      for (e2.anchor !== null && (e2.anchorMap[e2.anchor] = c), m = e2.input.charCodeAt(++e2.position); m !== 0; ) {
        if (skipSeparationSpace(e2, true, n2), m = e2.input.charCodeAt(e2.position), m === h3) return e2.position++, e2.tag = u, e2.anchor = a, e2.kind = s ? "mapping" : "sequence", e2.result = c, true;
        r ? m === 44 && throwError(e2, "expected the node content, but found ','") : throwError(e2, "missed comma between flow collection entries"), A = g = v = null, t = d = false, m === 63 && (p = e2.input.charCodeAt(e2.position + 1), is_WS_OR_EOL(p) && (t = d = true, e2.position++, skipSeparationSpace(e2, true, n2))), o = e2.line, l = e2.lineStart, f = e2.position, composeNode(e2, n2, CONTEXT_FLOW_IN, false, true), A = e2.tag, g = e2.result, skipSeparationSpace(e2, true, n2), m = e2.input.charCodeAt(e2.position), (d || e2.line === o) && m === 58 && (t = true, m = e2.input.charCodeAt(++e2.position), skipSeparationSpace(e2, true, n2), composeNode(e2, n2, CONTEXT_FLOW_IN, false, true), v = e2.result), s ? storeMappingPair(e2, c, x2, A, g, v, o, l, f) : t ? c.push(storeMappingPair(e2, null, x2, A, g, v, o, l, f)) : c.push(g), skipSeparationSpace(e2, true, n2), m = e2.input.charCodeAt(e2.position), m === 44 ? (r = true, m = e2.input.charCodeAt(++e2.position)) : r = false;
      }
      throwError(e2, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(e2, n2) {
      var r, o, l = CHOMPING_CLIP, f = false, u = false, c = n2, a = 0, p = false, h3, t;
      if (t = e2.input.charCodeAt(e2.position), t === 124) o = false;
      else if (t === 62) o = true;
      else return false;
      for (e2.kind = "scalar", e2.result = ""; t !== 0; ) if (t = e2.input.charCodeAt(++e2.position), t === 43 || t === 45) CHOMPING_CLIP === l ? l = t === 43 ? CHOMPING_KEEP : CHOMPING_STRIP : throwError(e2, "repeat of a chomping mode identifier");
      else if ((h3 = fromDecimalCode(t)) >= 0) h3 === 0 ? throwError(e2, "bad explicit indentation width of a block scalar; it cannot be less than one") : u ? throwError(e2, "repeat of an indentation width identifier") : (c = n2 + h3 - 1, u = true);
      else break;
      if (is_WHITE_SPACE(t)) {
        do
          t = e2.input.charCodeAt(++e2.position);
        while (is_WHITE_SPACE(t));
        if (t === 35) do
          t = e2.input.charCodeAt(++e2.position);
        while (!is_EOL(t) && t !== 0);
      }
      for (; t !== 0; ) {
        for (readLineBreak(e2), e2.lineIndent = 0, t = e2.input.charCodeAt(e2.position); (!u || e2.lineIndent < c) && t === 32; ) e2.lineIndent++, t = e2.input.charCodeAt(++e2.position);
        if (!u && e2.lineIndent > c && (c = e2.lineIndent), is_EOL(t)) {
          a++;
          continue;
        }
        if (e2.lineIndent < c) {
          l === CHOMPING_KEEP ? e2.result += common.repeat(`
`, f ? 1 + a : a) : l === CHOMPING_CLIP && f && (e2.result += `
`);
          break;
        }
        for (o ? is_WHITE_SPACE(t) ? (p = true, e2.result += common.repeat(`
`, f ? 1 + a : a)) : p ? (p = false, e2.result += common.repeat(`
`, a + 1)) : a === 0 ? f && (e2.result += " ") : e2.result += common.repeat(`
`, a) : e2.result += common.repeat(`
`, f ? 1 + a : a), f = true, u = true, a = 0, r = e2.position; !is_EOL(t) && t !== 0; ) t = e2.input.charCodeAt(++e2.position);
        captureSegment(e2, r, e2.position, false);
      }
      return true;
    }
    function readBlockSequence(e2, n2) {
      var r, o = e2.tag, l = e2.anchor, f = [], u, c = false, a;
      if (e2.firstTabInLine !== -1) return false;
      for (e2.anchor !== null && (e2.anchorMap[e2.anchor] = f), a = e2.input.charCodeAt(e2.position); a !== 0 && (e2.firstTabInLine !== -1 && (e2.position = e2.firstTabInLine, throwError(e2, "tab characters must not be used in indentation")), !(a !== 45 || (u = e2.input.charCodeAt(e2.position + 1), !is_WS_OR_EOL(u)))); ) {
        if (c = true, e2.position++, skipSeparationSpace(e2, true, -1) && e2.lineIndent <= n2) {
          f.push(null), a = e2.input.charCodeAt(e2.position);
          continue;
        }
        if (r = e2.line, composeNode(e2, n2, CONTEXT_BLOCK_IN, false, true), f.push(e2.result), skipSeparationSpace(e2, true, -1), a = e2.input.charCodeAt(e2.position), (e2.line === r || e2.lineIndent > n2) && a !== 0) throwError(e2, "bad indentation of a sequence entry");
        else if (e2.lineIndent < n2) break;
      }
      return c ? (e2.tag = o, e2.anchor = l, e2.kind = "sequence", e2.result = f, true) : false;
    }
    function readBlockMapping(e2, n2, r) {
      var o, l, f, u, c, a, p = e2.tag, h3 = e2.anchor, t = {}, d = /* @__PURE__ */ Object.create(null), s = null, x2 = null, g = null, A = false, v = false, m;
      if (e2.firstTabInLine !== -1) return false;
      for (e2.anchor !== null && (e2.anchorMap[e2.anchor] = t), m = e2.input.charCodeAt(e2.position); m !== 0; ) {
        if (!A && e2.firstTabInLine !== -1 && (e2.position = e2.firstTabInLine, throwError(e2, "tab characters must not be used in indentation")), o = e2.input.charCodeAt(e2.position + 1), f = e2.line, (m === 63 || m === 58) && is_WS_OR_EOL(o)) m === 63 ? (A && (storeMappingPair(e2, t, d, s, x2, null, u, c, a), s = x2 = g = null), v = true, A = true, l = true) : A ? (A = false, l = true) : throwError(e2, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), e2.position += 1, m = o;
        else {
          if (u = e2.line, c = e2.lineStart, a = e2.position, !composeNode(e2, r, CONTEXT_FLOW_OUT, false, true)) break;
          if (e2.line === f) {
            for (m = e2.input.charCodeAt(e2.position); is_WHITE_SPACE(m); ) m = e2.input.charCodeAt(++e2.position);
            if (m === 58) m = e2.input.charCodeAt(++e2.position), is_WS_OR_EOL(m) || throwError(e2, "a whitespace character is expected after the key-value separator within a block mapping"), A && (storeMappingPair(e2, t, d, s, x2, null, u, c, a), s = x2 = g = null), v = true, A = false, l = false, s = e2.tag, x2 = e2.result;
            else if (v) throwError(e2, "can not read an implicit mapping pair; a colon is missed");
            else return e2.tag = p, e2.anchor = h3, true;
          } else if (v) throwError(e2, "can not read a block mapping entry; a multiline key may not be an implicit key");
          else return e2.tag = p, e2.anchor = h3, true;
        }
        if ((e2.line === f || e2.lineIndent > n2) && (A && (u = e2.line, c = e2.lineStart, a = e2.position), composeNode(e2, n2, CONTEXT_BLOCK_OUT, true, l) && (A ? x2 = e2.result : g = e2.result), A || (storeMappingPair(e2, t, d, s, x2, g, u, c, a), s = x2 = g = null), skipSeparationSpace(e2, true, -1), m = e2.input.charCodeAt(e2.position)), (e2.line === f || e2.lineIndent > n2) && m !== 0) throwError(e2, "bad indentation of a mapping entry");
        else if (e2.lineIndent < n2) break;
      }
      return A && storeMappingPair(e2, t, d, s, x2, null, u, c, a), v && (e2.tag = p, e2.anchor = h3, e2.kind = "mapping", e2.result = t), v;
    }
    function readTagProperty(e2) {
      var n2, r = false, o = false, l, f, u;
      if (u = e2.input.charCodeAt(e2.position), u !== 33) return false;
      if (e2.tag !== null && throwError(e2, "duplication of a tag property"), u = e2.input.charCodeAt(++e2.position), u === 60 ? (r = true, u = e2.input.charCodeAt(++e2.position)) : u === 33 ? (o = true, l = "!!", u = e2.input.charCodeAt(++e2.position)) : l = "!", n2 = e2.position, r) {
        do
          u = e2.input.charCodeAt(++e2.position);
        while (u !== 0 && u !== 62);
        e2.position < e2.length ? (f = e2.input.slice(n2, e2.position), u = e2.input.charCodeAt(++e2.position)) : throwError(e2, "unexpected end of the stream within a verbatim tag");
      } else {
        for (; u !== 0 && !is_WS_OR_EOL(u); ) u === 33 && (o ? throwError(e2, "tag suffix cannot contain exclamation marks") : (l = e2.input.slice(n2 - 1, e2.position + 1), PATTERN_TAG_HANDLE.test(l) || throwError(e2, "named tag handle cannot contain such characters"), o = true, n2 = e2.position + 1)), u = e2.input.charCodeAt(++e2.position);
        f = e2.input.slice(n2, e2.position), PATTERN_FLOW_INDICATORS.test(f) && throwError(e2, "tag suffix cannot contain flow indicator characters");
      }
      f && !PATTERN_TAG_URI.test(f) && throwError(e2, "tag name cannot contain such characters: " + f);
      try {
        f = decodeURIComponent(f);
      } catch (e3) {
        throwError(e2, "tag name is malformed: " + f);
      }
      return r ? e2.tag = f : _hasOwnProperty$1.call(e2.tagMap, l) ? e2.tag = e2.tagMap[l] + f : l === "!" ? e2.tag = "!" + f : l === "!!" ? e2.tag = "tag:yaml.org,2002:" + f : throwError(e2, 'undeclared tag handle "' + l + '"'), true;
    }
    function readAnchorProperty(e2) {
      var n2, r;
      if (r = e2.input.charCodeAt(e2.position), r !== 38) return false;
      for (e2.anchor !== null && throwError(e2, "duplication of an anchor property"), r = e2.input.charCodeAt(++e2.position), n2 = e2.position; r !== 0 && !is_WS_OR_EOL(r) && !is_FLOW_INDICATOR(r); ) r = e2.input.charCodeAt(++e2.position);
      return e2.position === n2 && throwError(e2, "name of an anchor node must contain at least one character"), e2.anchor = e2.input.slice(n2, e2.position), true;
    }
    function readAlias(e2) {
      var n2, r, o;
      if (o = e2.input.charCodeAt(e2.position), o !== 42) return false;
      for (o = e2.input.charCodeAt(++e2.position), n2 = e2.position; o !== 0 && !is_WS_OR_EOL(o) && !is_FLOW_INDICATOR(o); ) o = e2.input.charCodeAt(++e2.position);
      return e2.position === n2 && throwError(e2, "name of an alias node must contain at least one character"), r = e2.input.slice(n2, e2.position), _hasOwnProperty$1.call(e2.anchorMap, r) || throwError(e2, 'unidentified alias "' + r + '"'), e2.result = e2.anchorMap[r], skipSeparationSpace(e2, true, -1), true;
    }
    function composeNode(e2, n2, r, o, l) {
      var f, u, c, a = 1, p = false, h3 = false, t, d, s, x2, g, A;
      if (e2.listener !== null && e2.listener("open", e2), e2.tag = null, e2.anchor = null, e2.kind = null, e2.result = null, f = u = c = CONTEXT_BLOCK_OUT === r || CONTEXT_BLOCK_IN === r, o && skipSeparationSpace(e2, true, -1) && (p = true, e2.lineIndent > n2 ? a = 1 : e2.lineIndent === n2 ? a = 0 : e2.lineIndent < n2 && (a = -1)), a === 1) for (; readTagProperty(e2) || readAnchorProperty(e2); ) skipSeparationSpace(e2, true, -1) ? (p = true, c = f, e2.lineIndent > n2 ? a = 1 : e2.lineIndent === n2 ? a = 0 : e2.lineIndent < n2 && (a = -1)) : c = false;
      if (c && (c = p || l), (a === 1 || CONTEXT_BLOCK_OUT === r) && (CONTEXT_FLOW_IN === r || CONTEXT_FLOW_OUT === r ? g = n2 : g = n2 + 1, A = e2.position - e2.lineStart, a === 1 ? c && (readBlockSequence(e2, A) || readBlockMapping(e2, A, g)) || readFlowCollection(e2, g) ? h3 = true : (u && readBlockScalar(e2, g) || readSingleQuotedScalar(e2, g) || readDoubleQuotedScalar(e2, g) ? h3 = true : readAlias(e2) ? (h3 = true, (e2.tag !== null || e2.anchor !== null) && throwError(e2, "alias node should not have any properties")) : readPlainScalar(e2, g, CONTEXT_FLOW_IN === r) && (h3 = true, e2.tag === null && (e2.tag = "?")), e2.anchor !== null && (e2.anchorMap[e2.anchor] = e2.result)) : a === 0 && (h3 = c && readBlockSequence(e2, A))), e2.tag === null) e2.anchor !== null && (e2.anchorMap[e2.anchor] = e2.result);
      else if (e2.tag === "?") {
        for (e2.result !== null && e2.kind !== "scalar" && throwError(e2, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e2.kind + '"'), t = 0, d = e2.implicitTypes.length; t < d; t += 1) if (x2 = e2.implicitTypes[t], x2.resolve(e2.result)) {
          e2.result = x2.construct(e2.result), e2.tag = x2.tag, e2.anchor !== null && (e2.anchorMap[e2.anchor] = e2.result);
          break;
        }
      } else if (e2.tag !== "!") {
        if (_hasOwnProperty$1.call(e2.typeMap[e2.kind || "fallback"], e2.tag)) x2 = e2.typeMap[e2.kind || "fallback"][e2.tag];
        else for (x2 = null, s = e2.typeMap.multi[e2.kind || "fallback"], t = 0, d = s.length; t < d; t += 1) if (e2.tag.slice(0, s[t].tag.length) === s[t].tag) {
          x2 = s[t];
          break;
        }
        x2 || throwError(e2, "unknown tag !<" + e2.tag + ">"), e2.result !== null && x2.kind !== e2.kind && throwError(e2, "unacceptable node kind for !<" + e2.tag + '> tag; it should be "' + x2.kind + '", not "' + e2.kind + '"'), x2.resolve(e2.result, e2.tag) ? (e2.result = x2.construct(e2.result, e2.tag), e2.anchor !== null && (e2.anchorMap[e2.anchor] = e2.result)) : throwError(e2, "cannot resolve a node with !<" + e2.tag + "> explicit tag");
      }
      return e2.listener !== null && e2.listener("close", e2), e2.tag !== null || e2.anchor !== null || h3;
    }
    function readDocument(e2) {
      var n2 = e2.position, r, o, l, f = false, u;
      for (e2.version = null, e2.checkLineBreaks = e2.legacy, e2.tagMap = /* @__PURE__ */ Object.create(null), e2.anchorMap = /* @__PURE__ */ Object.create(null); (u = e2.input.charCodeAt(e2.position)) !== 0 && (skipSeparationSpace(e2, true, -1), u = e2.input.charCodeAt(e2.position), !(e2.lineIndent > 0 || u !== 37)); ) {
        for (f = true, u = e2.input.charCodeAt(++e2.position), r = e2.position; u !== 0 && !is_WS_OR_EOL(u); ) u = e2.input.charCodeAt(++e2.position);
        for (o = e2.input.slice(r, e2.position), l = [], o.length < 1 && throwError(e2, "directive name must not be less than one character in length"); u !== 0; ) {
          for (; is_WHITE_SPACE(u); ) u = e2.input.charCodeAt(++e2.position);
          if (u === 35) {
            do
              u = e2.input.charCodeAt(++e2.position);
            while (u !== 0 && !is_EOL(u));
            break;
          }
          if (is_EOL(u)) break;
          for (r = e2.position; u !== 0 && !is_WS_OR_EOL(u); ) u = e2.input.charCodeAt(++e2.position);
          l.push(e2.input.slice(r, e2.position));
        }
        u !== 0 && readLineBreak(e2), _hasOwnProperty$1.call(directiveHandlers, o) ? directiveHandlers[o](e2, o, l) : throwWarning(e2, 'unknown document directive "' + o + '"');
      }
      if (skipSeparationSpace(e2, true, -1), e2.lineIndent === 0 && e2.input.charCodeAt(e2.position) === 45 && e2.input.charCodeAt(e2.position + 1) === 45 && e2.input.charCodeAt(e2.position + 2) === 45 ? (e2.position += 3, skipSeparationSpace(e2, true, -1)) : f && throwError(e2, "directives end mark is expected"), composeNode(e2, e2.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true), skipSeparationSpace(e2, true, -1), e2.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(e2.input.slice(n2, e2.position)) && throwWarning(e2, "non-ASCII line breaks are interpreted as content"), e2.documents.push(e2.result), e2.position === e2.lineStart && testDocumentSeparator(e2)) {
        e2.input.charCodeAt(e2.position) === 46 && (e2.position += 3, skipSeparationSpace(e2, true, -1));
        return;
      }
      if (e2.position < e2.length - 1) throwError(e2, "end of the stream or a document separator is expected");
      else return;
    }
    function loadDocuments(e2, n2) {
      e2 = String(e2), n2 = n2 || {}, e2.length !== 0 && (e2.charCodeAt(e2.length - 1) !== 10 && e2.charCodeAt(e2.length - 1) !== 13 && (e2 += `
`), e2.charCodeAt(0) === 65279 && (e2 = e2.slice(1)));
      var r = new State$1(e2, n2), o = e2.indexOf("\0");
      for (o !== -1 && (r.position = o, throwError(r, "null byte is not allowed in input")), r.input += "\0"; r.input.charCodeAt(r.position) === 32; ) r.lineIndent += 1, r.position += 1;
      for (; r.position < r.length - 1; ) readDocument(r);
      return r.documents;
    }
    function loadAll$1(e2, n2, r) {
      n2 !== null && typeof n2 == "object" && typeof r > "u" && (r = n2, n2 = null);
      var o = loadDocuments(e2, r);
      if (typeof n2 != "function") return o;
      for (var l = 0, f = o.length; l < f; l += 1) n2(o[l]);
    }
    function load$1(e2, n2) {
      var r = loadDocuments(e2, n2);
      if (r.length !== 0) {
        if (r.length === 1) return r[0];
        throw new exception("expected a single document in the stream, but found more");
      }
    }
    var loadAll_1 = loadAll$1;
    var load_1 = load$1;
    var loader = { loadAll: loadAll_1, load: load_1 };
    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_BOM = 65279;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_CARRIAGE_RETURN = 13;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_ASTERISK = 42;
    var CHAR_COMMA = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0", ESCAPE_SEQUENCES[7] = "\\a", ESCAPE_SEQUENCES[8] = "\\b", ESCAPE_SEQUENCES[9] = "\\t", ESCAPE_SEQUENCES[10] = "\\n", ESCAPE_SEQUENCES[11] = "\\v", ESCAPE_SEQUENCES[12] = "\\f", ESCAPE_SEQUENCES[13] = "\\r", ESCAPE_SEQUENCES[27] = "\\e", ESCAPE_SEQUENCES[34] = '\\"', ESCAPE_SEQUENCES[92] = "\\\\", ESCAPE_SEQUENCES[133] = "\\N", ESCAPE_SEQUENCES[160] = "\\_", ESCAPE_SEQUENCES[8232] = "\\L", ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = ["y", "Y", "yes", "Yes", "YES", "on", "On", "ON", "n", "N", "no", "No", "NO", "off", "Off", "OFF"];
    var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
    function compileStyleMap(e2, n2) {
      var r, o, l, f, u, c, a;
      if (n2 === null) return {};
      for (r = {}, o = Object.keys(n2), l = 0, f = o.length; l < f; l += 1) u = o[l], c = String(n2[u]), u.slice(0, 2) === "!!" && (u = "tag:yaml.org,2002:" + u.slice(2)), a = e2.compiledTypeMap.fallback[u], a && _hasOwnProperty.call(a.styleAliases, c) && (c = a.styleAliases[c]), r[u] = c;
      return r;
    }
    function encodeHex(e2) {
      var n2, r, o;
      if (n2 = e2.toString(16).toUpperCase(), e2 <= 255) r = "x", o = 2;
      else if (e2 <= 65535) r = "u", o = 4;
      else if (e2 <= 4294967295) r = "U", o = 8;
      else throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
      return "\\" + r + common.repeat("0", o - n2.length) + n2;
    }
    var QUOTING_TYPE_SINGLE = 1;
    var QUOTING_TYPE_DOUBLE = 2;
    function State(e2) {
      this.schema = e2.schema || _default, this.indent = Math.max(1, e2.indent || 2), this.noArrayIndent = e2.noArrayIndent || false, this.skipInvalid = e2.skipInvalid || false, this.flowLevel = common.isNothing(e2.flowLevel) ? -1 : e2.flowLevel, this.styleMap = compileStyleMap(this.schema, e2.styles || null), this.sortKeys = e2.sortKeys || false, this.lineWidth = e2.lineWidth || 80, this.noRefs = e2.noRefs || false, this.noCompatMode = e2.noCompatMode || false, this.condenseFlow = e2.condenseFlow || false, this.quotingType = e2.quotingType === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE, this.forceQuotes = e2.forceQuotes || false, this.replacer = typeof e2.replacer == "function" ? e2.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
    }
    function indentString(e2, n2) {
      for (var r = common.repeat(" ", n2), o = 0, l = -1, f = "", u, c = e2.length; o < c; ) l = e2.indexOf(`
`, o), l === -1 ? (u = e2.slice(o), o = c) : (u = e2.slice(o, l + 1), o = l + 1), u.length && u !== `
` && (f += r), f += u;
      return f;
    }
    function generateNextLine(e2, n2) {
      return `
` + common.repeat(" ", e2.indent * n2);
    }
    function testImplicitResolving(e2, n2) {
      var r, o, l;
      for (r = 0, o = e2.implicitTypes.length; r < o; r += 1) if (l = e2.implicitTypes[r], l.resolve(n2)) return true;
      return false;
    }
    function isWhitespace(e2) {
      return e2 === CHAR_SPACE || e2 === CHAR_TAB;
    }
    function isPrintable(e2) {
      return 32 <= e2 && e2 <= 126 || 161 <= e2 && e2 <= 55295 && e2 !== 8232 && e2 !== 8233 || 57344 <= e2 && e2 <= 65533 && e2 !== CHAR_BOM || 65536 <= e2 && e2 <= 1114111;
    }
    function isNsCharOrWhitespace(e2) {
      return isPrintable(e2) && e2 !== CHAR_BOM && e2 !== CHAR_CARRIAGE_RETURN && e2 !== CHAR_LINE_FEED;
    }
    function isPlainSafe(e2, n2, r) {
      var o = isNsCharOrWhitespace(e2), l = o && !isWhitespace(e2);
      return (r ? o : o && e2 !== CHAR_COMMA && e2 !== CHAR_LEFT_SQUARE_BRACKET && e2 !== CHAR_RIGHT_SQUARE_BRACKET && e2 !== CHAR_LEFT_CURLY_BRACKET && e2 !== CHAR_RIGHT_CURLY_BRACKET) && e2 !== CHAR_SHARP && !(n2 === CHAR_COLON && !l) || isNsCharOrWhitespace(n2) && !isWhitespace(n2) && e2 === CHAR_SHARP || n2 === CHAR_COLON && l;
    }
    function isPlainSafeFirst(e2) {
      return isPrintable(e2) && e2 !== CHAR_BOM && !isWhitespace(e2) && e2 !== CHAR_MINUS && e2 !== CHAR_QUESTION && e2 !== CHAR_COLON && e2 !== CHAR_COMMA && e2 !== CHAR_LEFT_SQUARE_BRACKET && e2 !== CHAR_RIGHT_SQUARE_BRACKET && e2 !== CHAR_LEFT_CURLY_BRACKET && e2 !== CHAR_RIGHT_CURLY_BRACKET && e2 !== CHAR_SHARP && e2 !== CHAR_AMPERSAND && e2 !== CHAR_ASTERISK && e2 !== CHAR_EXCLAMATION && e2 !== CHAR_VERTICAL_LINE && e2 !== CHAR_EQUALS && e2 !== CHAR_GREATER_THAN && e2 !== CHAR_SINGLE_QUOTE && e2 !== CHAR_DOUBLE_QUOTE && e2 !== CHAR_PERCENT && e2 !== CHAR_COMMERCIAL_AT && e2 !== CHAR_GRAVE_ACCENT;
    }
    function isPlainSafeLast(e2) {
      return !isWhitespace(e2) && e2 !== CHAR_COLON;
    }
    function codePointAt(e2, n2) {
      var r = e2.charCodeAt(n2), o;
      return r >= 55296 && r <= 56319 && n2 + 1 < e2.length && (o = e2.charCodeAt(n2 + 1), o >= 56320 && o <= 57343) ? (r - 55296) * 1024 + o - 56320 + 65536 : r;
    }
    function needIndentIndicator(e2) {
      var n2 = /^\n* /;
      return n2.test(e2);
    }
    var STYLE_PLAIN = 1;
    var STYLE_SINGLE = 2;
    var STYLE_LITERAL = 3;
    var STYLE_FOLDED = 4;
    var STYLE_DOUBLE = 5;
    function chooseScalarStyle(e2, n2, r, o, l, f, u, c) {
      var a, p = 0, h3 = null, t = false, d = false, s = o !== -1, x2 = -1, g = isPlainSafeFirst(codePointAt(e2, 0)) && isPlainSafeLast(codePointAt(e2, e2.length - 1));
      if (n2 || u) for (a = 0; a < e2.length; p >= 65536 ? a += 2 : a++) {
        if (p = codePointAt(e2, a), !isPrintable(p)) return STYLE_DOUBLE;
        g = g && isPlainSafe(p, h3, c), h3 = p;
      }
      else {
        for (a = 0; a < e2.length; p >= 65536 ? a += 2 : a++) {
          if (p = codePointAt(e2, a), p === CHAR_LINE_FEED) t = true, s && (d = d || a - x2 - 1 > o && e2[x2 + 1] !== " ", x2 = a);
          else if (!isPrintable(p)) return STYLE_DOUBLE;
          g = g && isPlainSafe(p, h3, c), h3 = p;
        }
        d = d || s && a - x2 - 1 > o && e2[x2 + 1] !== " ";
      }
      return !t && !d ? g && !u && !l(e2) ? STYLE_PLAIN : f === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE : r > 9 && needIndentIndicator(e2) ? STYLE_DOUBLE : u ? f === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE : d ? STYLE_FOLDED : STYLE_LITERAL;
    }
    function writeScalar(e2, n2, r, o, l) {
      e2.dump = function() {
        if (n2.length === 0) return e2.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
        if (!e2.noCompatMode && (DEPRECATED_BOOLEANS_SYNTAX.indexOf(n2) !== -1 || DEPRECATED_BASE60_SYNTAX.test(n2))) return e2.quotingType === QUOTING_TYPE_DOUBLE ? '"' + n2 + '"' : "'" + n2 + "'";
        var f = e2.indent * Math.max(1, r), u = e2.lineWidth === -1 ? -1 : Math.max(Math.min(e2.lineWidth, 40), e2.lineWidth - f), c = o || e2.flowLevel > -1 && r >= e2.flowLevel;
        function a(p) {
          return testImplicitResolving(e2, p);
        }
        switch (chooseScalarStyle(n2, c, e2.indent, u, a, e2.quotingType, e2.forceQuotes && !o, l)) {
          case STYLE_PLAIN:
            return n2;
          case STYLE_SINGLE:
            return "'" + n2.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(n2, e2.indent) + dropEndingNewline(indentString(n2, f));
          case STYLE_FOLDED:
            return ">" + blockHeader(n2, e2.indent) + dropEndingNewline(indentString(foldString(n2, u), f));
          case STYLE_DOUBLE:
            return '"' + escapeString(n2) + '"';
          default:
            throw new exception("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(e2, n2) {
      var r = needIndentIndicator(e2) ? String(n2) : "", o = e2[e2.length - 1] === `
`, l = o && (e2[e2.length - 2] === `
` || e2 === `
`), f = l ? "+" : o ? "" : "-";
      return r + f + `
`;
    }
    function dropEndingNewline(e2) {
      return e2[e2.length - 1] === `
` ? e2.slice(0, -1) : e2;
    }
    function foldString(e2, n2) {
      for (var r = /(\n+)([^\n]*)/g, o = function() {
        var p = e2.indexOf(`
`);
        return p = p !== -1 ? p : e2.length, r.lastIndex = p, foldLine(e2.slice(0, p), n2);
      }(), l = e2[0] === `
` || e2[0] === " ", f, u; u = r.exec(e2); ) {
        var c = u[1], a = u[2];
        f = a[0] === " ", o += c + (!l && !f && a !== "" ? `
` : "") + foldLine(a, n2), l = f;
      }
      return o;
    }
    function foldLine(e2, n2) {
      if (e2 === "" || e2[0] === " ") return e2;
      for (var r = / [^ ]/g, o, l = 0, f, u = 0, c = 0, a = ""; o = r.exec(e2); ) c = o.index, c - l > n2 && (f = u > l ? u : c, a += `
` + e2.slice(l, f), l = f + 1), u = c;
      return a += `
`, e2.length - l > n2 && u > l ? a += e2.slice(l, u) + `
` + e2.slice(u + 1) : a += e2.slice(l), a.slice(1);
    }
    function escapeString(e2) {
      for (var n2 = "", r = 0, o, l = 0; l < e2.length; r >= 65536 ? l += 2 : l++) r = codePointAt(e2, l), o = ESCAPE_SEQUENCES[r], !o && isPrintable(r) ? (n2 += e2[l], r >= 65536 && (n2 += e2[l + 1])) : n2 += o || encodeHex(r);
      return n2;
    }
    function writeFlowSequence(e2, n2, r) {
      var o = "", l = e2.tag, f, u, c;
      for (f = 0, u = r.length; f < u; f += 1) c = r[f], e2.replacer && (c = e2.replacer.call(r, String(f), c)), (writeNode(e2, n2, c, false, false) || typeof c > "u" && writeNode(e2, n2, null, false, false)) && (o !== "" && (o += "," + (e2.condenseFlow ? "" : " ")), o += e2.dump);
      e2.tag = l, e2.dump = "[" + o + "]";
    }
    function writeBlockSequence(e2, n2, r, o) {
      var l = "", f = e2.tag, u, c, a;
      for (u = 0, c = r.length; u < c; u += 1) a = r[u], e2.replacer && (a = e2.replacer.call(r, String(u), a)), (writeNode(e2, n2 + 1, a, true, true, false, true) || typeof a > "u" && writeNode(e2, n2 + 1, null, true, true, false, true)) && ((!o || l !== "") && (l += generateNextLine(e2, n2)), e2.dump && CHAR_LINE_FEED === e2.dump.charCodeAt(0) ? l += "-" : l += "- ", l += e2.dump);
      e2.tag = f, e2.dump = l || "[]";
    }
    function writeFlowMapping(e2, n2, r) {
      var o = "", l = e2.tag, f = Object.keys(r), u, c, a, p, h3;
      for (u = 0, c = f.length; u < c; u += 1) h3 = "", o !== "" && (h3 += ", "), e2.condenseFlow && (h3 += '"'), a = f[u], p = r[a], e2.replacer && (p = e2.replacer.call(r, a, p)), writeNode(e2, n2, a, false, false) && (e2.dump.length > 1024 && (h3 += "? "), h3 += e2.dump + (e2.condenseFlow ? '"' : "") + ":" + (e2.condenseFlow ? "" : " "), writeNode(e2, n2, p, false, false) && (h3 += e2.dump, o += h3));
      e2.tag = l, e2.dump = "{" + o + "}";
    }
    function writeBlockMapping(e2, n2, r, o) {
      var l = "", f = e2.tag, u = Object.keys(r), c, a, p, h3, t, d;
      if (e2.sortKeys === true) u.sort();
      else if (typeof e2.sortKeys == "function") u.sort(e2.sortKeys);
      else if (e2.sortKeys) throw new exception("sortKeys must be a boolean or a function");
      for (c = 0, a = u.length; c < a; c += 1) d = "", (!o || l !== "") && (d += generateNextLine(e2, n2)), p = u[c], h3 = r[p], e2.replacer && (h3 = e2.replacer.call(r, p, h3)), writeNode(e2, n2 + 1, p, true, true, true) && (t = e2.tag !== null && e2.tag !== "?" || e2.dump && e2.dump.length > 1024, t && (e2.dump && CHAR_LINE_FEED === e2.dump.charCodeAt(0) ? d += "?" : d += "? "), d += e2.dump, t && (d += generateNextLine(e2, n2)), writeNode(e2, n2 + 1, h3, true, t) && (e2.dump && CHAR_LINE_FEED === e2.dump.charCodeAt(0) ? d += ":" : d += ": ", d += e2.dump, l += d));
      e2.tag = f, e2.dump = l || "{}";
    }
    function detectType(e2, n2, r) {
      var o, l, f, u, c, a;
      for (l = r ? e2.explicitTypes : e2.implicitTypes, f = 0, u = l.length; f < u; f += 1) if (c = l[f], (c.instanceOf || c.predicate) && (!c.instanceOf || typeof n2 == "object" && n2 instanceof c.instanceOf) && (!c.predicate || c.predicate(n2))) {
        if (r ? c.multi && c.representName ? e2.tag = c.representName(n2) : e2.tag = c.tag : e2.tag = "?", c.represent) {
          if (a = e2.styleMap[c.tag] || c.defaultStyle, _toString.call(c.represent) === "[object Function]") o = c.represent(n2, a);
          else if (_hasOwnProperty.call(c.represent, a)) o = c.represent[a](n2, a);
          else throw new exception("!<" + c.tag + '> tag resolver accepts not "' + a + '" style');
          e2.dump = o;
        }
        return true;
      }
      return false;
    }
    function writeNode(e2, n2, r, o, l, f, u) {
      e2.tag = null, e2.dump = r, detectType(e2, r, false) || detectType(e2, r, true);
      var c = _toString.call(e2.dump), a = o, p;
      o && (o = e2.flowLevel < 0 || e2.flowLevel > n2);
      var h3 = c === "[object Object]" || c === "[object Array]", t, d;
      if (h3 && (t = e2.duplicates.indexOf(r), d = t !== -1), (e2.tag !== null && e2.tag !== "?" || d || e2.indent !== 2 && n2 > 0) && (l = false), d && e2.usedDuplicates[t]) e2.dump = "*ref_" + t;
      else {
        if (h3 && d && !e2.usedDuplicates[t] && (e2.usedDuplicates[t] = true), c === "[object Object]") o && Object.keys(e2.dump).length !== 0 ? (writeBlockMapping(e2, n2, e2.dump, l), d && (e2.dump = "&ref_" + t + e2.dump)) : (writeFlowMapping(e2, n2, e2.dump), d && (e2.dump = "&ref_" + t + " " + e2.dump));
        else if (c === "[object Array]") o && e2.dump.length !== 0 ? (e2.noArrayIndent && !u && n2 > 0 ? writeBlockSequence(e2, n2 - 1, e2.dump, l) : writeBlockSequence(e2, n2, e2.dump, l), d && (e2.dump = "&ref_" + t + e2.dump)) : (writeFlowSequence(e2, n2, e2.dump), d && (e2.dump = "&ref_" + t + " " + e2.dump));
        else if (c === "[object String]") e2.tag !== "?" && writeScalar(e2, e2.dump, n2, f, a);
        else {
          if (c === "[object Undefined]") return false;
          if (e2.skipInvalid) return false;
          throw new exception("unacceptable kind of an object to dump " + c);
        }
        e2.tag !== null && e2.tag !== "?" && (p = encodeURI(e2.tag[0] === "!" ? e2.tag.slice(1) : e2.tag).replace(/!/g, "%21"), e2.tag[0] === "!" ? p = "!" + p : p.slice(0, 18) === "tag:yaml.org,2002:" ? p = "!!" + p.slice(18) : p = "!<" + p + ">", e2.dump = p + " " + e2.dump);
      }
      return true;
    }
    function getDuplicateReferences(e2, n2) {
      var r = [], o = [], l, f;
      for (inspectNode(e2, r, o), l = 0, f = o.length; l < f; l += 1) n2.duplicates.push(r[o[l]]);
      n2.usedDuplicates = new Array(f);
    }
    function inspectNode(e2, n2, r) {
      var o, l, f;
      if (e2 !== null && typeof e2 == "object") if (l = n2.indexOf(e2), l !== -1) r.indexOf(l) === -1 && r.push(l);
      else if (n2.push(e2), Array.isArray(e2)) for (l = 0, f = e2.length; l < f; l += 1) inspectNode(e2[l], n2, r);
      else for (o = Object.keys(e2), l = 0, f = o.length; l < f; l += 1) inspectNode(e2[o[l]], n2, r);
    }
    function dump$1(e2, n2) {
      n2 = n2 || {};
      var r = new State(n2);
      r.noRefs || getDuplicateReferences(e2, r);
      var o = e2;
      return r.replacer && (o = r.replacer.call({ "": o }, "", o)), writeNode(r, 0, o, true, true) ? r.dump + `
` : "";
    }
    var dump_1 = dump$1;
    var dumper = { dump: dump_1 };
    var load = loader.load;
    var dump = dumper.dump;
    function parseYAML(e2, n2) {
      const r = load(e2, n2);
      return _format.storeFormat(e2, r, n2), r;
    }
    function stringifyYAML(e2, n2) {
      const r = _format.getFormat(e2, { preserveIndentation: false }), o = typeof r.indent == "string" ? r.indent.length : r.indent, l = dump(e2, { indent: o, ...n2 });
      return r.whitespace.start + l.trim() + r.whitespace.end;
    }
    exports.parseYAML = parseYAML, exports.stringifyYAML = stringifyYAML;
  }
});

// ../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/toml.cjs
var require_toml = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/toml.cjs"(exports) {
    "use strict";
    var _ = Object.defineProperty;
    var A = (e2, n2, t) => n2 in e2 ? _(e2, n2, { enumerable: true, configurable: true, writable: true, value: t }) : e2[n2] = t;
    var b = (e2, n2, t) => (A(e2, typeof n2 != "symbol" ? n2 + "" : n2, t), t);
    var E = (e2, n2, t) => {
      if (!n2.has(e2)) throw TypeError("Cannot " + t);
    };
    var c = (e2, n2, t) => (E(e2, n2, "read from private field"), t ? t.call(e2) : n2.get(e2));
    var O = (e2, n2, t) => {
      if (n2.has(e2)) throw TypeError("Cannot add the same private member more than once");
      n2 instanceof WeakSet ? n2.add(e2) : n2.set(e2, t);
    };
    var d = (e2, n2, t, i) => (E(e2, n2, "write to private field"), i ? i.call(e2, t) : n2.set(e2, t), t);
    var h3;
    var w;
    var s;
    var _format = require_confbox_3768c7e9();
    function getLineColFromPtr(e2, n2) {
      let t = e2.slice(0, n2).split(/\r\n|\n|\r/g);
      return [t.length, t.pop().length + 1];
    }
    function makeCodeBlock(e2, n2, t) {
      let i = e2.split(/\r\n|\n|\r/g), l = "", r = (Math.log10(n2 + 1) | 0) + 1;
      for (let f = n2 - 1; f <= n2 + 1; f++) {
        let o = i[f - 1];
        o && (l += f.toString().padEnd(r, " "), l += ":  ", l += o, l += `
`, f === n2 && (l += " ".repeat(r + t + 2), l += `^
`));
      }
      return l;
    }
    var TomlError = class extends Error {
      constructor(t, i) {
        const [l, r] = getLineColFromPtr(i.toml, i.ptr), f = makeCodeBlock(i.toml, l, r);
        super(`Invalid TOML document: ${t}

${f}`, i);
        b(this, "line");
        b(this, "column");
        b(this, "codeblock");
        this.line = l, this.column = r, this.codeblock = f;
      }
    };
    function indexOfNewline(e2, n2 = 0, t = e2.length) {
      let i = e2.indexOf(`
`, n2);
      return e2[i - 1] === "\r" && i--, i <= t ? i : -1;
    }
    function skipComment(e2, n2) {
      for (let t = n2; t < e2.length; t++) {
        let i = e2[t];
        if (i === `
`) return t;
        if (i === "\r" && e2[t + 1] === `
`) return t + 1;
        if (i < " " && i !== "	" || i === "\x7F") throw new TomlError("control characters are not allowed in comments", { toml: e2, ptr: n2 });
      }
      return e2.length;
    }
    function skipVoid(e2, n2, t, i) {
      let l;
      for (; (l = e2[n2]) === " " || l === "	" || !t && (l === `
` || l === "\r" && e2[n2 + 1] === `
`); ) n2++;
      return i || l !== "#" ? n2 : skipVoid(e2, skipComment(e2, n2), t);
    }
    function skipUntil(e2, n2, t, i, l = false) {
      if (!i) return n2 = indexOfNewline(e2, n2), n2 < 0 ? e2.length : n2;
      for (let r = n2; r < e2.length; r++) {
        let f = e2[r];
        if (f === "#") r = indexOfNewline(e2, r);
        else {
          if (f === t) return r + 1;
          if (f === i) return r;
          if (l && (f === `
` || f === "\r" && e2[r + 1] === `
`)) return r;
        }
      }
      throw new TomlError("cannot find end of structure", { toml: e2, ptr: n2 });
    }
    function getStringEnd(e2, n2) {
      let t = e2[n2], i = t === e2[n2 + 1] && e2[n2 + 1] === e2[n2 + 2] ? e2.slice(n2, n2 + 3) : t;
      n2 += i.length - 1;
      do
        n2 = e2.indexOf(i, ++n2);
      while (n2 > -1 && t !== "'" && e2[n2 - 1] === "\\" && e2[n2 - 2] !== "\\");
      return n2 > -1 && (n2 += i.length, i.length > 1 && (e2[n2] === t && n2++, e2[n2] === t && n2++)), n2;
    }
    var DATE_TIME_RE = /^(\d{4}-\d{2}-\d{2})?[T ]?(?:(\d{2}):\d{2}:\d{2}(?:\.\d+)?)?(Z|[-+]\d{2}:\d{2})?$/i;
    var g = class g2 extends Date {
      constructor(t) {
        let i = true, l = true, r = "Z";
        if (typeof t == "string") {
          let f = t.match(DATE_TIME_RE);
          f ? (f[1] || (i = false, t = `0000-01-01T${t}`), l = !!f[2], f[2] && +f[2] > 23 ? t = "" : (r = f[3] || null, t = t.toUpperCase(), !r && l && (t += "Z"))) : t = "";
        }
        super(t);
        O(this, h3, false);
        O(this, w, false);
        O(this, s, null);
        isNaN(this.getTime()) || (d(this, h3, i), d(this, w, l), d(this, s, r));
      }
      isDateTime() {
        return c(this, h3) && c(this, w);
      }
      isLocal() {
        return !c(this, h3) || !c(this, w) || !c(this, s);
      }
      isDate() {
        return c(this, h3) && !c(this, w);
      }
      isTime() {
        return c(this, w) && !c(this, h3);
      }
      isValid() {
        return c(this, h3) || c(this, w);
      }
      toISOString() {
        let t = super.toISOString();
        if (this.isDate()) return t.slice(0, 10);
        if (this.isTime()) return t.slice(11, 23);
        if (c(this, s) === null) return t.slice(0, -1);
        if (c(this, s) === "Z") return t;
        let i = +c(this, s).slice(1, 3) * 60 + +c(this, s).slice(4, 6);
        return i = c(this, s)[0] === "-" ? i : -i, new Date(this.getTime() - i * 6e4).toISOString().slice(0, -1) + c(this, s);
      }
      static wrapAsOffsetDateTime(t, i = "Z") {
        let l = new g2(t);
        return d(l, s, i), l;
      }
      static wrapAsLocalDateTime(t) {
        let i = new g2(t);
        return d(i, s, null), i;
      }
      static wrapAsLocalDate(t) {
        let i = new g2(t);
        return d(i, w, false), d(i, s, null), i;
      }
      static wrapAsLocalTime(t) {
        let i = new g2(t);
        return d(i, h3, false), d(i, s, null), i;
      }
    };
    h3 = /* @__PURE__ */ new WeakMap(), w = /* @__PURE__ */ new WeakMap(), s = /* @__PURE__ */ new WeakMap();
    var TomlDate = g;
    var INT_REGEX = /^((0x[0-9a-fA-F](_?[0-9a-fA-F])*)|(([+-]|0[ob])?\d(_?\d)*))$/;
    var FLOAT_REGEX = /^[+-]?\d(_?\d)*(\.\d(_?\d)*)?([eE][+-]?\d(_?\d)*)?$/;
    var LEADING_ZERO = /^[+-]?0[0-9_]/;
    var ESCAPE_REGEX = /^[0-9a-f]{4,8}$/i;
    var ESC_MAP = { b: "\b", t: "	", n: `
`, f: "\f", r: "\r", '"': '"', "\\": "\\" };
    function parseString(e2, n2 = 0, t = e2.length) {
      let i = e2[n2] === "'", l = e2[n2++] === e2[n2] && e2[n2] === e2[n2 + 1];
      l && (t -= 2, e2[n2 += 2] === "\r" && n2++, e2[n2] === `
` && n2++);
      let r = 0, f, o = "", a = n2;
      for (; n2 < t - 1; ) {
        let u = e2[n2++];
        if (u === `
` || u === "\r" && e2[n2] === `
`) {
          if (!l) throw new TomlError("newlines are not allowed in strings", { toml: e2, ptr: n2 - 1 });
        } else if (u < " " && u !== "	" || u === "\x7F") throw new TomlError("control characters are not allowed in strings", { toml: e2, ptr: n2 - 1 });
        if (f) {
          if (f = false, u === "u" || u === "U") {
            let m = e2.slice(n2, n2 += u === "u" ? 4 : 8);
            if (!ESCAPE_REGEX.test(m)) throw new TomlError("invalid unicode escape", { toml: e2, ptr: r });
            try {
              o += String.fromCodePoint(parseInt(m, 16));
            } catch (e3) {
              throw new TomlError("invalid unicode escape", { toml: e2, ptr: r });
            }
          } else if (l && (u === `
` || u === " " || u === "	" || u === "\r")) {
            if (n2 = skipVoid(e2, n2 - 1, true), e2[n2] !== `
` && e2[n2] !== "\r") throw new TomlError("invalid escape: only line-ending whitespace may be escaped", { toml: e2, ptr: r });
            n2 = skipVoid(e2, n2);
          } else if (u in ESC_MAP) o += ESC_MAP[u];
          else throw new TomlError("unrecognized escape sequence", { toml: e2, ptr: r });
          a = n2;
        } else !i && u === "\\" && (r = n2 - 1, f = true, o += e2.slice(a, r));
      }
      return o + e2.slice(a, t - 1);
    }
    function parseValue(e2, n2, t) {
      if (e2 === "true") return true;
      if (e2 === "false") return false;
      if (e2 === "-inf") return -1 / 0;
      if (e2 === "inf" || e2 === "+inf") return 1 / 0;
      if (e2 === "nan" || e2 === "+nan" || e2 === "-nan") return NaN;
      if (e2 === "-0") return 0;
      let i;
      if ((i = INT_REGEX.test(e2)) || FLOAT_REGEX.test(e2)) {
        if (LEADING_ZERO.test(e2)) throw new TomlError("leading zeroes are not allowed", { toml: n2, ptr: t });
        let r = +e2.replace(/_/g, "");
        if (isNaN(r)) throw new TomlError("invalid number", { toml: n2, ptr: t });
        if (i && !Number.isSafeInteger(r)) throw new TomlError("integer value cannot be represented losslessly", { toml: n2, ptr: t });
        return r;
      }
      let l = new TomlDate(e2);
      if (!l.isValid()) throw new TomlError("invalid value", { toml: n2, ptr: t });
      return l;
    }
    function sliceAndTrimEndOf(e2, n2, t, i) {
      let l = e2.slice(n2, t), r = l.indexOf("#");
      r > -1 && (skipComment(e2, r), l = l.slice(0, r));
      let f = l.trimEnd();
      if (!i) {
        let o = l.indexOf(`
`, f.length);
        if (o > -1) throw new TomlError("newlines are not allowed in inline tables", { toml: e2, ptr: n2 + o });
      }
      return [f, r];
    }
    function extractValue(e2, n2, t) {
      let i = e2[n2];
      if (i === "[" || i === "{") {
        let [f, o] = i === "[" ? parseArray(e2, n2) : parseInlineTable(e2, n2), a = skipUntil(e2, o, ",", t);
        if (t === "}") {
          let u = indexOfNewline(e2, o, a);
          if (u > -1) throw new TomlError("newlines are not allowed in inline tables", { toml: e2, ptr: u });
        }
        return [f, a];
      }
      let l;
      if (i === '"' || i === "'") {
        l = getStringEnd(e2, n2);
        let f = parseString(e2, n2, l);
        if (t) {
          if (l = skipVoid(e2, l, t !== "]"), e2[l] && e2[l] !== "," && e2[l] !== t && e2[l] !== `
` && e2[l] !== "\r") throw new TomlError("unexpected character encountered", { toml: e2, ptr: l });
          l += +(e2[l] === ",");
        }
        return [f, l];
      }
      l = skipUntil(e2, n2, ",", t);
      let r = sliceAndTrimEndOf(e2, n2, l - +(e2[l - 1] === ","), t === "]");
      if (!r[0]) throw new TomlError("incomplete key-value declaration: no value specified", { toml: e2, ptr: n2 });
      return t && r[1] > -1 && (l = skipVoid(e2, n2 + r[1]), l += +(e2[l] === ",")), [parseValue(r[0], e2, n2), l];
    }
    var KEY_PART_RE = /^[a-zA-Z0-9-_]+[ \t]*$/;
    function parseKey(e2, n2, t = "=") {
      let i = n2 - 1, l = [], r = e2.indexOf(t, n2);
      if (r < 0) throw new TomlError("incomplete key-value: cannot find end of key", { toml: e2, ptr: n2 });
      do {
        let f = e2[n2 = ++i];
        if (f !== " " && f !== "	") if (f === '"' || f === "'") {
          if (f === e2[n2 + 1] && f === e2[n2 + 2]) throw new TomlError("multiline strings are not allowed in keys", { toml: e2, ptr: n2 });
          let o = getStringEnd(e2, n2);
          if (o < 0) throw new TomlError("unfinished string encountered", { toml: e2, ptr: n2 });
          i = e2.indexOf(".", o);
          let a = e2.slice(o, i < 0 || i > r ? r : i), u = indexOfNewline(a);
          if (u > -1) throw new TomlError("newlines are not allowed in keys", { toml: e2, ptr: n2 + i + u });
          if (a.trimStart()) throw new TomlError("found extra tokens after the string part", { toml: e2, ptr: o });
          if (r < o && (r = e2.indexOf(t, o), r < 0)) throw new TomlError("incomplete key-value: cannot find end of key", { toml: e2, ptr: n2 });
          l.push(parseString(e2, n2, o));
        } else {
          i = e2.indexOf(".", n2);
          let o = e2.slice(n2, i < 0 || i > r ? r : i);
          if (!KEY_PART_RE.test(o)) throw new TomlError("only letter, numbers, dashes and underscores are allowed in keys", { toml: e2, ptr: n2 });
          l.push(o.trimEnd());
        }
      } while (i + 1 && i < r);
      return [l, skipVoid(e2, r + 1, true, true)];
    }
    function parseInlineTable(e2, n2) {
      let t = {}, i = /* @__PURE__ */ new Set(), l, r = 0;
      for (n2++; (l = e2[n2++]) !== "}" && l; ) {
        if (l === `
`) throw new TomlError("newlines are not allowed in inline tables", { toml: e2, ptr: n2 - 1 });
        if (l === "#") throw new TomlError("inline tables cannot contain comments", { toml: e2, ptr: n2 - 1 });
        if (l === ",") throw new TomlError("expected key-value, found comma", { toml: e2, ptr: n2 - 1 });
        if (l !== " " && l !== "	") {
          let f, o = t, a = false, [u, m] = parseKey(e2, n2 - 1);
          for (let y = 0; y < u.length; y++) {
            if (y && (o = a ? o[f] : o[f] = {}), f = u[y], (a = Object.hasOwn(o, f)) && (typeof o[f] != "object" || i.has(o[f]))) throw new TomlError("trying to redefine an already defined value", { toml: e2, ptr: n2 });
            !a && f === "__proto__" && Object.defineProperty(o, f, { enumerable: true, configurable: true, writable: true });
          }
          if (a) throw new TomlError("trying to redefine an already defined value", { toml: e2, ptr: n2 });
          let [T, x2] = extractValue(e2, m, "}");
          i.add(T), o[f] = T, n2 = x2, r = e2[n2 - 1] === "," ? n2 - 1 : 0;
        }
      }
      if (r) throw new TomlError("trailing commas are not allowed in inline tables", { toml: e2, ptr: r });
      if (!l) throw new TomlError("unfinished table encountered", { toml: e2, ptr: n2 });
      return [t, n2];
    }
    function parseArray(e2, n2) {
      let t = [], i;
      for (n2++; (i = e2[n2++]) !== "]" && i; ) {
        if (i === ",") throw new TomlError("expected value, found comma", { toml: e2, ptr: n2 - 1 });
        if (i === "#") n2 = skipComment(e2, n2);
        else if (i !== " " && i !== "	" && i !== `
` && i !== "\r") {
          let l = extractValue(e2, n2 - 1, "]");
          t.push(l[0]), n2 = l[1];
        }
      }
      if (!i) throw new TomlError("unfinished array encountered", { toml: e2, ptr: n2 });
      return [t, n2];
    }
    function peekTable(e2, n2, t, i) {
      var _a3, _b2;
      let l = n2, r = t, f, o = false, a;
      for (let u = 0; u < e2.length; u++) {
        if (u) {
          if (l = o ? l[f] : l[f] = {}, r = (a = r[f]).c, i === 0 && (a.t === 1 || a.t === 2)) return null;
          if (a.t === 2) {
            let m = l.length - 1;
            l = l[m], r = r[m].c;
          }
        }
        if (f = e2[u], (o = Object.hasOwn(l, f)) && ((_a3 = r[f]) == null ? void 0 : _a3.t) === 0 && ((_b2 = r[f]) == null ? void 0 : _b2.d)) return null;
        o || (f === "__proto__" && (Object.defineProperty(l, f, { enumerable: true, configurable: true, writable: true }), Object.defineProperty(r, f, { enumerable: true, configurable: true, writable: true })), r[f] = { t: u < e2.length - 1 && i === 2 ? 3 : i, d: false, i: 0, c: {} });
      }
      if (a = r[f], a.t !== i && !(i === 1 && a.t === 3) || (i === 2 && (a.d || (a.d = true, l[f] = []), l[f].push(l = {}), a.c[a.i++] = a = { t: 1, d: false, i: 0, c: {} }), a.d)) return null;
      if (a.d = true, i === 1) l = o ? l[f] : l[f] = {};
      else if (i === 0 && o) return null;
      return [f, l, a.c];
    }
    function parse2(e2) {
      let n2 = {}, t = {}, i = n2, l = t;
      for (let r = skipVoid(e2, 0); r < e2.length; ) {
        if (e2[r] === "[") {
          let f = e2[++r] === "[", o = parseKey(e2, r += +f, "]");
          if (f) {
            if (e2[o[1] - 1] !== "]") throw new TomlError("expected end of table declaration", { toml: e2, ptr: o[1] - 1 });
            o[1]++;
          }
          let a = peekTable(o[0], n2, t, f ? 2 : 1);
          if (!a) throw new TomlError("trying to redefine an already defined table or value", { toml: e2, ptr: r });
          l = a[2], i = a[1], r = o[1];
        } else {
          let f = parseKey(e2, r), o = peekTable(f[0], i, l, 0);
          if (!o) throw new TomlError("trying to redefine an already defined table or value", { toml: e2, ptr: r });
          let a = extractValue(e2, f[1]);
          o[1][o[0]] = a[0], r = a[1];
        }
        if (r = skipVoid(e2, r, true), e2[r] && e2[r] !== `
` && e2[r] !== "\r") throw new TomlError("each key-value declaration must be followed by an end-of-line", { toml: e2, ptr: r });
        r = skipVoid(e2, r);
      }
      return n2;
    }
    var BARE_KEY = /^[a-z0-9-_]+$/i;
    function extendedTypeOf(e2) {
      let n2 = typeof e2;
      if (n2 === "object") {
        if (Array.isArray(e2)) return "array";
        if (e2 instanceof Date) return "date";
      }
      return n2;
    }
    function isArrayOfTables(e2) {
      for (let n2 = 0; n2 < e2.length; n2++) if (extendedTypeOf(e2[n2]) !== "object") return false;
      return e2.length != 0;
    }
    function formatString(e2) {
      return JSON.stringify(e2).replace(/\x7f/g, "\\u007f");
    }
    function stringifyValue(e2, n2 = extendedTypeOf(e2)) {
      if (n2 === "number") return isNaN(e2) ? "nan" : e2 === 1 / 0 ? "inf" : e2 === -1 / 0 ? "-inf" : e2.toString();
      if (n2 === "bigint" || n2 === "boolean") return e2.toString();
      if (n2 === "string") return formatString(e2);
      if (n2 === "date") {
        if (isNaN(e2.getTime())) throw new TypeError("cannot serialize invalid date");
        return e2.toISOString();
      }
      if (n2 === "object") return stringifyInlineTable(e2);
      if (n2 === "array") return stringifyArray(e2);
    }
    function stringifyInlineTable(e2) {
      let n2 = Object.keys(e2);
      if (n2.length === 0) return "{}";
      let t = "{ ";
      for (let i = 0; i < n2.length; i++) {
        let l = n2[i];
        i && (t += ", "), t += BARE_KEY.test(l) ? l : formatString(l), t += " = ", t += stringifyValue(e2[l]);
      }
      return t + " }";
    }
    function stringifyArray(e2) {
      if (e2.length === 0) return "[]";
      let n2 = "[ ";
      for (let t = 0; t < e2.length; t++) {
        if (t && (n2 += ", "), e2[t] === null || e2[t] === void 0) throw new TypeError("arrays cannot contain null or undefined values");
        n2 += stringifyValue(e2[t]);
      }
      return n2 + " ]";
    }
    function stringifyArrayTable(e2, n2) {
      let t = "";
      for (let i = 0; i < e2.length; i++) t += `[[${n2}]]
`, t += stringifyTable(e2[i], n2), t += `

`;
      return t;
    }
    function stringifyTable(e2, n2 = "") {
      let t = "", i = "", l = Object.keys(e2);
      for (let r = 0; r < l.length; r++) {
        let f = l[r];
        if (e2[f] !== null && e2[f] !== void 0) {
          let o = extendedTypeOf(e2[f]);
          if (o === "symbol" || o === "function") throw new TypeError(`cannot serialize values of type '${o}'`);
          let a = BARE_KEY.test(f) ? f : formatString(f);
          if (o === "array" && isArrayOfTables(e2[f])) i += stringifyArrayTable(e2[f], n2 ? `${n2}.${a}` : a);
          else if (o === "object") {
            let u = n2 ? `${n2}.${a}` : a;
            i += `[${u}]
`, i += stringifyTable(e2[f], u), i += `

`;
          } else t += a, t += " = ", t += stringifyValue(e2[f], o), t += `
`;
        }
      }
      return `${t}
${i}`.trim();
    }
    function stringify(e2) {
      if (extendedTypeOf(e2) !== "object") throw new TypeError("stringify can only be called with an object");
      return stringifyTable(e2);
    }
    function parseTOML(e2) {
      const n2 = parse2(e2);
      return _format.storeFormat(e2, n2, { preserveIndentation: false }), n2;
    }
    function stringifyTOML(e2) {
      const n2 = _format.getFormat(e2, { preserveIndentation: false }), t = stringify(e2);
      return n2.whitespace.start + t + n2.whitespace.end;
    }
    exports.parseTOML = parseTOML, exports.stringifyTOML = stringifyTOML;
  }
});

// ../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/index.cjs
var require_dist3 = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/index.cjs"(exports) {
    "use strict";
    var json5 = require_json5();
    var jsonc = require_confbox_6b479c78();
    var yaml = require_yaml();
    var toml = require_toml();
    require_confbox_3768c7e9(), exports.parseJSON5 = json5.parseJSON5, exports.stringifyJSON5 = json5.stringifyJSON5, exports.parseJSON = jsonc.parseJSON, exports.parseJSONC = jsonc.parseJSONC, exports.stringifyJSON = jsonc.stringifyJSON, exports.stringifyJSONC = jsonc.stringifyJSONC, exports.parseYAML = yaml.parseYAML, exports.stringifyYAML = yaml.stringifyYAML, exports.parseTOML = toml.parseTOML, exports.stringifyTOML = toml.stringifyTOML;
  }
});

// ../../node_modules/.pnpm/pkg-types@1.3.1/node_modules/pkg-types/dist/index.cjs
var require_dist4 = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/pkg-types@1.3.1/node_modules/pkg-types/dist/index.cjs"(exports) {
    "use strict";
    var node_fs = _chunk42PBKAQTcjs.__require.call(void 0, "fs");
    var pathe = require_dist2();
    var mlly = require_dist5();
    var confbox = require_dist3();
    var defaultFindOptions = {
      startingFrom: ".",
      rootPattern: /^node_modules$/,
      reverse: false,
      test: (filePath) => {
        try {
          if (node_fs.statSync(filePath).isFile()) {
            return true;
          }
        } catch (e2) {
        }
      }
    };
    async function findFile(filename, _options = {}) {
      const filenames = Array.isArray(filename) ? filename : [filename];
      const options = { ...defaultFindOptions, ..._options };
      const basePath = pathe.resolve(options.startingFrom);
      const leadingSlash = basePath[0] === "/";
      const segments = basePath.split("/").filter(Boolean);
      if (leadingSlash) {
        segments[0] = "/" + segments[0];
      }
      let root = segments.findIndex((r) => r.match(options.rootPattern));
      if (root === -1) {
        root = 0;
      }
      if (options.reverse) {
        for (let index = root + 1; index <= segments.length; index++) {
          for (const filename2 of filenames) {
            const filePath = pathe.join(...segments.slice(0, index), filename2);
            if (await options.test(filePath)) {
              return filePath;
            }
          }
        }
      } else {
        for (let index = segments.length; index > root; index--) {
          for (const filename2 of filenames) {
            const filePath = pathe.join(...segments.slice(0, index), filename2);
            if (await options.test(filePath)) {
              return filePath;
            }
          }
        }
      }
      throw new Error(
        `Cannot find matching ${filename} in ${options.startingFrom} or parent directories`
      );
    }
    function findNearestFile(filename, _options = {}) {
      return findFile(filename, _options);
    }
    function findFarthestFile(filename, _options = {}) {
      return findFile(filename, { ..._options, reverse: true });
    }
    function definePackageJSON(package_) {
      return package_;
    }
    function defineTSConfig(tsconfig) {
      return tsconfig;
    }
    var FileCache = /* @__PURE__ */ new Map();
    async function readPackageJSON(id, options = {}) {
      const resolvedPath = await resolvePackageJSON(id, options);
      const cache2 = options.cache && typeof options.cache !== "boolean" ? options.cache : FileCache;
      if (options.cache && cache2.has(resolvedPath)) {
        return cache2.get(resolvedPath);
      }
      const blob = await node_fs.promises.readFile(resolvedPath, "utf8");
      let parsed;
      try {
        parsed = confbox.parseJSON(blob);
      } catch (e2) {
        parsed = confbox.parseJSONC(blob);
      }
      cache2.set(resolvedPath, parsed);
      return parsed;
    }
    async function writePackageJSON(path7, package_) {
      await node_fs.promises.writeFile(path7, confbox.stringifyJSON(package_));
    }
    async function readTSConfig(id, options = {}) {
      const resolvedPath = await resolveTSConfig(id, options);
      const cache2 = options.cache && typeof options.cache !== "boolean" ? options.cache : FileCache;
      if (options.cache && cache2.has(resolvedPath)) {
        return cache2.get(resolvedPath);
      }
      const text = await node_fs.promises.readFile(resolvedPath, "utf8");
      const parsed = confbox.parseJSONC(text);
      cache2.set(resolvedPath, parsed);
      return parsed;
    }
    async function writeTSConfig(path7, tsconfig) {
      await node_fs.promises.writeFile(path7, confbox.stringifyJSONC(tsconfig));
    }
    async function resolvePackageJSON(id = process.cwd(), options = {}) {
      const resolvedPath = pathe.isAbsolute(id) ? id : await mlly.resolvePath(id, options);
      return findNearestFile("package.json", {
        startingFrom: resolvedPath,
        ...options
      });
    }
    async function resolveTSConfig(id = process.cwd(), options = {}) {
      const resolvedPath = pathe.isAbsolute(id) ? id : await mlly.resolvePath(id, options);
      return findNearestFile("tsconfig.json", {
        startingFrom: resolvedPath,
        ...options
      });
    }
    var lockFiles = [
      "yarn.lock",
      "package-lock.json",
      "pnpm-lock.yaml",
      "npm-shrinkwrap.json",
      "bun.lockb",
      "bun.lock"
    ];
    async function resolveLockfile(id = process.cwd(), options = {}) {
      const resolvedPath = pathe.isAbsolute(id) ? id : await mlly.resolvePath(id, options);
      const _options = { startingFrom: resolvedPath, ...options };
      try {
        return await findNearestFile(lockFiles, _options);
      } catch (e2) {
      }
      throw new Error("No lockfile found from " + id);
    }
    async function findWorkspaceDir(id = process.cwd(), options = {}) {
      const resolvedPath = pathe.isAbsolute(id) ? id : await mlly.resolvePath(id, options);
      const _options = { startingFrom: resolvedPath, ...options };
      try {
        const r = await findNearestFile(".git/config", _options);
        return pathe.resolve(r, "../..");
      } catch (e2) {
      }
      try {
        const r = await resolveLockfile(resolvedPath, {
          ..._options,
          reverse: true
        });
        return pathe.dirname(r);
      } catch (e2) {
      }
      try {
        const r = await findFile(resolvedPath, _options);
        return pathe.dirname(r);
      } catch (e2) {
      }
      throw new Error("Cannot detect workspace root from " + id);
    }
    exports.definePackageJSON = definePackageJSON;
    exports.defineTSConfig = defineTSConfig;
    exports.findFarthestFile = findFarthestFile;
    exports.findFile = findFile;
    exports.findNearestFile = findNearestFile;
    exports.findWorkspaceDir = findWorkspaceDir;
    exports.readPackageJSON = readPackageJSON;
    exports.readTSConfig = readTSConfig;
    exports.resolveLockfile = resolveLockfile;
    exports.resolvePackageJSON = resolvePackageJSON;
    exports.resolveTSConfig = resolveTSConfig;
    exports.writePackageJSON = writePackageJSON;
    exports.writeTSConfig = writeTSConfig;
  }
});

// ../../node_modules/.pnpm/mlly@1.7.4/node_modules/mlly/dist/index.cjs
var require_dist5 = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/mlly@1.7.4/node_modules/mlly/dist/index.cjs"(exports) {
    "use strict";
    var acorn = require_acorn();
    var node_module = _chunk42PBKAQTcjs.__require.call(void 0, "module");
    var fs5 = _chunk42PBKAQTcjs.__require.call(void 0, "fs");
    var ufo = require_dist();
    var pathe = require_dist2();
    var pkgTypes = require_dist4();
    var node_url = _chunk42PBKAQTcjs.__require.call(void 0, "url");
    var assert = _chunk42PBKAQTcjs.__require.call(void 0, "assert");
    var process$1 = _chunk42PBKAQTcjs.__require.call(void 0, "process");
    var path7 = _chunk42PBKAQTcjs.__require.call(void 0, "path");
    var v8 = _chunk42PBKAQTcjs.__require.call(void 0, "v8");
    var node_util = _chunk42PBKAQTcjs.__require.call(void 0, "util");
    function _interopDefaultCompat(e2) {
      return e2 && typeof e2 === "object" && "default" in e2 ? e2.default : e2;
    }
    var fs__default = /* @__PURE__ */ _interopDefaultCompat(fs5);
    var assert__default = /* @__PURE__ */ _interopDefaultCompat(assert);
    var process__default = /* @__PURE__ */ _interopDefaultCompat(process$1);
    var path__default = /* @__PURE__ */ _interopDefaultCompat(path7);
    var v8__default = /* @__PURE__ */ _interopDefaultCompat(v8);
    var BUILTIN_MODULES = new Set(node_module.builtinModules);
    function normalizeSlash(path8) {
      return path8.replace(/\\/g, "/");
    }
    function isObject3(value) {
      return value !== null && typeof value === "object";
    }
    function matchAll(regex, string, addition) {
      const matches = [];
      for (const match of string.matchAll(regex)) {
        matches.push({
          ...addition,
          ...match.groups,
          code: match[0],
          start: match.index,
          end: (match.index || 0) + match[0].length
        });
      }
      return matches;
    }
    function clearImports(imports) {
      return (imports || "").replace(/(\/\/[^\n]*\n|\/\*.*\*\/)/g, "").replace(/\s+/g, " ");
    }
    function getImportNames(cleanedImports) {
      var _a3, _b2;
      const topLevelImports = cleanedImports.replace(/{([^}]*)}/, "");
      const namespacedImport = (_a3 = topLevelImports.match(/\* as \s*(\S*)/)) == null ? void 0 : _a3[1];
      const defaultImport = ((_b2 = topLevelImports.split(",").find((index) => !/[*{}]/.test(index))) == null ? void 0 : _b2.trim()) || void 0;
      return {
        namespacedImport,
        defaultImport
      };
    }
    var own$1 = {}.hasOwnProperty;
    var classRegExp = /^([A-Z][a-z\d]*)+$/;
    var kTypes = /* @__PURE__ */ new Set([
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ]);
    var codes = {};
    function formatList(array, type = "and") {
      return array.length < 3 ? array.join(` ${type} `) : `${array.slice(0, -1).join(", ")}, ${type} ${array[array.length - 1]}`;
    }
    var messages = /* @__PURE__ */ new Map();
    var nodeInternalPrefix = "__node_internal_";
    var userStackTraceLimit;
    codes.ERR_INVALID_ARG_TYPE = createError(
      "ERR_INVALID_ARG_TYPE",
      /**
       * @param {string} name
       * @param {Array<string> | string} expected
       * @param {unknown} actual
       */
      (name2, expected, actual) => {
        assert__default(typeof name2 === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let message = "The ";
        if (name2.endsWith(" argument")) {
          message += `${name2} `;
        } else {
          const type = name2.includes(".") ? "property" : "argument";
          message += `"${name2}" ${type} `;
        }
        message += "must be ";
        const types = [];
        const instances = [];
        const other = [];
        for (const value of expected) {
          assert__default(
            typeof value === "string",
            "All expected entries have to be of type string"
          );
          if (kTypes.has(value)) {
            types.push(value.toLowerCase());
          } else if (classRegExp.exec(value) === null) {
            assert__default(
              value !== "object",
              'The value "object" should be written as "Object"'
            );
            other.push(value);
          } else {
            instances.push(value);
          }
        }
        if (instances.length > 0) {
          const pos = types.indexOf("object");
          if (pos !== -1) {
            types.slice(pos, 1);
            instances.push("Object");
          }
        }
        if (types.length > 0) {
          message += `${types.length > 1 ? "one of type" : "of type"} ${formatList(
            types,
            "or"
          )}`;
          if (instances.length > 0 || other.length > 0) message += " or ";
        }
        if (instances.length > 0) {
          message += `an instance of ${formatList(instances, "or")}`;
          if (other.length > 0) message += " or ";
        }
        if (other.length > 0) {
          if (other.length > 1) {
            message += `one of ${formatList(other, "or")}`;
          } else {
            if (other[0].toLowerCase() !== other[0]) message += "an ";
            message += `${other[0]}`;
          }
        }
        message += `. Received ${determineSpecificType(actual)}`;
        return message;
      },
      TypeError
    );
    codes.ERR_INVALID_MODULE_SPECIFIER = createError(
      "ERR_INVALID_MODULE_SPECIFIER",
      /**
       * @param {string} request
       * @param {string} reason
       * @param {string} [base]
       */
      (request, reason, base = void 0) => {
        return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`;
      },
      TypeError
    );
    codes.ERR_INVALID_PACKAGE_CONFIG = createError(
      "ERR_INVALID_PACKAGE_CONFIG",
      /**
       * @param {string} path
       * @param {string} [base]
       * @param {string} [message]
       */
      (path8, base, message) => {
        return `Invalid package config ${path8}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`;
      },
      Error
    );
    codes.ERR_INVALID_PACKAGE_TARGET = createError(
      "ERR_INVALID_PACKAGE_TARGET",
      /**
       * @param {string} packagePath
       * @param {string} key
       * @param {unknown} target
       * @param {boolean} [isImport=false]
       * @param {string} [base]
       */
      (packagePath, key, target, isImport = false, base = void 0) => {
        const relatedError = typeof target === "string" && !isImport && target.length > 0 && !target.startsWith("./");
        if (key === ".") {
          assert__default(isImport === false);
          return `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
        }
        return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(
          target
        )} defined for '${key}' in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
      },
      Error
    );
    codes.ERR_MODULE_NOT_FOUND = createError(
      "ERR_MODULE_NOT_FOUND",
      /**
       * @param {string} path
       * @param {string} base
       * @param {boolean} [exactUrl]
       */
      (path8, base, exactUrl = false) => {
        return `Cannot find ${exactUrl ? "module" : "package"} '${path8}' imported from ${base}`;
      },
      Error
    );
    codes.ERR_NETWORK_IMPORT_DISALLOWED = createError(
      "ERR_NETWORK_IMPORT_DISALLOWED",
      "import of '%s' by %s is not supported: %s",
      Error
    );
    codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(
      "ERR_PACKAGE_IMPORT_NOT_DEFINED",
      /**
       * @param {string} specifier
       * @param {string} packagePath
       * @param {string} base
       */
      (specifier, packagePath, base) => {
        return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`;
      },
      TypeError
    );
    codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError(
      "ERR_PACKAGE_PATH_NOT_EXPORTED",
      /**
       * @param {string} packagePath
       * @param {string} subpath
       * @param {string} [base]
       */
      (packagePath, subpath, base = void 0) => {
        if (subpath === ".")
          return `No "exports" main defined in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
        return `Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
      },
      Error
    );
    codes.ERR_UNSUPPORTED_DIR_IMPORT = createError(
      "ERR_UNSUPPORTED_DIR_IMPORT",
      "Directory import '%s' is not supported resolving ES modules imported from %s",
      Error
    );
    codes.ERR_UNSUPPORTED_RESOLVE_REQUEST = createError(
      "ERR_UNSUPPORTED_RESOLVE_REQUEST",
      'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.',
      TypeError
    );
    codes.ERR_UNKNOWN_FILE_EXTENSION = createError(
      "ERR_UNKNOWN_FILE_EXTENSION",
      /**
       * @param {string} extension
       * @param {string} path
       */
      (extension, path8) => {
        return `Unknown file extension "${extension}" for ${path8}`;
      },
      TypeError
    );
    codes.ERR_INVALID_ARG_VALUE = createError(
      "ERR_INVALID_ARG_VALUE",
      /**
       * @param {string} name
       * @param {unknown} value
       * @param {string} [reason='is invalid']
       */
      (name2, value, reason = "is invalid") => {
        let inspected = node_util.inspect(value);
        if (inspected.length > 128) {
          inspected = `${inspected.slice(0, 128)}...`;
        }
        const type = name2.includes(".") ? "property" : "argument";
        return `The ${type} '${name2}' ${reason}. Received ${inspected}`;
      },
      TypeError
      // Note: extra classes have been shaken out.
      // , RangeError
    );
    function createError(sym, value, constructor) {
      messages.set(sym, value);
      return makeNodeErrorWithCode(constructor, sym);
    }
    function makeNodeErrorWithCode(Base, key) {
      return NodeError;
      function NodeError(...parameters) {
        const limit = Error.stackTraceLimit;
        if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
        const error = new Base();
        if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;
        const message = getMessage(key, parameters, error);
        Object.defineProperties(error, {
          // Note: no need to implement `kIsNodeError` symbol, would be hard,
          // probably.
          message: {
            value: message,
            enumerable: false,
            writable: true,
            configurable: true
          },
          toString: {
            /** @this {Error} */
            value() {
              return `${this.name} [${key}]: ${this.message}`;
            },
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        captureLargerStackTrace(error);
        error.code = key;
        return error;
      }
    }
    function isErrorStackTraceLimitWritable() {
      try {
        if (v8__default.startupSnapshot.isBuildingSnapshot()) {
          return false;
        }
      } catch (e2) {
      }
      const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
      if (desc === void 0) {
        return Object.isExtensible(Error);
      }
      return own$1.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
    }
    function hideStackFrames(wrappedFunction) {
      const hidden = nodeInternalPrefix + wrappedFunction.name;
      Object.defineProperty(wrappedFunction, "name", { value: hidden });
      return wrappedFunction;
    }
    var captureLargerStackTrace = hideStackFrames(
      /**
       * @param {Error} error
       * @returns {Error}
       */
      // @ts-expect-error: fine
      function(error) {
        const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
        if (stackTraceLimitIsWritable) {
          userStackTraceLimit = Error.stackTraceLimit;
          Error.stackTraceLimit = Number.POSITIVE_INFINITY;
        }
        Error.captureStackTrace(error);
        if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;
        return error;
      }
    );
    function getMessage(key, parameters, self2) {
      const message = messages.get(key);
      assert__default(message !== void 0, "expected `message` to be found");
      if (typeof message === "function") {
        assert__default(
          message.length <= parameters.length,
          // Default options do not count.
          `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${message.length}).`
        );
        return Reflect.apply(message, self2, parameters);
      }
      const regex = /%[dfijoOs]/g;
      let expectedLength = 0;
      while (regex.exec(message) !== null) expectedLength++;
      assert__default(
        expectedLength === parameters.length,
        `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${expectedLength}).`
      );
      if (parameters.length === 0) return message;
      parameters.unshift(message);
      return Reflect.apply(node_util.format, null, parameters);
    }
    function determineSpecificType(value) {
      if (value === null || value === void 0) {
        return String(value);
      }
      if (typeof value === "function" && value.name) {
        return `function ${value.name}`;
      }
      if (typeof value === "object") {
        if (value.constructor && value.constructor.name) {
          return `an instance of ${value.constructor.name}`;
        }
        return `${node_util.inspect(value, { depth: -1 })}`;
      }
      let inspected = node_util.inspect(value, { colors: false });
      if (inspected.length > 28) {
        inspected = `${inspected.slice(0, 25)}...`;
      }
      return `type ${typeof value} (${inspected})`;
    }
    var hasOwnProperty$1 = {}.hasOwnProperty;
    var { ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG$1 } = codes;
    var cache2 = /* @__PURE__ */ new Map();
    function read(jsonPath, { base, specifier }) {
      const existing = cache2.get(jsonPath);
      if (existing) {
        return existing;
      }
      let string;
      try {
        string = fs__default.readFileSync(path__default.toNamespacedPath(jsonPath), "utf8");
      } catch (error) {
        const exception = (
          /** @type {ErrnoException} */
          error
        );
        if (exception.code !== "ENOENT") {
          throw exception;
        }
      }
      const result = {
        exists: false,
        pjsonPath: jsonPath,
        main: void 0,
        name: void 0,
        type: "none",
        // Ignore unknown types for forwards compatibility
        exports: void 0,
        imports: void 0
      };
      if (string !== void 0) {
        let parsed;
        try {
          parsed = JSON.parse(string);
        } catch (error_) {
          const cause = (
            /** @type {ErrnoException} */
            error_
          );
          const error = new ERR_INVALID_PACKAGE_CONFIG$1(
            jsonPath,
            (base ? `"${specifier}" from ` : "") + node_url.fileURLToPath(base || specifier),
            cause.message
          );
          error.cause = cause;
          throw error;
        }
        result.exists = true;
        if (hasOwnProperty$1.call(parsed, "name") && typeof parsed.name === "string") {
          result.name = parsed.name;
        }
        if (hasOwnProperty$1.call(parsed, "main") && typeof parsed.main === "string") {
          result.main = parsed.main;
        }
        if (hasOwnProperty$1.call(parsed, "exports")) {
          result.exports = parsed.exports;
        }
        if (hasOwnProperty$1.call(parsed, "imports")) {
          result.imports = parsed.imports;
        }
        if (hasOwnProperty$1.call(parsed, "type") && (parsed.type === "commonjs" || parsed.type === "module")) {
          result.type = parsed.type;
        }
      }
      cache2.set(jsonPath, result);
      return result;
    }
    function getPackageScopeConfig(resolved) {
      let packageJSONUrl = new URL("package.json", resolved);
      while (true) {
        const packageJSONPath2 = packageJSONUrl.pathname;
        if (packageJSONPath2.endsWith("node_modules/package.json")) {
          break;
        }
        const packageConfig = read(node_url.fileURLToPath(packageJSONUrl), {
          specifier: resolved
        });
        if (packageConfig.exists) {
          return packageConfig;
        }
        const lastPackageJSONUrl = packageJSONUrl;
        packageJSONUrl = new URL("../package.json", packageJSONUrl);
        if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {
          break;
        }
      }
      const packageJSONPath = node_url.fileURLToPath(packageJSONUrl);
      return {
        pjsonPath: packageJSONPath,
        exists: false,
        type: "none"
      };
    }
    function getPackageType(url) {
      return getPackageScopeConfig(url).type;
    }
    var { ERR_UNKNOWN_FILE_EXTENSION } = codes;
    var hasOwnProperty = {}.hasOwnProperty;
    var extensionFormatMap = {
      // @ts-expect-error: hush.
      __proto__: null,
      ".cjs": "commonjs",
      ".js": "module",
      ".json": "json",
      ".mjs": "module"
    };
    function mimeToFormat(mime) {
      if (mime && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime))
        return "module";
      if (mime === "application/json") return "json";
      return null;
    }
    var protocolHandlers = {
      // @ts-expect-error: hush.
      __proto__: null,
      "data:": getDataProtocolModuleFormat,
      "file:": getFileProtocolModuleFormat,
      "http:": getHttpProtocolModuleFormat,
      "https:": getHttpProtocolModuleFormat,
      "node:"() {
        return "builtin";
      }
    };
    function getDataProtocolModuleFormat(parsed) {
      const { 1: mime } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(
        parsed.pathname
      ) || [null, null, null];
      return mimeToFormat(mime);
    }
    function extname(url) {
      const pathname = url.pathname;
      let index = pathname.length;
      while (index--) {
        const code = pathname.codePointAt(index);
        if (code === 47) {
          return "";
        }
        if (code === 46) {
          return pathname.codePointAt(index - 1) === 47 ? "" : pathname.slice(index);
        }
      }
      return "";
    }
    function getFileProtocolModuleFormat(url, _context, ignoreErrors) {
      const value = extname(url);
      if (value === ".js") {
        const packageType = getPackageType(url);
        if (packageType !== "none") {
          return packageType;
        }
        return "commonjs";
      }
      if (value === "") {
        const packageType = getPackageType(url);
        if (packageType === "none" || packageType === "commonjs") {
          return "commonjs";
        }
        return "module";
      }
      const format = extensionFormatMap[value];
      if (format) return format;
      if (ignoreErrors) {
        return void 0;
      }
      const filepath = node_url.fileURLToPath(url);
      throw new ERR_UNKNOWN_FILE_EXTENSION(value, filepath);
    }
    function getHttpProtocolModuleFormat() {
    }
    function defaultGetFormatWithoutErrors(url, context) {
      const protocol = url.protocol;
      if (!hasOwnProperty.call(protocolHandlers, protocol)) {
        return null;
      }
      return protocolHandlers[protocol](url, context, true) || null;
    }
    var RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];
    var {
      ERR_NETWORK_IMPORT_DISALLOWED,
      ERR_INVALID_MODULE_SPECIFIER,
      ERR_INVALID_PACKAGE_CONFIG,
      ERR_INVALID_PACKAGE_TARGET,
      ERR_MODULE_NOT_FOUND,
      ERR_PACKAGE_IMPORT_NOT_DEFINED,
      ERR_PACKAGE_PATH_NOT_EXPORTED,
      ERR_UNSUPPORTED_DIR_IMPORT,
      ERR_UNSUPPORTED_RESOLVE_REQUEST
    } = codes;
    var own = {}.hasOwnProperty;
    var invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
    var deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
    var invalidPackageNameRegEx = /^\.|%|\\/;
    var patternRegEx = /\*/g;
    var encodedSeparatorRegEx = /%2f|%5c/i;
    var emittedPackageWarnings = /* @__PURE__ */ new Set();
    var doubleSlashRegEx = /[/\\]{2}/;
    function emitInvalidSegmentDeprecation(target, request, match, packageJsonUrl, internal, base, isTarget) {
      if (process__default.noDeprecation) {
        return;
      }
      const pjsonPath = node_url.fileURLToPath(packageJsonUrl);
      const double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;
      process__default.emitWarning(
        `Use of deprecated ${double ? "double slash" : "leading or trailing slash matching"} resolving "${target}" for module request "${request}" ${request === match ? "" : `matched to "${match}" `}in the "${internal ? "imports" : "exports"}" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${node_url.fileURLToPath(base)}` : ""}.`,
        "DeprecationWarning",
        "DEP0166"
      );
    }
    function emitLegacyIndexDeprecation(url, packageJsonUrl, base, main) {
      if (process__default.noDeprecation) {
        return;
      }
      const format = defaultGetFormatWithoutErrors(url, { parentURL: base.href });
      if (format !== "module") return;
      const urlPath = node_url.fileURLToPath(url.href);
      const packagePath = node_url.fileURLToPath(new node_url.URL(".", packageJsonUrl));
      const basePath = node_url.fileURLToPath(base);
      if (!main) {
        process__default.emitWarning(
          `No "main" or "exports" field defined in the package.json for ${packagePath} resolving the main entry point "${urlPath.slice(
            packagePath.length
          )}", imported from ${basePath}.
Default "index" lookups for the main are deprecated for ES modules.`,
          "DeprecationWarning",
          "DEP0151"
        );
      } else if (path__default.resolve(packagePath, main) !== urlPath) {
        process__default.emitWarning(
          `Package ${packagePath} has a "main" field set to "${main}", excluding the full filename and extension to the resolved file at "${urlPath.slice(
            packagePath.length
          )}", imported from ${basePath}.
 Automatic extension resolution of the "main" field is deprecated for ES modules.`,
          "DeprecationWarning",
          "DEP0151"
        );
      }
    }
    function tryStatSync(path8) {
      try {
        return fs5.statSync(path8);
      } catch (e2) {
      }
    }
    function fileExists(url) {
      const stats = fs5.statSync(url, { throwIfNoEntry: false });
      const isFile = stats ? stats.isFile() : void 0;
      return isFile === null || isFile === void 0 ? false : isFile;
    }
    function legacyMainResolve(packageJsonUrl, packageConfig, base) {
      let guess;
      if (packageConfig.main !== void 0) {
        guess = new node_url.URL(packageConfig.main, packageJsonUrl);
        if (fileExists(guess)) return guess;
        const tries2 = [
          `./${packageConfig.main}.js`,
          `./${packageConfig.main}.json`,
          `./${packageConfig.main}.node`,
          `./${packageConfig.main}/index.js`,
          `./${packageConfig.main}/index.json`,
          `./${packageConfig.main}/index.node`
        ];
        let i2 = -1;
        while (++i2 < tries2.length) {
          guess = new node_url.URL(tries2[i2], packageJsonUrl);
          if (fileExists(guess)) break;
          guess = void 0;
        }
        if (guess) {
          emitLegacyIndexDeprecation(
            guess,
            packageJsonUrl,
            base,
            packageConfig.main
          );
          return guess;
        }
      }
      const tries = ["./index.js", "./index.json", "./index.node"];
      let i = -1;
      while (++i < tries.length) {
        guess = new node_url.URL(tries[i], packageJsonUrl);
        if (fileExists(guess)) break;
        guess = void 0;
      }
      if (guess) {
        emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
        return guess;
      }
      throw new ERR_MODULE_NOT_FOUND(
        node_url.fileURLToPath(new node_url.URL(".", packageJsonUrl)),
        node_url.fileURLToPath(base)
      );
    }
    function finalizeResolution(resolved, base, preserveSymlinks) {
      if (encodedSeparatorRegEx.exec(resolved.pathname) !== null) {
        throw new ERR_INVALID_MODULE_SPECIFIER(
          resolved.pathname,
          'must not include encoded "/" or "\\" characters',
          node_url.fileURLToPath(base)
        );
      }
      let filePath;
      try {
        filePath = node_url.fileURLToPath(resolved);
      } catch (error) {
        const cause = (
          /** @type {ErrnoException} */
          error
        );
        Object.defineProperty(cause, "input", { value: String(resolved) });
        Object.defineProperty(cause, "module", { value: String(base) });
        throw cause;
      }
      const stats = tryStatSync(
        filePath.endsWith("/") ? filePath.slice(-1) : filePath
      );
      if (stats && stats.isDirectory()) {
        const error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, node_url.fileURLToPath(base));
        error.url = String(resolved);
        throw error;
      }
      if (!stats || !stats.isFile()) {
        const error = new ERR_MODULE_NOT_FOUND(
          filePath || resolved.pathname,
          base && node_url.fileURLToPath(base),
          true
        );
        error.url = String(resolved);
        throw error;
      }
      {
        const real = fs5.realpathSync(filePath);
        const { search, hash: hash2 } = resolved;
        resolved = node_url.pathToFileURL(real + (filePath.endsWith(path__default.sep) ? "/" : ""));
        resolved.search = search;
        resolved.hash = hash2;
      }
      return resolved;
    }
    function importNotDefined(specifier, packageJsonUrl, base) {
      return new ERR_PACKAGE_IMPORT_NOT_DEFINED(
        specifier,
        packageJsonUrl && node_url.fileURLToPath(new node_url.URL(".", packageJsonUrl)),
        node_url.fileURLToPath(base)
      );
    }
    function exportsNotFound(subpath, packageJsonUrl, base) {
      return new ERR_PACKAGE_PATH_NOT_EXPORTED(
        node_url.fileURLToPath(new node_url.URL(".", packageJsonUrl)),
        subpath,
        base && node_url.fileURLToPath(base)
      );
    }
    function throwInvalidSubpath(request, match, packageJsonUrl, internal, base) {
      const reason = `request is not a valid match in pattern "${match}" for the "${internal ? "imports" : "exports"}" resolution of ${node_url.fileURLToPath(packageJsonUrl)}`;
      throw new ERR_INVALID_MODULE_SPECIFIER(
        request,
        reason,
        base && node_url.fileURLToPath(base)
      );
    }
    function invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {
      target = typeof target === "object" && target !== null ? JSON.stringify(target, null, "") : `${target}`;
      return new ERR_INVALID_PACKAGE_TARGET(
        node_url.fileURLToPath(new node_url.URL(".", packageJsonUrl)),
        subpath,
        target,
        internal,
        base && node_url.fileURLToPath(base)
      );
    }
    function resolvePackageTargetString(target, subpath, match, packageJsonUrl, base, pattern, internal, isPathMap, conditions) {
      if (subpath !== "" && !pattern && target[target.length - 1] !== "/")
        throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
      if (!target.startsWith("./")) {
        if (internal && !target.startsWith("../") && !target.startsWith("/")) {
          let isURL = false;
          try {
            new node_url.URL(target);
            isURL = true;
          } catch (e2) {
          }
          if (!isURL) {
            const exportTarget = pattern ? RegExpPrototypeSymbolReplace.call(
              patternRegEx,
              target,
              () => subpath
            ) : target + subpath;
            return packageResolve(exportTarget, packageJsonUrl, conditions);
          }
        }
        throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
      }
      if (invalidSegmentRegEx.exec(target.slice(2)) !== null) {
        if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {
          if (!isPathMap) {
            const request = pattern ? match.replace("*", () => subpath) : match + subpath;
            const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
              patternRegEx,
              target,
              () => subpath
            ) : target;
            emitInvalidSegmentDeprecation(
              resolvedTarget,
              request,
              match,
              packageJsonUrl,
              internal,
              base,
              true
            );
          }
        } else {
          throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
        }
      }
      const resolved = new node_url.URL(target, packageJsonUrl);
      const resolvedPath = resolved.pathname;
      const packagePath = new node_url.URL(".", packageJsonUrl).pathname;
      if (!resolvedPath.startsWith(packagePath))
        throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
      if (subpath === "") return resolved;
      if (invalidSegmentRegEx.exec(subpath) !== null) {
        const request = pattern ? match.replace("*", () => subpath) : match + subpath;
        if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
          if (!isPathMap) {
            const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
              patternRegEx,
              target,
              () => subpath
            ) : target;
            emitInvalidSegmentDeprecation(
              resolvedTarget,
              request,
              match,
              packageJsonUrl,
              internal,
              base,
              false
            );
          }
        } else {
          throwInvalidSubpath(request, match, packageJsonUrl, internal, base);
        }
      }
      if (pattern) {
        return new node_url.URL(
          RegExpPrototypeSymbolReplace.call(
            patternRegEx,
            resolved.href,
            () => subpath
          )
        );
      }
      return new node_url.URL(subpath, resolved);
    }
    function isArrayIndex(key) {
      const keyNumber = Number(key);
      if (`${keyNumber}` !== key) return false;
      return keyNumber >= 0 && keyNumber < 4294967295;
    }
    function resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions) {
      if (typeof target === "string") {
        return resolvePackageTargetString(
          target,
          subpath,
          packageSubpath,
          packageJsonUrl,
          base,
          pattern,
          internal,
          isPathMap,
          conditions
        );
      }
      if (Array.isArray(target)) {
        const targetList = target;
        if (targetList.length === 0) return null;
        let lastException;
        let i = -1;
        while (++i < targetList.length) {
          const targetItem = targetList[i];
          let resolveResult;
          try {
            resolveResult = resolvePackageTarget(
              packageJsonUrl,
              targetItem,
              subpath,
              packageSubpath,
              base,
              pattern,
              internal,
              isPathMap,
              conditions
            );
          } catch (error) {
            const exception = (
              /** @type {ErrnoException} */
              error
            );
            lastException = exception;
            if (exception.code === "ERR_INVALID_PACKAGE_TARGET") continue;
            throw error;
          }
          if (resolveResult === void 0) continue;
          if (resolveResult === null) {
            lastException = null;
            continue;
          }
          return resolveResult;
        }
        if (lastException === void 0 || lastException === null) {
          return null;
        }
        throw lastException;
      }
      if (typeof target === "object" && target !== null) {
        const keys = Object.getOwnPropertyNames(target);
        let i = -1;
        while (++i < keys.length) {
          const key = keys[i];
          if (isArrayIndex(key)) {
            throw new ERR_INVALID_PACKAGE_CONFIG(
              node_url.fileURLToPath(packageJsonUrl),
              base,
              '"exports" cannot contain numeric property keys.'
            );
          }
        }
        i = -1;
        while (++i < keys.length) {
          const key = keys[i];
          if (key === "default" || conditions && conditions.has(key)) {
            const conditionalTarget = (
              /** @type {unknown} */
              target[key]
            );
            const resolveResult = resolvePackageTarget(
              packageJsonUrl,
              conditionalTarget,
              subpath,
              packageSubpath,
              base,
              pattern,
              internal,
              isPathMap,
              conditions
            );
            if (resolveResult === void 0) continue;
            return resolveResult;
          }
        }
        return null;
      }
      if (target === null) {
        return null;
      }
      throw invalidPackageTarget(
        packageSubpath,
        target,
        packageJsonUrl,
        internal,
        base
      );
    }
    function isConditionalExportsMainSugar(exports2, packageJsonUrl, base) {
      if (typeof exports2 === "string" || Array.isArray(exports2)) return true;
      if (typeof exports2 !== "object" || exports2 === null) return false;
      const keys = Object.getOwnPropertyNames(exports2);
      let isConditionalSugar = false;
      let i = 0;
      let keyIndex = -1;
      while (++keyIndex < keys.length) {
        const key = keys[keyIndex];
        const currentIsConditionalSugar = key === "" || key[0] !== ".";
        if (i++ === 0) {
          isConditionalSugar = currentIsConditionalSugar;
        } else if (isConditionalSugar !== currentIsConditionalSugar) {
          throw new ERR_INVALID_PACKAGE_CONFIG(
            node_url.fileURLToPath(packageJsonUrl),
            base,
            `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`
          );
        }
      }
      return isConditionalSugar;
    }
    function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {
      if (process__default.noDeprecation) {
        return;
      }
      const pjsonPath = node_url.fileURLToPath(pjsonUrl);
      if (emittedPackageWarnings.has(pjsonPath + "|" + match)) return;
      emittedPackageWarnings.add(pjsonPath + "|" + match);
      process__default.emitWarning(
        `Use of deprecated trailing slash pattern mapping "${match}" in the "exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${node_url.fileURLToPath(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`,
        "DeprecationWarning",
        "DEP0155"
      );
    }
    function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
      let exports2 = packageConfig.exports;
      if (isConditionalExportsMainSugar(exports2, packageJsonUrl, base)) {
        exports2 = { ".": exports2 };
      }
      if (own.call(exports2, packageSubpath) && !packageSubpath.includes("*") && !packageSubpath.endsWith("/")) {
        const target = exports2[packageSubpath];
        const resolveResult = resolvePackageTarget(
          packageJsonUrl,
          target,
          "",
          packageSubpath,
          base,
          false,
          false,
          false,
          conditions
        );
        if (resolveResult === null || resolveResult === void 0) {
          throw exportsNotFound(packageSubpath, packageJsonUrl, base);
        }
        return resolveResult;
      }
      let bestMatch = "";
      let bestMatchSubpath = "";
      const keys = Object.getOwnPropertyNames(exports2);
      let i = -1;
      while (++i < keys.length) {
        const key = keys[i];
        const patternIndex = key.indexOf("*");
        if (patternIndex !== -1 && packageSubpath.startsWith(key.slice(0, patternIndex))) {
          if (packageSubpath.endsWith("/")) {
            emitTrailingSlashPatternDeprecation(
              packageSubpath,
              packageJsonUrl,
              base
            );
          }
          const patternTrailer = key.slice(patternIndex + 1);
          if (packageSubpath.length >= key.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
            bestMatch = key;
            bestMatchSubpath = packageSubpath.slice(
              patternIndex,
              packageSubpath.length - patternTrailer.length
            );
          }
        }
      }
      if (bestMatch) {
        const target = (
          /** @type {unknown} */
          exports2[bestMatch]
        );
        const resolveResult = resolvePackageTarget(
          packageJsonUrl,
          target,
          bestMatchSubpath,
          bestMatch,
          base,
          true,
          false,
          packageSubpath.endsWith("/"),
          conditions
        );
        if (resolveResult === null || resolveResult === void 0) {
          throw exportsNotFound(packageSubpath, packageJsonUrl, base);
        }
        return resolveResult;
      }
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    function patternKeyCompare(a, b) {
      const aPatternIndex = a.indexOf("*");
      const bPatternIndex = b.indexOf("*");
      const baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
      const baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
      if (baseLengthA > baseLengthB) return -1;
      if (baseLengthB > baseLengthA) return 1;
      if (aPatternIndex === -1) return 1;
      if (bPatternIndex === -1) return -1;
      if (a.length > b.length) return -1;
      if (b.length > a.length) return 1;
      return 0;
    }
    function packageImportsResolve(name2, base, conditions) {
      if (name2 === "#" || name2.startsWith("#/") || name2.endsWith("/")) {
        const reason = "is not a valid internal imports specifier name";
        throw new ERR_INVALID_MODULE_SPECIFIER(name2, reason, node_url.fileURLToPath(base));
      }
      let packageJsonUrl;
      const packageConfig = getPackageScopeConfig(base);
      if (packageConfig.exists) {
        packageJsonUrl = node_url.pathToFileURL(packageConfig.pjsonPath);
        const imports = packageConfig.imports;
        if (imports) {
          if (own.call(imports, name2) && !name2.includes("*")) {
            const resolveResult = resolvePackageTarget(
              packageJsonUrl,
              imports[name2],
              "",
              name2,
              base,
              false,
              true,
              false,
              conditions
            );
            if (resolveResult !== null && resolveResult !== void 0) {
              return resolveResult;
            }
          } else {
            let bestMatch = "";
            let bestMatchSubpath = "";
            const keys = Object.getOwnPropertyNames(imports);
            let i = -1;
            while (++i < keys.length) {
              const key = keys[i];
              const patternIndex = key.indexOf("*");
              if (patternIndex !== -1 && name2.startsWith(key.slice(0, -1))) {
                const patternTrailer = key.slice(patternIndex + 1);
                if (name2.length >= key.length && name2.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
                  bestMatch = key;
                  bestMatchSubpath = name2.slice(
                    patternIndex,
                    name2.length - patternTrailer.length
                  );
                }
              }
            }
            if (bestMatch) {
              const target = imports[bestMatch];
              const resolveResult = resolvePackageTarget(
                packageJsonUrl,
                target,
                bestMatchSubpath,
                bestMatch,
                base,
                true,
                true,
                false,
                conditions
              );
              if (resolveResult !== null && resolveResult !== void 0) {
                return resolveResult;
              }
            }
          }
        }
      }
      throw importNotDefined(name2, packageJsonUrl, base);
    }
    function parsePackageName(specifier, base) {
      let separatorIndex = specifier.indexOf("/");
      let validPackageName = true;
      let isScoped = false;
      if (specifier[0] === "@") {
        isScoped = true;
        if (separatorIndex === -1 || specifier.length === 0) {
          validPackageName = false;
        } else {
          separatorIndex = specifier.indexOf("/", separatorIndex + 1);
        }
      }
      const packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
      if (invalidPackageNameRegEx.exec(packageName) !== null) {
        validPackageName = false;
      }
      if (!validPackageName) {
        throw new ERR_INVALID_MODULE_SPECIFIER(
          specifier,
          "is not a valid package name",
          node_url.fileURLToPath(base)
        );
      }
      const packageSubpath = "." + (separatorIndex === -1 ? "" : specifier.slice(separatorIndex));
      return { packageName, packageSubpath, isScoped };
    }
    function packageResolve(specifier, base, conditions) {
      if (node_module.builtinModules.includes(specifier)) {
        return new node_url.URL("node:" + specifier);
      }
      const { packageName, packageSubpath, isScoped } = parsePackageName(
        specifier,
        base
      );
      const packageConfig = getPackageScopeConfig(base);
      if (packageConfig.exists) {
        const packageJsonUrl2 = node_url.pathToFileURL(packageConfig.pjsonPath);
        if (packageConfig.name === packageName && packageConfig.exports !== void 0 && packageConfig.exports !== null) {
          return packageExportsResolve(
            packageJsonUrl2,
            packageSubpath,
            packageConfig,
            base,
            conditions
          );
        }
      }
      let packageJsonUrl = new node_url.URL(
        "./node_modules/" + packageName + "/package.json",
        base
      );
      let packageJsonPath = node_url.fileURLToPath(packageJsonUrl);
      let lastPath;
      do {
        const stat = tryStatSync(packageJsonPath.slice(0, -13));
        if (!stat || !stat.isDirectory()) {
          lastPath = packageJsonPath;
          packageJsonUrl = new node_url.URL(
            (isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json",
            packageJsonUrl
          );
          packageJsonPath = node_url.fileURLToPath(packageJsonUrl);
          continue;
        }
        const packageConfig2 = read(packageJsonPath, { base, specifier });
        if (packageConfig2.exports !== void 0 && packageConfig2.exports !== null) {
          return packageExportsResolve(
            packageJsonUrl,
            packageSubpath,
            packageConfig2,
            base,
            conditions
          );
        }
        if (packageSubpath === ".") {
          return legacyMainResolve(packageJsonUrl, packageConfig2, base);
        }
        return new node_url.URL(packageSubpath, packageJsonUrl);
      } while (packageJsonPath.length !== lastPath.length);
      throw new ERR_MODULE_NOT_FOUND(packageName, node_url.fileURLToPath(base), false);
    }
    function isRelativeSpecifier(specifier) {
      if (specifier[0] === ".") {
        if (specifier.length === 1 || specifier[1] === "/") return true;
        if (specifier[1] === "." && (specifier.length === 2 || specifier[2] === "/")) {
          return true;
        }
      }
      return false;
    }
    function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
      if (specifier === "") return false;
      if (specifier[0] === "/") return true;
      return isRelativeSpecifier(specifier);
    }
    function moduleResolve(specifier, base, conditions, preserveSymlinks) {
      const protocol = base.protocol;
      const isData = protocol === "data:";
      const isRemote = isData || protocol === "http:" || protocol === "https:";
      let resolved;
      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
        try {
          resolved = new node_url.URL(specifier, base);
        } catch (error_) {
          const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
          error.cause = error_;
          throw error;
        }
      } else if (protocol === "file:" && specifier[0] === "#") {
        resolved = packageImportsResolve(specifier, base, conditions);
      } else {
        try {
          resolved = new node_url.URL(specifier);
        } catch (error_) {
          if (isRemote && !node_module.builtinModules.includes(specifier)) {
            const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
            error.cause = error_;
            throw error;
          }
          resolved = packageResolve(specifier, base, conditions);
        }
      }
      assert__default(resolved !== void 0, "expected to be defined");
      if (resolved.protocol !== "file:") {
        return resolved;
      }
      return finalizeResolution(resolved, base);
    }
    function fileURLToPath3(id) {
      if (typeof id === "string" && !id.startsWith("file://")) {
        return normalizeSlash(id);
      }
      return normalizeSlash(node_url.fileURLToPath(id));
    }
    function pathToFileURL(id) {
      return node_url.pathToFileURL(fileURLToPath3(id)).toString();
    }
    var INVALID_CHAR_RE = /[\u0000-\u001F"#$&*+,/:;<=>?@[\]^`{|}\u007F]+/g;
    function sanitizeURIComponent(name2 = "", replacement = "_") {
      return name2.replace(INVALID_CHAR_RE, replacement).replace(/%../g, replacement);
    }
    function sanitizeFilePath(filePath = "") {
      return filePath.replace(/\?.*$/, "").split(/[/\\]/g).map((p) => sanitizeURIComponent(p)).join("/").replace(/^([A-Za-z])_\//, "$1:/");
    }
    function normalizeid(id) {
      if (typeof id !== "string") {
        id = id.toString();
      }
      if (/(node|data|http|https|file):/.test(id)) {
        return id;
      }
      if (BUILTIN_MODULES.has(id)) {
        return "node:" + id;
      }
      return "file://" + encodeURI(normalizeSlash(id));
    }
    async function loadURL(url) {
      const code = await fs5.promises.readFile(fileURLToPath3(url), "utf8");
      return code;
    }
    function toDataURL(code) {
      const base64 = Buffer.from(code).toString("base64");
      return `data:text/javascript;base64,${base64}`;
    }
    function isNodeBuiltin(id = "") {
      id = id.replace(/^node:/, "").split("/")[0];
      return BUILTIN_MODULES.has(id);
    }
    var ProtocolRegex = /^(?<proto>.{2,}?):.+$/;
    function getProtocol(id) {
      var _a3;
      const proto = id.match(ProtocolRegex);
      return proto ? (_a3 = proto.groups) == null ? void 0 : _a3.proto : void 0;
    }
    var DEFAULT_CONDITIONS_SET = /* @__PURE__ */ new Set(["node", "import"]);
    var DEFAULT_EXTENSIONS = [".mjs", ".cjs", ".js", ".json"];
    var NOT_FOUND_ERRORS = /* @__PURE__ */ new Set([
      "ERR_MODULE_NOT_FOUND",
      "ERR_UNSUPPORTED_DIR_IMPORT",
      "MODULE_NOT_FOUND",
      "ERR_PACKAGE_PATH_NOT_EXPORTED"
    ]);
    function _tryModuleResolve(id, url, conditions) {
      try {
        return moduleResolve(id, url, conditions);
      } catch (error) {
        if (!NOT_FOUND_ERRORS.has(error == null ? void 0 : error.code)) {
          throw error;
        }
      }
    }
    function _resolve(id, options = {}) {
      if (typeof id !== "string") {
        if (id instanceof URL) {
          id = fileURLToPath3(id);
        } else {
          throw new TypeError("input must be a `string` or `URL`");
        }
      }
      if (/(node|data|http|https):/.test(id)) {
        return id;
      }
      if (BUILTIN_MODULES.has(id)) {
        return "node:" + id;
      }
      if (id.startsWith("file://")) {
        id = fileURLToPath3(id);
      }
      if (pathe.isAbsolute(id)) {
        try {
          const stat = fs5.statSync(id);
          if (stat.isFile()) {
            return pathToFileURL(id);
          }
        } catch (error) {
          if ((error == null ? void 0 : error.code) !== "ENOENT") {
            throw error;
          }
        }
      }
      const conditionsSet = options.conditions ? new Set(options.conditions) : DEFAULT_CONDITIONS_SET;
      const _urls = (Array.isArray(options.url) ? options.url : [options.url]).filter(Boolean).map((url) => new URL(normalizeid(url.toString())));
      if (_urls.length === 0) {
        _urls.push(new URL(pathToFileURL(process.cwd())));
      }
      const urls = [..._urls];
      for (const url of _urls) {
        if (url.protocol === "file:") {
          urls.push(
            new URL("./", url),
            // If url is directory
            new URL(ufo.joinURL(url.pathname, "_index.js"), url),
            // TODO: Remove in next major version?
            new URL("node_modules", url)
          );
        }
      }
      let resolved;
      for (const url of urls) {
        resolved = _tryModuleResolve(id, url, conditionsSet);
        if (resolved) {
          break;
        }
        for (const prefix of ["", "/index"]) {
          for (const extension of options.extensions || DEFAULT_EXTENSIONS) {
            resolved = _tryModuleResolve(
              ufo.joinURL(id, prefix) + extension,
              url,
              conditionsSet
            );
            if (resolved) {
              break;
            }
          }
          if (resolved) {
            break;
          }
        }
        if (resolved) {
          break;
        }
      }
      if (!resolved) {
        const error = new Error(
          `Cannot find module ${id} imported from ${urls.join(", ")}`
        );
        error.code = "ERR_MODULE_NOT_FOUND";
        throw error;
      }
      return pathToFileURL(resolved);
    }
    function resolveSync(id, options) {
      return _resolve(id, options);
    }
    function resolve4(id, options) {
      try {
        return Promise.resolve(resolveSync(id, options));
      } catch (error) {
        return Promise.reject(error);
      }
    }
    function resolvePathSync(id, options) {
      return fileURLToPath3(resolveSync(id, options));
    }
    function resolvePath(id, options) {
      try {
        return Promise.resolve(resolvePathSync(id, options));
      } catch (error) {
        return Promise.reject(error);
      }
    }
    function createResolve(defaults) {
      return (id, url) => {
        return resolve4(id, { url, ...defaults });
      };
    }
    var NODE_MODULES_RE = /^(.+\/node_modules\/)([^/@]+|@[^/]+\/[^/]+)(\/?.*?)?$/;
    function parseNodeModulePath(path8) {
      if (!path8) {
        return {};
      }
      path8 = pathe.normalize(fileURLToPath3(path8));
      const match = NODE_MODULES_RE.exec(path8);
      if (!match) {
        return {};
      }
      const [, dir, name2, subpath] = match;
      return {
        dir,
        name: name2,
        subpath: subpath ? `.${subpath}` : void 0
      };
    }
    async function lookupNodeModuleSubpath(path8) {
      path8 = pathe.normalize(fileURLToPath3(path8));
      const { name: name2, subpath } = parseNodeModulePath(path8);
      if (!name2 || !subpath) {
        return subpath;
      }
      const { exports: exports2 } = await pkgTypes.readPackageJSON(path8).catch(() => {
      }) || {};
      if (exports2) {
        const resolvedSubpath = _findSubpath(subpath, exports2);
        if (resolvedSubpath) {
          return resolvedSubpath;
        }
      }
      return subpath;
    }
    function _findSubpath(subpath, exports2) {
      var _a3;
      if (typeof exports2 === "string") {
        exports2 = { ".": exports2 };
      }
      if (!subpath.startsWith(".")) {
        subpath = subpath.startsWith("/") ? `.${subpath}` : `./${subpath}`;
      }
      if (subpath in (exports2 || {})) {
        return subpath;
      }
      return (_a3 = _flattenExports(exports2).find((p) => p.fsPath === subpath)) == null ? void 0 : _a3.subpath;
    }
    function _flattenExports(exports2 = {}, parentSubpath = "./") {
      return Object.entries(exports2).flatMap(([key, value]) => {
        const [subpath, condition] = key.startsWith(".") ? [key.slice(1), void 0] : ["", key];
        const _subPath = ufo.joinURL(parentSubpath, subpath);
        if (typeof value === "string") {
          return [{ subpath: _subPath, fsPath: value, condition }];
        } else {
          return _flattenExports(value, _subPath);
        }
      });
    }
    var ESM_STATIC_IMPORT_RE = /(?<=\s|^|;|\})import\s*([\s"']*(?<imports>[\p{L}\p{M}\w\t\n\r $*,/{}@.]+)from\s*)?["']\s*(?<specifier>(?<="\s*)[^"]*[^\s"](?=\s*")|(?<='\s*)[^']*[^\s'](?=\s*'))\s*["'][\s;]*/gmu;
    var DYNAMIC_IMPORT_RE = /import\s*\((?<expression>(?:[^()]+|\((?:[^()]+|\([^()]*\))*\))*)\)/gm;
    var IMPORT_NAMED_TYPE_RE = /(?<=\s|^|;|})import\s*type\s+([\s"']*(?<imports>[\w\t\n\r $*,/{}]+)from\s*)?["']\s*(?<specifier>(?<="\s*)[^"]*[^\s"](?=\s*")|(?<='\s*)[^']*[^\s'](?=\s*'))\s*["'][\s;]*/gm;
    var EXPORT_DECAL_RE = /\bexport\s+(?<declaration>(async function\s*\*?|function\s*\*?|let|const enum|const|enum|var|class))\s+\*?(?<name>[\w$]+)(?<extraNames>.*,\s*[\s\w:[\]{}]*[\w$\]}]+)*/g;
    var EXPORT_DECAL_TYPE_RE = /\bexport\s+(?<declaration>(interface|type|declare (async function|function|let|const enum|const|enum|var|class)))\s+(?<name>[\w$]+)/g;
    var EXPORT_NAMED_RE = /\bexport\s*{(?<exports>[^}]+?)[\s,]*}(\s*from\s*["']\s*(?<specifier>(?<="\s*)[^"]*[^\s"](?=\s*")|(?<='\s*)[^']*[^\s'](?=\s*'))\s*["'][^\n;]*)?/g;
    var EXPORT_NAMED_TYPE_RE = /\bexport\s+type\s*{(?<exports>[^}]+?)[\s,]*}(\s*from\s*["']\s*(?<specifier>(?<="\s*)[^"]*[^\s"](?=\s*")|(?<='\s*)[^']*[^\s'](?=\s*'))\s*["'][^\n;]*)?/g;
    var EXPORT_NAMED_DESTRUCT = /\bexport\s+(let|var|const)\s+(?:{(?<exports1>[^}]+?)[\s,]*}|\[(?<exports2>[^\]]+?)[\s,]*])\s+=/gm;
    var EXPORT_STAR_RE = /\bexport\s*(\*)(\s*as\s+(?<name>[\w$]+)\s+)?\s*(\s*from\s*["']\s*(?<specifier>(?<="\s*)[^"]*[^\s"](?=\s*")|(?<='\s*)[^']*[^\s'](?=\s*'))\s*["'][^\n;]*)?/g;
    var EXPORT_DEFAULT_RE = /\bexport\s+default\s+(async function|function|class|true|false|\W|\d)|\bexport\s+default\s+(?<defaultName>.*)/g;
    var TYPE_RE = /^\s*?type\s/;
    function findStaticImports(code) {
      return _filterStatement(
        _tryGetLocations(code, "import"),
        matchAll(ESM_STATIC_IMPORT_RE, code, { type: "static" })
      );
    }
    function findDynamicImports(code) {
      return _filterStatement(
        _tryGetLocations(code, "import"),
        matchAll(DYNAMIC_IMPORT_RE, code, { type: "dynamic" })
      );
    }
    function findTypeImports(code) {
      return [
        ...matchAll(IMPORT_NAMED_TYPE_RE, code, { type: "type" }),
        ...matchAll(ESM_STATIC_IMPORT_RE, code, { type: "static" }).filter(
          (match) => /[^A-Za-z]type\s/.test(match.imports)
        )
      ];
    }
    function parseStaticImport(matched) {
      var _a3, _b2;
      const cleanedImports = clearImports(matched.imports);
      const namedImports = {};
      const _matches = ((_b2 = (_a3 = cleanedImports.match(/{([^}]*)}/)) == null ? void 0 : _a3[1]) == null ? void 0 : _b2.split(",")) || [];
      for (const namedImport of _matches) {
        const _match = namedImport.match(/^\s*(\S*) as (\S*)\s*$/);
        const source = (_match == null ? void 0 : _match[1]) || namedImport.trim();
        const importName = (_match == null ? void 0 : _match[2]) || source;
        if (source && !TYPE_RE.test(source)) {
          namedImports[source] = importName;
        }
      }
      const { namespacedImport, defaultImport } = getImportNames(cleanedImports);
      return {
        ...matched,
        defaultImport,
        namespacedImport,
        namedImports
      };
    }
    function parseTypeImport(matched) {
      var _a3, _b2;
      if (matched.type === "type") {
        return parseStaticImport(matched);
      }
      const cleanedImports = clearImports(matched.imports);
      const namedImports = {};
      const _matches = ((_b2 = (_a3 = cleanedImports.match(/{([^}]*)}/)) == null ? void 0 : _a3[1]) == null ? void 0 : _b2.split(",")) || [];
      for (const namedImport of _matches) {
        const _match = /\s+as\s+/.test(namedImport) ? namedImport.match(/^\s*type\s+(\S*) as (\S*)\s*$/) : namedImport.match(/^\s*type\s+(\S*)\s*$/);
        const source = (_match == null ? void 0 : _match[1]) || namedImport.trim();
        const importName = (_match == null ? void 0 : _match[2]) || source;
        if (source && TYPE_RE.test(namedImport)) {
          namedImports[source] = importName;
        }
      }
      const { namespacedImport, defaultImport } = getImportNames(cleanedImports);
      return {
        ...matched,
        defaultImport,
        namespacedImport,
        namedImports
      };
    }
    function findExports(code) {
      const declaredExports = matchAll(EXPORT_DECAL_RE, code, {
        type: "declaration"
      });
      for (const declaredExport of declaredExports) {
        const extraNamesStr = declaredExport.extraNames;
        if (extraNamesStr) {
          const extraNames = matchAll(
            /({.*?})|(\[.*?])|(,\s*(?<name>\w+))/g,
            extraNamesStr,
            {}
          ).map((m) => m.name).filter(Boolean);
          declaredExport.names = [declaredExport.name, ...extraNames];
        }
        delete declaredExport.extraNames;
      }
      const namedExports = normalizeNamedExports(
        matchAll(EXPORT_NAMED_RE, code, {
          type: "named"
        })
      );
      const destructuredExports = matchAll(
        EXPORT_NAMED_DESTRUCT,
        code,
        { type: "named" }
      );
      for (const namedExport of destructuredExports) {
        namedExport.exports = namedExport.exports1 || namedExport.exports2;
        namedExport.names = namedExport.exports.replace(/^\r?\n?/, "").split(/\s*,\s*/g).filter((name2) => !TYPE_RE.test(name2)).map(
          (name2) => name2.replace(/^.*?\s*:\s*/, "").replace(/\s*=\s*.*$/, "").trim()
        );
      }
      const defaultExport = matchAll(EXPORT_DEFAULT_RE, code, {
        type: "default",
        name: "default"
      });
      const starExports = matchAll(EXPORT_STAR_RE, code, {
        type: "star"
      });
      const exports2 = normalizeExports([
        ...declaredExports,
        ...namedExports,
        ...destructuredExports,
        ...defaultExport,
        ...starExports
      ]);
      if (exports2.length === 0) {
        return [];
      }
      const exportLocations = _tryGetLocations(code, "export");
      if (exportLocations && exportLocations.length === 0) {
        return [];
      }
      return (
        // Filter false positive export matches
        _filterStatement(exportLocations, exports2).filter((exp, index, exports22) => {
          const nextExport = exports22[index + 1];
          return !nextExport || exp.type !== nextExport.type || !exp.name || exp.name !== nextExport.name;
        })
      );
    }
    function findTypeExports(code) {
      const declaredExports = matchAll(
        EXPORT_DECAL_TYPE_RE,
        code,
        { type: "declaration" }
      );
      const namedExports = normalizeNamedExports(
        matchAll(EXPORT_NAMED_TYPE_RE, code, {
          type: "named"
        })
      );
      const exports2 = normalizeExports([
        ...declaredExports,
        ...namedExports
      ]);
      if (exports2.length === 0) {
        return [];
      }
      const exportLocations = _tryGetLocations(code, "export");
      if (exportLocations && exportLocations.length === 0) {
        return [];
      }
      return (
        // Filter false positive export matches
        _filterStatement(exportLocations, exports2).filter((exp, index, exports22) => {
          const nextExport = exports22[index + 1];
          return !nextExport || exp.type !== nextExport.type || !exp.name || exp.name !== nextExport.name;
        })
      );
    }
    function normalizeExports(exports2) {
      for (const exp of exports2) {
        if (!exp.name && exp.names && exp.names.length === 1) {
          exp.name = exp.names[0];
        }
        if (exp.name === "default" && exp.type !== "default") {
          exp._type = exp.type;
          exp.type = "default";
        }
        if (!exp.names && exp.name) {
          exp.names = [exp.name];
        }
        if (exp.type === "declaration" && exp.declaration) {
          exp.declarationType = exp.declaration.replace(
            /^declare\s*/,
            ""
          );
        }
      }
      return exports2;
    }
    function normalizeNamedExports(namedExports) {
      for (const namedExport of namedExports) {
        namedExport.names = namedExport.exports.replace(/^\r?\n?/, "").split(/\s*,\s*/g).filter((name2) => !TYPE_RE.test(name2)).map((name2) => name2.replace(/^.*?\sas\s/, "").trim());
      }
      return namedExports;
    }
    function findExportNames(code) {
      return findExports(code).flatMap((exp) => exp.names).filter(Boolean);
    }
    async function resolveModuleExportNames(id, options) {
      const url = await resolvePath(id, options);
      const code = await loadURL(url);
      const exports2 = findExports(code);
      const exportNames = new Set(
        exports2.flatMap((exp) => exp.names).filter(Boolean)
      );
      for (const exp of exports2) {
        if (exp.type !== "star" || !exp.specifier) {
          continue;
        }
        const subExports = await resolveModuleExportNames(exp.specifier, {
          ...options,
          url
        });
        for (const subExport of subExports) {
          exportNames.add(subExport);
        }
      }
      return [...exportNames];
    }
    function _filterStatement(locations, statements) {
      return statements.filter((exp) => {
        return !locations || locations.some((location) => {
          return exp.start <= location.start && exp.end >= location.end;
        });
      });
    }
    function _tryGetLocations(code, label) {
      try {
        return _getLocations(code, label);
      } catch (e2) {
      }
    }
    function _getLocations(code, label) {
      const tokens = acorn.tokenizer(code, {
        ecmaVersion: "latest",
        sourceType: "module",
        allowHashBang: true,
        allowAwaitOutsideFunction: true,
        allowImportExportEverywhere: true
      });
      const locations = [];
      for (const token of tokens) {
        if (token.type.label === label) {
          locations.push({
            start: token.start,
            end: token.end
          });
        }
      }
      return locations;
    }
    function createCommonJS(url) {
      const __filename2 = fileURLToPath3(url);
      const __dirname = path7.dirname(__filename2);
      let _nativeRequire;
      const getNativeRequire = () => {
        if (!_nativeRequire) {
          _nativeRequire = node_module.createRequire(url);
        }
        return _nativeRequire;
      };
      function require2(id) {
        return getNativeRequire()(id);
      }
      require2.resolve = function requireResolve(id, options) {
        return getNativeRequire().resolve(id, options);
      };
      return {
        __filename: __filename2,
        __dirname,
        require: require2
      };
    }
    function interopDefault2(sourceModule, opts = {}) {
      if (!isObject3(sourceModule) || !("default" in sourceModule)) {
        return sourceModule;
      }
      const defaultValue = sourceModule.default;
      if (defaultValue === void 0 || defaultValue === null) {
        return sourceModule;
      }
      const _defaultType = typeof defaultValue;
      if (_defaultType !== "object" && !(_defaultType === "function" && !opts.preferNamespace)) {
        return opts.preferNamespace ? sourceModule : defaultValue;
      }
      for (const key in sourceModule) {
        try {
          if (!(key in defaultValue)) {
            Object.defineProperty(defaultValue, key, {
              enumerable: key !== "default",
              configurable: key !== "default",
              get() {
                return sourceModule[key];
              }
            });
          }
        } catch (e2) {
        }
      }
      return defaultValue;
    }
    var EVAL_ESM_IMPORT_RE = /(?<=import .* from ["'])([^"']+)(?=["'])|(?<=export .* from ["'])([^"']+)(?=["'])|(?<=import\s*["'])([^"']+)(?=["'])|(?<=import\s*\(["'])([^"']+)(?=["']\))/g;
    async function loadModule(id, options = {}) {
      const url = await resolve4(id, options);
      const code = await loadURL(url);
      return evalModule(code, { ...options, url });
    }
    async function evalModule(code, options = {}) {
      const transformed = await transformModule(code, options);
      const dataURL = toDataURL(transformed);
      return Promise.resolve().then(() => _interopRequireWildcard(require(dataURL))).catch((error) => {
        error.stack = error.stack.replace(
          new RegExp(dataURL, "g"),
          options.url || "_mlly_eval_"
        );
        throw error;
      });
    }
    function transformModule(code, options = {}) {
      if (options.url && options.url.endsWith(".json")) {
        return Promise.resolve("export default " + code);
      }
      if (options.url) {
        code = code.replace(/import\.meta\.url/g, `'${options.url}'`);
      }
      return Promise.resolve(code);
    }
    async function resolveImports(code, options) {
      const imports = [...code.matchAll(EVAL_ESM_IMPORT_RE)].map((m) => m[0]);
      if (imports.length === 0) {
        return code;
      }
      const uniqueImports = [...new Set(imports)];
      const resolved = /* @__PURE__ */ new Map();
      await Promise.all(
        uniqueImports.map(async (id) => {
          let url = await resolve4(id, options);
          if (url.endsWith(".json")) {
            const code2 = await loadURL(url);
            url = toDataURL(await transformModule(code2, { url }));
          }
          resolved.set(id, url);
        })
      );
      const re = new RegExp(
        uniqueImports.map((index) => `(${index})`).join("|"),
        "g"
      );
      return code.replace(re, (id) => resolved.get(id));
    }
    var ESM_RE = /([\s;]|^)(import[\s\w*,{}]*from|import\s*["'*{]|export\b\s*(?:[*{]|default|class|type|function|const|var|let|async function)|import\.meta\b)/m;
    var CJS_RE = /([\s;]|^)(module.exports\b|exports\.\w|require\s*\(|global\.\w)/m;
    var COMMENT_RE = /\/\*.+?\*\/|\/\/.*(?=[nr])/g;
    var BUILTIN_EXTENSIONS = /* @__PURE__ */ new Set([".mjs", ".cjs", ".node", ".wasm"]);
    function hasESMSyntax(code, opts = {}) {
      if (opts.stripComments) {
        code = code.replace(COMMENT_RE, "");
      }
      return ESM_RE.test(code);
    }
    function hasCJSSyntax(code, opts = {}) {
      if (opts.stripComments) {
        code = code.replace(COMMENT_RE, "");
      }
      return CJS_RE.test(code);
    }
    function detectSyntax(code, opts = {}) {
      if (opts.stripComments) {
        code = code.replace(COMMENT_RE, "");
      }
      const hasESM = hasESMSyntax(code, {});
      const hasCJS = hasCJSSyntax(code, {});
      return {
        hasESM,
        hasCJS,
        isMixed: hasESM && hasCJS
      };
    }
    var validNodeImportDefaults = {
      allowedProtocols: ["node", "file", "data"]
    };
    async function isValidNodeImport(id, _options = {}) {
      var _a3;
      if (isNodeBuiltin(id)) {
        return true;
      }
      const options = { ...validNodeImportDefaults, ..._options };
      const proto = getProtocol(id);
      if (proto && !((_a3 = options.allowedProtocols) == null ? void 0 : _a3.includes(proto))) {
        return false;
      }
      if (proto === "data") {
        return true;
      }
      const resolvedPath = await resolvePath(id, options);
      const extension = pathe.extname(resolvedPath);
      if (BUILTIN_EXTENSIONS.has(extension)) {
        return true;
      }
      if (extension !== ".js") {
        return false;
      }
      const package_ = await pkgTypes.readPackageJSON(resolvedPath).catch(() => {
      });
      if ((package_ == null ? void 0 : package_.type) === "module") {
        return true;
      }
      if (/\.(\w+-)?esm?(-\w+)?\.js$|\/(esm?)\//.test(resolvedPath)) {
        return false;
      }
      const code = options.code || await fs5.promises.readFile(resolvedPath, "utf8").catch(() => {
      }) || "";
      return !hasESMSyntax(code, { stripComments: options.stripComments });
    }
    exports.DYNAMIC_IMPORT_RE = DYNAMIC_IMPORT_RE;
    exports.ESM_STATIC_IMPORT_RE = ESM_STATIC_IMPORT_RE;
    exports.EXPORT_DECAL_RE = EXPORT_DECAL_RE;
    exports.EXPORT_DECAL_TYPE_RE = EXPORT_DECAL_TYPE_RE;
    exports.createCommonJS = createCommonJS;
    exports.createResolve = createResolve;
    exports.detectSyntax = detectSyntax;
    exports.evalModule = evalModule;
    exports.fileURLToPath = fileURLToPath3;
    exports.findDynamicImports = findDynamicImports;
    exports.findExportNames = findExportNames;
    exports.findExports = findExports;
    exports.findStaticImports = findStaticImports;
    exports.findTypeExports = findTypeExports;
    exports.findTypeImports = findTypeImports;
    exports.getProtocol = getProtocol;
    exports.hasCJSSyntax = hasCJSSyntax;
    exports.hasESMSyntax = hasESMSyntax;
    exports.interopDefault = interopDefault2;
    exports.isNodeBuiltin = isNodeBuiltin;
    exports.isValidNodeImport = isValidNodeImport;
    exports.loadModule = loadModule;
    exports.loadURL = loadURL;
    exports.lookupNodeModuleSubpath = lookupNodeModuleSubpath;
    exports.normalizeid = normalizeid;
    exports.parseNodeModulePath = parseNodeModulePath;
    exports.parseStaticImport = parseStaticImport;
    exports.parseTypeImport = parseTypeImport;
    exports.pathToFileURL = pathToFileURL;
    exports.resolve = resolve4;
    exports.resolveImports = resolveImports;
    exports.resolveModuleExportNames = resolveModuleExportNames;
    exports.resolvePath = resolvePath;
    exports.resolvePathSync = resolvePathSync;
    exports.resolveSync = resolveSync;
    exports.sanitizeFilePath = sanitizeFilePath;
    exports.sanitizeURIComponent = sanitizeURIComponent;
    exports.toDataURL = toDataURL;
    exports.transformModule = transformModule;
  }
});

// ../../node_modules/.pnpm/local-pkg@1.0.0/node_modules/local-pkg/dist/index.cjs
var require_dist6 = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/local-pkg@1.0.0/node_modules/local-pkg/dist/index.cjs"(exports) {
    "use strict";
    var fs5 = _chunk42PBKAQTcjs.__require.call(void 0, "fs");
    var fsPromises3 = _chunk42PBKAQTcjs.__require.call(void 0, "fs/promises");
    var node_module = _chunk42PBKAQTcjs.__require.call(void 0, "module");
    var path7 = _chunk42PBKAQTcjs.__require.call(void 0, "path");
    var process7 = _chunk42PBKAQTcjs.__require.call(void 0, "process");
    var node_url = _chunk42PBKAQTcjs.__require.call(void 0, "url");
    var mlly = require_dist5();
    var _documentCurrentScript = typeof document !== "undefined" ? document.currentScript : null;
    function _interopDefaultCompat(e2) {
      return e2 && typeof e2 === "object" && "default" in e2 ? e2.default : e2;
    }
    var fs__default = /* @__PURE__ */ _interopDefaultCompat(fs5);
    var fsPromises__default = /* @__PURE__ */ _interopDefaultCompat(fsPromises3);
    var path__default = /* @__PURE__ */ _interopDefaultCompat(path7);
    var process__default = /* @__PURE__ */ _interopDefaultCompat(process7);
    var toPath3 = (urlOrPath) => urlOrPath instanceof URL ? node_url.fileURLToPath(urlOrPath) : urlOrPath;
    async function findUp3(name2, {
      cwd = process__default.cwd(),
      type = "file",
      stopAt
    } = {}) {
      var _a3;
      let directory = path__default.resolve((_a3 = toPath3(cwd)) != null ? _a3 : "");
      const { root } = path__default.parse(directory);
      stopAt = path__default.resolve(directory, toPath3(stopAt != null ? stopAt : root));
      while (directory && directory !== stopAt && directory !== root) {
        const filePath = path__default.isAbsolute(name2) ? name2 : path__default.join(directory, name2);
        try {
          const stats = await fsPromises__default.stat(filePath);
          if (type === "file" && stats.isFile() || type === "directory" && stats.isDirectory()) {
            return filePath;
          }
        } catch (e2) {
        }
        directory = path__default.dirname(directory);
      }
    }
    function _resolve(path$1, options = {}) {
      if (options.platform === "auto" || !options.platform)
        options.platform = process__default.platform === "win32" ? "win32" : "posix";
      if (process__default.versions.pnp) {
        const paths = options.paths || [];
        if (paths.length === 0)
          paths.push(process__default.cwd());
        const targetRequire = node_module.createRequire(typeof document === "undefined" ? _chunk42PBKAQTcjs.__require.call(void 0, "url").pathToFileURL(__filename).href : _documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === "SCRIPT" && _documentCurrentScript.src || new URL("index.cjs", document.baseURI).href);
        try {
          return targetRequire.resolve(path$1, { paths });
        } catch (e2) {
        }
      }
      const modulePath = mlly.resolvePathSync(path$1, {
        url: options.paths
      });
      if (options.platform === "win32")
        return path7.win32.normalize(modulePath);
      return modulePath;
    }
    function resolveModule(name2, options = {}) {
      try {
        return _resolve(name2, options);
      } catch (e2) {
        return void 0;
      }
    }
    async function importModule(path8) {
      const i = await Promise.resolve().then(() => _interopRequireWildcard(require(path8)));
      if (i)
        return mlly.interopDefault(i);
      return i;
    }
    function isPackageExists(name2, options = {}) {
      return !!resolvePackage(name2, options);
    }
    function getPackageJsonPath(name2, options = {}) {
      const entry = resolvePackage(name2, options);
      if (!entry)
        return;
      return searchPackageJSON(entry);
    }
    async function getPackageInfo(name2, options = {}) {
      const packageJsonPath = getPackageJsonPath(name2, options);
      if (!packageJsonPath)
        return;
      const packageJson = JSON.parse(await fs__default.promises.readFile(packageJsonPath, "utf8"));
      return {
        name: name2,
        version: packageJson.version,
        rootPath: path7.dirname(packageJsonPath),
        packageJsonPath,
        packageJson
      };
    }
    function getPackageInfoSync(name2, options = {}) {
      const packageJsonPath = getPackageJsonPath(name2, options);
      if (!packageJsonPath)
        return;
      const packageJson = JSON.parse(fs__default.readFileSync(packageJsonPath, "utf8"));
      return {
        name: name2,
        version: packageJson.version,
        rootPath: path7.dirname(packageJsonPath),
        packageJsonPath,
        packageJson
      };
    }
    function resolvePackage(name2, options = {}) {
      try {
        return _resolve(`${name2}/package.json`, options);
      } catch (e2) {
      }
      try {
        return _resolve(name2, options);
      } catch (e2) {
        if (e2.code !== "MODULE_NOT_FOUND" && e2.code !== "ERR_MODULE_NOT_FOUND")
          console.error(e2);
        return false;
      }
    }
    function searchPackageJSON(dir) {
      let packageJsonPath;
      while (true) {
        if (!dir)
          return;
        const newDir = path7.dirname(dir);
        if (newDir === dir)
          return;
        dir = newDir;
        packageJsonPath = path7.join(dir, "package.json");
        if (fs__default.existsSync(packageJsonPath))
          break;
      }
      return packageJsonPath;
    }
    async function loadPackageJSON(cwd = process__default.cwd()) {
      const path8 = await findUp3("package.json", { cwd });
      if (!path8 || !fs__default.existsSync(path8))
        return null;
      return JSON.parse(await fsPromises__default.readFile(path8, "utf-8"));
    }
    async function isPackageListed(name2, cwd) {
      const pkg = await loadPackageJSON(cwd) || {};
      return name2 in (pkg.dependencies || {}) || name2 in (pkg.devDependencies || {});
    }
    exports.getPackageInfo = getPackageInfo;
    exports.getPackageInfoSync = getPackageInfoSync;
    exports.importModule = importModule;
    exports.isPackageExists = isPackageExists;
    exports.isPackageListed = isPackageListed;
    exports.loadPackageJSON = loadPackageJSON;
    exports.resolveModule = resolveModule;
  }
});

// ../../node_modules/.pnpm/package-manager-detector@0.2.9/node_modules/package-manager-detector/dist/constants.cjs
var require_constants2 = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/package-manager-detector@0.2.9/node_modules/package-manager-detector/dist/constants.cjs"(exports) {
    "use strict";
    var AGENTS = [
      "npm",
      "yarn",
      "yarn@berry",
      "pnpm",
      "pnpm@6",
      "bun",
      "deno"
    ];
    var LOCKS = {
      "bun.lock": "bun",
      "bun.lockb": "bun",
      "deno.lock": "deno",
      "pnpm-lock.yaml": "pnpm",
      "yarn.lock": "yarn",
      "package-lock.json": "npm",
      "npm-shrinkwrap.json": "npm"
    };
    var INSTALL_PAGE = {
      "bun": "https://bun.sh",
      "deno": "https://deno.com",
      "pnpm": "https://pnpm.io/installation",
      "pnpm@6": "https://pnpm.io/6.x/installation",
      "yarn": "https://classic.yarnpkg.com/en/docs/install",
      "yarn@berry": "https://yarnpkg.com/getting-started/install",
      "npm": "https://docs.npmjs.com/cli/v8/configuring-npm/install"
    };
    exports.AGENTS = AGENTS;
    exports.INSTALL_PAGE = INSTALL_PAGE;
    exports.LOCKS = LOCKS;
  }
});

// ../../node_modules/.pnpm/package-manager-detector@0.2.9/node_modules/package-manager-detector/dist/detect.cjs
var require_detect = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/package-manager-detector@0.2.9/node_modules/package-manager-detector/dist/detect.cjs"(exports) {
    "use strict";
    var fs5 = _chunk42PBKAQTcjs.__require.call(void 0, "fs");
    var fsPromises3 = _chunk42PBKAQTcjs.__require.call(void 0, "fs/promises");
    var path7 = _chunk42PBKAQTcjs.__require.call(void 0, "path");
    var process7 = _chunk42PBKAQTcjs.__require.call(void 0, "process");
    var constants2 = require_constants2();
    function _interopDefaultCompat(e2) {
      return e2 && typeof e2 === "object" && "default" in e2 ? e2.default : e2;
    }
    var fs__default = /* @__PURE__ */ _interopDefaultCompat(fs5);
    var fsPromises__default = /* @__PURE__ */ _interopDefaultCompat(fsPromises3);
    var path__default = /* @__PURE__ */ _interopDefaultCompat(path7);
    var process__default = /* @__PURE__ */ _interopDefaultCompat(process7);
    async function detect(options = {}) {
      const { cwd, onUnknown } = options;
      for (const directory of lookup(cwd)) {
        for (const lock of Object.keys(constants2.LOCKS)) {
          if (await fileExists(path__default.join(directory, lock))) {
            const name2 = constants2.LOCKS[lock];
            const result2 = await parsePackageJson(path__default.join(directory, "package.json"), onUnknown);
            if (result2)
              return result2;
            else
              return { name: name2, agent: name2 };
          }
        }
        const result = await parsePackageJson(path__default.join(directory, "package.json"), onUnknown);
        if (result)
          return result;
      }
      return null;
    }
    function detectSync(options = {}) {
      const { cwd, onUnknown } = options;
      for (const directory of lookup(cwd)) {
        for (const lock of Object.keys(constants2.LOCKS)) {
          if (fileExistsSync(path__default.join(directory, lock))) {
            const name2 = constants2.LOCKS[lock];
            const result2 = parsePackageJsonSync(path__default.join(directory, "package.json"), onUnknown);
            if (result2)
              return result2;
            else
              return { name: name2, agent: name2 };
          }
        }
        const result = parsePackageJsonSync(path__default.join(directory, "package.json"), onUnknown);
        if (result)
          return result;
      }
      return null;
    }
    function getUserAgent() {
      const userAgent = process__default.env.npm_config_user_agent;
      if (!userAgent) {
        return null;
      }
      const name2 = userAgent.split("/")[0];
      return constants2.AGENTS.includes(name2) ? name2 : null;
    }
    function* lookup(cwd = process__default.cwd()) {
      let directory = path__default.resolve(cwd);
      const { root } = path__default.parse(directory);
      while (directory && directory !== root) {
        yield directory;
        directory = path__default.dirname(directory);
      }
    }
    async function parsePackageJson(filepath, onUnknown) {
      return !filepath || !await fileExists(filepath) ? null : handlePackageManager(filepath, onUnknown);
    }
    function parsePackageJsonSync(filepath, onUnknown) {
      return !filepath || !fileExistsSync(filepath) ? null : handlePackageManager(filepath, onUnknown);
    }
    function handlePackageManager(filepath, onUnknown) {
      var _a3;
      try {
        const pkg = JSON.parse(fs__default.readFileSync(filepath, "utf8"));
        let agent;
        if (typeof pkg.packageManager === "string") {
          const [name2, ver] = pkg.packageManager.replace(/^\^/, "").split("@");
          let version3 = ver;
          if (name2 === "yarn" && Number.parseInt(ver) > 1) {
            agent = "yarn@berry";
            version3 = "berry";
            return { name: name2, agent, version: version3 };
          } else if (name2 === "pnpm" && Number.parseInt(ver) < 7) {
            agent = "pnpm@6";
            return { name: name2, agent, version: version3 };
          } else if (constants2.AGENTS.includes(name2)) {
            agent = name2;
            return { name: name2, agent, version: version3 };
          } else {
            return (_a3 = onUnknown == null ? void 0 : onUnknown(pkg.packageManager)) != null ? _a3 : null;
          }
        }
      } catch (e2) {
      }
      return null;
    }
    async function fileExists(filePath) {
      try {
        const stats = await fsPromises__default.stat(filePath);
        if (stats.isFile()) {
          return true;
        }
      } catch (e2) {
      }
      return false;
    }
    function fileExistsSync(filePath) {
      try {
        const stats = fs__default.statSync(filePath);
        if (stats.isFile()) {
          return true;
        }
      } catch (e2) {
      }
      return false;
    }
    exports.detect = detect;
    exports.detectSync = detectSync;
    exports.getUserAgent = getUserAgent;
  }
});

// ../../node_modules/.pnpm/tinyexec@0.3.2/node_modules/tinyexec/dist/main.cjs
var require_main = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/tinyexec@0.3.2/node_modules/tinyexec/dist/main.cjs"(exports, module) {
    "use strict";
    var It = Object.create;
    var v = Object.defineProperty;
    var Lt = Object.getOwnPropertyDescriptor;
    var jt = Object.getOwnPropertyNames;
    var Ft = Object.getPrototypeOf;
    var zt = Object.prototype.hasOwnProperty;
    var l = (t, e2) => () => (e2 || t((e2 = { exports: {} }).exports, e2), e2.exports);
    var Ht = (t, e2) => {
      for (var n2 in e2)
        v(t, n2, { get: e2[n2], enumerable: true });
    };
    var N = (t, e2, n2, r) => {
      if (e2 && typeof e2 == "object" || typeof e2 == "function")
        for (let s of jt(e2))
          !zt.call(t, s) && s !== n2 && v(t, s, { get: () => e2[s], enumerable: !(r = Lt(e2, s)) || r.enumerable });
      return t;
    };
    var q = (t, e2, n2) => (n2 = t != null ? It(Ft(t)) : {}, N(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      e2 || !t || !t.__esModule ? v(n2, "default", { value: t, enumerable: true }) : n2,
      t
    ));
    var Wt = (t) => N(v({}, "__esModule", { value: true }), t);
    var K = l((Pe, D) => {
      "use strict";
      D.exports = W;
      W.sync = Xt;
      var z = _chunk42PBKAQTcjs.__require.call(void 0, "fs");
      function Bt(t, e2) {
        var n2 = e2.pathExt !== void 0 ? e2.pathExt : process.env.PATHEXT;
        if (!n2 || (n2 = n2.split(";"), n2.indexOf("") !== -1))
          return true;
        for (var r = 0; r < n2.length; r++) {
          var s = n2[r].toLowerCase();
          if (s && t.substr(-s.length).toLowerCase() === s)
            return true;
        }
        return false;
      }
      function H(t, e2, n2) {
        return !t.isSymbolicLink() && !t.isFile() ? false : Bt(e2, n2);
      }
      function W(t, e2, n2) {
        z.stat(t, function(r, s) {
          n2(r, r ? false : H(s, t, e2));
        });
      }
      function Xt(t, e2) {
        return H(z.statSync(t), t, e2);
      }
    });
    var U = l((Oe, G) => {
      "use strict";
      G.exports = B;
      B.sync = Gt;
      var M = _chunk42PBKAQTcjs.__require.call(void 0, "fs");
      function B(t, e2, n2) {
        M.stat(t, function(r, s) {
          n2(r, r ? false : X(s, e2));
        });
      }
      function Gt(t, e2) {
        return X(M.statSync(t), e2);
      }
      function X(t, e2) {
        return t.isFile() && Ut(t, e2);
      }
      function Ut(t, e2) {
        var n2 = t.mode, r = t.uid, s = t.gid, o = e2.uid !== void 0 ? e2.uid : process.getuid && process.getuid(), i = e2.gid !== void 0 ? e2.gid : process.getgid && process.getgid(), a = parseInt("100", 8), c = parseInt("010", 8), u = parseInt("001", 8), f = a | c, p = n2 & u || n2 & c && s === i || n2 & a && r === o || n2 & f && o === 0;
        return p;
      }
    });
    var V = l((ke, Y) => {
      "use strict";
      var Se = _chunk42PBKAQTcjs.__require.call(void 0, "fs"), b;
      process.platform === "win32" || global.TESTING_WINDOWS ? b = K() : b = U();
      Y.exports = C;
      C.sync = Yt;
      function C(t, e2, n2) {
        if (typeof e2 == "function" && (n2 = e2, e2 = {}), !n2) {
          if (typeof Promise != "function")
            throw new TypeError("callback not provided");
          return new Promise(function(r, s) {
            C(t, e2 || {}, function(o, i) {
              o ? s(o) : r(i);
            });
          });
        }
        b(t, e2 || {}, function(r, s) {
          r && (r.code === "EACCES" || e2 && e2.ignoreErrors) && (r = null, s = false), n2(r, s);
        });
      }
      function Yt(t, e2) {
        try {
          return b.sync(t, e2 || {});
        } catch (n2) {
          if (e2 && e2.ignoreErrors || n2.code === "EACCES")
            return false;
          throw n2;
        }
      }
    });
    var rt = l((Te, nt) => {
      "use strict";
      var g = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys", J = _chunk42PBKAQTcjs.__require.call(void 0, "path"), Vt = g ? ";" : ":", Q = V(), Z = (t) => Object.assign(new Error(`not found: ${t}`), { code: "ENOENT" }), tt = (t, e2) => {
        let n2 = e2.colon || Vt, r = t.match(/\//) || g && t.match(/\\/) ? [""] : [
          // windows always checks the cwd first
          ...g ? [process.cwd()] : [],
          ...(e2.path || process.env.PATH || /* istanbul ignore next: very unusual */
          "").split(n2)
        ], s = g ? e2.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "", o = g ? s.split(n2) : [""];
        return g && t.indexOf(".") !== -1 && o[0] !== "" && o.unshift(""), {
          pathEnv: r,
          pathExt: o,
          pathExtExe: s
        };
      }, et = (t, e2, n2) => {
        typeof e2 == "function" && (n2 = e2, e2 = {}), e2 || (e2 = {});
        let { pathEnv: r, pathExt: s, pathExtExe: o } = tt(t, e2), i = [], a = (u) => new Promise((f, p) => {
          if (u === r.length)
            return e2.all && i.length ? f(i) : p(Z(t));
          let d = r[u], x2 = /^".*"$/.test(d) ? d.slice(1, -1) : d, m = J.join(x2, t), _ = !x2 && /^\.[\\\/]/.test(t) ? t.slice(0, 2) + m : m;
          f(c(_, u, 0));
        }), c = (u, f, p) => new Promise((d, x2) => {
          if (p === s.length)
            return d(a(f + 1));
          let m = s[p];
          Q(u + m, { pathExt: o }, (_, qt) => {
            if (!_ && qt)
              if (e2.all)
                i.push(u + m);
              else
                return d(u + m);
            return d(c(u, f, p + 1));
          });
        });
        return n2 ? a(0).then((u) => n2(null, u), n2) : a(0);
      }, Jt = (t, e2) => {
        e2 = e2 || {};
        let { pathEnv: n2, pathExt: r, pathExtExe: s } = tt(t, e2), o = [];
        for (let i = 0; i < n2.length; i++) {
          let a = n2[i], c = /^".*"$/.test(a) ? a.slice(1, -1) : a, u = J.join(c, t), f = !c && /^\.[\\\/]/.test(t) ? t.slice(0, 2) + u : u;
          for (let p = 0; p < r.length; p++) {
            let d = f + r[p];
            try {
              if (Q.sync(d, { pathExt: s }))
                if (e2.all)
                  o.push(d);
                else
                  return d;
            } catch (e3) {
            }
          }
        }
        if (e2.all && o.length)
          return o;
        if (e2.nothrow)
          return null;
        throw Z(t);
      };
      nt.exports = et;
      et.sync = Jt;
    });
    var ot = l((Ae, P) => {
      "use strict";
      var st = (t = {}) => {
        let e2 = t.env || process.env;
        return (t.platform || process.platform) !== "win32" ? "PATH" : Object.keys(e2).reverse().find((r) => r.toUpperCase() === "PATH") || "Path";
      };
      P.exports = st;
      P.exports.default = st;
    });
    var at = l((Re, ut) => {
      "use strict";
      var it = _chunk42PBKAQTcjs.__require.call(void 0, "path"), Qt = rt(), Zt = ot();
      function ct(t, e2) {
        let n2 = t.options.env || process.env, r = process.cwd(), s = t.options.cwd != null, o = s && process.chdir !== void 0 && !process.chdir.disabled;
        if (o)
          try {
            process.chdir(t.options.cwd);
          } catch (e3) {
          }
        let i;
        try {
          i = Qt.sync(t.command, {
            path: n2[Zt({ env: n2 })],
            pathExt: e2 ? it.delimiter : void 0
          });
        } catch (e3) {
        } finally {
          o && process.chdir(r);
        }
        return i && (i = it.resolve(s ? t.options.cwd : "", i)), i;
      }
      function te(t) {
        return ct(t) || ct(t, true);
      }
      ut.exports = te;
    });
    var lt = l(($e, S) => {
      "use strict";
      var O = /([()\][%!^"`<>&|;, *?])/g;
      function ee(t) {
        return t = t.replace(O, "^$1"), t;
      }
      function ne(t, e2) {
        return t = `${t}`, t = t.replace(/(\\*)"/g, '$1$1\\"'), t = t.replace(/(\\*)$/, "$1$1"), t = `"${t}"`, t = t.replace(O, "^$1"), e2 && (t = t.replace(O, "^$1")), t;
      }
      S.exports.command = ee;
      S.exports.argument = ne;
    });
    var dt = l((Ne, pt) => {
      "use strict";
      pt.exports = /^#!(.*)/;
    });
    var ht = l((qe, ft) => {
      "use strict";
      var re = dt();
      ft.exports = (t = "") => {
        let e2 = t.match(re);
        if (!e2)
          return null;
        let [n2, r] = e2[0].replace(/#! ?/, "").split(" "), s = n2.split("/").pop();
        return s === "env" ? r : r ? `${s} ${r}` : s;
      };
    });
    var gt = l((Ie, mt) => {
      "use strict";
      var k = _chunk42PBKAQTcjs.__require.call(void 0, "fs"), se = ht();
      function oe(t) {
        let n2 = Buffer.alloc(150), r;
        try {
          r = k.openSync(t, "r"), k.readSync(r, n2, 0, 150, 0), k.closeSync(r);
        } catch (e2) {
        }
        return se(n2.toString());
      }
      mt.exports = oe;
    });
    var vt = l((Le, xt) => {
      "use strict";
      var ie = _chunk42PBKAQTcjs.__require.call(void 0, "path"), Et = at(), wt = lt(), ce = gt(), ue = process.platform === "win32", ae = /\.(?:com|exe)$/i, le = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
      function pe(t) {
        t.file = Et(t);
        let e2 = t.file && ce(t.file);
        return e2 ? (t.args.unshift(t.file), t.command = e2, Et(t)) : t.file;
      }
      function de(t) {
        if (!ue)
          return t;
        let e2 = pe(t), n2 = !ae.test(e2);
        if (t.options.forceShell || n2) {
          let r = le.test(e2);
          t.command = ie.normalize(t.command), t.command = wt.command(t.command), t.args = t.args.map((o) => wt.argument(o, r));
          let s = [t.command].concat(t.args).join(" ");
          t.args = ["/d", "/s", "/c", `"${s}"`], t.command = process.env.comspec || "cmd.exe", t.options.windowsVerbatimArguments = true;
        }
        return t;
      }
      function fe(t, e2, n2) {
        e2 && !Array.isArray(e2) && (n2 = e2, e2 = null), e2 = e2 ? e2.slice(0) : [], n2 = Object.assign({}, n2);
        let r = {
          command: t,
          args: e2,
          options: n2,
          file: void 0,
          original: {
            command: t,
            args: e2
          }
        };
        return n2.shell ? r : de(r);
      }
      xt.exports = fe;
    });
    var _t = l((je, yt) => {
      "use strict";
      var T = process.platform === "win32";
      function A(t, e2) {
        return Object.assign(new Error(`${e2} ${t.command} ENOENT`), {
          code: "ENOENT",
          errno: "ENOENT",
          syscall: `${e2} ${t.command}`,
          path: t.command,
          spawnargs: t.args
        });
      }
      function he(t, e2) {
        if (!T)
          return;
        let n2 = t.emit;
        t.emit = function(r, s) {
          if (r === "exit") {
            let o = bt(s, e2, "spawn");
            if (o)
              return n2.call(t, "error", o);
          }
          return n2.apply(t, arguments);
        };
      }
      function bt(t, e2) {
        return T && t === 1 && !e2.file ? A(e2.original, "spawn") : null;
      }
      function me(t, e2) {
        return T && t === 1 && !e2.file ? A(e2.original, "spawnSync") : null;
      }
      yt.exports = {
        hookChildProcess: he,
        verifyENOENT: bt,
        verifyENOENTSync: me,
        notFoundError: A
      };
    });
    var Ot = l((Fe, E) => {
      "use strict";
      var Ct = _chunk42PBKAQTcjs.__require.call(void 0, "child_process"), R = vt(), $ = _t();
      function Pt(t, e2, n2) {
        let r = R(t, e2, n2), s = Ct.spawn(r.command, r.args, r.options);
        return $.hookChildProcess(s, r), s;
      }
      function ge(t, e2, n2) {
        let r = R(t, e2, n2), s = Ct.spawnSync(r.command, r.args, r.options);
        return s.error = s.error || $.verifyENOENTSync(s.status, r), s;
      }
      E.exports = Pt;
      E.exports.spawn = Pt;
      E.exports.sync = ge;
      E.exports._parse = R;
      E.exports._enoent = $;
    });
    var be = {};
    Ht(be, {
      ExecProcess: () => y,
      NonZeroExitError: () => w,
      exec: () => Nt,
      x: () => $t
    });
    module.exports = Wt(be);
    var St = _chunk42PBKAQTcjs.__require.call(void 0, "child_process");
    var kt = _chunk42PBKAQTcjs.__require.call(void 0, "path");
    var Tt = _chunk42PBKAQTcjs.__require.call(void 0, "process");
    var h3 = _chunk42PBKAQTcjs.__require.call(void 0, "path");
    var Dt = /^path$/i;
    var I = { key: "PATH", value: "" };
    function Kt(t) {
      for (let e2 in t) {
        if (!Object.prototype.hasOwnProperty.call(t, e2) || !Dt.test(e2))
          continue;
        let n2 = t[e2];
        return n2 ? { key: e2, value: n2 } : I;
      }
      return I;
    }
    function Mt(t, e2) {
      let n2 = e2.value.split(h3.delimiter), r = t, s;
      do
        n2.push((0, h3.resolve)(r, "node_modules", ".bin")), s = r, r = (0, h3.dirname)(r);
      while (r !== s);
      return { key: e2.key, value: n2.join(h3.delimiter) };
    }
    function L(t, e2) {
      let n2 = {
        ...process.env,
        ...e2
      }, r = Mt(t, Kt(n2));
      return n2[r.key] = r.value, n2;
    }
    var j = _chunk42PBKAQTcjs.__require.call(void 0, "stream");
    var F = (t) => {
      let e2 = t.length, n2 = new j.PassThrough(), r = () => {
        --e2 === 0 && n2.emit("end");
      };
      for (let s of t)
        s.pipe(n2, { end: false }), s.on("end", r);
      return n2;
    };
    var At = q(_chunk42PBKAQTcjs.__require.call(void 0, "readline"), 1);
    var Rt = q(Ot(), 1);
    var w = class extends Error {
      constructor(e2, n2) {
        super(`Process exited with non-zero status (${e2.exitCode})`);
        _chunk42PBKAQTcjs.__publicField.call(void 0, this, "result");
        _chunk42PBKAQTcjs.__publicField.call(void 0, this, "output");
        this.result = e2, this.output = n2;
      }
      get exitCode() {
        if (this.result.exitCode !== null)
          return this.result.exitCode;
      }
    };
    var Ee = {
      timeout: void 0,
      persist: false
    };
    var we = {
      windowsHide: true
    };
    function xe(t, e2) {
      return {
        command: (0, kt.normalize)(t),
        args: e2 != null ? e2 : []
      };
    }
    function ve(t) {
      let e2 = new AbortController();
      for (let n2 of t) {
        if (n2.aborted)
          return e2.abort(), n2;
        let r = () => {
          e2.abort(n2.reason);
        };
        n2.addEventListener("abort", r, {
          signal: e2.signal
        });
      }
      return e2.signal;
    }
    var y = class {
      constructor(e2, n2, r) {
        _chunk42PBKAQTcjs.__publicField.call(void 0, this, "_process");
        _chunk42PBKAQTcjs.__publicField.call(void 0, this, "_aborted", false);
        _chunk42PBKAQTcjs.__publicField.call(void 0, this, "_options");
        _chunk42PBKAQTcjs.__publicField.call(void 0, this, "_command");
        _chunk42PBKAQTcjs.__publicField.call(void 0, this, "_args");
        _chunk42PBKAQTcjs.__publicField.call(void 0, this, "_resolveClose");
        _chunk42PBKAQTcjs.__publicField.call(void 0, this, "_processClosed");
        _chunk42PBKAQTcjs.__publicField.call(void 0, this, "_thrownError");
        _chunk42PBKAQTcjs.__publicField.call(void 0, this, "_streamOut");
        _chunk42PBKAQTcjs.__publicField.call(void 0, this, "_streamErr");
        _chunk42PBKAQTcjs.__publicField.call(void 0, this, "_onError", (e2) => {
          if (e2.name === "AbortError" && (!(e2.cause instanceof Error) || e2.cause.name !== "TimeoutError")) {
            this._aborted = true;
            return;
          }
          this._thrownError = e2;
        });
        _chunk42PBKAQTcjs.__publicField.call(void 0, this, "_onClose", () => {
          this._resolveClose && this._resolveClose();
        });
        this._options = {
          ...Ee,
          ...r
        }, this._command = e2, this._args = n2 != null ? n2 : [], this._processClosed = new Promise((s) => {
          this._resolveClose = s;
        });
      }
      get process() {
        return this._process;
      }
      get pid() {
        var _a3;
        return (_a3 = this._process) == null ? void 0 : _a3.pid;
      }
      get exitCode() {
        if (this._process && this._process.exitCode !== null)
          return this._process.exitCode;
      }
      kill(e2) {
        var _a3;
        return ((_a3 = this._process) == null ? void 0 : _a3.kill(e2)) === true;
      }
      get aborted() {
        return this._aborted;
      }
      get killed() {
        var _a3;
        return ((_a3 = this._process) == null ? void 0 : _a3.killed) === true;
      }
      pipe(e2, n2, r) {
        return Nt(e2, n2, {
          ...r,
          stdin: this
        });
      }
      async *[Symbol.asyncIterator]() {
        var _a3;
        let e2 = this._process;
        if (!e2)
          return;
        let n2 = [];
        this._streamErr && n2.push(this._streamErr), this._streamOut && n2.push(this._streamOut);
        let r = F(n2), s = At.default.createInterface({
          input: r
        });
        for await (let o of s)
          yield o.toString();
        if (await this._processClosed, e2.removeAllListeners(), this._thrownError)
          throw this._thrownError;
        if (((_a3 = this._options) == null ? void 0 : _a3.throwOnError) && this.exitCode !== 0 && this.exitCode !== void 0)
          throw new w(this);
      }
      async _waitForOutput() {
        var _a3;
        let e2 = this._process;
        if (!e2)
          throw new Error("No process was started");
        let n2 = "", r = "";
        if (this._streamOut)
          for await (let o of this._streamOut)
            r += o.toString();
        if (this._streamErr)
          for await (let o of this._streamErr)
            n2 += o.toString();
        if (await this._processClosed, ((_a3 = this._options) == null ? void 0 : _a3.stdin) && await this._options.stdin, e2.removeAllListeners(), this._thrownError)
          throw this._thrownError;
        let s = {
          stderr: n2,
          stdout: r,
          exitCode: this.exitCode
        };
        if (this._options.throwOnError && this.exitCode !== 0 && this.exitCode !== void 0)
          throw new w(this, s);
        return s;
      }
      then(e2, n2) {
        return this._waitForOutput().then(e2, n2);
      }
      spawn() {
        let e2 = (0, Tt.cwd)(), n2 = this._options, r = {
          ...we,
          ...n2.nodeOptions
        }, s = [];
        this._resetState(), n2.timeout !== void 0 && s.push(AbortSignal.timeout(n2.timeout)), n2.signal !== void 0 && s.push(n2.signal), n2.persist === true && (r.detached = true), s.length > 0 && (r.signal = ve(s)), r.env = L(e2, r.env);
        let { command: o, args: i } = xe(this._command, this._args), a = (0, Rt._parse)(o, i, r), c = (0, St.spawn)(
          a.command,
          a.args,
          a.options
        );
        if (c.stderr && (this._streamErr = c.stderr), c.stdout && (this._streamOut = c.stdout), this._process = c, c.once("error", this._onError), c.once("close", this._onClose), n2.stdin !== void 0 && c.stdin && n2.stdin.process) {
          let { stdout: u } = n2.stdin.process;
          u && u.pipe(c.stdin);
        }
      }
      _resetState() {
        this._aborted = false, this._processClosed = new Promise((e2) => {
          this._resolveClose = e2;
        }), this._thrownError = void 0;
      }
    };
    var $t = (t, e2, n2) => {
      let r = new y(t, e2, n2);
      return r.spawn(), r;
    };
    var Nt = $t;
  }
});

// ../../node_modules/.pnpm/@antfu+install-pkg@1.0.0/node_modules/@antfu/install-pkg/dist/index.cjs
var require_dist7 = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/@antfu+install-pkg@1.0.0/node_modules/@antfu/install-pkg/dist/index.cjs"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name2 in all)
        __defProp(target, name2, { get: all[name2], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      detectPackageManager: () => detectPackageManager,
      installPackage: () => installPackage
    });
    module.exports = __toCommonJS(src_exports);
    var import_node_process5 = __toESM2(_chunk42PBKAQTcjs.__require.call(void 0, "process"), 1);
    var import_detect = require_detect();
    async function detectPackageManager(cwd = import_node_process5.default.cwd()) {
      const result = await (0, import_detect.detect)({
        cwd,
        onUnknown(packageManager) {
          console.warn("[@antfu/install-pkg] Unknown packageManager:", packageManager);
          return void 0;
        }
      });
      return (result == null ? void 0 : result.agent) || null;
    }
    var import_node_fs5 = _chunk42PBKAQTcjs.__require.call(void 0, "fs");
    var import_node_path5 = _chunk42PBKAQTcjs.__require.call(void 0, "path");
    var import_node_process22 = __toESM2(_chunk42PBKAQTcjs.__require.call(void 0, "process"), 1);
    var import_tinyexec = require_main();
    async function installPackage(names, options = {}) {
      var _a3;
      const detectedAgent = options.packageManager || await detectPackageManager(options.cwd) || "npm";
      const [agent] = detectedAgent.split("@");
      if (!Array.isArray(names))
        names = [names];
      const args = (typeof options.additionalArgs === "function" ? options.additionalArgs(agent, detectedAgent) : options.additionalArgs) || [];
      if (options.preferOffline) {
        if (detectedAgent === "yarn@berry")
          args.unshift("--cached");
        else
          args.unshift("--prefer-offline");
      }
      if (agent === "pnpm" && (0, import_node_fs5.existsSync)((0, import_node_path5.resolve)((_a3 = options.cwd) != null ? _a3 : import_node_process22.default.cwd(), "pnpm-workspace.yaml"))) {
        args.unshift(
          "-w",
          /**
           * Prevent pnpm from removing installed devDeps while `NODE_ENV` is `production`
           * @see https://pnpm.io/cli/install#--prod--p
           */
          "--prod=false"
        );
      }
      return (0, import_tinyexec.x)(
        agent,
        [
          agent === "yarn" ? "add" : "install",
          options.dev ? "-D" : "",
          ...args,
          ...names
        ].filter(Boolean),
        {
          nodeOptions: {
            stdio: options.silent ? "ignore" : "inherit",
            cwd: options.cwd
          },
          throwOnError: true
        }
      );
    }
  }
});

// ../../node_modules/.pnpm/@antfu+utils@8.1.0/node_modules/@antfu/utils/dist/index.cjs
var require_dist8 = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/@antfu+utils@8.1.0/node_modules/@antfu/utils/dist/index.cjs"(exports) {
    "use strict";
    function clamp(n2, min, max) {
      return Math.min(max, Math.max(min, n2));
    }
    function sum(...args) {
      return flattenArrayable(args).reduce((a, b) => a + b, 0);
    }
    function lerp(min, max, t) {
      const interpolation = clamp(t, 0, 1);
      return min + (max - min) * interpolation;
    }
    function remap(n2, inMin, inMax, outMin, outMax) {
      const interpolation = (n2 - inMin) / (inMax - inMin);
      return lerp(outMin, outMax, interpolation);
    }
    function toArray4(array) {
      array = array != null ? array : [];
      return Array.isArray(array) ? array : [array];
    }
    function flattenArrayable(array) {
      return toArray4(array).flat(1);
    }
    function mergeArrayable(...args) {
      return args.flatMap((i) => toArray4(i));
    }
    function partition(array, ...filters2) {
      const result = Array.from({ length: filters2.length + 1 }).fill(null).map(() => []);
      array.forEach((e2, idx, arr) => {
        let i = 0;
        for (const filter of filters2) {
          if (filter(e2, idx, arr)) {
            result[i].push(e2);
            return;
          }
          i += 1;
        }
        result[i].push(e2);
      });
      return result;
    }
    function uniq2(array) {
      return Array.from(new Set(array));
    }
    function uniqueBy2(array, equalFn) {
      return array.reduce((acc, cur) => {
        const index = acc.findIndex((item) => equalFn(cur, item));
        if (index === -1)
          acc.push(cur);
        return acc;
      }, []);
    }
    function last(array) {
      return at(array, -1);
    }
    function remove(array, value) {
      if (!array)
        return false;
      const index = array.indexOf(value);
      if (index >= 0) {
        array.splice(index, 1);
        return true;
      }
      return false;
    }
    function at(array, index) {
      const len = array.length;
      if (!len)
        return void 0;
      if (index < 0)
        index += len;
      return array[index];
    }
    function range(...args) {
      let start, stop, step;
      if (args.length === 1) {
        start = 0;
        step = 1;
        [stop] = args;
      } else {
        [start, stop, step = 1] = args;
      }
      const arr = [];
      let current = start;
      while (current < stop) {
        arr.push(current);
        current += step || 1;
      }
      return arr;
    }
    function move(arr, from, to) {
      arr.splice(to, 0, arr.splice(from, 1)[0]);
      return arr;
    }
    function clampArrayRange(n2, arr) {
      return clamp(n2, 0, arr.length - 1);
    }
    function sample(arr, quantity) {
      return Array.from({ length: quantity }, (_) => arr[Math.round(Math.random() * (arr.length - 1))]);
    }
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }
    function filterInPlace(array, predicate) {
      for (let i = array.length; i--; i >= 0) {
        if (!predicate(array[i], i, array))
          array.splice(i, 1);
      }
      return array;
    }
    function assert(condition, message) {
      if (!condition)
        throw new Error(message);
    }
    var toString2 = (v) => Object.prototype.toString.call(v);
    function getTypeName(v) {
      if (v === null)
        return "null";
      const type = toString2(v).slice(8, -1).toLowerCase();
      return typeof v === "object" || typeof v === "function" ? type : typeof v;
    }
    function noop2() {
    }
    function isDeepEqual(value1, value2) {
      const type1 = getTypeName(value1);
      const type2 = getTypeName(value2);
      if (type1 !== type2)
        return false;
      if (type1 === "array") {
        if (value1.length !== value2.length)
          return false;
        return value1.every((item, i) => {
          return isDeepEqual(item, value2[i]);
        });
      }
      if (type1 === "object") {
        const keyArr = Object.keys(value1);
        if (keyArr.length !== Object.keys(value2).length)
          return false;
        return keyArr.every((key) => {
          return isDeepEqual(value1[key], value2[key]);
        });
      }
      return Object.is(value1, value2);
    }
    function batchInvoke(functions) {
      functions.forEach((fn) => fn && fn());
    }
    function invoke(fn) {
      return fn();
    }
    function tap(value, callback) {
      callback(value);
      return value;
    }
    function notNullish2(v) {
      return v != null;
    }
    function noNull(v) {
      return v !== null;
    }
    function notUndefined(v) {
      return v !== void 0;
    }
    function isTruthy(v) {
      return Boolean(v);
    }
    var isDef = (val) => typeof val !== "undefined";
    var isBoolean = (val) => typeof val === "boolean";
    var isFunction = (val) => typeof val === "function";
    var isNumber = (val) => typeof val === "number";
    var isString2 = (val) => typeof val === "string";
    var isObject3 = (val) => toString2(val) === "[object Object]";
    var isUndefined = (val) => toString2(val) === "[object Undefined]";
    var isNull = (val) => toString2(val) === "[object Null]";
    var isRegExp = (val) => toString2(val) === "[object RegExp]";
    var isDate = (val) => toString2(val) === "[object Date]";
    var isWindow = (val) => typeof window !== "undefined" && toString2(val) === "[object Window]";
    var isBrowser = typeof window !== "undefined";
    function objectMap(obj, fn) {
      return Object.fromEntries(
        Object.entries(obj).map(([k, v]) => fn(k, v)).filter(notNullish2)
      );
    }
    function isKeyOf(obj, k) {
      return k in obj;
    }
    function objectKeys(obj) {
      return Object.keys(obj);
    }
    function objectEntries(obj) {
      return Object.entries(obj);
    }
    function deepMerge(target, ...sources) {
      if (!sources.length)
        return target;
      const source = sources.shift();
      if (source === void 0)
        return target;
      if (isMergableObject(target) && isMergableObject(source)) {
        objectKeys(source).forEach((key) => {
          if (key === "__proto__" || key === "constructor" || key === "prototype")
            return;
          if (isMergableObject(source[key])) {
            if (!target[key])
              target[key] = {};
            if (isMergableObject(target[key])) {
              deepMerge(target[key], source[key]);
            } else {
              target[key] = source[key];
            }
          } else {
            target[key] = source[key];
          }
        });
      }
      return deepMerge(target, ...sources);
    }
    function deepMergeWithArray(target, ...sources) {
      if (!sources.length)
        return target;
      const source = sources.shift();
      if (source === void 0)
        return target;
      if (Array.isArray(target) && Array.isArray(source))
        target.push(...source);
      if (isMergableObject(target) && isMergableObject(source)) {
        objectKeys(source).forEach((key) => {
          if (key === "__proto__" || key === "constructor" || key === "prototype")
            return;
          if (Array.isArray(source[key])) {
            if (!target[key])
              target[key] = [];
            deepMergeWithArray(target[key], source[key]);
          } else if (isMergableObject(source[key])) {
            if (!target[key])
              target[key] = {};
            deepMergeWithArray(target[key], source[key]);
          } else {
            target[key] = source[key];
          }
        });
      }
      return deepMergeWithArray(target, ...sources);
    }
    function isMergableObject(item) {
      return isObject3(item) && !Array.isArray(item);
    }
    function objectPick(obj, keys, omitUndefined = false) {
      return keys.reduce((n2, k) => {
        if (k in obj) {
          if (!omitUndefined || obj[k] !== void 0)
            n2[k] = obj[k];
        }
        return n2;
      }, {});
    }
    function clearUndefined(obj) {
      Object.keys(obj).forEach((key) => obj[key] === void 0 ? delete obj[key] : {});
      return obj;
    }
    function hasOwnProperty(obj, v) {
      if (obj == null)
        return false;
      return Object.prototype.hasOwnProperty.call(obj, v);
    }
    var Node2 = class {
      constructor(value) {
        _chunk42PBKAQTcjs.__publicField.call(void 0, this, "value");
        _chunk42PBKAQTcjs.__publicField.call(void 0, this, "next");
        this.value = value;
      }
    };
    var _head3, _tail3, _size3;
    var Queue2 = class {
      constructor() {
        _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _head3);
        _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _tail3);
        _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _size3);
        this.clear();
      }
      enqueue(value) {
        const node = new Node2(value);
        if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _head3)) {
          _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _tail3).next = node;
          _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _tail3, node);
        } else {
          _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _head3, node);
          _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _tail3, node);
        }
        _chunk42PBKAQTcjs.__privateWrapper.call(void 0, this, _size3)._++;
      }
      dequeue() {
        const current = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _head3);
        if (!current) {
          return;
        }
        _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _head3, _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _head3).next);
        _chunk42PBKAQTcjs.__privateWrapper.call(void 0, this, _size3)._--;
        return current.value;
      }
      peek() {
        if (!_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _head3)) {
          return;
        }
        return _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _head3).value;
      }
      clear() {
        _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _head3, void 0);
        _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _tail3, void 0);
        _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _size3, 0);
      }
      get size() {
        return _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _size3);
      }
      *[Symbol.iterator]() {
        let current = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _head3);
        while (current) {
          yield current.value;
          current = current.next;
        }
      }
    };
    _head3 = new WeakMap();
    _tail3 = new WeakMap();
    _size3 = new WeakMap();
    function pLimit2(concurrency) {
      validateConcurrency(concurrency);
      const queue = new Queue2();
      let activeCount = 0;
      const resumeNext = () => {
        if (activeCount < concurrency && queue.size > 0) {
          queue.dequeue()();
          activeCount++;
        }
      };
      const next = () => {
        activeCount--;
        resumeNext();
      };
      const run = async (function_, resolve4, arguments_) => {
        const result = (async () => function_(...arguments_))();
        resolve4(result);
        try {
          await result;
        } catch (e2) {
        }
        next();
      };
      const enqueue = (function_, resolve4, arguments_) => {
        new Promise((internalResolve) => {
          queue.enqueue(internalResolve);
        }).then(
          run.bind(void 0, function_, resolve4, arguments_)
        );
        (async () => {
          await Promise.resolve();
          if (activeCount < concurrency) {
            resumeNext();
          }
        })();
      };
      const generator = (function_, ...arguments_) => new Promise((resolve4) => {
        enqueue(function_, resolve4, arguments_);
      });
      Object.defineProperties(generator, {
        activeCount: {
          get: () => activeCount
        },
        pendingCount: {
          get: () => queue.size
        },
        clearQueue: {
          value() {
            queue.clear();
          }
        },
        concurrency: {
          get: () => concurrency,
          set(newConcurrency) {
            validateConcurrency(newConcurrency);
            concurrency = newConcurrency;
            queueMicrotask(() => {
              while (activeCount < concurrency && queue.size > 0) {
                resumeNext();
              }
            });
          }
        }
      });
      return generator;
    }
    function validateConcurrency(concurrency) {
      if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
        throw new TypeError("Expected `concurrency` to be a number from 1 and up");
      }
    }
    var VOID = Symbol("p-void");
    var PInstance = class _PInstance extends Promise {
      constructor(items = [], options) {
        super(() => {
        });
        this.items = items;
        this.options = options;
        this.promises = /* @__PURE__ */ new Set();
      }
      get promise() {
        var _a3;
        let batch;
        const items = [...Array.from(this.items), ...Array.from(this.promises)];
        if ((_a3 = this.options) == null ? void 0 : _a3.concurrency) {
          const limit = pLimit2(this.options.concurrency);
          batch = Promise.all(items.map((p2) => limit(() => p2)));
        } else {
          batch = Promise.all(items);
        }
        return batch.then((l) => l.filter((i) => i !== VOID));
      }
      add(...args) {
        args.forEach((i) => {
          this.promises.add(i);
        });
      }
      map(fn) {
        return new _PInstance(
          Array.from(this.items).map(async (i, idx) => {
            const v = await i;
            if (v === VOID)
              return VOID;
            return fn(v, idx);
          }),
          this.options
        );
      }
      filter(fn) {
        return new _PInstance(
          Array.from(this.items).map(async (i, idx) => {
            const v = await i;
            const r = await fn(v, idx);
            if (!r)
              return VOID;
            return v;
          }),
          this.options
        );
      }
      forEach(fn) {
        return this.map(fn).then();
      }
      reduce(fn, initialValue) {
        return this.promise.then((array) => array.reduce(fn, initialValue));
      }
      clear() {
        this.promises.clear();
      }
      then(fn) {
        const p2 = this.promise;
        if (fn)
          return p2.then(fn);
        else
          return p2;
      }
      catch(fn) {
        return this.promise.catch(fn);
      }
      finally(fn) {
        return this.promise.finally(fn);
      }
    };
    function p(items, options) {
      return new PInstance(items, options);
    }
    function createSingletonPromise(fn) {
      let _promise;
      function wrapper() {
        if (!_promise)
          _promise = fn();
        return _promise;
      }
      wrapper.reset = async () => {
        const _prev2 = _promise;
        _promise = void 0;
        if (_prev2)
          await _prev2;
      };
      return wrapper;
    }
    function sleep(ms, callback) {
      return new Promise(
        (resolve4) => setTimeout(async () => {
          await (callback == null ? void 0 : callback());
          resolve4();
        }, ms)
      );
    }
    function createPromiseLock() {
      const locks = [];
      return {
        async run(fn) {
          const p2 = fn();
          locks.push(p2);
          try {
            return await p2;
          } finally {
            remove(locks, p2);
          }
        },
        async wait() {
          await Promise.allSettled(locks);
        },
        isWaiting() {
          return Boolean(locks.length);
        },
        clear() {
          locks.length = 0;
        }
      };
    }
    function createControlledPromise() {
      let resolve4, reject;
      const promise = new Promise((_resolve, _reject) => {
        resolve4 = _resolve;
        reject = _reject;
      });
      promise.resolve = resolve4;
      promise.reject = reject;
      return promise;
    }
    function slash(str) {
      return str.replace(/\\/g, "/");
    }
    function ensurePrefix(prefix, str) {
      if (!str.startsWith(prefix))
        return prefix + str;
      return str;
    }
    function ensureSuffix(suffix, str) {
      if (!str.endsWith(suffix))
        return str + suffix;
      return str;
    }
    function template(str, ...args) {
      const [firstArg, fallback] = args;
      if (isObject3(firstArg)) {
        const vars = firstArg;
        return str.replace(/\{(\w+)\}/g, (_, key) => {
          var _a3;
          return vars[key] || ((_a3 = typeof fallback === "function" ? fallback(key) : fallback) != null ? _a3 : key);
        });
      } else {
        return str.replace(/\{(\d+)\}/g, (_, key) => {
          const index = Number(key);
          if (Number.isNaN(index))
            return key;
          return args[index];
        });
      }
    }
    var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    function randomStr(size = 16, dict = urlAlphabet) {
      let id = "";
      let i = size;
      const len = dict.length;
      while (i--)
        id += dict[Math.random() * len | 0];
      return id;
    }
    function capitalize(str) {
      return str[0].toUpperCase() + str.slice(1).toLowerCase();
    }
    var _reFullWs = /^\s*$/;
    function unindent(str) {
      const lines = (typeof str === "string" ? str : str[0]).split("\n");
      const whitespaceLines = lines.map((line) => _reFullWs.test(line));
      const commonIndent = lines.reduce((min, line, idx) => {
        var _a3;
        if (whitespaceLines[idx])
          return min;
        const indent = (_a3 = line.match(/^\s*/)) == null ? void 0 : _a3[0].length;
        return indent === void 0 ? min : Math.min(min, indent);
      }, Number.POSITIVE_INFINITY);
      let emptyLinesHead = 0;
      while (emptyLinesHead < lines.length && whitespaceLines[emptyLinesHead])
        emptyLinesHead++;
      let emptyLinesTail = 0;
      while (emptyLinesTail < lines.length && whitespaceLines[lines.length - emptyLinesTail - 1])
        emptyLinesTail++;
      return lines.slice(emptyLinesHead, lines.length - emptyLinesTail).map((line) => line.slice(commonIndent)).join("\n");
    }
    var timestamp = () => +Date.now();
    function throttle2(delay, callback, options) {
      var _ref = options || {}, _ref$noTrailing = _ref.noTrailing, noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing, _ref$noLeading = _ref.noLeading, noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading, _ref$debounceMode = _ref.debounceMode, debounceMode = _ref$debounceMode === void 0 ? void 0 : _ref$debounceMode;
      var timeoutID;
      var cancelled = false;
      var lastExec = 0;
      function clearExistingTimeout() {
        if (timeoutID) {
          clearTimeout(timeoutID);
        }
      }
      function cancel(options2) {
        var _ref2 = options2 || {}, _ref2$upcomingOnly = _ref2.upcomingOnly, upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;
        clearExistingTimeout();
        cancelled = !upcomingOnly;
      }
      function wrapper() {
        for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
          arguments_[_key] = arguments[_key];
        }
        var self2 = this;
        var elapsed = Date.now() - lastExec;
        if (cancelled) {
          return;
        }
        function exec2() {
          lastExec = Date.now();
          callback.apply(self2, arguments_);
        }
        function clear() {
          timeoutID = void 0;
        }
        if (!noLeading && debounceMode && !timeoutID) {
          exec2();
        }
        clearExistingTimeout();
        if (debounceMode === void 0 && elapsed > delay) {
          if (noLeading) {
            lastExec = Date.now();
            if (!noTrailing) {
              timeoutID = setTimeout(debounceMode ? clear : exec2, delay);
            }
          } else {
            exec2();
          }
        } else if (noTrailing !== true) {
          timeoutID = setTimeout(debounceMode ? clear : exec2, debounceMode === void 0 ? delay - elapsed : delay);
        }
      }
      wrapper.cancel = cancel;
      return wrapper;
    }
    function debounce(delay, callback, options) {
      var _ref = options || {}, _ref$atBegin = _ref.atBegin, atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;
      return throttle2(delay, callback, {
        debounceMode: atBegin !== false
      });
    }
    exports.assert = assert;
    exports.at = at;
    exports.batchInvoke = batchInvoke;
    exports.capitalize = capitalize;
    exports.clamp = clamp;
    exports.clampArrayRange = clampArrayRange;
    exports.clearUndefined = clearUndefined;
    exports.createControlledPromise = createControlledPromise;
    exports.createPromiseLock = createPromiseLock;
    exports.createSingletonPromise = createSingletonPromise;
    exports.debounce = debounce;
    exports.deepMerge = deepMerge;
    exports.deepMergeWithArray = deepMergeWithArray;
    exports.ensurePrefix = ensurePrefix;
    exports.ensureSuffix = ensureSuffix;
    exports.filterInPlace = filterInPlace;
    exports.flattenArrayable = flattenArrayable;
    exports.getTypeName = getTypeName;
    exports.hasOwnProperty = hasOwnProperty;
    exports.invoke = invoke;
    exports.isBoolean = isBoolean;
    exports.isBrowser = isBrowser;
    exports.isDate = isDate;
    exports.isDeepEqual = isDeepEqual;
    exports.isDef = isDef;
    exports.isFunction = isFunction;
    exports.isKeyOf = isKeyOf;
    exports.isNull = isNull;
    exports.isNumber = isNumber;
    exports.isObject = isObject3;
    exports.isRegExp = isRegExp;
    exports.isString = isString2;
    exports.isTruthy = isTruthy;
    exports.isUndefined = isUndefined;
    exports.isWindow = isWindow;
    exports.last = last;
    exports.lerp = lerp;
    exports.mergeArrayable = mergeArrayable;
    exports.move = move;
    exports.noNull = noNull;
    exports.noop = noop2;
    exports.notNullish = notNullish2;
    exports.notUndefined = notUndefined;
    exports.objectEntries = objectEntries;
    exports.objectKeys = objectKeys;
    exports.objectMap = objectMap;
    exports.objectPick = objectPick;
    exports.p = p;
    exports.partition = partition;
    exports.randomStr = randomStr;
    exports.range = range;
    exports.remap = remap;
    exports.remove = remove;
    exports.sample = sample;
    exports.shuffle = shuffle;
    exports.slash = slash;
    exports.sleep = sleep;
    exports.sum = sum;
    exports.tap = tap;
    exports.template = template;
    exports.throttle = throttle2;
    exports.timestamp = timestamp;
    exports.toArray = toArray4;
    exports.toString = toString2;
    exports.unindent = unindent;
    exports.uniq = uniq2;
    exports.uniqueBy = uniqueBy2;
  }
});

// ../../node_modules/.pnpm/kolorist@1.8.0/node_modules/kolorist/dist/cjs/index.js
var require_cjs = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/kolorist@1.8.0/node_modules/kolorist/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.link = exports.trueColorBg = exports.trueColor = exports.ansi256Bg = exports.ansi256 = exports.bgLightGray = exports.bgLightCyan = exports.bgLightMagenta = exports.bgLightBlue = exports.bgLightYellow = exports.bgLightGreen = exports.bgLightRed = exports.bgGray = exports.bgWhite = exports.bgCyan = exports.bgMagenta = exports.bgBlue = exports.bgYellow = exports.bgGreen = exports.bgRed = exports.bgBlack = exports.lightCyan = exports.lightMagenta = exports.lightBlue = exports.lightYellow = exports.lightGreen = exports.lightRed = exports.lightGray = exports.gray = exports.white = exports.cyan = exports.magenta = exports.blue = exports.yellow = exports.green = exports.red = exports.black = exports.strikethrough = exports.hidden = exports.inverse = exports.underline = exports.italic = exports.dim = exports.bold = exports.reset = exports.stripColors = exports.options = void 0;
    var enabled = true;
    var globalVar = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
    var supportLevel = 0;
    if (globalVar.process && globalVar.process.env && globalVar.process.stdout) {
      const { FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, COLORTERM } = globalVar.process.env;
      if (NODE_DISABLE_COLORS || NO_COLOR || FORCE_COLOR === "0") {
        enabled = false;
      } else if (FORCE_COLOR === "1" || FORCE_COLOR === "2" || FORCE_COLOR === "3") {
        enabled = true;
      } else if (TERM === "dumb") {
        enabled = false;
      } else if ("CI" in globalVar.process.env && [
        "TRAVIS",
        "CIRCLECI",
        "APPVEYOR",
        "GITLAB_CI",
        "GITHUB_ACTIONS",
        "BUILDKITE",
        "DRONE"
      ].some((vendor) => vendor in globalVar.process.env)) {
        enabled = true;
      } else {
        enabled = process.stdout.isTTY;
      }
      if (enabled) {
        if (process.platform === "win32") {
          supportLevel = 3;
        } else {
          if (COLORTERM && (COLORTERM === "truecolor" || COLORTERM === "24bit")) {
            supportLevel = 3;
          } else if (TERM && (TERM.endsWith("-256color") || TERM.endsWith("256"))) {
            supportLevel = 2;
          } else {
            supportLevel = 1;
          }
        }
      }
    }
    exports.options = {
      enabled,
      supportLevel
    };
    function kolorist(start, end, level = 1) {
      const open = `\x1B[${start}m`;
      const close = `\x1B[${end}m`;
      const regex = new RegExp(`\\x1b\\[${end}m`, "g");
      return (str) => {
        return exports.options.enabled && exports.options.supportLevel >= level ? open + ("" + str).replace(regex, open) + close : "" + str;
      };
    }
    function rgbToAnsi256(r, g, b) {
      if (r >> 4 === g >> 4 && g >> 4 === b >> 4) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    }
    function stripColors(str) {
      return ("" + str).replace(/\x1b\[[0-9;]+m/g, "").replace(/\x1b\]8;;.*?\x07(.*?)\x1b\]8;;\x07/g, (_, group) => group);
    }
    exports.stripColors = stripColors;
    exports.reset = kolorist(0, 0);
    exports.bold = kolorist(1, 22);
    exports.dim = kolorist(2, 22);
    exports.italic = kolorist(3, 23);
    exports.underline = kolorist(4, 24);
    exports.inverse = kolorist(7, 27);
    exports.hidden = kolorist(8, 28);
    exports.strikethrough = kolorist(9, 29);
    exports.black = kolorist(30, 39);
    exports.red = kolorist(31, 39);
    exports.green = kolorist(32, 39);
    exports.yellow = kolorist(33, 39);
    exports.blue = kolorist(34, 39);
    exports.magenta = kolorist(35, 39);
    exports.cyan = kolorist(36, 39);
    exports.white = kolorist(97, 39);
    exports.gray = kolorist(90, 39);
    exports.lightGray = kolorist(37, 39);
    exports.lightRed = kolorist(91, 39);
    exports.lightGreen = kolorist(92, 39);
    exports.lightYellow = kolorist(93, 39);
    exports.lightBlue = kolorist(94, 39);
    exports.lightMagenta = kolorist(95, 39);
    exports.lightCyan = kolorist(96, 39);
    exports.bgBlack = kolorist(40, 49);
    exports.bgRed = kolorist(41, 49);
    exports.bgGreen = kolorist(42, 49);
    exports.bgYellow = kolorist(43, 49);
    exports.bgBlue = kolorist(44, 49);
    exports.bgMagenta = kolorist(45, 49);
    exports.bgCyan = kolorist(46, 49);
    exports.bgWhite = kolorist(107, 49);
    exports.bgGray = kolorist(100, 49);
    exports.bgLightRed = kolorist(101, 49);
    exports.bgLightGreen = kolorist(102, 49);
    exports.bgLightYellow = kolorist(103, 49);
    exports.bgLightBlue = kolorist(104, 49);
    exports.bgLightMagenta = kolorist(105, 49);
    exports.bgLightCyan = kolorist(106, 49);
    exports.bgLightGray = kolorist(47, 49);
    var ansi256 = (n2) => kolorist(
      "38;5;" + n2,
      0,
      2
      /* ansi256 */
    );
    exports.ansi256 = ansi256;
    var ansi256Bg = (n2) => kolorist(
      "48;5;" + n2,
      0,
      2
      /* ansi256 */
    );
    exports.ansi256Bg = ansi256Bg;
    var trueColor = (r, g, b) => {
      return exports.options.supportLevel === 2 ? exports.ansi256(rgbToAnsi256(r, g, b)) : kolorist(
        `38;2;${r};${g};${b}`,
        0,
        3
        /* trueColor */
      );
    };
    exports.trueColor = trueColor;
    var trueColorBg = (r, g, b) => {
      return exports.options.supportLevel === 2 ? exports.ansi256Bg(rgbToAnsi256(r, g, b)) : kolorist(
        `48;2;${r};${g};${b}`,
        0,
        3
        /* trueColor */
      );
    };
    exports.trueColorBg = trueColorBg;
    var OSC = "\x1B]";
    var BEL = "\x07";
    var SEP = ";";
    function link(text, url) {
      return exports.options.enabled ? OSC + "8" + SEP + SEP + url + BEL + text + OSC + "8" + SEP + SEP + BEL : `${text} (\u200B${url}\u200B)`;
    }
    exports.link = link;
  }
});

// ../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/loader/warn.cjs
var require_warn = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/loader/warn.cjs"(exports) {
    "use strict";
    var kolorist = require_cjs();
    var warned4 = /* @__PURE__ */ new Set();
    function warnOnce2(msg) {
      if (!warned4.has(msg)) {
        warned4.add(msg);
        console.warn(kolorist.yellow(`[@iconify-loader] ${msg}`));
      }
    }
    exports.warnOnce = warnOnce2;
  }
});

// ../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/loader/install-pkg.cjs
var require_install_pkg = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/loader/install-pkg.cjs"(exports) {
    "use strict";
    var installPkg = require_dist7();
    var utils = require_dist8();
    var kolorist = require_cjs();
    var loader_warn = require_warn();
    var pending;
    var tasks = {};
    async function tryInstallPkg(name2, autoInstall) {
      if (pending) {
        await pending;
      }
      if (!tasks[name2]) {
        console.log(kolorist.cyan(`Installing ${name2}...`));
        if (typeof autoInstall === "function") {
          tasks[name2] = pending = autoInstall(name2).then(() => utils.sleep(300)).finally(() => {
            pending = void 0;
          });
        } else {
          tasks[name2] = pending = installPkg.installPackage(name2, {
            dev: true,
            preferOffline: true
          }).then(() => utils.sleep(300)).catch((e2) => {
            loader_warn.warnOnce(`Failed to install ${name2}`);
            console.error(e2);
          }).finally(() => {
            pending = void 0;
          });
        }
      }
      return tasks[name2];
    }
    exports.tryInstallPkg = tryInstallPkg;
  }
});

// ../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/loader/fs.cjs
var require_fs2 = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/loader/fs.cjs"(exports) {
    "use strict";
    var fs5 = _chunk42PBKAQTcjs.__require.call(void 0, "fs");
    var localPkg = require_dist6();
    var loader_installPkg = require_install_pkg();
    var mlly = require_dist5();
    require_dist7();
    require_dist8();
    require_cjs();
    require_warn();
    var _collections = /* @__PURE__ */ Object.create(null);
    var isLegacyExists = /* @__PURE__ */ Object.create(null);
    async function loadCollectionFromFS(name2, autoInstall = false, scope = "@iconify-json", cwd = process.cwd()) {
      const cache2 = _collections[cwd] || (_collections[cwd] = /* @__PURE__ */ Object.create(null));
      if (!await cache2[name2]) {
        cache2[name2] = task();
      }
      return cache2[name2];
      async function task() {
        const packageName = scope.length === 0 ? name2 : `${scope}/${name2}`;
        let jsonPath = await mlly.resolvePath(`${packageName}/icons.json`, {
          url: cwd
        }).catch(() => void 0);
        if (scope === "@iconify-json") {
          if (isLegacyExists[cwd] === void 0) {
            const testResult = await mlly.resolvePath(
              `@iconify/json/collections.json`,
              {
                url: cwd
              }
            ).catch(() => void 0);
            isLegacyExists[cwd] = !!testResult;
          }
          const checkLegacy = isLegacyExists[cwd];
          if (!jsonPath && checkLegacy) {
            jsonPath = await mlly.resolvePath(
              `@iconify/json/json/${name2}.json`,
              {
                url: cwd
              }
            ).catch(() => void 0);
          }
          if (!jsonPath && !checkLegacy && autoInstall) {
            await loader_installPkg.tryInstallPkg(packageName, autoInstall);
            jsonPath = await mlly.resolvePath(`${packageName}/icons.json`, {
              url: cwd
            }).catch(() => void 0);
          }
        } else if (!jsonPath && autoInstall) {
          await loader_installPkg.tryInstallPkg(packageName, autoInstall);
          jsonPath = await mlly.resolvePath(`${packageName}/icons.json`, {
            url: cwd
          }).catch(() => void 0);
        }
        if (!jsonPath) {
          let packagePath = await mlly.resolvePath(packageName, {
            url: cwd
          }).catch(() => void 0);
          if (packagePath == null ? void 0 : packagePath.match(/^[a-z]:/i)) {
            packagePath = `file:///${packagePath}`.replace(/\\/g, "/");
          }
          if (packagePath) {
            const { icons } = await localPkg.importModule(
              packagePath
            );
            if (icons)
              return icons;
          }
        }
        let stat;
        try {
          stat = jsonPath ? await fs5.promises.lstat(jsonPath) : void 0;
        } catch (err) {
          return void 0;
        }
        if (stat == null ? void 0 : stat.isFile()) {
          return JSON.parse(
            await fs5.promises.readFile(jsonPath, "utf8")
          );
        } else {
          return void 0;
        }
      }
    }
    exports.loadCollectionFromFS = loadCollectionFromFS;
  }
});

// ../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/svg/trim.cjs
var require_trim = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/svg/trim.cjs"(exports) {
    "use strict";
    function trimSVG(str) {
      return str.replace(/(['"])\s*\n\s*([^>\\/\s])/g, "$1 $2").replace(/(["';{}><])\s*\n\s*/g, "$1").replace(/\s*\n\s*/g, " ").replace(/\s+"/g, '"').replace(/="\s+/g, '="').replace(/(\s)+\/>/g, "/>").trim();
    }
    exports.trimSVG = trimSVG;
  }
});

// ../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/loader/custom.cjs
var require_custom = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/loader/custom.cjs"(exports) {
    "use strict";
    var createDebugger = _chunkTR37ZOITcjs.require_src.call(void 0, );
    var loader_utils = require_utils4();
    var svg_trim = require_trim();
    require_build();
    require_defaults();
    require_defaults2();
    require_size();
    require_defs();
    function _interopDefaultCompat(e2) {
      return e2 && typeof e2 === "object" && "default" in e2 ? e2.default : e2;
    }
    var createDebugger__default = /* @__PURE__ */ _interopDefaultCompat(createDebugger);
    var debug = createDebugger__default("@iconify-loader:custom");
    async function getCustomIcon(custom5, collection, icon, options) {
      var _a3, _b2;
      let result;
      debug(`${collection}:${icon}`);
      try {
        if (typeof custom5 === "function") {
          result = await custom5(icon);
        } else {
          const inline = custom5[icon];
          result = typeof inline === "function" ? await inline() : inline;
        }
      } catch (err) {
        console.warn(
          `Failed to load custom icon "${icon}" in "${collection}":`,
          err
        );
        return;
      }
      if (result) {
        const cleanupIdx = result.indexOf("<svg");
        if (cleanupIdx > 0)
          result = result.slice(cleanupIdx);
        const { transform: transform3 } = (_a3 = options == null ? void 0 : options.customizations) != null ? _a3 : {};
        result = typeof transform3 === "function" ? await transform3(result, collection, icon) : result;
        if (!result.startsWith("<svg")) {
          console.warn(
            `Custom icon "${icon}" in "${collection}" is not a valid SVG`
          );
          return result;
        }
        return await loader_utils.mergeIconProps(
          ((_b2 = options == null ? void 0 : options.customizations) == null ? void 0 : _b2.trimCustomSvg) === true ? svg_trim.trimSVG(result) : result,
          collection,
          icon,
          options,
          void 0
        );
      }
    }
    exports.getCustomIcon = getCustomIcon;
  }
});

// ../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/loader/loader.cjs
var require_loader = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/loader/loader.cjs"(exports) {
    "use strict";
    var loader_custom = require_custom();
    var loader_modern = require_modern();
    _chunkTR37ZOITcjs.require_src.call(void 0, );
    require_utils4();
    require_build();
    require_defaults();
    require_defaults2();
    require_size();
    require_defs();
    require_trim();
    require_get_icon();
    require_merge();
    require_transformations();
    require_tree();
    var loadIcon2 = async (collection, icon, options) => {
      var _a3;
      const custom5 = (_a3 = options == null ? void 0 : options.customCollections) == null ? void 0 : _a3[collection];
      if (custom5) {
        if (typeof custom5 === "function") {
          let result;
          try {
            result = await custom5(icon);
          } catch (err) {
            console.warn(
              `Failed to load custom icon "${icon}" in "${collection}":`,
              err
            );
            return;
          }
          if (result) {
            if (typeof result === "string") {
              return await loader_custom.getCustomIcon(
                () => result,
                collection,
                icon,
                options
              );
            }
            if ("icons" in result) {
              const ids = [
                icon,
                icon.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
                icon.replace(/([a-z])(\d+)/g, "$1-$2")
              ];
              return await loader_modern.searchForIcon(
                result,
                collection,
                ids,
                options
              );
            }
          }
        } else {
          return await loader_custom.getCustomIcon(custom5, collection, icon, options);
        }
      }
    };
    exports.loadIcon = loadIcon2;
  }
});

// ../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/loader/node-loader.cjs
var require_node_loader = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/loader/node-loader.cjs"(exports) {
    "use strict";
    var loader_modern = require_modern();
    var loader_fs = require_fs2();
    var loader_warn = require_warn();
    var loader_loader = require_loader();
    var loader_utils = require_utils4();
    require_build();
    require_defaults();
    require_defaults2();
    require_size();
    require_defs();
    require_get_icon();
    require_merge();
    require_transformations();
    require_tree();
    _chunkTR37ZOITcjs.require_src.call(void 0, );
    _chunk42PBKAQTcjs.__require.call(void 0, "fs");
    require_dist6();
    require_install_pkg();
    require_dist7();
    require_dist8();
    require_cjs();
    require_dist5();
    require_custom();
    require_trim();
    var loadNodeIcon = async (collection, icon, options) => {
      let result = await loader_loader.loadIcon(collection, icon, options);
      if (result) {
        return result;
      }
      const cwds = Array.isArray(options == null ? void 0 : options.cwd) ? options.cwd : [options == null ? void 0 : options.cwd];
      for (let i = 0; i < cwds.length; i++) {
        const iconSet = await loader_fs.loadCollectionFromFS(
          collection,
          i === cwds.length - 1 ? options == null ? void 0 : options.autoInstall : false,
          void 0,
          cwds[i]
        );
        if (iconSet) {
          result = await loader_modern.searchForIcon(
            iconSet,
            collection,
            loader_utils.getPossibleIconNames(icon),
            options
          );
          if (result) {
            return result;
          }
        }
      }
      if (options == null ? void 0 : options.warn) {
        loader_warn.warnOnce(`failed to load ${options.warn} icon`);
      }
    };
    exports.loadNodeIcon = loadNodeIcon;
  }
});

// ../../node_modules/.pnpm/prettier@2.8.8/node_modules/prettier/parser-postcss.js
var require_parser_postcss = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/prettier@2.8.8/node_modules/prettier/parser-postcss.js"(exports, module) {
    "use strict";
    (function(e2) {
      if (typeof exports == "object" && typeof module == "object") module.exports = e2();
      else if (typeof define == "function" && define.amd) define(e2);
      else {
        var i = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
        i.prettierPlugins = i.prettierPlugins || {}, i.prettierPlugins.postcss = e2();
      }
    })(function() {
      "use strict";
      var U = (e2, n2) => () => (n2 || e2((n2 = { exports: {} }).exports, n2), n2.exports);
      var pe = U((wp, Gt) => {
        var er = function(e2) {
          return e2 && e2.Math == Math && e2;
        };
        Gt.exports = er(typeof globalThis == "object" && globalThis) || er(typeof window == "object" && window) || er(typeof self == "object" && self) || er(typeof global == "object" && global) || /* @__PURE__ */ function() {
          return this;
        }() || Function("return this")();
      });
      var be = U((_p, Ht) => {
        Ht.exports = function(e2) {
          try {
            return !!e2();
          } catch (e3) {
            return true;
          }
        };
      });
      var Oe = U((bp, Jt) => {
        var _a3 = be();
        Jt.exports = !_a3(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      });
      var Tr = U((xp, Kt) => {
        var ba = be();
        Kt.exports = !ba(function() {
          var e2 = function() {
          }.bind();
          return typeof e2 != "function" || e2.hasOwnProperty("prototype");
        });
      });
      var tr = U((Sp, Qt) => {
        var xa = Tr(), rr = Function.prototype.call;
        Qt.exports = xa ? rr.bind(rr) : function() {
          return rr.apply(rr, arguments);
        };
      });
      var en = U((Zt) => {
        "use strict";
        var Yt = {}.propertyIsEnumerable, Xt = Object.getOwnPropertyDescriptor, Sa = Xt && !Yt.call({ 1: 2 }, 1);
        Zt.f = Sa ? function(n2) {
          var i = Xt(this, n2);
          return !!i && i.enumerable;
        } : Yt;
      });
      var Er = U((Op, rn) => {
        rn.exports = function(e2, n2) {
          return { enumerable: !(e2 & 1), configurable: !(e2 & 2), writable: !(e2 & 4), value: n2 };
        };
      });
      var xe = U((Tp, sn) => {
        var tn = Tr(), nn = Function.prototype, qr = nn.call, ka = tn && nn.bind.bind(qr, qr);
        sn.exports = tn ? ka : function(e2) {
          return function() {
            return qr.apply(e2, arguments);
          };
        };
      });
      var un = U((Ep, an) => {
        var on = xe(), Oa = on({}.toString), Ta = on("".slice);
        an.exports = function(e2) {
          return Ta(Oa(e2), 8, -1);
        };
      });
      var ln = U((qp, cn) => {
        var Ea = xe(), qa = be(), Aa = un(), Ar = Object, Pa = Ea("".split);
        cn.exports = qa(function() {
          return !Ar("z").propertyIsEnumerable(0);
        }) ? function(e2) {
          return Aa(e2) == "String" ? Pa(e2, "") : Ar(e2);
        } : Ar;
      });
      var Pr = U((Ap, fn) => {
        fn.exports = function(e2) {
          return e2 == null;
        };
      });
      var Ir = U((Pp, pn) => {
        var Ia = Pr(), Ra = TypeError;
        pn.exports = function(e2) {
          if (Ia(e2)) throw Ra("Can't call method on " + e2);
          return e2;
        };
      });
      var nr = U((Ip, hn) => {
        var Ca = ln(), Na = Ir();
        hn.exports = function(e2) {
          return Ca(Na(e2));
        };
      });
      var Cr = U((Rp, dn) => {
        var Rr = typeof document == "object" && document.all, ja = typeof Rr > "u" && Rr !== void 0;
        dn.exports = { all: Rr, IS_HTMLDDA: ja };
      });
      var he = U((Cp, mn) => {
        var vn = Cr(), Ma = vn.all;
        mn.exports = vn.IS_HTMLDDA ? function(e2) {
          return typeof e2 == "function" || e2 === Ma;
        } : function(e2) {
          return typeof e2 == "function";
        };
      });
      var Me = U((Np, wn) => {
        var gn = he(), yn = Cr(), Da = yn.all;
        wn.exports = yn.IS_HTMLDDA ? function(e2) {
          return typeof e2 == "object" ? e2 !== null : gn(e2) || e2 === Da;
        } : function(e2) {
          return typeof e2 == "object" ? e2 !== null : gn(e2);
        };
      });
      var ir = U((jp, _n) => {
        var Nr = pe(), La = he(), za = function(e2) {
          return La(e2) ? e2 : void 0;
        };
        _n.exports = function(e2, n2) {
          return arguments.length < 2 ? za(Nr[e2]) : Nr[e2] && Nr[e2][n2];
        };
      });
      var xn = U((Mp, bn) => {
        var Ba = xe();
        bn.exports = Ba({}.isPrototypeOf);
      });
      var kn = U((Dp, Sn) => {
        var Fa = ir();
        Sn.exports = Fa("navigator", "userAgent") || "";
      });
      var In = U((Lp, Pn) => {
        var An = pe(), jr = kn(), On = An.process, Tn = An.Deno, En = On && On.versions || Tn && Tn.version, qn = En && En.v8, de, sr;
        qn && (de = qn.split("."), sr = de[0] > 0 && de[0] < 4 ? 1 : +(de[0] + de[1]));
        !sr && jr && (de = jr.match(/Edge\/(\d+)/), (!de || de[1] >= 74) && (de = jr.match(/Chrome\/(\d+)/), de && (sr = +de[1])));
        Pn.exports = sr;
      });
      var Mr = U((zp, Cn) => {
        var Rn = In(), Ua = be();
        Cn.exports = !!Object.getOwnPropertySymbols && !Ua(function() {
          var e2 = Symbol();
          return !String(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && Rn && Rn < 41;
        });
      });
      var Dr = U((Bp, Nn) => {
        var $a = Mr();
        Nn.exports = $a && !Symbol.sham && typeof Symbol.iterator == "symbol";
      });
      var Lr = U((Fp, jn) => {
        var Wa = ir(), Va = he(), Ga = xn(), Ha = Dr(), Ja = Object;
        jn.exports = Ha ? function(e2) {
          return typeof e2 == "symbol";
        } : function(e2) {
          var n2 = Wa("Symbol");
          return Va(n2) && Ga(n2.prototype, Ja(e2));
        };
      });
      var Dn = U((Up, Mn) => {
        var Ka = String;
        Mn.exports = function(e2) {
          try {
            return Ka(e2);
          } catch (e3) {
            return "Object";
          }
        };
      });
      var zn = U(($p, Ln) => {
        var Qa = he(), Ya = Dn(), Xa = TypeError;
        Ln.exports = function(e2) {
          if (Qa(e2)) return e2;
          throw Xa(Ya(e2) + " is not a function");
        };
      });
      var Fn = U((Wp, Bn) => {
        var Za = zn(), eu = Pr();
        Bn.exports = function(e2, n2) {
          var i = e2[n2];
          return eu(i) ? void 0 : Za(i);
        };
      });
      var $n = U((Vp, Un) => {
        var zr = tr(), Br = he(), Fr = Me(), ru = TypeError;
        Un.exports = function(e2, n2) {
          var i, u;
          if (n2 === "string" && Br(i = e2.toString) && !Fr(u = zr(i, e2)) || Br(i = e2.valueOf) && !Fr(u = zr(i, e2)) || n2 !== "string" && Br(i = e2.toString) && !Fr(u = zr(i, e2))) return u;
          throw ru("Can't convert object to primitive value");
        };
      });
      var Vn = U((Gp, Wn) => {
        Wn.exports = false;
      });
      var or = U((Hp, Hn) => {
        var Gn = pe(), tu = Object.defineProperty;
        Hn.exports = function(e2, n2) {
          try {
            tu(Gn, e2, { value: n2, configurable: true, writable: true });
          } catch (e3) {
            Gn[e2] = n2;
          }
          return n2;
        };
      });
      var ar = U((Jp, Kn) => {
        var nu = pe(), iu = or(), Jn = "__core-js_shared__", su = nu[Jn] || iu(Jn, {});
        Kn.exports = su;
      });
      var Ur = U((Kp, Yn) => {
        var ou = Vn(), Qn = ar();
        (Yn.exports = function(e2, n2) {
          return Qn[e2] || (Qn[e2] = n2 !== void 0 ? n2 : {});
        })("versions", []).push({ version: "3.26.1", mode: ou ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" });
      });
      var Zn = U((Qp, Xn) => {
        var au = Ir(), uu = Object;
        Xn.exports = function(e2) {
          return uu(au(e2));
        };
      });
      var Te = U((Yp, ei) => {
        var cu = xe(), lu = Zn(), fu = cu({}.hasOwnProperty);
        ei.exports = Object.hasOwn || function(n2, i) {
          return fu(lu(n2), i);
        };
      });
      var $r = U((Xp, ri) => {
        var pu = xe(), hu = 0, du = Math.random(), vu = pu(1 .toString);
        ri.exports = function(e2) {
          return "Symbol(" + (e2 === void 0 ? "" : e2) + ")_" + vu(++hu + du, 36);
        };
      });
      var ai = U((Zp, oi) => {
        var mu = pe(), gu = Ur(), ti = Te(), yu = $r(), ni = Mr(), si = Dr(), De = gu("wks"), Ee = mu.Symbol, ii = Ee && Ee.for, wu = si ? Ee : Ee && Ee.withoutSetter || yu;
        oi.exports = function(e2) {
          if (!ti(De, e2) || !(ni || typeof De[e2] == "string")) {
            var n2 = "Symbol." + e2;
            ni && ti(Ee, e2) ? De[e2] = Ee[e2] : si && ii ? De[e2] = ii(n2) : De[e2] = wu(n2);
          }
          return De[e2];
        };
      });
      var fi = U((eh, li) => {
        var _u = tr(), ui = Me(), ci = Lr(), bu = Fn(), xu = $n(), Su = ai(), ku = TypeError, Ou = Su("toPrimitive");
        li.exports = function(e2, n2) {
          if (!ui(e2) || ci(e2)) return e2;
          var i = bu(e2, Ou), u;
          if (i) {
            if (n2 === void 0 && (n2 = "default"), u = _u(i, e2, n2), !ui(u) || ci(u)) return u;
            throw ku("Can't convert object to primitive value");
          }
          return n2 === void 0 && (n2 = "number"), xu(e2, n2);
        };
      });
      var Wr = U((rh, pi) => {
        var Tu = fi(), Eu = Lr();
        pi.exports = function(e2) {
          var n2 = Tu(e2, "string");
          return Eu(n2) ? n2 : n2 + "";
        };
      });
      var vi = U((th, di) => {
        var qu = pe(), hi = Me(), Vr = qu.document, Au = hi(Vr) && hi(Vr.createElement);
        di.exports = function(e2) {
          return Au ? Vr.createElement(e2) : {};
        };
      });
      var Gr = U((nh, mi) => {
        var Pu = Oe(), Iu = be(), Ru = vi();
        mi.exports = !Pu && !Iu(function() {
          return Object.defineProperty(Ru("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      });
      var Hr = U((yi) => {
        var Cu = Oe(), Nu = tr(), ju = en(), Mu = Er(), Du = nr(), Lu = Wr(), zu = Te(), Bu = Gr(), gi = Object.getOwnPropertyDescriptor;
        yi.f = Cu ? gi : function(n2, i) {
          if (n2 = Du(n2), i = Lu(i), Bu) try {
            return gi(n2, i);
          } catch (e2) {
          }
          if (zu(n2, i)) return Mu(!Nu(ju.f, n2, i), n2[i]);
        };
      });
      var _i = U((sh, wi) => {
        var Fu = Oe(), Uu = be();
        wi.exports = Fu && Uu(function() {
          return Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype != 42;
        });
      });
      var Jr = U((oh, bi) => {
        var $u = Me(), Wu = String, Vu = TypeError;
        bi.exports = function(e2) {
          if ($u(e2)) return e2;
          throw Vu(Wu(e2) + " is not an object");
        };
      });
      var cr = U((Si) => {
        var Gu = Oe(), Hu = Gr(), Ju = _i(), ur = Jr(), xi = Wr(), Ku = TypeError, Kr = Object.defineProperty, Qu = Object.getOwnPropertyDescriptor, Qr = "enumerable", Yr = "configurable", Xr = "writable";
        Si.f = Gu ? Ju ? function(n2, i, u) {
          if (ur(n2), i = xi(i), ur(u), typeof n2 == "function" && i === "prototype" && "value" in u && Xr in u && !u[Xr]) {
            var o = Qu(n2, i);
            o && o[Xr] && (n2[i] = u.value, u = { configurable: Yr in u ? u[Yr] : o[Yr], enumerable: Qr in u ? u[Qr] : o[Qr], writable: false });
          }
          return Kr(n2, i, u);
        } : Kr : function(n2, i, u) {
          if (ur(n2), i = xi(i), ur(u), Hu) try {
            return Kr(n2, i, u);
          } catch (e2) {
          }
          if ("get" in u || "set" in u) throw Ku("Accessors not supported");
          return "value" in u && (n2[i] = u.value), n2;
        };
      });
      var Zr = U((uh, ki) => {
        var Yu = Oe(), Xu = cr(), Zu = Er();
        ki.exports = Yu ? function(e2, n2, i) {
          return Xu.f(e2, n2, Zu(1, i));
        } : function(e2, n2, i) {
          return e2[n2] = i, e2;
        };
      });
      var Ei = U((ch, Ti) => {
        var et = Oe(), ec = Te(), Oi = Function.prototype, rc = et && Object.getOwnPropertyDescriptor, rt = ec(Oi, "name"), tc = rt && function() {
        }.name === "something", nc = rt && (!et || et && rc(Oi, "name").configurable);
        Ti.exports = { EXISTS: rt, PROPER: tc, CONFIGURABLE: nc };
      });
      var Ai = U((lh, qi) => {
        var ic = xe(), sc = he(), tt = ar(), oc = ic(Function.toString);
        sc(tt.inspectSource) || (tt.inspectSource = function(e2) {
          return oc(e2);
        });
        qi.exports = tt.inspectSource;
      });
      var Ri = U((fh, Ii) => {
        var ac = pe(), uc = he(), Pi = ac.WeakMap;
        Ii.exports = uc(Pi) && /native code/.test(String(Pi));
      });
      var ji = U((ph, Ni) => {
        var cc = Ur(), lc = $r(), Ci = cc("keys");
        Ni.exports = function(e2) {
          return Ci[e2] || (Ci[e2] = lc(e2));
        };
      });
      var nt = U((hh, Mi) => {
        Mi.exports = {};
      });
      var Bi = U((dh, zi) => {
        var fc = Ri(), Li = pe(), pc = Me(), hc = Zr(), it = Te(), st = ar(), dc = ji(), vc = nt(), Di = "Object already initialized", ot = Li.TypeError, mc = Li.WeakMap, lr, Fe, fr, gc = function(e2) {
          return fr(e2) ? Fe(e2) : lr(e2, {});
        }, yc = function(e2) {
          return function(n2) {
            var i;
            if (!pc(n2) || (i = Fe(n2)).type !== e2) throw ot("Incompatible receiver, " + e2 + " required");
            return i;
          };
        };
        fc || st.state ? (ve = st.state || (st.state = new mc()), ve.get = ve.get, ve.has = ve.has, ve.set = ve.set, lr = function(e2, n2) {
          if (ve.has(e2)) throw ot(Di);
          return n2.facade = e2, ve.set(e2, n2), n2;
        }, Fe = function(e2) {
          return ve.get(e2) || {};
        }, fr = function(e2) {
          return ve.has(e2);
        }) : (qe = dc("state"), vc[qe] = true, lr = function(e2, n2) {
          if (it(e2, qe)) throw ot(Di);
          return n2.facade = e2, hc(e2, qe, n2), n2;
        }, Fe = function(e2) {
          return it(e2, qe) ? e2[qe] : {};
        }, fr = function(e2) {
          return it(e2, qe);
        });
        var ve, qe;
        zi.exports = { set: lr, get: Fe, has: fr, enforce: gc, getterFor: yc };
      });
      var $i = U((vh, Ui) => {
        var wc = be(), _c = he(), pr = Te(), at = Oe(), bc = Ei().CONFIGURABLE, xc = Ai(), Fi = Bi(), Sc = Fi.enforce, kc = Fi.get, hr = Object.defineProperty, Oc = at && !wc(function() {
          return hr(function() {
          }, "length", { value: 8 }).length !== 8;
        }), Tc = String(String).split("String"), Ec = Ui.exports = function(e2, n2, i) {
          String(n2).slice(0, 7) === "Symbol(" && (n2 = "[" + String(n2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), i && i.getter && (n2 = "get " + n2), i && i.setter && (n2 = "set " + n2), (!pr(e2, "name") || bc && e2.name !== n2) && (at ? hr(e2, "name", { value: n2, configurable: true }) : e2.name = n2), Oc && i && pr(i, "arity") && e2.length !== i.arity && hr(e2, "length", { value: i.arity });
          try {
            i && pr(i, "constructor") && i.constructor ? at && hr(e2, "prototype", { writable: false }) : e2.prototype && (e2.prototype = void 0);
          } catch (e3) {
          }
          var u = Sc(e2);
          return pr(u, "source") || (u.source = Tc.join(typeof n2 == "string" ? n2 : "")), e2;
        };
        Function.prototype.toString = Ec(function() {
          return _c(this) && kc(this).source || xc(this);
        }, "toString");
      });
      var Vi = U((mh, Wi) => {
        var qc = he(), Ac = cr(), Pc = $i(), Ic = or();
        Wi.exports = function(e2, n2, i, u) {
          u || (u = {});
          var o = u.enumerable, h3 = u.name !== void 0 ? u.name : n2;
          if (qc(i) && Pc(i, h3, u), u.global) o ? e2[n2] = i : Ic(n2, i);
          else {
            try {
              u.unsafe ? e2[n2] && (o = true) : delete e2[n2];
            } catch (e3) {
            }
            o ? e2[n2] = i : Ac.f(e2, n2, { value: i, enumerable: false, configurable: !u.nonConfigurable, writable: !u.nonWritable });
          }
          return e2;
        };
      });
      var Hi = U((gh, Gi) => {
        var Rc = Math.ceil, Cc = Math.floor;
        Gi.exports = Math.trunc || function(n2) {
          var i = +n2;
          return (i > 0 ? Cc : Rc)(i);
        };
      });
      var ut = U((yh, Ji) => {
        var Nc = Hi();
        Ji.exports = function(e2) {
          var n2 = +e2;
          return n2 !== n2 || n2 === 0 ? 0 : Nc(n2);
        };
      });
      var Qi = U((wh, Ki) => {
        var jc = ut(), Mc = Math.max, Dc = Math.min;
        Ki.exports = function(e2, n2) {
          var i = jc(e2);
          return i < 0 ? Mc(i + n2, 0) : Dc(i, n2);
        };
      });
      var Xi = U((_h, Yi) => {
        var Lc = ut(), zc = Math.min;
        Yi.exports = function(e2) {
          return e2 > 0 ? zc(Lc(e2), 9007199254740991) : 0;
        };
      });
      var es = U((bh, Zi) => {
        var Bc = Xi();
        Zi.exports = function(e2) {
          return Bc(e2.length);
        };
      });
      var ns = U((xh, ts) => {
        var Fc = nr(), Uc = Qi(), $c = es(), rs = function(e2) {
          return function(n2, i, u) {
            var o = Fc(n2), h3 = $c(o), l = Uc(u, h3), p;
            if (e2 && i != i) {
              for (; h3 > l; ) if (p = o[l++], p != p) return true;
            } else for (; h3 > l; l++) if ((e2 || l in o) && o[l] === i) return e2 || l || 0;
            return !e2 && -1;
          };
        };
        ts.exports = { includes: rs(true), indexOf: rs(false) };
      });
      var os = U((Sh, ss) => {
        var Wc = xe(), ct = Te(), Vc = nr(), Gc = ns().indexOf, Hc = nt(), is = Wc([].push);
        ss.exports = function(e2, n2) {
          var i = Vc(e2), u = 0, o = [], h3;
          for (h3 in i) !ct(Hc, h3) && ct(i, h3) && is(o, h3);
          for (; n2.length > u; ) ct(i, h3 = n2[u++]) && (~Gc(o, h3) || is(o, h3));
          return o;
        };
      });
      var us = U((kh, as) => {
        as.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      });
      var ls = U((cs) => {
        var Jc = os(), Kc = us(), Qc = Kc.concat("length", "prototype");
        cs.f = Object.getOwnPropertyNames || function(n2) {
          return Jc(n2, Qc);
        };
      });
      var ps = U((fs5) => {
        fs5.f = Object.getOwnPropertySymbols;
      });
      var ds = U((Eh, hs) => {
        var Yc = ir(), Xc = xe(), Zc = ls(), el = ps(), rl = Jr(), tl = Xc([].concat);
        hs.exports = Yc("Reflect", "ownKeys") || function(n2) {
          var i = Zc.f(rl(n2)), u = el.f;
          return u ? tl(i, u(n2)) : i;
        };
      });
      var gs = U((qh, ms) => {
        var vs = Te(), nl = ds(), il = Hr(), sl = cr();
        ms.exports = function(e2, n2, i) {
          for (var u = nl(n2), o = sl.f, h3 = il.f, l = 0; l < u.length; l++) {
            var p = u[l];
            !vs(e2, p) && !(i && vs(i, p)) && o(e2, p, h3(n2, p));
          }
        };
      });
      var ws = U((Ah, ys) => {
        var ol = be(), al = he(), ul = /#|\.prototype\./, Ue = function(e2, n2) {
          var i = ll[cl(e2)];
          return i == pl ? true : i == fl ? false : al(n2) ? ol(n2) : !!n2;
        }, cl = Ue.normalize = function(e2) {
          return String(e2).replace(ul, ".").toLowerCase();
        }, ll = Ue.data = {}, fl = Ue.NATIVE = "N", pl = Ue.POLYFILL = "P";
        ys.exports = Ue;
      });
      var bs = U((Ph, _s) => {
        var lt = pe(), hl = Hr().f, dl = Zr(), vl = Vi(), ml = or(), gl = gs(), yl = ws();
        _s.exports = function(e2, n2) {
          var i = e2.target, u = e2.global, o = e2.stat, h3, l, p, m, c, t;
          if (u ? l = lt : o ? l = lt[i] || ml(i, {}) : l = (lt[i] || {}).prototype, l) for (p in n2) {
            if (c = n2[p], e2.dontCallGetSet ? (t = hl(l, p), m = t && t.value) : m = l[p], h3 = yl(u ? p : i + (o ? "." : "#") + p, e2.forced), !h3 && m !== void 0) {
              if (typeof c == typeof m) continue;
              gl(c, m);
            }
            (e2.sham || m && m.sham) && dl(c, "sham", true), vl(l, p, c, e2);
          }
        };
      });
      var xs = U(() => {
        var wl = bs(), ft = pe();
        wl({ global: true, forced: ft.globalThis !== ft }, { globalThis: ft });
      });
      var Ss = U(() => {
        xs();
      });
      var gp = U((Fh, wa) => {
        Ss();
        var Et = Object.defineProperty, _l = Object.getOwnPropertyDescriptor, qt = Object.getOwnPropertyNames, bl = Object.prototype.hasOwnProperty, Le = (e2, n2) => function() {
          return e2 && (n2 = (0, e2[qt(e2)[0]])(e2 = 0)), n2;
        }, P = (e2, n2) => function() {
          return n2 || (0, e2[qt(e2)[0]])((n2 = { exports: {} }).exports, n2), n2.exports;
        }, At = (e2, n2) => {
          for (var i in n2) Et(e2, i, { get: n2[i], enumerable: true });
        }, xl = (e2, n2, i, u) => {
          if (n2 && typeof n2 == "object" || typeof n2 == "function") for (let o of qt(n2)) !bl.call(e2, o) && o !== i && Et(e2, o, { get: () => n2[o], enumerable: !(u = _l(n2, o)) || u.enumerable });
          return e2;
        }, Pt = (e2) => xl(Et({}, "__esModule", { value: true }), e2), A = Le({ "<define:process>"() {
        } }), Sl = P({ "src/common/parser-create-error.js"(e2, n2) {
          "use strict";
          A();
          function i(u, o) {
            let h3 = new SyntaxError(u + " (" + o.start.line + ":" + o.start.column + ")");
            return h3.loc = o, h3;
          }
          n2.exports = i;
        } }), Us = P({ "src/utils/get-last.js"(e2, n2) {
          "use strict";
          A();
          var i = (u) => u[u.length - 1];
          n2.exports = i;
        } }), $s = P({ "src/utils/front-matter/parse.js"(e2, n2) {
          "use strict";
          A();
          var i = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
          function u(o) {
            let h3 = o.match(i);
            if (!h3) return { content: o };
            let { startDelimiter: l, language: p, value: m = "", endDelimiter: c } = h3.groups, t = p.trim() || "yaml";
            if (l === "+++" && (t = "toml"), t !== "yaml" && l !== c) return { content: o };
            let [r] = h3;
            return { frontMatter: { type: "front-matter", lang: t, value: m, startDelimiter: l, endDelimiter: c, raw: r.replace(/\n$/, "") }, content: r.replace(/[^\n]/g, " ") + o.slice(r.length) };
          }
          n2.exports = u;
        } }), Ws = {};
        At(Ws, { EOL: () => bt, arch: () => kl, cpus: () => Ys, default: () => to, endianness: () => Vs, freemem: () => Ks, getNetworkInterfaces: () => ro, hostname: () => Gs, loadavg: () => Hs, networkInterfaces: () => eo, platform: () => Ol, release: () => Zs, tmpDir: () => wt, tmpdir: () => _t, totalmem: () => Qs, type: () => Xs, uptime: () => Js });
        function Vs() {
          if (typeof dr > "u") {
            var e2 = new ArrayBuffer(2), n2 = new Uint8Array(e2), i = new Uint16Array(e2);
            if (n2[0] = 1, n2[1] = 2, i[0] === 258) dr = "BE";
            else if (i[0] === 513) dr = "LE";
            else throw new Error("unable to figure out endianess");
          }
          return dr;
        }
        function Gs() {
          return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
        }
        function Hs() {
          return [];
        }
        function Js() {
          return 0;
        }
        function Ks() {
          return Number.MAX_VALUE;
        }
        function Qs() {
          return Number.MAX_VALUE;
        }
        function Ys() {
          return [];
        }
        function Xs() {
          return "Browser";
        }
        function Zs() {
          return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
        }
        function eo() {
        }
        function ro() {
        }
        function kl() {
          return "javascript";
        }
        function Ol() {
          return "browser";
        }
        function wt() {
          return "/tmp";
        }
        var dr, _t, bt, to, Tl = Le({ "node-modules-polyfills:os"() {
          A(), _t = wt, bt = `
`, to = { EOL: bt, tmpdir: _t, tmpDir: wt, networkInterfaces: eo, getNetworkInterfaces: ro, release: Zs, type: Xs, cpus: Ys, totalmem: Qs, freemem: Ks, uptime: Js, loadavg: Hs, hostname: Gs, endianness: Vs };
        } }), El = P({ "node-modules-polyfills-commonjs:os"(e2, n2) {
          A();
          var i = (Tl(), Pt(Ws));
          if (i && i.default) {
            n2.exports = i.default;
            for (let u in i) n2.exports[u] = i[u];
          } else i && (n2.exports = i);
        } }), ql = P({ "node_modules/detect-newline/index.js"(e2, n2) {
          "use strict";
          A();
          var i = (u) => {
            if (typeof u != "string") throw new TypeError("Expected a string");
            let o = u.match(/(?:\r?\n)/g) || [];
            if (o.length === 0) return;
            let h3 = o.filter((p) => p === `\r
`).length, l = o.length - h3;
            return h3 > l ? `\r
` : `
`;
          };
          n2.exports = i, n2.exports.graceful = (u) => typeof u == "string" && i(u) || `
`;
        } }), Al = P({ "node_modules/jest-docblock/build/index.js"(e2) {
          "use strict";
          A(), Object.defineProperty(e2, "__esModule", { value: true }), e2.extract = s, e2.parse = g, e2.parseWithComments = v, e2.print = y, e2.strip = f;
          function n2() {
            let d = El();
            return n2 = function() {
              return d;
            }, d;
          }
          function i() {
            let d = u(ql());
            return i = function() {
              return d;
            }, d;
          }
          function u(d) {
            return d && d.__esModule ? d : { default: d };
          }
          var o = /\*\/$/, h3 = /^\/\*\*?/, l = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, p = /(^|\s+)\/\/([^\r\n]*)/g, m = /^(\r?\n)+/, c = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, t = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, r = /(\r?\n|^) *\* ?/g, a = [];
          function s(d) {
            let _ = d.match(l);
            return _ ? _[0].trimLeft() : "";
          }
          function f(d) {
            let _ = d.match(l);
            return _ && _[0] ? d.substring(_[0].length) : d;
          }
          function g(d) {
            return v(d).pragmas;
          }
          function v(d) {
            let _ = (0, i().default)(d) || n2().EOL;
            d = d.replace(h3, "").replace(o, "").replace(r, "$1");
            let k = "";
            for (; k !== d; ) k = d, d = d.replace(c, `${_}$1 $2${_}`);
            d = d.replace(m, "").trimRight();
            let x2 = /* @__PURE__ */ Object.create(null), N = d.replace(t, "").replace(m, "").trimRight(), I;
            for (; I = t.exec(d); ) {
              let W = I[2].replace(p, "");
              typeof x2[I[1]] == "string" || Array.isArray(x2[I[1]]) ? x2[I[1]] = a.concat(x2[I[1]], W) : x2[I[1]] = W;
            }
            return { comments: N, pragmas: x2 };
          }
          function y(d) {
            let { comments: _ = "", pragmas: k = {} } = d, x2 = (0, i().default)(_) || n2().EOL, N = "/**", I = " *", W = " */", $ = Object.keys(k), H = $.map((V) => w(V, k[V])).reduce((V, B) => V.concat(B), []).map((V) => `${I} ${V}${x2}`).join("");
            if (!_) {
              if ($.length === 0) return "";
              if ($.length === 1 && !Array.isArray(k[$[0]])) {
                let V = k[$[0]];
                return `${N} ${w($[0], V)[0]}${W}`;
              }
            }
            let D = _.split(x2).map((V) => `${I} ${V}`).join(x2) + x2;
            return N + x2 + (_ ? D : "") + (_ && $.length ? I + x2 : "") + H + W;
          }
          function w(d, _) {
            return a.concat(_).map((k) => `@${d} ${k}`.trim());
          }
        } }), Pl = P({ "src/common/end-of-line.js"(e2, n2) {
          "use strict";
          A();
          function i(l) {
            let p = l.indexOf("\r");
            return p >= 0 ? l.charAt(p + 1) === `
` ? "crlf" : "cr" : "lf";
          }
          function u(l) {
            switch (l) {
              case "cr":
                return "\r";
              case "crlf":
                return `\r
`;
              default:
                return `
`;
            }
          }
          function o(l, p) {
            let m;
            switch (p) {
              case `
`:
                m = /\n/g;
                break;
              case "\r":
                m = /\r/g;
                break;
              case `\r
`:
                m = /\r\n/g;
                break;
              default:
                throw new Error(`Unexpected "eol" ${JSON.stringify(p)}.`);
            }
            let c = l.match(m);
            return c ? c.length : 0;
          }
          function h3(l) {
            return l.replace(/\r\n?/g, `
`);
          }
          n2.exports = { guessEndOfLine: i, convertEndOfLineToChars: u, countEndOfLineChars: o, normalizeEndOfLine: h3 };
        } }), Il = P({ "src/language-js/utils/get-shebang.js"(e2, n2) {
          "use strict";
          A();
          function i(u) {
            if (!u.startsWith("#!")) return "";
            let o = u.indexOf(`
`);
            return o === -1 ? u : u.slice(0, o);
          }
          n2.exports = i;
        } }), Rl = P({ "src/language-js/pragma.js"(e2, n2) {
          "use strict";
          A();
          var { parseWithComments: i, strip: u, extract: o, print: h3 } = Al(), { normalizeEndOfLine: l } = Pl(), p = Il();
          function m(r) {
            let a = p(r);
            a && (r = r.slice(a.length + 1));
            let s = o(r), { pragmas: f, comments: g } = i(s);
            return { shebang: a, text: r, pragmas: f, comments: g };
          }
          function c(r) {
            let a = Object.keys(m(r).pragmas);
            return a.includes("prettier") || a.includes("format");
          }
          function t(r) {
            let { shebang: a, text: s, pragmas: f, comments: g } = m(r), v = u(s), y = h3({ pragmas: Object.assign({ format: "" }, f), comments: g.trimStart() });
            return (a ? `${a}
` : "") + l(y) + (v.startsWith(`
`) ? `
` : `

`) + v;
          }
          n2.exports = { hasPragma: c, insertPragma: t };
        } }), Cl = P({ "src/language-css/pragma.js"(e2, n2) {
          "use strict";
          A();
          var i = Rl(), u = $s();
          function o(l) {
            return i.hasPragma(u(l).content);
          }
          function h3(l) {
            let { frontMatter: p, content: m } = u(l);
            return (p ? p.raw + `

` : "") + i.insertPragma(m);
          }
          n2.exports = { hasPragma: o, insertPragma: h3 };
        } }), Nl = P({ "src/utils/text/skip.js"(e2, n2) {
          "use strict";
          A();
          function i(p) {
            return (m, c, t) => {
              let r = t && t.backwards;
              if (c === false) return false;
              let { length: a } = m, s = c;
              for (; s >= 0 && s < a; ) {
                let f = m.charAt(s);
                if (p instanceof RegExp) {
                  if (!p.test(f)) return s;
                } else if (!p.includes(f)) return s;
                r ? s-- : s++;
              }
              return s === -1 || s === a ? s : false;
            };
          }
          var u = i(/\s/), o = i(" 	"), h3 = i(",; 	"), l = i(/[^\n\r]/);
          n2.exports = { skipWhitespace: u, skipSpaces: o, skipToLineEnd: h3, skipEverythingButNewLine: l };
        } }), jl = P({ "src/utils/line-column-to-index.js"(e2, n2) {
          "use strict";
          A(), n2.exports = function(i, u) {
            let o = 0;
            for (let h3 = 0; h3 < i.line - 1; ++h3) o = u.indexOf(`
`, o) + 1;
            return o + i.column;
          };
        } }), no = P({ "src/language-css/loc.js"(e2, n2) {
          "use strict";
          A();
          var { skipEverythingButNewLine: i } = Nl(), u = Us(), o = jl();
          function h3(s, f) {
            return typeof s.sourceIndex == "number" ? s.sourceIndex : s.source ? o(s.source.start, f) - 1 : null;
          }
          function l(s, f) {
            if (s.type === "css-comment" && s.inline) return i(f, s.source.startOffset);
            let g = s.nodes && u(s.nodes);
            return g && s.source && !s.source.end && (s = g), s.source && s.source.end ? o(s.source.end, f) : null;
          }
          function p(s, f) {
            s.source && (s.source.startOffset = h3(s, f), s.source.endOffset = l(s, f));
            for (let g in s) {
              let v = s[g];
              g === "source" || !v || typeof v != "object" || (v.type === "value-root" || v.type === "value-unknown" ? m(v, c(s), v.text || v.value) : p(v, f));
            }
          }
          function m(s, f, g) {
            s.source && (s.source.startOffset = h3(s, g) + f, s.source.endOffset = l(s, g) + f);
            for (let v in s) {
              let y = s[v];
              v === "source" || !y || typeof y != "object" || m(y, f, g);
            }
          }
          function c(s) {
            let f = s.source.startOffset;
            return typeof s.prop == "string" && (f += s.prop.length), s.type === "css-atrule" && typeof s.name == "string" && (f += 1 + s.name.length + s.raws.afterName.match(/^\s*:?\s*/)[0].length), s.type !== "css-atrule" && s.raws && typeof s.raws.between == "string" && (f += s.raws.between.length), f;
          }
          function t(s) {
            let f = "initial", g = "initial", v, y = false, w = [];
            for (let d = 0; d < s.length; d++) {
              let _ = s[d];
              switch (f) {
                case "initial":
                  if (_ === "'") {
                    f = "single-quotes";
                    continue;
                  }
                  if (_ === '"') {
                    f = "double-quotes";
                    continue;
                  }
                  if ((_ === "u" || _ === "U") && s.slice(d, d + 4).toLowerCase() === "url(") {
                    f = "url", d += 3;
                    continue;
                  }
                  if (_ === "*" && s[d - 1] === "/") {
                    f = "comment-block";
                    continue;
                  }
                  if (_ === "/" && s[d - 1] === "/") {
                    f = "comment-inline", v = d - 1;
                    continue;
                  }
                  continue;
                case "single-quotes":
                  if (_ === "'" && s[d - 1] !== "\\" && (f = g, g = "initial"), _ === `
` || _ === "\r") return s;
                  continue;
                case "double-quotes":
                  if (_ === '"' && s[d - 1] !== "\\" && (f = g, g = "initial"), _ === `
` || _ === "\r") return s;
                  continue;
                case "url":
                  if (_ === ")" && (f = "initial"), _ === `
` || _ === "\r") return s;
                  if (_ === "'") {
                    f = "single-quotes", g = "url";
                    continue;
                  }
                  if (_ === '"') {
                    f = "double-quotes", g = "url";
                    continue;
                  }
                  continue;
                case "comment-block":
                  _ === "/" && s[d - 1] === "*" && (f = "initial");
                  continue;
                case "comment-inline":
                  (_ === '"' || _ === "'" || _ === "*") && (y = true), (_ === `
` || _ === "\r") && (y && w.push([v, d]), f = "initial", y = false);
                  continue;
              }
            }
            for (let [d, _] of w) s = s.slice(0, d) + s.slice(d, _).replace(/["'*]/g, " ") + s.slice(_);
            return s;
          }
          function r(s) {
            return s.source.startOffset;
          }
          function a(s) {
            return s.source.endOffset;
          }
          n2.exports = { locStart: r, locEnd: a, calculateLoc: p, replaceQuotesInInlineComments: t };
        } }), Ml = P({ "src/utils/is-non-empty-array.js"(e2, n2) {
          "use strict";
          A();
          function i(u) {
            return Array.isArray(u) && u.length > 0;
          }
          n2.exports = i;
        } }), Dl = P({ "src/language-css/utils/has-scss-interpolation.js"(e2, n2) {
          "use strict";
          A();
          var i = Ml();
          function u(o) {
            if (i(o)) {
              for (let h3 = o.length - 1; h3 > 0; h3--) if (o[h3].type === "word" && o[h3].value === "{" && o[h3 - 1].type === "word" && o[h3 - 1].value.endsWith("#")) return true;
            }
            return false;
          }
          n2.exports = u;
        } }), Ll = P({ "src/language-css/utils/has-string-or-function.js"(e2, n2) {
          "use strict";
          A();
          function i(u) {
            return u.some((o) => o.type === "string" || o.type === "func");
          }
          n2.exports = i;
        } }), zl = P({ "src/language-css/utils/is-less-parser.js"(e2, n2) {
          "use strict";
          A();
          function i(u) {
            return u.parser === "css" || u.parser === "less";
          }
          n2.exports = i;
        } }), Bl = P({ "src/language-css/utils/is-scss.js"(e2, n2) {
          "use strict";
          A();
          function i(u, o) {
            return u === "less" || u === "scss" ? u === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(o);
          }
          n2.exports = i;
        } }), Fl = P({ "src/language-css/utils/is-scss-nested-property-node.js"(e2, n2) {
          "use strict";
          A();
          function i(u) {
            return u.selector ? u.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*\n/, "").trim().endsWith(":") : false;
          }
          n2.exports = i;
        } }), Ul = P({ "src/language-css/utils/is-scss-variable.js"(e2, n2) {
          "use strict";
          A();
          function i(u) {
            return Boolean((u == null ? void 0 : u.type) === "word" && u.value.startsWith("$"));
          }
          n2.exports = i;
        } }), $l = P({ "src/language-css/utils/stringify-node.js"(e2, n2) {
          "use strict";
          A();
          function i(u) {
            var o, h3, l;
            if (u.groups) {
              var p, m, c;
              let y = ((p = u.open) === null || p === void 0 ? void 0 : p.value) || "", w = u.groups.map((_) => i(_)).join(((m = u.groups[0]) === null || m === void 0 ? void 0 : m.type) === "comma_group" ? "," : ""), d = ((c = u.close) === null || c === void 0 ? void 0 : c.value) || "";
              return y + w + d;
            }
            let t = ((o = u.raws) === null || o === void 0 ? void 0 : o.before) || "", r = ((h3 = u.raws) === null || h3 === void 0 ? void 0 : h3.quote) || "", a = u.type === "atword" ? "@" : "", s = u.value || "", f = u.unit || "", g = u.group ? i(u.group) : "", v = ((l = u.raws) === null || l === void 0 ? void 0 : l.after) || "";
            return t + r + a + s + r + f + g + v;
          }
          n2.exports = i;
        } }), Wl = P({ "src/language-css/utils/is-module-rule-name.js"(e2, n2) {
          "use strict";
          A();
          var i = /* @__PURE__ */ new Set(["import", "use", "forward"]);
          function u(o) {
            return i.has(o);
          }
          n2.exports = u;
        } }), we = P({ "node_modules/postcss-values-parser/lib/node.js"(e2, n2) {
          "use strict";
          A();
          var i = function(u, o) {
            let h3 = new u.constructor();
            for (let l in u) {
              if (!u.hasOwnProperty(l)) continue;
              let p = u[l], m = typeof p;
              l === "parent" && m === "object" ? o && (h3[l] = o) : l === "source" ? h3[l] = p : p instanceof Array ? h3[l] = p.map((c) => i(c, h3)) : l !== "before" && l !== "after" && l !== "between" && l !== "semicolon" && (m === "object" && p !== null && (p = i(p)), h3[l] = p);
            }
            return h3;
          };
          n2.exports = class {
            constructor(o) {
              o = o || {}, this.raws = { before: "", after: "" };
              for (let h3 in o) this[h3] = o[h3];
            }
            remove() {
              return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
            }
            toString() {
              return [this.raws.before, String(this.value), this.raws.after].join("");
            }
            clone(o) {
              o = o || {};
              let h3 = i(this);
              for (let l in o) h3[l] = o[l];
              return h3;
            }
            cloneBefore(o) {
              o = o || {};
              let h3 = this.clone(o);
              return this.parent.insertBefore(this, h3), h3;
            }
            cloneAfter(o) {
              o = o || {};
              let h3 = this.clone(o);
              return this.parent.insertAfter(this, h3), h3;
            }
            replaceWith() {
              let o = Array.prototype.slice.call(arguments);
              if (this.parent) {
                for (let h3 of o) this.parent.insertBefore(this, h3);
                this.remove();
              }
              return this;
            }
            moveTo(o) {
              return this.cleanRaws(this.root() === o.root()), this.remove(), o.append(this), this;
            }
            moveBefore(o) {
              return this.cleanRaws(this.root() === o.root()), this.remove(), o.parent.insertBefore(o, this), this;
            }
            moveAfter(o) {
              return this.cleanRaws(this.root() === o.root()), this.remove(), o.parent.insertAfter(o, this), this;
            }
            next() {
              let o = this.parent.index(this);
              return this.parent.nodes[o + 1];
            }
            prev() {
              let o = this.parent.index(this);
              return this.parent.nodes[o - 1];
            }
            toJSON() {
              let o = {};
              for (let h3 in this) {
                if (!this.hasOwnProperty(h3) || h3 === "parent") continue;
                let l = this[h3];
                l instanceof Array ? o[h3] = l.map((p) => typeof p == "object" && p.toJSON ? p.toJSON() : p) : typeof l == "object" && l.toJSON ? o[h3] = l.toJSON() : o[h3] = l;
              }
              return o;
            }
            root() {
              let o = this;
              for (; o.parent; ) o = o.parent;
              return o;
            }
            cleanRaws(o) {
              delete this.raws.before, delete this.raws.after, o || delete this.raws.between;
            }
            positionInside(o) {
              let h3 = this.toString(), l = this.source.start.column, p = this.source.start.line;
              for (let m = 0; m < o; m++) h3[m] === `
` ? (l = 1, p += 1) : l += 1;
              return { line: p, column: l };
            }
            positionBy(o) {
              let h3 = this.source.start;
              if (Object(o).index) h3 = this.positionInside(o.index);
              else if (Object(o).word) {
                let l = this.toString().indexOf(o.word);
                l !== -1 && (h3 = this.positionInside(l));
              }
              return h3;
            }
          };
        } }), ae = P({ "node_modules/postcss-values-parser/lib/container.js"(e2, n2) {
          "use strict";
          A();
          var i = we(), u = class extends i {
            constructor(o) {
              super(o), this.nodes || (this.nodes = []);
            }
            push(o) {
              return o.parent = this, this.nodes.push(o), this;
            }
            each(o) {
              this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
              let h3 = this.lastEach, l, p;
              if (this.indexes[h3] = 0, !!this.nodes) {
                for (; this.indexes[h3] < this.nodes.length && (l = this.indexes[h3], p = o(this.nodes[l], l), p !== false); ) this.indexes[h3] += 1;
                return delete this.indexes[h3], p;
              }
            }
            walk(o) {
              return this.each((h3, l) => {
                let p = o(h3, l);
                return p !== false && h3.walk && (p = h3.walk(o)), p;
              });
            }
            walkType(o, h3) {
              if (!o || !h3) throw new Error("Parameters {type} and {callback} are required.");
              let l = typeof o == "function";
              return this.walk((p, m) => {
                if (l && p instanceof o || !l && p.type === o) return h3.call(this, p, m);
              });
            }
            append(o) {
              return o.parent = this, this.nodes.push(o), this;
            }
            prepend(o) {
              return o.parent = this, this.nodes.unshift(o), this;
            }
            cleanRaws(o) {
              if (super.cleanRaws(o), this.nodes) for (let h3 of this.nodes) h3.cleanRaws(o);
            }
            insertAfter(o, h3) {
              let l = this.index(o), p;
              this.nodes.splice(l + 1, 0, h3);
              for (let m in this.indexes) p = this.indexes[m], l <= p && (this.indexes[m] = p + this.nodes.length);
              return this;
            }
            insertBefore(o, h3) {
              let l = this.index(o), p;
              this.nodes.splice(l, 0, h3);
              for (let m in this.indexes) p = this.indexes[m], l <= p && (this.indexes[m] = p + this.nodes.length);
              return this;
            }
            removeChild(o) {
              o = this.index(o), this.nodes[o].parent = void 0, this.nodes.splice(o, 1);
              let h3;
              for (let l in this.indexes) h3 = this.indexes[l], h3 >= o && (this.indexes[l] = h3 - 1);
              return this;
            }
            removeAll() {
              for (let o of this.nodes) o.parent = void 0;
              return this.nodes = [], this;
            }
            every(o) {
              return this.nodes.every(o);
            }
            some(o) {
              return this.nodes.some(o);
            }
            index(o) {
              return typeof o == "number" ? o : this.nodes.indexOf(o);
            }
            get first() {
              if (this.nodes) return this.nodes[0];
            }
            get last() {
              if (this.nodes) return this.nodes[this.nodes.length - 1];
            }
            toString() {
              let o = this.nodes.map(String).join("");
              return this.value && (o = this.value + o), this.raws.before && (o = this.raws.before + o), this.raws.after && (o += this.raws.after), o;
            }
          };
          u.registerWalker = (o) => {
            let h3 = "walk" + o.name;
            h3.lastIndexOf("s") !== h3.length - 1 && (h3 += "s"), !u.prototype[h3] && (u.prototype[h3] = function(l) {
              return this.walkType(o, l);
            });
          }, n2.exports = u;
        } }), Vl = P({ "node_modules/postcss-values-parser/lib/root.js"(e2, n2) {
          "use strict";
          A();
          var i = ae();
          n2.exports = class extends i {
            constructor(o) {
              super(o), this.type = "root";
            }
          };
        } }), io = P({ "node_modules/postcss-values-parser/lib/value.js"(e2, n2) {
          "use strict";
          A();
          var i = ae();
          n2.exports = class extends i {
            constructor(o) {
              super(o), this.type = "value", this.unbalanced = 0;
            }
          };
        } }), so = P({ "node_modules/postcss-values-parser/lib/atword.js"(e2, n2) {
          "use strict";
          A();
          var i = ae(), u = class extends i {
            constructor(o) {
              super(o), this.type = "atword";
            }
            toString() {
              let o = this.quoted ? this.raws.quote : "";
              return [this.raws.before, "@", String.prototype.toString.call(this.value), this.raws.after].join("");
            }
          };
          i.registerWalker(u), n2.exports = u;
        } }), oo = P({ "node_modules/postcss-values-parser/lib/colon.js"(e2, n2) {
          "use strict";
          A();
          var i = ae(), u = we(), o = class extends u {
            constructor(h3) {
              super(h3), this.type = "colon";
            }
          };
          i.registerWalker(o), n2.exports = o;
        } }), ao = P({ "node_modules/postcss-values-parser/lib/comma.js"(e2, n2) {
          "use strict";
          A();
          var i = ae(), u = we(), o = class extends u {
            constructor(h3) {
              super(h3), this.type = "comma";
            }
          };
          i.registerWalker(o), n2.exports = o;
        } }), uo = P({ "node_modules/postcss-values-parser/lib/comment.js"(e2, n2) {
          "use strict";
          A();
          var i = ae(), u = we(), o = class extends u {
            constructor(h3) {
              super(h3), this.type = "comment", this.inline = Object(h3).inline || false;
            }
            toString() {
              return [this.raws.before, this.inline ? "//" : "/*", String(this.value), this.inline ? "" : "*/", this.raws.after].join("");
            }
          };
          i.registerWalker(o), n2.exports = o;
        } }), co = P({ "node_modules/postcss-values-parser/lib/function.js"(e2, n2) {
          "use strict";
          A();
          var i = ae(), u = class extends i {
            constructor(o) {
              super(o), this.type = "func", this.unbalanced = -1;
            }
          };
          i.registerWalker(u), n2.exports = u;
        } }), lo = P({ "node_modules/postcss-values-parser/lib/number.js"(e2, n2) {
          "use strict";
          A();
          var i = ae(), u = we(), o = class extends u {
            constructor(h3) {
              super(h3), this.type = "number", this.unit = Object(h3).unit || "";
            }
            toString() {
              return [this.raws.before, String(this.value), this.unit, this.raws.after].join("");
            }
          };
          i.registerWalker(o), n2.exports = o;
        } }), fo = P({ "node_modules/postcss-values-parser/lib/operator.js"(e2, n2) {
          "use strict";
          A();
          var i = ae(), u = we(), o = class extends u {
            constructor(h3) {
              super(h3), this.type = "operator";
            }
          };
          i.registerWalker(o), n2.exports = o;
        } }), po = P({ "node_modules/postcss-values-parser/lib/paren.js"(e2, n2) {
          "use strict";
          A();
          var i = ae(), u = we(), o = class extends u {
            constructor(h3) {
              super(h3), this.type = "paren", this.parenType = "";
            }
          };
          i.registerWalker(o), n2.exports = o;
        } }), ho = P({ "node_modules/postcss-values-parser/lib/string.js"(e2, n2) {
          "use strict";
          A();
          var i = ae(), u = we(), o = class extends u {
            constructor(h3) {
              super(h3), this.type = "string";
            }
            toString() {
              let h3 = this.quoted ? this.raws.quote : "";
              return [this.raws.before, h3, this.value + "", h3, this.raws.after].join("");
            }
          };
          i.registerWalker(o), n2.exports = o;
        } }), vo = P({ "node_modules/postcss-values-parser/lib/word.js"(e2, n2) {
          "use strict";
          A();
          var i = ae(), u = we(), o = class extends u {
            constructor(h3) {
              super(h3), this.type = "word";
            }
          };
          i.registerWalker(o), n2.exports = o;
        } }), mo = P({ "node_modules/postcss-values-parser/lib/unicode-range.js"(e2, n2) {
          "use strict";
          A();
          var i = ae(), u = we(), o = class extends u {
            constructor(h3) {
              super(h3), this.type = "unicode-range";
            }
          };
          i.registerWalker(o), n2.exports = o;
        } });
        function go() {
          throw new Error("setTimeout has not been defined");
        }
        function yo() {
          throw new Error("clearTimeout has not been defined");
        }
        function wo(e2) {
          if (Se === setTimeout) return setTimeout(e2, 0);
          if ((Se === go || !Se) && setTimeout) return Se = setTimeout, setTimeout(e2, 0);
          try {
            return Se(e2, 0);
          } catch (e3) {
            try {
              return Se.call(null, e2, 0);
            } catch (e4) {
              return Se.call(this, e2, 0);
            }
          }
        }
        function Gl(e2) {
          if (ke === clearTimeout) return clearTimeout(e2);
          if ((ke === yo || !ke) && clearTimeout) return ke = clearTimeout, clearTimeout(e2);
          try {
            return ke(e2);
          } catch (e3) {
            try {
              return ke.call(null, e2);
            } catch (e4) {
              return ke.call(this, e2);
            }
          }
        }
        function Hl() {
          !Ne || !Ce || (Ne = false, Ce.length ? me = Ce.concat(me) : We = -1, me.length && _o());
        }
        function _o() {
          if (!Ne) {
            var e2 = wo(Hl);
            Ne = true;
            for (var n2 = me.length; n2; ) {
              for (Ce = me, me = []; ++We < n2; ) Ce && Ce[We].run();
              We = -1, n2 = me.length;
            }
            Ce = null, Ne = false, Gl(e2);
          }
        }
        function Jl(e2) {
          var n2 = new Array(arguments.length - 1);
          if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) n2[i - 1] = arguments[i];
          me.push(new bo(e2, n2)), me.length === 1 && !Ne && wo(_o);
        }
        function bo(e2, n2) {
          this.fun = e2, this.array = n2;
        }
        function Ae() {
        }
        function Kl(e2) {
          throw new Error("process.binding is not supported");
        }
        function Ql() {
          return "/";
        }
        function Yl(e2) {
          throw new Error("process.chdir is not supported");
        }
        function Xl() {
          return 0;
        }
        function Zl(e2) {
          var n2 = xo.call(Ie) * 1e-3, i = Math.floor(n2), u = Math.floor(n2 % 1 * 1e9);
          return e2 && (i = i - e2[0], u = u - e2[1], u < 0 && (i--, u += 1e9)), [i, u];
        }
        function ef() {
          var e2 = /* @__PURE__ */ new Date(), n2 = e2 - So;
          return n2 / 1e3;
        }
        var Se, ke, me, Ne, Ce, We, ks, Os, Ts, Es, qs, As, Ps, Is, Rs, Cs, Ns, js, Ms, Ds, Ls, zs, Ie, xo, So, Bs, Ve, rf = Le({ "node-modules-polyfills:process"() {
          A(), Se = go, ke = yo, typeof globalThis.setTimeout == "function" && (Se = setTimeout), typeof globalThis.clearTimeout == "function" && (ke = clearTimeout), me = [], Ne = false, We = -1, bo.prototype.run = function() {
            this.fun.apply(null, this.array);
          }, ks = "browser", Os = "browser", Ts = true, Es = {}, qs = [], As = "", Ps = {}, Is = {}, Rs = {}, Cs = Ae, Ns = Ae, js = Ae, Ms = Ae, Ds = Ae, Ls = Ae, zs = Ae, Ie = globalThis.performance || {}, xo = Ie.now || Ie.mozNow || Ie.msNow || Ie.oNow || Ie.webkitNow || function() {
            return (/* @__PURE__ */ new Date()).getTime();
          }, So = /* @__PURE__ */ new Date(), Bs = { nextTick: Jl, title: ks, browser: Ts, env: Es, argv: qs, version: As, versions: Ps, on: Cs, addListener: Ns, once: js, off: Ms, removeListener: Ds, removeAllListeners: Ls, emit: zs, binding: Kl, cwd: Ql, chdir: Yl, umask: Xl, hrtime: Zl, platform: Os, release: Is, config: Rs, uptime: ef }, Ve = Bs;
        } }), pt, It, tf = Le({ "node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
          A(), typeof Object.create == "function" ? pt = function(n2, i) {
            n2.super_ = i, n2.prototype = Object.create(i.prototype, { constructor: { value: n2, enumerable: false, writable: true, configurable: true } });
          } : pt = function(n2, i) {
            n2.super_ = i;
            var u = function() {
            };
            u.prototype = i.prototype, n2.prototype = new u(), n2.prototype.constructor = n2;
          }, It = pt;
        } }), ko = {};
        At(ko, { _extend: () => Mt, debuglog: () => Oo, default: () => No, deprecate: () => Rt, format: () => wr, inherits: () => It, inspect: () => ye, isArray: () => Ct, isBoolean: () => _r, isBuffer: () => Ao, isDate: () => gr, isError: () => He, isFunction: () => Je, isNull: () => Ke, isNullOrUndefined: () => To, isNumber: () => Nt, isObject: () => je, isPrimitive: () => qo, isRegExp: () => Ge, isString: () => Qe, isSymbol: () => Eo, isUndefined: () => ge, log: () => Po });
        function wr(e2) {
          if (!Qe(e2)) {
            for (var n2 = [], i = 0; i < arguments.length; i++) n2.push(ye(arguments[i]));
            return n2.join(" ");
          }
          for (var i = 1, u = arguments, o = u.length, h3 = String(e2).replace(Ro, function(p) {
            if (p === "%%") return "%";
            if (i >= o) return p;
            switch (p) {
              case "%s":
                return String(u[i++]);
              case "%d":
                return Number(u[i++]);
              case "%j":
                try {
                  return JSON.stringify(u[i++]);
                } catch (e3) {
                  return "[Circular]";
                }
              default:
                return p;
            }
          }), l = u[i]; i < o; l = u[++i]) Ke(l) || !je(l) ? h3 += " " + l : h3 += " " + ye(l);
          return h3;
        }
        function Rt(e2, n2) {
          if (ge(globalThis.process)) return function() {
            return Rt(e2, n2).apply(this, arguments);
          };
          if (Ve.noDeprecation === true) return e2;
          var i = false;
          function u() {
            if (!i) {
              if (Ve.throwDeprecation) throw new Error(n2);
              Ve.traceDeprecation ? console.trace(n2) : console.error(n2), i = true;
            }
            return e2.apply(this, arguments);
          }
          return u;
        }
        function Oo(e2) {
          if (ge(vt) && (vt = Ve.env.NODE_DEBUG || ""), e2 = e2.toUpperCase(), !$e[e2]) if (new RegExp("\\b" + e2 + "\\b", "i").test(vt)) {
            var n2 = 0;
            $e[e2] = function() {
              var i = wr.apply(null, arguments);
              console.error("%s %d: %s", e2, n2, i);
            };
          } else $e[e2] = function() {
          };
          return $e[e2];
        }
        function ye(e2, n2) {
          var i = { seen: [], stylize: sf };
          return arguments.length >= 3 && (i.depth = arguments[2]), arguments.length >= 4 && (i.colors = arguments[3]), _r(n2) ? i.showHidden = n2 : n2 && Mt(i, n2), ge(i.showHidden) && (i.showHidden = false), ge(i.depth) && (i.depth = 2), ge(i.colors) && (i.colors = false), ge(i.customInspect) && (i.customInspect = true), i.colors && (i.stylize = nf), mr(i, e2, i.depth);
        }
        function nf(e2, n2) {
          var i = ye.styles[n2];
          return i ? "\x1B[" + ye.colors[i][0] + "m" + e2 + "\x1B[" + ye.colors[i][1] + "m" : e2;
        }
        function sf(e2, n2) {
          return e2;
        }
        function of(e2) {
          var n2 = {};
          return e2.forEach(function(i, u) {
            n2[i] = true;
          }), n2;
        }
        function mr(e2, n2, i) {
          if (e2.customInspect && n2 && Je(n2.inspect) && n2.inspect !== ye && !(n2.constructor && n2.constructor.prototype === n2)) {
            var u = n2.inspect(i, e2);
            return Qe(u) || (u = mr(e2, u, i)), u;
          }
          var o = af(e2, n2);
          if (o) return o;
          var h3 = Object.keys(n2), l = of(h3);
          if (e2.showHidden && (h3 = Object.getOwnPropertyNames(n2)), He(n2) && (h3.indexOf("message") >= 0 || h3.indexOf("description") >= 0)) return ht(n2);
          if (h3.length === 0) {
            if (Je(n2)) {
              var p = n2.name ? ": " + n2.name : "";
              return e2.stylize("[Function" + p + "]", "special");
            }
            if (Ge(n2)) return e2.stylize(RegExp.prototype.toString.call(n2), "regexp");
            if (gr(n2)) return e2.stylize(Date.prototype.toString.call(n2), "date");
            if (He(n2)) return ht(n2);
          }
          var m = "", c = false, t = ["{", "}"];
          if (Ct(n2) && (c = true, t = ["[", "]"]), Je(n2)) {
            var r = n2.name ? ": " + n2.name : "";
            m = " [Function" + r + "]";
          }
          if (Ge(n2) && (m = " " + RegExp.prototype.toString.call(n2)), gr(n2) && (m = " " + Date.prototype.toUTCString.call(n2)), He(n2) && (m = " " + ht(n2)), h3.length === 0 && (!c || n2.length == 0)) return t[0] + m + t[1];
          if (i < 0) return Ge(n2) ? e2.stylize(RegExp.prototype.toString.call(n2), "regexp") : e2.stylize("[Object]", "special");
          e2.seen.push(n2);
          var a;
          return c ? a = uf(e2, n2, i, l, h3) : a = h3.map(function(s) {
            return xt(e2, n2, i, l, s, c);
          }), e2.seen.pop(), cf(a, m, t);
        }
        function af(e2, n2) {
          if (ge(n2)) return e2.stylize("undefined", "undefined");
          if (Qe(n2)) {
            var i = "'" + JSON.stringify(n2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return e2.stylize(i, "string");
          }
          if (Nt(n2)) return e2.stylize("" + n2, "number");
          if (_r(n2)) return e2.stylize("" + n2, "boolean");
          if (Ke(n2)) return e2.stylize("null", "null");
        }
        function ht(e2) {
          return "[" + Error.prototype.toString.call(e2) + "]";
        }
        function uf(e2, n2, i, u, o) {
          for (var h3 = [], l = 0, p = n2.length; l < p; ++l) Io(n2, String(l)) ? h3.push(xt(e2, n2, i, u, String(l), true)) : h3.push("");
          return o.forEach(function(m) {
            m.match(/^\d+$/) || h3.push(xt(e2, n2, i, u, m, true));
          }), h3;
        }
        function xt(e2, n2, i, u, o, h3) {
          var l, p, m;
          if (m = Object.getOwnPropertyDescriptor(n2, o) || { value: n2[o] }, m.get ? m.set ? p = e2.stylize("[Getter/Setter]", "special") : p = e2.stylize("[Getter]", "special") : m.set && (p = e2.stylize("[Setter]", "special")), Io(u, o) || (l = "[" + o + "]"), p || (e2.seen.indexOf(m.value) < 0 ? (Ke(i) ? p = mr(e2, m.value, null) : p = mr(e2, m.value, i - 1), p.indexOf(`
`) > -1 && (h3 ? p = p.split(`
`).map(function(c) {
            return "  " + c;
          }).join(`
`).substr(2) : p = `
` + p.split(`
`).map(function(c) {
            return "   " + c;
          }).join(`
`))) : p = e2.stylize("[Circular]", "special")), ge(l)) {
            if (h3 && o.match(/^\d+$/)) return p;
            l = JSON.stringify("" + o), l.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (l = l.substr(1, l.length - 2), l = e2.stylize(l, "name")) : (l = l.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), l = e2.stylize(l, "string"));
          }
          return l + ": " + p;
        }
        function cf(e2, n2, i) {
          var u = 0, o = e2.reduce(function(h3, l) {
            return u++, l.indexOf(`
`) >= 0 && u++, h3 + l.replace(/\u001b\[\d\d?m/g, "").length + 1;
          }, 0);
          return o > 60 ? i[0] + (n2 === "" ? "" : n2 + `
 `) + " " + e2.join(`,
  `) + " " + i[1] : i[0] + n2 + " " + e2.join(", ") + " " + i[1];
        }
        function Ct(e2) {
          return Array.isArray(e2);
        }
        function _r(e2) {
          return typeof e2 == "boolean";
        }
        function Ke(e2) {
          return e2 === null;
        }
        function To(e2) {
          return e2 == null;
        }
        function Nt(e2) {
          return typeof e2 == "number";
        }
        function Qe(e2) {
          return typeof e2 == "string";
        }
        function Eo(e2) {
          return typeof e2 == "symbol";
        }
        function ge(e2) {
          return e2 === void 0;
        }
        function Ge(e2) {
          return je(e2) && jt(e2) === "[object RegExp]";
        }
        function je(e2) {
          return typeof e2 == "object" && e2 !== null;
        }
        function gr(e2) {
          return je(e2) && jt(e2) === "[object Date]";
        }
        function He(e2) {
          return je(e2) && (jt(e2) === "[object Error]" || e2 instanceof Error);
        }
        function Je(e2) {
          return typeof e2 == "function";
        }
        function qo(e2) {
          return e2 === null || typeof e2 == "boolean" || typeof e2 == "number" || typeof e2 == "string" || typeof e2 == "symbol" || typeof e2 > "u";
        }
        function Ao(e2) {
          return Buffer.isBuffer(e2);
        }
        function jt(e2) {
          return Object.prototype.toString.call(e2);
        }
        function dt(e2) {
          return e2 < 10 ? "0" + e2.toString(10) : e2.toString(10);
        }
        function lf() {
          var e2 = /* @__PURE__ */ new Date(), n2 = [dt(e2.getHours()), dt(e2.getMinutes()), dt(e2.getSeconds())].join(":");
          return [e2.getDate(), Co[e2.getMonth()], n2].join(" ");
        }
        function Po() {
          console.log("%s - %s", lf(), wr.apply(null, arguments));
        }
        function Mt(e2, n2) {
          if (!n2 || !je(n2)) return e2;
          for (var i = Object.keys(n2), u = i.length; u--; ) e2[i[u]] = n2[i[u]];
          return e2;
        }
        function Io(e2, n2) {
          return Object.prototype.hasOwnProperty.call(e2, n2);
        }
        var Ro, $e, vt, Co, No, ff = Le({ "node-modules-polyfills:util"() {
          A(), rf(), tf(), Ro = /%[sdj%]/g, $e = {}, ye.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, ye.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, Co = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], No = { inherits: It, _extend: Mt, log: Po, isBuffer: Ao, isPrimitive: qo, isFunction: Je, isError: He, isDate: gr, isObject: je, isRegExp: Ge, isUndefined: ge, isSymbol: Eo, isString: Qe, isNumber: Nt, isNullOrUndefined: To, isNull: Ke, isBoolean: _r, isArray: Ct, inspect: ye, deprecate: Rt, format: wr, debuglog: Oo };
        } }), pf = P({ "node-modules-polyfills-commonjs:util"(e2, n2) {
          A();
          var i = (ff(), Pt(ko));
          if (i && i.default) {
            n2.exports = i.default;
            for (let u in i) n2.exports[u] = i[u];
          } else i && (n2.exports = i);
        } }), hf = P({ "node_modules/postcss-values-parser/lib/errors/TokenizeError.js"(e2, n2) {
          "use strict";
          A();
          var i = class extends Error {
            constructor(u) {
              super(u), this.name = this.constructor.name, this.message = u || "An error ocurred while tokzenizing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(u).stack;
            }
          };
          n2.exports = i;
        } }), df = P({ "node_modules/postcss-values-parser/lib/tokenize.js"(e2, n2) {
          "use strict";
          A();
          var i = "{".charCodeAt(0), u = "}".charCodeAt(0), o = "(".charCodeAt(0), h3 = ")".charCodeAt(0), l = "'".charCodeAt(0), p = '"'.charCodeAt(0), m = "\\".charCodeAt(0), c = "/".charCodeAt(0), t = ".".charCodeAt(0), r = ",".charCodeAt(0), a = ":".charCodeAt(0), s = "*".charCodeAt(0), f = "-".charCodeAt(0), g = "+".charCodeAt(0), v = "#".charCodeAt(0), y = `
`.charCodeAt(0), w = " ".charCodeAt(0), d = "\f".charCodeAt(0), _ = "	".charCodeAt(0), k = "\r".charCodeAt(0), x2 = "@".charCodeAt(0), N = "e".charCodeAt(0), I = "E".charCodeAt(0), W = "0".charCodeAt(0), $ = "9".charCodeAt(0), H = "u".charCodeAt(0), D = "U".charCodeAt(0), V = /[ \n\t\r\{\(\)'"\\;,/]/g, B = /[ \n\t\r\(\)\{\}\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g, O = /[ \n\t\r\(\)\{\}\*:;@!&'"\-\+\|~>,\[\]\\]|\//g, j = /^[a-z0-9]/i, C = /^[a-f0-9?\-]/i, R = pf(), X = hf();
          n2.exports = function(Q, K) {
            K = K || {};
            let J = [], M = Q.valueOf(), Y = M.length, G = -1, E = 1, S = 0, b = 0, L = null, q, T, F, z, ee, te, ue, le, re, ne, oe, ie;
            function ce(Ze) {
              let _e = R.format("Unclosed %s at line: %d, column: %d, token: %d", Ze, E, S - G, S);
              throw new X(_e);
            }
            function fe() {
              let Ze = R.format("Syntax error at line: %d, column: %d, token: %d", E, S - G, S);
              throw new X(Ze);
            }
            for (; S < Y; ) {
              switch (q = M.charCodeAt(S), q === y && (G = S, E += 1), q) {
                case y:
                case w:
                case _:
                case k:
                case d:
                  T = S;
                  do
                    T += 1, q = M.charCodeAt(T), q === y && (G = T, E += 1);
                  while (q === w || q === y || q === _ || q === k || q === d);
                  J.push(["space", M.slice(S, T), E, S - G, E, T - G, S]), S = T - 1;
                  break;
                case a:
                  T = S + 1, J.push(["colon", M.slice(S, T), E, S - G, E, T - G, S]), S = T - 1;
                  break;
                case r:
                  T = S + 1, J.push(["comma", M.slice(S, T), E, S - G, E, T - G, S]), S = T - 1;
                  break;
                case i:
                  J.push(["{", "{", E, S - G, E, T - G, S]);
                  break;
                case u:
                  J.push(["}", "}", E, S - G, E, T - G, S]);
                  break;
                case o:
                  b++, L = !L && b === 1 && J.length > 0 && J[J.length - 1][0] === "word" && J[J.length - 1][1] === "url", J.push(["(", "(", E, S - G, E, T - G, S]);
                  break;
                case h3:
                  b--, L = L && b > 0, J.push([")", ")", E, S - G, E, T - G, S]);
                  break;
                case l:
                case p:
                  F = q === l ? "'" : '"', T = S;
                  do
                    for (ne = false, T = M.indexOf(F, T + 1), T === -1 && ce("quote", F), oe = T; M.charCodeAt(oe - 1) === m; ) oe -= 1, ne = !ne;
                  while (ne);
                  J.push(["string", M.slice(S, T + 1), E, S - G, E, T - G, S]), S = T;
                  break;
                case x2:
                  V.lastIndex = S + 1, V.test(M), V.lastIndex === 0 ? T = M.length - 1 : T = V.lastIndex - 2, J.push(["atword", M.slice(S, T + 1), E, S - G, E, T - G, S]), S = T;
                  break;
                case m:
                  T = S, q = M.charCodeAt(T + 1), ue && q !== c && q !== w && q !== y && q !== _ && q !== k && q !== d && (T += 1), J.push(["word", M.slice(S, T + 1), E, S - G, E, T - G, S]), S = T;
                  break;
                case g:
                case f:
                case s:
                  T = S + 1, ie = M.slice(S + 1, T + 1);
                  let Ze = M.slice(S - 1, S);
                  if (q === f && ie.charCodeAt(0) === f) {
                    T++, J.push(["word", M.slice(S, T), E, S - G, E, T - G, S]), S = T - 1;
                    break;
                  }
                  J.push(["operator", M.slice(S, T), E, S - G, E, T - G, S]), S = T - 1;
                  break;
                default:
                  if (q === c && (M.charCodeAt(S + 1) === s || K.loose && !L && M.charCodeAt(S + 1) === c)) {
                    if (M.charCodeAt(S + 1) === s) T = M.indexOf("*/", S + 2) + 1, T === 0 && ce("comment", "*/");
                    else {
                      let Be = M.indexOf(`
`, S + 2);
                      T = Be !== -1 ? Be - 1 : Y;
                    }
                    te = M.slice(S, T + 1), z = te.split(`
`), ee = z.length - 1, ee > 0 ? (le = E + ee, re = T - z[ee].length) : (le = E, re = G), J.push(["comment", te, E, S - G, le, T - re, S]), G = re, E = le, S = T;
                  } else if (q === v && !j.test(M.slice(S + 1, S + 2))) T = S + 1, J.push(["#", M.slice(S, T), E, S - G, E, T - G, S]), S = T - 1;
                  else if ((q === H || q === D) && M.charCodeAt(S + 1) === g) {
                    T = S + 2;
                    do
                      T += 1, q = M.charCodeAt(T);
                    while (T < Y && C.test(M.slice(T, T + 1)));
                    J.push(["unicoderange", M.slice(S, T), E, S - G, E, T - G, S]), S = T - 1;
                  } else if (q === c) T = S + 1, J.push(["operator", M.slice(S, T), E, S - G, E, T - G, S]), S = T - 1;
                  else {
                    let _e = B;
                    if (q >= W && q <= $ && (_e = O), _e.lastIndex = S + 1, _e.test(M), _e.lastIndex === 0 ? T = M.length - 1 : T = _e.lastIndex - 2, _e === O || q === t) {
                      let Be = M.charCodeAt(T), Wt = M.charCodeAt(T + 1), Vt = M.charCodeAt(T + 2);
                      (Be === N || Be === I) && (Wt === f || Wt === g) && Vt >= W && Vt <= $ && (O.lastIndex = T + 2, O.test(M), O.lastIndex === 0 ? T = M.length - 1 : T = O.lastIndex - 2);
                    }
                    J.push(["word", M.slice(S, T + 1), E, S - G, E, T - G, S]), S = T;
                  }
                  break;
              }
              S++;
            }
            return J;
          };
        } }), jo = P({ "node_modules/flatten/index.js"(e2, n2) {
          A(), n2.exports = function(u, o) {
            if (o = typeof o == "number" ? o : 1 / 0, !o) return Array.isArray(u) ? u.map(function(l) {
              return l;
            }) : u;
            return h3(u, 1);
            function h3(l, p) {
              return l.reduce(function(m, c) {
                return Array.isArray(c) && p < o ? m.concat(h3(c, p + 1)) : m.concat(c);
              }, []);
            }
          };
        } }), Mo = P({ "node_modules/indexes-of/index.js"(e2, n2) {
          A(), n2.exports = function(i, u) {
            for (var o = -1, h3 = []; (o = i.indexOf(u, o + 1)) !== -1; ) h3.push(o);
            return h3;
          };
        } }), Do = P({ "node_modules/uniq/uniq.js"(e2, n2) {
          "use strict";
          A();
          function i(h3, l) {
            for (var p = 1, m = h3.length, c = h3[0], t = h3[0], r = 1; r < m; ++r) if (t = c, c = h3[r], l(c, t)) {
              if (r === p) {
                p++;
                continue;
              }
              h3[p++] = c;
            }
            return h3.length = p, h3;
          }
          function u(h3) {
            for (var l = 1, p = h3.length, m = h3[0], c = h3[0], t = 1; t < p; ++t, c = m) if (c = m, m = h3[t], m !== c) {
              if (t === l) {
                l++;
                continue;
              }
              h3[l++] = m;
            }
            return h3.length = l, h3;
          }
          function o(h3, l, p) {
            return h3.length === 0 ? h3 : l ? (p || h3.sort(l), i(h3, l)) : (p || h3.sort(), u(h3));
          }
          n2.exports = o;
        } }), vf = P({ "node_modules/postcss-values-parser/lib/errors/ParserError.js"(e2, n2) {
          "use strict";
          A();
          var i = class extends Error {
            constructor(u) {
              super(u), this.name = this.constructor.name, this.message = u || "An error ocurred while parsing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(u).stack;
            }
          };
          n2.exports = i;
        } }), mf = P({ "node_modules/postcss-values-parser/lib/parser.js"(e2, n2) {
          "use strict";
          A();
          var i = Vl(), u = io(), o = so(), h3 = oo(), l = ao(), p = uo(), m = co(), c = lo(), t = fo(), r = po(), a = ho(), s = vo(), f = mo(), g = df(), v = jo(), y = Mo(), w = Do(), d = vf();
          function _(k) {
            return k.sort((x2, N) => x2 - N);
          }
          n2.exports = class {
            constructor(x2, N) {
              let I = { loose: false };
              this.cache = [], this.input = x2, this.options = Object.assign({}, I, N), this.position = 0, this.unbalanced = 0, this.root = new i();
              let W = new u();
              this.root.append(W), this.current = W, this.tokens = g(x2, this.options);
            }
            parse() {
              return this.loop();
            }
            colon() {
              let x2 = this.currToken;
              this.newNode(new h3({ value: x2[1], source: { start: { line: x2[2], column: x2[3] }, end: { line: x2[4], column: x2[5] } }, sourceIndex: x2[6] })), this.position++;
            }
            comma() {
              let x2 = this.currToken;
              this.newNode(new l({ value: x2[1], source: { start: { line: x2[2], column: x2[3] }, end: { line: x2[4], column: x2[5] } }, sourceIndex: x2[6] })), this.position++;
            }
            comment() {
              let x2 = false, N = this.currToken[1].replace(/\/\*|\*\//g, ""), I;
              this.options.loose && N.startsWith("//") && (N = N.substring(2), x2 = true), I = new p({ value: N, inline: x2, source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] }), this.newNode(I), this.position++;
            }
            error(x2, N) {
              throw new d(x2 + ` at line: ${N[2]}, column ${N[3]}`);
            }
            loop() {
              for (; this.position < this.tokens.length; ) this.parseTokens();
              return !this.current.last && this.spaces ? this.current.raws.before += this.spaces : this.spaces && (this.current.last.raws.after += this.spaces), this.spaces = "", this.root;
            }
            operator() {
              let x2 = this.currToken[1], N;
              if (x2 === "+" || x2 === "-") {
                if (this.options.loose || this.position > 0 && (this.current.type === "func" && this.current.value === "calc" ? this.prevToken[0] !== "space" && this.prevToken[0] !== "(" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] !== "space" && this.nextToken[0] !== "word" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] === "word" && this.current.last.type !== "operator" && this.current.last.value !== "(" && this.error("Syntax Error", this.currToken) : (this.nextToken[0] === "space" || this.nextToken[0] === "operator" || this.prevToken[0] === "operator") && this.error("Syntax Error", this.currToken)), this.options.loose) {
                  if ((!this.current.nodes.length || this.current.last && this.current.last.type === "operator") && this.nextToken[0] === "word") return this.word();
                } else if (this.nextToken[0] === "word") return this.word();
              }
              return N = new t({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), this.position++, this.newNode(N);
            }
            parseTokens() {
              switch (this.currToken[0]) {
                case "space":
                  this.space();
                  break;
                case "colon":
                  this.colon();
                  break;
                case "comma":
                  this.comma();
                  break;
                case "comment":
                  this.comment();
                  break;
                case "(":
                  this.parenOpen();
                  break;
                case ")":
                  this.parenClose();
                  break;
                case "atword":
                case "word":
                  this.word();
                  break;
                case "operator":
                  this.operator();
                  break;
                case "string":
                  this.string();
                  break;
                case "unicoderange":
                  this.unicodeRange();
                  break;
                default:
                  this.word();
                  break;
              }
            }
            parenOpen() {
              let x2 = 1, N = this.position + 1, I = this.currToken, W;
              for (; N < this.tokens.length && x2; ) {
                let $ = this.tokens[N];
                $[0] === "(" && x2++, $[0] === ")" && x2--, N++;
              }
              if (x2 && this.error("Expected closing parenthesis", I), W = this.current.last, W && W.type === "func" && W.unbalanced < 0 && (W.unbalanced = 0, this.current = W), this.current.unbalanced++, this.newNode(new r({ value: I[1], source: { start: { line: I[2], column: I[3] }, end: { line: I[4], column: I[5] } }, sourceIndex: I[6] })), this.position++, this.current.type === "func" && this.current.unbalanced && this.current.value === "url" && this.currToken[0] !== "string" && this.currToken[0] !== ")" && !this.options.loose) {
                let $ = this.nextToken, H = this.currToken[1], D = { line: this.currToken[2], column: this.currToken[3] };
                for (; $ && $[0] !== ")" && this.current.unbalanced; ) this.position++, H += this.currToken[1], $ = this.nextToken;
                this.position !== this.tokens.length - 1 && (this.position++, this.newNode(new s({ value: H, source: { start: D, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })));
              }
            }
            parenClose() {
              let x2 = this.currToken;
              this.newNode(new r({ value: x2[1], source: { start: { line: x2[2], column: x2[3] }, end: { line: x2[4], column: x2[5] } }, sourceIndex: x2[6] })), this.position++, !(this.position >= this.tokens.length - 1 && !this.current.unbalanced) && (this.current.unbalanced--, this.current.unbalanced < 0 && this.error("Expected opening parenthesis", x2), !this.current.unbalanced && this.cache.length && (this.current = this.cache.pop()));
            }
            space() {
              let x2 = this.currToken;
              this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.raws.after += x2[1], this.position++) : (this.spaces = x2[1], this.position++);
            }
            unicodeRange() {
              let x2 = this.currToken;
              this.newNode(new f({ value: x2[1], source: { start: { line: x2[2], column: x2[3] }, end: { line: x2[4], column: x2[5] } }, sourceIndex: x2[6] })), this.position++;
            }
            splitWord() {
              let x2 = this.nextToken, N = this.currToken[1], I = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/, W = /^(?!\#([a-z0-9]+))[\#\{\}]/gi, $, H;
              if (!W.test(N)) for (; x2 && x2[0] === "word"; ) {
                this.position++;
                let D = this.currToken[1];
                N += D, x2 = this.nextToken;
              }
              $ = y(N, "@"), H = _(w(v([[0], $]))), H.forEach((D, V) => {
                let B = H[V + 1] || N.length, O = N.slice(D, B), j;
                if (~$.indexOf(D)) j = new o({ value: O.slice(1), source: { start: { line: this.currToken[2], column: this.currToken[3] + D }, end: { line: this.currToken[4], column: this.currToken[3] + (B - 1) } }, sourceIndex: this.currToken[6] + H[V] });
                else if (I.test(this.currToken[1])) {
                  let C = O.replace(I, "");
                  j = new c({ value: O.replace(C, ""), source: { start: { line: this.currToken[2], column: this.currToken[3] + D }, end: { line: this.currToken[4], column: this.currToken[3] + (B - 1) } }, sourceIndex: this.currToken[6] + H[V], unit: C });
                } else j = new (x2 && x2[0] === "(" ? m : s)({ value: O, source: { start: { line: this.currToken[2], column: this.currToken[3] + D }, end: { line: this.currToken[4], column: this.currToken[3] + (B - 1) } }, sourceIndex: this.currToken[6] + H[V] }), j.type === "word" ? (j.isHex = /^#(.+)/.test(O), j.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(O)) : this.cache.push(this.current);
                this.newNode(j);
              }), this.position++;
            }
            string() {
              let x2 = this.currToken, N = this.currToken[1], I = /^(\"|\')/, W = I.test(N), $ = "", H;
              W && ($ = N.match(I)[0], N = N.slice(1, N.length - 1)), H = new a({ value: N, source: { start: { line: x2[2], column: x2[3] }, end: { line: x2[4], column: x2[5] } }, sourceIndex: x2[6], quoted: W }), H.raws.quote = $, this.newNode(H), this.position++;
            }
            word() {
              return this.splitWord();
            }
            newNode(x2) {
              return this.spaces && (x2.raws.before += this.spaces, this.spaces = ""), this.current.append(x2);
            }
            get currToken() {
              return this.tokens[this.position];
            }
            get nextToken() {
              return this.tokens[this.position + 1];
            }
            get prevToken() {
              return this.tokens[this.position - 1];
            }
          };
        } }), gf = P({ "node_modules/postcss-values-parser/lib/index.js"(e2, n2) {
          "use strict";
          A();
          var i = mf(), u = so(), o = oo(), h3 = ao(), l = uo(), p = co(), m = lo(), c = fo(), t = po(), r = ho(), a = mo(), s = io(), f = vo(), g = function(v, y) {
            return new i(v, y);
          };
          g.atword = function(v) {
            return new u(v);
          }, g.colon = function(v) {
            return new o(Object.assign({ value: ":" }, v));
          }, g.comma = function(v) {
            return new h3(Object.assign({ value: "," }, v));
          }, g.comment = function(v) {
            return new l(v);
          }, g.func = function(v) {
            return new p(v);
          }, g.number = function(v) {
            return new m(v);
          }, g.operator = function(v) {
            return new c(v);
          }, g.paren = function(v) {
            return new t(Object.assign({ value: "(" }, v));
          }, g.string = function(v) {
            return new r(Object.assign({ quote: "'" }, v));
          }, g.value = function(v) {
            return new s(v);
          }, g.word = function(v) {
            return new f(v);
          }, g.unicodeRange = function(v) {
            return new a(v);
          }, n2.exports = g;
        } }), ze = P({ "node_modules/postcss-selector-parser/dist/selectors/node.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true;
          var i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
            return typeof l;
          } : function(l) {
            return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
          };
          function u(l, p) {
            if (!(l instanceof p)) throw new TypeError("Cannot call a class as a function");
          }
          var o = function l(p, m) {
            if ((typeof p > "u" ? "undefined" : i(p)) !== "object") return p;
            var c = new p.constructor();
            for (var t in p) if (p.hasOwnProperty(t)) {
              var r = p[t], a = typeof r > "u" ? "undefined" : i(r);
              t === "parent" && a === "object" ? m && (c[t] = m) : r instanceof Array ? c[t] = r.map(function(s) {
                return l(s, c);
              }) : c[t] = l(r, c);
            }
            return c;
          }, h3 = function() {
            function l() {
              var p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              u(this, l);
              for (var m in p) this[m] = p[m];
              var c = p.spaces;
              c = c === void 0 ? {} : c;
              var t = c.before, r = t === void 0 ? "" : t, a = c.after, s = a === void 0 ? "" : a;
              this.spaces = { before: r, after: s };
            }
            return l.prototype.remove = function() {
              return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
            }, l.prototype.replaceWith = function() {
              if (this.parent) {
                for (var m in arguments) this.parent.insertBefore(this, arguments[m]);
                this.remove();
              }
              return this;
            }, l.prototype.next = function() {
              return this.parent.at(this.parent.index(this) + 1);
            }, l.prototype.prev = function() {
              return this.parent.at(this.parent.index(this) - 1);
            }, l.prototype.clone = function() {
              var m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, c = o(this);
              for (var t in m) c[t] = m[t];
              return c;
            }, l.prototype.toString = function() {
              return [this.spaces.before, String(this.value), this.spaces.after].join("");
            }, l;
          }();
          e2.default = h3, n2.exports = e2.default;
        } }), se = P({ "node_modules/postcss-selector-parser/dist/selectors/types.js"(e2) {
          "use strict";
          A(), e2.__esModule = true;
          var n2 = e2.TAG = "tag", i = e2.STRING = "string", u = e2.SELECTOR = "selector", o = e2.ROOT = "root", h3 = e2.PSEUDO = "pseudo", l = e2.NESTING = "nesting", p = e2.ID = "id", m = e2.COMMENT = "comment", c = e2.COMBINATOR = "combinator", t = e2.CLASS = "class", r = e2.ATTRIBUTE = "attribute", a = e2.UNIVERSAL = "universal";
        } }), Dt = P({ "node_modules/postcss-selector-parser/dist/selectors/container.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true;
          var i = /* @__PURE__ */ function() {
            function s(f, g) {
              for (var v = 0; v < g.length; v++) {
                var y = g[v];
                y.enumerable = y.enumerable || false, y.configurable = true, "value" in y && (y.writable = true), Object.defineProperty(f, y.key, y);
              }
            }
            return function(f, g, v) {
              return g && s(f.prototype, g), v && s(f, v), f;
            };
          }(), u = ze(), o = m(u), h3 = se(), l = p(h3);
          function p(s) {
            if (s && s.__esModule) return s;
            var f = {};
            if (s != null) for (var g in s) Object.prototype.hasOwnProperty.call(s, g) && (f[g] = s[g]);
            return f.default = s, f;
          }
          function m(s) {
            return s && s.__esModule ? s : { default: s };
          }
          function c(s, f) {
            if (!(s instanceof f)) throw new TypeError("Cannot call a class as a function");
          }
          function t(s, f) {
            if (!s) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return f && (typeof f == "object" || typeof f == "function") ? f : s;
          }
          function r(s, f) {
            if (typeof f != "function" && f !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof f);
            s.prototype = Object.create(f && f.prototype, { constructor: { value: s, enumerable: false, writable: true, configurable: true } }), f && (Object.setPrototypeOf ? Object.setPrototypeOf(s, f) : s.__proto__ = f);
          }
          var a = function(s) {
            r(f, s);
            function f(g) {
              c(this, f);
              var v = t(this, s.call(this, g));
              return v.nodes || (v.nodes = []), v;
            }
            return f.prototype.append = function(v) {
              return v.parent = this, this.nodes.push(v), this;
            }, f.prototype.prepend = function(v) {
              return v.parent = this, this.nodes.unshift(v), this;
            }, f.prototype.at = function(v) {
              return this.nodes[v];
            }, f.prototype.index = function(v) {
              return typeof v == "number" ? v : this.nodes.indexOf(v);
            }, f.prototype.removeChild = function(v) {
              v = this.index(v), this.at(v).parent = void 0, this.nodes.splice(v, 1);
              var y = void 0;
              for (var w in this.indexes) y = this.indexes[w], y >= v && (this.indexes[w] = y - 1);
              return this;
            }, f.prototype.removeAll = function() {
              for (var w = this.nodes, v = Array.isArray(w), y = 0, w = v ? w : w[Symbol.iterator](); ; ) {
                var d;
                if (v) {
                  if (y >= w.length) break;
                  d = w[y++];
                } else {
                  if (y = w.next(), y.done) break;
                  d = y.value;
                }
                var _ = d;
                _.parent = void 0;
              }
              return this.nodes = [], this;
            }, f.prototype.empty = function() {
              return this.removeAll();
            }, f.prototype.insertAfter = function(v, y) {
              var w = this.index(v);
              this.nodes.splice(w + 1, 0, y);
              var d = void 0;
              for (var _ in this.indexes) d = this.indexes[_], w <= d && (this.indexes[_] = d + this.nodes.length);
              return this;
            }, f.prototype.insertBefore = function(v, y) {
              var w = this.index(v);
              this.nodes.splice(w, 0, y);
              var d = void 0;
              for (var _ in this.indexes) d = this.indexes[_], w <= d && (this.indexes[_] = d + this.nodes.length);
              return this;
            }, f.prototype.each = function(v) {
              this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
              var y = this.lastEach;
              if (this.indexes[y] = 0, !!this.length) {
                for (var w = void 0, d = void 0; this.indexes[y] < this.length && (w = this.indexes[y], d = v(this.at(w), w), d !== false); ) this.indexes[y] += 1;
                if (delete this.indexes[y], d === false) return false;
              }
            }, f.prototype.walk = function(v) {
              return this.each(function(y, w) {
                var d = v(y, w);
                if (d !== false && y.length && (d = y.walk(v)), d === false) return false;
              });
            }, f.prototype.walkAttributes = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === l.ATTRIBUTE) return v.call(y, w);
              });
            }, f.prototype.walkClasses = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === l.CLASS) return v.call(y, w);
              });
            }, f.prototype.walkCombinators = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === l.COMBINATOR) return v.call(y, w);
              });
            }, f.prototype.walkComments = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === l.COMMENT) return v.call(y, w);
              });
            }, f.prototype.walkIds = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === l.ID) return v.call(y, w);
              });
            }, f.prototype.walkNesting = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === l.NESTING) return v.call(y, w);
              });
            }, f.prototype.walkPseudos = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === l.PSEUDO) return v.call(y, w);
              });
            }, f.prototype.walkTags = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === l.TAG) return v.call(y, w);
              });
            }, f.prototype.walkUniversals = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === l.UNIVERSAL) return v.call(y, w);
              });
            }, f.prototype.split = function(v) {
              var y = this, w = [];
              return this.reduce(function(d, _, k) {
                var x2 = v.call(y, _);
                return w.push(_), x2 ? (d.push(w), w = []) : k === y.length - 1 && d.push(w), d;
              }, []);
            }, f.prototype.map = function(v) {
              return this.nodes.map(v);
            }, f.prototype.reduce = function(v, y) {
              return this.nodes.reduce(v, y);
            }, f.prototype.every = function(v) {
              return this.nodes.every(v);
            }, f.prototype.some = function(v) {
              return this.nodes.some(v);
            }, f.prototype.filter = function(v) {
              return this.nodes.filter(v);
            }, f.prototype.sort = function(v) {
              return this.nodes.sort(v);
            }, f.prototype.toString = function() {
              return this.map(String).join("");
            }, i(f, [{ key: "first", get: function() {
              return this.at(0);
            } }, { key: "last", get: function() {
              return this.at(this.length - 1);
            } }, { key: "length", get: function() {
              return this.nodes.length;
            } }]), f;
          }(o.default);
          e2.default = a, n2.exports = e2.default;
        } }), Lo = P({ "node_modules/postcss-selector-parser/dist/selectors/root.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true;
          var i = Dt(), u = h3(i), o = se();
          function h3(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function m(t, r) {
            if (typeof r != "function" && r !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            m(r, t);
            function r(a) {
              l(this, r);
              var s = p(this, t.call(this, a));
              return s.type = o.ROOT, s;
            }
            return r.prototype.toString = function() {
              var s = this.reduce(function(f, g) {
                var v = String(g);
                return v ? f + v + "," : "";
              }, "").slice(0, -1);
              return this.trailingComma ? s + "," : s;
            }, r;
          }(u.default);
          e2.default = c, n2.exports = e2.default;
        } }), zo = P({ "node_modules/postcss-selector-parser/dist/selectors/selector.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true;
          var i = Dt(), u = h3(i), o = se();
          function h3(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function m(t, r) {
            if (typeof r != "function" && r !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            m(r, t);
            function r(a) {
              l(this, r);
              var s = p(this, t.call(this, a));
              return s.type = o.SELECTOR, s;
            }
            return r;
          }(u.default);
          e2.default = c, n2.exports = e2.default;
        } }), Ye = P({ "node_modules/postcss-selector-parser/dist/selectors/namespace.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true;
          var i = /* @__PURE__ */ function() {
            function t(r, a) {
              for (var s = 0; s < a.length; s++) {
                var f = a[s];
                f.enumerable = f.enumerable || false, f.configurable = true, "value" in f && (f.writable = true), Object.defineProperty(r, f.key, f);
              }
            }
            return function(r, a, s) {
              return a && t(r.prototype, a), s && t(r, s), r;
            };
          }(), u = ze(), o = h3(u);
          function h3(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function m(t, r) {
            if (typeof r != "function" && r !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            m(r, t);
            function r() {
              return l(this, r), p(this, t.apply(this, arguments));
            }
            return r.prototype.toString = function() {
              return [this.spaces.before, this.ns, String(this.value), this.spaces.after].join("");
            }, i(r, [{ key: "ns", get: function() {
              var s = this.namespace;
              return s ? (typeof s == "string" ? s : "") + "|" : "";
            } }]), r;
          }(o.default);
          e2.default = c, n2.exports = e2.default;
        } }), Bo = P({ "node_modules/postcss-selector-parser/dist/selectors/className.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true;
          var i = Ye(), u = h3(i), o = se();
          function h3(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function m(t, r) {
            if (typeof r != "function" && r !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            m(r, t);
            function r(a) {
              l(this, r);
              var s = p(this, t.call(this, a));
              return s.type = o.CLASS, s;
            }
            return r.prototype.toString = function() {
              return [this.spaces.before, this.ns, String("." + this.value), this.spaces.after].join("");
            }, r;
          }(u.default);
          e2.default = c, n2.exports = e2.default;
        } }), Fo = P({ "node_modules/postcss-selector-parser/dist/selectors/comment.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true;
          var i = ze(), u = h3(i), o = se();
          function h3(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function m(t, r) {
            if (typeof r != "function" && r !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            m(r, t);
            function r(a) {
              l(this, r);
              var s = p(this, t.call(this, a));
              return s.type = o.COMMENT, s;
            }
            return r;
          }(u.default);
          e2.default = c, n2.exports = e2.default;
        } }), Uo = P({ "node_modules/postcss-selector-parser/dist/selectors/id.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true;
          var i = Ye(), u = h3(i), o = se();
          function h3(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function m(t, r) {
            if (typeof r != "function" && r !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            m(r, t);
            function r(a) {
              l(this, r);
              var s = p(this, t.call(this, a));
              return s.type = o.ID, s;
            }
            return r.prototype.toString = function() {
              return [this.spaces.before, this.ns, String("#" + this.value), this.spaces.after].join("");
            }, r;
          }(u.default);
          e2.default = c, n2.exports = e2.default;
        } }), $o = P({ "node_modules/postcss-selector-parser/dist/selectors/tag.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true;
          var i = Ye(), u = h3(i), o = se();
          function h3(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function m(t, r) {
            if (typeof r != "function" && r !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            m(r, t);
            function r(a) {
              l(this, r);
              var s = p(this, t.call(this, a));
              return s.type = o.TAG, s;
            }
            return r;
          }(u.default);
          e2.default = c, n2.exports = e2.default;
        } }), Wo = P({ "node_modules/postcss-selector-parser/dist/selectors/string.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true;
          var i = ze(), u = h3(i), o = se();
          function h3(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function m(t, r) {
            if (typeof r != "function" && r !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            m(r, t);
            function r(a) {
              l(this, r);
              var s = p(this, t.call(this, a));
              return s.type = o.STRING, s;
            }
            return r;
          }(u.default);
          e2.default = c, n2.exports = e2.default;
        } }), Vo = P({ "node_modules/postcss-selector-parser/dist/selectors/pseudo.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true;
          var i = Dt(), u = h3(i), o = se();
          function h3(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function m(t, r) {
            if (typeof r != "function" && r !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            m(r, t);
            function r(a) {
              l(this, r);
              var s = p(this, t.call(this, a));
              return s.type = o.PSEUDO, s;
            }
            return r.prototype.toString = function() {
              var s = this.length ? "(" + this.map(String).join(",") + ")" : "";
              return [this.spaces.before, String(this.value), s, this.spaces.after].join("");
            }, r;
          }(u.default);
          e2.default = c, n2.exports = e2.default;
        } }), Go = P({ "node_modules/postcss-selector-parser/dist/selectors/attribute.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true;
          var i = Ye(), u = h3(i), o = se();
          function h3(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function m(t, r) {
            if (typeof r != "function" && r !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            m(r, t);
            function r(a) {
              l(this, r);
              var s = p(this, t.call(this, a));
              return s.type = o.ATTRIBUTE, s.raws = {}, s;
            }
            return r.prototype.toString = function() {
              var s = [this.spaces.before, "[", this.ns, this.attribute];
              return this.operator && s.push(this.operator), this.value && s.push(this.value), this.raws.insensitive ? s.push(this.raws.insensitive) : this.insensitive && s.push(" i"), s.push("]"), s.concat(this.spaces.after).join("");
            }, r;
          }(u.default);
          e2.default = c, n2.exports = e2.default;
        } }), Ho = P({ "node_modules/postcss-selector-parser/dist/selectors/universal.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true;
          var i = Ye(), u = h3(i), o = se();
          function h3(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function m(t, r) {
            if (typeof r != "function" && r !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            m(r, t);
            function r(a) {
              l(this, r);
              var s = p(this, t.call(this, a));
              return s.type = o.UNIVERSAL, s.value = "*", s;
            }
            return r;
          }(u.default);
          e2.default = c, n2.exports = e2.default;
        } }), Jo = P({ "node_modules/postcss-selector-parser/dist/selectors/combinator.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true;
          var i = ze(), u = h3(i), o = se();
          function h3(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function m(t, r) {
            if (typeof r != "function" && r !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            m(r, t);
            function r(a) {
              l(this, r);
              var s = p(this, t.call(this, a));
              return s.type = o.COMBINATOR, s;
            }
            return r;
          }(u.default);
          e2.default = c, n2.exports = e2.default;
        } }), Ko = P({ "node_modules/postcss-selector-parser/dist/selectors/nesting.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true;
          var i = ze(), u = h3(i), o = se();
          function h3(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function m(t, r) {
            if (typeof r != "function" && r !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            m(r, t);
            function r(a) {
              l(this, r);
              var s = p(this, t.call(this, a));
              return s.type = o.NESTING, s.value = "&", s;
            }
            return r;
          }(u.default);
          e2.default = c, n2.exports = e2.default;
        } }), yf = P({ "node_modules/postcss-selector-parser/dist/sortAscending.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true, e2.default = i;
          function i(u) {
            return u.sort(function(o, h3) {
              return o - h3;
            });
          }
          n2.exports = e2.default;
        } }), wf = P({ "node_modules/postcss-selector-parser/dist/tokenize.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true, e2.default = H;
          var i = 39, u = 34, o = 92, h3 = 47, l = 10, p = 32, m = 12, c = 9, t = 13, r = 43, a = 62, s = 126, f = 124, g = 44, v = 40, y = 41, w = 91, d = 93, _ = 59, k = 42, x2 = 58, N = 38, I = 64, W = /[ \n\t\r\{\(\)'"\\;/]/g, $ = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
          function H(D) {
            for (var V = [], B = D.css.valueOf(), O = void 0, j = void 0, C = void 0, R = void 0, X = void 0, Z = void 0, Q = void 0, K = void 0, J = void 0, M = void 0, Y = void 0, G = B.length, E = -1, S = 1, b = 0, L = function(T, F) {
              if (D.safe) B += F, j = B.length - 1;
              else throw D.error("Unclosed " + T, S, b - E, b);
            }; b < G; ) {
              switch (O = B.charCodeAt(b), O === l && (E = b, S += 1), O) {
                case l:
                case p:
                case c:
                case t:
                case m:
                  j = b;
                  do
                    j += 1, O = B.charCodeAt(j), O === l && (E = j, S += 1);
                  while (O === p || O === l || O === c || O === t || O === m);
                  V.push(["space", B.slice(b, j), S, b - E, b]), b = j - 1;
                  break;
                case r:
                case a:
                case s:
                case f:
                  j = b;
                  do
                    j += 1, O = B.charCodeAt(j);
                  while (O === r || O === a || O === s || O === f);
                  V.push(["combinator", B.slice(b, j), S, b - E, b]), b = j - 1;
                  break;
                case k:
                  V.push(["*", "*", S, b - E, b]);
                  break;
                case N:
                  V.push(["&", "&", S, b - E, b]);
                  break;
                case g:
                  V.push([",", ",", S, b - E, b]);
                  break;
                case w:
                  V.push(["[", "[", S, b - E, b]);
                  break;
                case d:
                  V.push(["]", "]", S, b - E, b]);
                  break;
                case x2:
                  V.push([":", ":", S, b - E, b]);
                  break;
                case _:
                  V.push([";", ";", S, b - E, b]);
                  break;
                case v:
                  V.push(["(", "(", S, b - E, b]);
                  break;
                case y:
                  V.push([")", ")", S, b - E, b]);
                  break;
                case i:
                case u:
                  C = O === i ? "'" : '"', j = b;
                  do
                    for (M = false, j = B.indexOf(C, j + 1), j === -1 && L("quote", C), Y = j; B.charCodeAt(Y - 1) === o; ) Y -= 1, M = !M;
                  while (M);
                  V.push(["string", B.slice(b, j + 1), S, b - E, S, j - E, b]), b = j;
                  break;
                case I:
                  W.lastIndex = b + 1, W.test(B), W.lastIndex === 0 ? j = B.length - 1 : j = W.lastIndex - 2, V.push(["at-word", B.slice(b, j + 1), S, b - E, S, j - E, b]), b = j;
                  break;
                case o:
                  for (j = b, Q = true; B.charCodeAt(j + 1) === o; ) j += 1, Q = !Q;
                  O = B.charCodeAt(j + 1), Q && O !== h3 && O !== p && O !== l && O !== c && O !== t && O !== m && (j += 1), V.push(["word", B.slice(b, j + 1), S, b - E, S, j - E, b]), b = j;
                  break;
                default:
                  O === h3 && B.charCodeAt(b + 1) === k ? (j = B.indexOf("*/", b + 2) + 1, j === 0 && L("comment", "*/"), Z = B.slice(b, j + 1), R = Z.split(`
`), X = R.length - 1, X > 0 ? (K = S + X, J = j - R[X].length) : (K = S, J = E), V.push(["comment", Z, S, b - E, K, j - J, b]), E = J, S = K, b = j) : ($.lastIndex = b + 1, $.test(B), $.lastIndex === 0 ? j = B.length - 1 : j = $.lastIndex - 2, V.push(["word", B.slice(b, j + 1), S, b - E, S, j - E, b]), b = j);
                  break;
              }
              b++;
            }
            return V;
          }
          n2.exports = e2.default;
        } }), _f = P({ "node_modules/postcss-selector-parser/dist/parser.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true;
          var i = /* @__PURE__ */ function() {
            function E(S, b) {
              for (var L = 0; L < b.length; L++) {
                var q = b[L];
                q.enumerable = q.enumerable || false, q.configurable = true, "value" in q && (q.writable = true), Object.defineProperty(S, q.key, q);
              }
            }
            return function(S, b, L) {
              return b && E(S.prototype, b), L && E(S, L), S;
            };
          }(), u = jo(), o = M(u), h3 = Mo(), l = M(h3), p = Do(), m = M(p), c = Lo(), t = M(c), r = zo(), a = M(r), s = Bo(), f = M(s), g = Fo(), v = M(g), y = Uo(), w = M(y), d = $o(), _ = M(d), k = Wo(), x2 = M(k), N = Vo(), I = M(N), W = Go(), $ = M(W), H = Ho(), D = M(H), V = Jo(), B = M(V), O = Ko(), j = M(O), C = yf(), R = M(C), X = wf(), Z = M(X), Q = se(), K = J(Q);
          function J(E) {
            if (E && E.__esModule) return E;
            var S = {};
            if (E != null) for (var b in E) Object.prototype.hasOwnProperty.call(E, b) && (S[b] = E[b]);
            return S.default = E, S;
          }
          function M(E) {
            return E && E.__esModule ? E : { default: E };
          }
          function Y(E, S) {
            if (!(E instanceof S)) throw new TypeError("Cannot call a class as a function");
          }
          var G = function() {
            function E(S) {
              Y(this, E), this.input = S, this.lossy = S.options.lossless === false, this.position = 0, this.root = new t.default();
              var b = new a.default();
              return this.root.append(b), this.current = b, this.lossy ? this.tokens = (0, Z.default)({ safe: S.safe, css: S.css.trim() }) : this.tokens = (0, Z.default)(S), this.loop();
            }
            return E.prototype.attribute = function() {
              var b = "", L = void 0, q = this.currToken;
              for (this.position++; this.position < this.tokens.length && this.currToken[0] !== "]"; ) b += this.tokens[this.position][1], this.position++;
              this.position === this.tokens.length && !~b.indexOf("]") && this.error("Expected a closing square bracket.");
              var T = b.split(/((?:[*~^$|]?=))([^]*)/), F = T[0].split(/(\|)/g), z = { operator: T[1], value: T[2], source: { start: { line: q[2], column: q[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: q[4] };
              if (F.length > 1 ? (F[0] === "" && (F[0] = true), z.attribute = this.parseValue(F[2]), z.namespace = this.parseNamespace(F[0])) : z.attribute = this.parseValue(T[0]), L = new $.default(z), T[2]) {
                var ee = T[2].split(/(\s+i\s*?)$/), te = ee[0].trim();
                L.value = this.lossy ? te : ee[0], ee[1] && (L.insensitive = true, this.lossy || (L.raws.insensitive = ee[1])), L.quoted = te[0] === "'" || te[0] === '"', L.raws.unquoted = L.quoted ? te.slice(1, -1) : te;
              }
              this.newNode(L), this.position++;
            }, E.prototype.combinator = function() {
              if (this.currToken[1] === "|") return this.namespace();
              for (var b = new B.default({ value: "", source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }); this.position < this.tokens.length && this.currToken && (this.currToken[0] === "space" || this.currToken[0] === "combinator"); ) this.nextToken && this.nextToken[0] === "combinator" ? (b.spaces.before = this.parseSpace(this.currToken[1]), b.source.start.line = this.nextToken[2], b.source.start.column = this.nextToken[3], b.source.end.column = this.nextToken[3], b.source.end.line = this.nextToken[2], b.sourceIndex = this.nextToken[4]) : this.prevToken && this.prevToken[0] === "combinator" ? b.spaces.after = this.parseSpace(this.currToken[1]) : this.currToken[0] === "combinator" ? b.value = this.currToken[1] : this.currToken[0] === "space" && (b.value = this.parseSpace(this.currToken[1], " ")), this.position++;
              return this.newNode(b);
            }, E.prototype.comma = function() {
              if (this.position === this.tokens.length - 1) {
                this.root.trailingComma = true, this.position++;
                return;
              }
              var b = new a.default();
              this.current.parent.append(b), this.current = b, this.position++;
            }, E.prototype.comment = function() {
              var b = new v.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] });
              this.newNode(b), this.position++;
            }, E.prototype.error = function(b) {
              throw new this.input.error(b);
            }, E.prototype.missingBackslash = function() {
              return this.error("Expected a backslash preceding the semicolon.");
            }, E.prototype.missingParenthesis = function() {
              return this.error("Expected opening parenthesis.");
            }, E.prototype.missingSquareBracket = function() {
              return this.error("Expected opening square bracket.");
            }, E.prototype.namespace = function() {
              var b = this.prevToken && this.prevToken[1] || true;
              if (this.nextToken[0] === "word") return this.position++, this.word(b);
              if (this.nextToken[0] === "*") return this.position++, this.universal(b);
            }, E.prototype.nesting = function() {
              this.newNode(new j.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++;
            }, E.prototype.parentheses = function() {
              var b = this.current.last;
              if (b && b.type === K.PSEUDO) {
                var L = new a.default(), q = this.current;
                b.append(L), this.current = L;
                var T = 1;
                for (this.position++; this.position < this.tokens.length && T; ) this.currToken[0] === "(" && T++, this.currToken[0] === ")" && T--, T ? this.parse() : (L.parent.source.end.line = this.currToken[2], L.parent.source.end.column = this.currToken[3], this.position++);
                T && this.error("Expected closing parenthesis."), this.current = q;
              } else {
                var F = 1;
                for (this.position++, b.value += "("; this.position < this.tokens.length && F; ) this.currToken[0] === "(" && F++, this.currToken[0] === ")" && F--, b.value += this.parseParenthesisToken(this.currToken), this.position++;
                F && this.error("Expected closing parenthesis.");
              }
            }, E.prototype.pseudo = function() {
              for (var b = this, L = "", q = this.currToken; this.currToken && this.currToken[0] === ":"; ) L += this.currToken[1], this.position++;
              if (!this.currToken) return this.error("Expected pseudo-class or pseudo-element");
              if (this.currToken[0] === "word") {
                var T = void 0;
                this.splitWord(false, function(F, z) {
                  L += F, T = new I.default({ value: L, source: { start: { line: q[2], column: q[3] }, end: { line: b.currToken[4], column: b.currToken[5] } }, sourceIndex: q[4] }), b.newNode(T), z > 1 && b.nextToken && b.nextToken[0] === "(" && b.error("Misplaced parenthesis.");
                });
              } else this.error('Unexpected "' + this.currToken[0] + '" found.');
            }, E.prototype.space = function() {
              var b = this.currToken;
              this.position === 0 || this.prevToken[0] === "," || this.prevToken[0] === "(" ? (this.spaces = this.parseSpace(b[1]), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.spaces.after = this.parseSpace(b[1]), this.position++) : this.combinator();
            }, E.prototype.string = function() {
              var b = this.currToken;
              this.newNode(new x2.default({ value: this.currToken[1], source: { start: { line: b[2], column: b[3] }, end: { line: b[4], column: b[5] } }, sourceIndex: b[6] })), this.position++;
            }, E.prototype.universal = function(b) {
              var L = this.nextToken;
              if (L && L[1] === "|") return this.position++, this.namespace();
              this.newNode(new D.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), b), this.position++;
            }, E.prototype.splitWord = function(b, L) {
              for (var q = this, T = this.nextToken, F = this.currToken[1]; T && T[0] === "word"; ) {
                this.position++;
                var z = this.currToken[1];
                if (F += z, z.lastIndexOf("\\") === z.length - 1) {
                  var ee = this.nextToken;
                  ee && ee[0] === "space" && (F += this.parseSpace(ee[1], " "), this.position++);
                }
                T = this.nextToken;
              }
              var te = (0, l.default)(F, "."), ue = (0, l.default)(F, "#"), le = (0, l.default)(F, "#{");
              le.length && (ue = ue.filter(function(ne) {
                return !~le.indexOf(ne);
              }));
              var re = (0, R.default)((0, m.default)((0, o.default)([[0], te, ue])));
              re.forEach(function(ne, oe) {
                var ie = re[oe + 1] || F.length, ce = F.slice(ne, ie);
                if (oe === 0 && L) return L.call(q, ce, re.length);
                var fe = void 0;
                ~te.indexOf(ne) ? fe = new f.default({ value: ce.slice(1), source: { start: { line: q.currToken[2], column: q.currToken[3] + ne }, end: { line: q.currToken[4], column: q.currToken[3] + (ie - 1) } }, sourceIndex: q.currToken[6] + re[oe] }) : ~ue.indexOf(ne) ? fe = new w.default({ value: ce.slice(1), source: { start: { line: q.currToken[2], column: q.currToken[3] + ne }, end: { line: q.currToken[4], column: q.currToken[3] + (ie - 1) } }, sourceIndex: q.currToken[6] + re[oe] }) : fe = new _.default({ value: ce, source: { start: { line: q.currToken[2], column: q.currToken[3] + ne }, end: { line: q.currToken[4], column: q.currToken[3] + (ie - 1) } }, sourceIndex: q.currToken[6] + re[oe] }), q.newNode(fe, b);
              }), this.position++;
            }, E.prototype.word = function(b) {
              var L = this.nextToken;
              return L && L[1] === "|" ? (this.position++, this.namespace()) : this.splitWord(b);
            }, E.prototype.loop = function() {
              for (; this.position < this.tokens.length; ) this.parse(true);
              return this.root;
            }, E.prototype.parse = function(b) {
              switch (this.currToken[0]) {
                case "space":
                  this.space();
                  break;
                case "comment":
                  this.comment();
                  break;
                case "(":
                  this.parentheses();
                  break;
                case ")":
                  b && this.missingParenthesis();
                  break;
                case "[":
                  this.attribute();
                  break;
                case "]":
                  this.missingSquareBracket();
                  break;
                case "at-word":
                case "word":
                  this.word();
                  break;
                case ":":
                  this.pseudo();
                  break;
                case ";":
                  this.missingBackslash();
                  break;
                case ",":
                  this.comma();
                  break;
                case "*":
                  this.universal();
                  break;
                case "&":
                  this.nesting();
                  break;
                case "combinator":
                  this.combinator();
                  break;
                case "string":
                  this.string();
                  break;
              }
            }, E.prototype.parseNamespace = function(b) {
              if (this.lossy && typeof b == "string") {
                var L = b.trim();
                return L.length ? L : true;
              }
              return b;
            }, E.prototype.parseSpace = function(b, L) {
              return this.lossy ? L || "" : b;
            }, E.prototype.parseValue = function(b) {
              return this.lossy && b && typeof b == "string" ? b.trim() : b;
            }, E.prototype.parseParenthesisToken = function(b) {
              return this.lossy ? b[0] === "space" ? this.parseSpace(b[1], " ") : this.parseValue(b[1]) : b[1];
            }, E.prototype.newNode = function(b, L) {
              return L && (b.namespace = this.parseNamespace(L)), this.spaces && (b.spaces.before = this.spaces, this.spaces = ""), this.current.append(b);
            }, i(E, [{ key: "currToken", get: function() {
              return this.tokens[this.position];
            } }, { key: "nextToken", get: function() {
              return this.tokens[this.position + 1];
            } }, { key: "prevToken", get: function() {
              return this.tokens[this.position - 1];
            } }]), E;
          }();
          e2.default = G, n2.exports = e2.default;
        } }), bf = P({ "node_modules/postcss-selector-parser/dist/processor.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true;
          var i = /* @__PURE__ */ function() {
            function m(c, t) {
              for (var r = 0; r < t.length; r++) {
                var a = t[r];
                a.enumerable = a.enumerable || false, a.configurable = true, "value" in a && (a.writable = true), Object.defineProperty(c, a.key, a);
              }
            }
            return function(c, t, r) {
              return t && m(c.prototype, t), r && m(c, r), c;
            };
          }(), u = _f(), o = h3(u);
          function h3(m) {
            return m && m.__esModule ? m : { default: m };
          }
          function l(m, c) {
            if (!(m instanceof c)) throw new TypeError("Cannot call a class as a function");
          }
          var p = function() {
            function m(c) {
              return l(this, m), this.func = c || function() {
              }, this;
            }
            return m.prototype.process = function(t) {
              var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a = new o.default({ css: t, error: function(f) {
                throw new Error(f);
              }, options: r });
              return this.res = a, this.func(a), this;
            }, i(m, [{ key: "result", get: function() {
              return String(this.res);
            } }]), m;
          }();
          e2.default = p, n2.exports = e2.default;
        } }), xf = P({ "node_modules/postcss-selector-parser/dist/index.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true;
          var i = bf(), u = O(i), o = Go(), h3 = O(o), l = Bo(), p = O(l), m = Jo(), c = O(m), t = Fo(), r = O(t), a = Uo(), s = O(a), f = Ko(), g = O(f), v = Vo(), y = O(v), w = Lo(), d = O(w), _ = zo(), k = O(_), x2 = Wo(), N = O(x2), I = $o(), W = O(I), $ = Ho(), H = O($), D = se(), V = B(D);
          function B(C) {
            if (C && C.__esModule) return C;
            var R = {};
            if (C != null) for (var X in C) Object.prototype.hasOwnProperty.call(C, X) && (R[X] = C[X]);
            return R.default = C, R;
          }
          function O(C) {
            return C && C.__esModule ? C : { default: C };
          }
          var j = function(R) {
            return new u.default(R);
          };
          j.attribute = function(C) {
            return new h3.default(C);
          }, j.className = function(C) {
            return new p.default(C);
          }, j.combinator = function(C) {
            return new c.default(C);
          }, j.comment = function(C) {
            return new r.default(C);
          }, j.id = function(C) {
            return new s.default(C);
          }, j.nesting = function(C) {
            return new g.default(C);
          }, j.pseudo = function(C) {
            return new y.default(C);
          }, j.root = function(C) {
            return new d.default(C);
          }, j.selector = function(C) {
            return new k.default(C);
          }, j.string = function(C) {
            return new N.default(C);
          }, j.tag = function(C) {
            return new W.default(C);
          }, j.universal = function(C) {
            return new H.default(C);
          }, Object.keys(V).forEach(function(C) {
            C !== "__esModule" && (j[C] = V[C]);
          }), e2.default = j, n2.exports = e2.default;
        } }), Qo = P({ "node_modules/postcss-media-query-parser/dist/nodes/Node.js"(e2) {
          "use strict";
          A(), Object.defineProperty(e2, "__esModule", { value: true });
          function n2(i) {
            this.after = i.after, this.before = i.before, this.type = i.type, this.value = i.value, this.sourceIndex = i.sourceIndex;
          }
          e2.default = n2;
        } }), Yo = P({ "node_modules/postcss-media-query-parser/dist/nodes/Container.js"(e2) {
          "use strict";
          A(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = Qo(), i = u(n2);
          function u(h3) {
            return h3 && h3.__esModule ? h3 : { default: h3 };
          }
          function o(h3) {
            var l = this;
            this.constructor(h3), this.nodes = h3.nodes, this.after === void 0 && (this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ""), this.before === void 0 && (this.before = this.nodes.length > 0 ? this.nodes[0].before : ""), this.sourceIndex === void 0 && (this.sourceIndex = this.before.length), this.nodes.forEach(function(p) {
              p.parent = l;
            });
          }
          o.prototype = Object.create(i.default.prototype), o.constructor = i.default, o.prototype.walk = function(l, p) {
            for (var m = typeof l == "string" || l instanceof RegExp, c = m ? p : l, t = typeof l == "string" ? new RegExp(l) : l, r = 0; r < this.nodes.length; r++) {
              var a = this.nodes[r], s = m ? t.test(a.type) : true;
              if (s && c && c(a, r, this.nodes) === false || a.nodes && a.walk(l, p) === false) return false;
            }
            return true;
          }, o.prototype.each = function() {
            for (var l = arguments.length <= 0 || arguments[0] === void 0 ? function() {
            } : arguments[0], p = 0; p < this.nodes.length; p++) {
              var m = this.nodes[p];
              if (l(m, p, this.nodes) === false) return false;
            }
            return true;
          }, e2.default = o;
        } }), Sf = P({ "node_modules/postcss-media-query-parser/dist/parsers.js"(e2) {
          "use strict";
          A(), Object.defineProperty(e2, "__esModule", { value: true }), e2.parseMediaFeature = l, e2.parseMediaQuery = p, e2.parseMediaList = m;
          var n2 = Qo(), i = h3(n2), u = Yo(), o = h3(u);
          function h3(c) {
            return c && c.__esModule ? c : { default: c };
          }
          function l(c) {
            var t = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], r = [{ mode: "normal", character: null }], a = [], s = 0, f = "", g = null, v = null, y = t, w = c;
            c[0] === "(" && c[c.length - 1] === ")" && (w = c.substring(1, c.length - 1), y++);
            for (var d = 0; d < w.length; d++) {
              var _ = w[d];
              if ((_ === "'" || _ === '"') && (r[s].isCalculationEnabled === true ? (r.push({ mode: "string", isCalculationEnabled: false, character: _ }), s++) : r[s].mode === "string" && r[s].character === _ && w[d - 1] !== "\\" && (r.pop(), s--)), _ === "{" ? (r.push({ mode: "interpolation", isCalculationEnabled: true }), s++) : _ === "}" && (r.pop(), s--), r[s].mode === "normal" && _ === ":") {
                var k = w.substring(d + 1);
                v = { type: "value", before: /^(\s*)/.exec(k)[1], after: /(\s*)$/.exec(k)[1], value: k.trim() }, v.sourceIndex = v.before.length + d + 1 + y, g = { type: "colon", sourceIndex: d + y, after: v.before, value: ":" };
                break;
              }
              f += _;
            }
            return f = { type: "media-feature", before: /^(\s*)/.exec(f)[1], after: /(\s*)$/.exec(f)[1], value: f.trim() }, f.sourceIndex = f.before.length + y, a.push(f), g !== null && (g.before = f.after, a.push(g)), v !== null && a.push(v), a;
          }
          function p(c) {
            var t = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], r = [], a = 0, s = false, f = void 0;
            function g() {
              return { before: "", after: "", value: "" };
            }
            f = g();
            for (var v = 0; v < c.length; v++) {
              var y = c[v];
              s ? (f.value += y, (y === "{" || y === "(") && a++, (y === ")" || y === "}") && a--) : y.search(/\s/) !== -1 ? f.before += y : (y === "(" && (f.type = "media-feature-expression", a++), f.value = y, f.sourceIndex = t + v, s = true), s && a === 0 && (y === ")" || v === c.length - 1 || c[v + 1].search(/\s/) !== -1) && (["not", "only", "and"].indexOf(f.value) !== -1 && (f.type = "keyword"), f.type === "media-feature-expression" && (f.nodes = l(f.value, f.sourceIndex)), r.push(Array.isArray(f.nodes) ? new o.default(f) : new i.default(f)), f = g(), s = false);
            }
            for (var w = 0; w < r.length; w++) if (f = r[w], w > 0 && (r[w - 1].after = f.before), f.type === void 0) {
              if (w > 0) {
                if (r[w - 1].type === "media-feature-expression") {
                  f.type = "keyword";
                  continue;
                }
                if (r[w - 1].value === "not" || r[w - 1].value === "only") {
                  f.type = "media-type";
                  continue;
                }
                if (r[w - 1].value === "and") {
                  f.type = "media-feature-expression";
                  continue;
                }
                r[w - 1].type === "media-type" && (r[w + 1] ? f.type = r[w + 1].type === "media-feature-expression" ? "keyword" : "media-feature-expression" : f.type = "media-feature-expression");
              }
              if (w === 0) {
                if (!r[w + 1]) {
                  f.type = "media-type";
                  continue;
                }
                if (r[w + 1] && (r[w + 1].type === "media-feature-expression" || r[w + 1].type === "keyword")) {
                  f.type = "media-type";
                  continue;
                }
                if (r[w + 2]) {
                  if (r[w + 2].type === "media-feature-expression") {
                    f.type = "media-type", r[w + 1].type = "keyword";
                    continue;
                  }
                  if (r[w + 2].type === "keyword") {
                    f.type = "keyword", r[w + 1].type = "media-type";
                    continue;
                  }
                }
                if (r[w + 3] && r[w + 3].type === "media-feature-expression") {
                  f.type = "keyword", r[w + 1].type = "media-type", r[w + 2].type = "keyword";
                  continue;
                }
              }
            }
            return r;
          }
          function m(c) {
            var t = [], r = 0, a = 0, s = /^(\s*)url\s*\(/.exec(c);
            if (s !== null) {
              for (var f = s[0].length, g = 1; g > 0; ) {
                var v = c[f];
                v === "(" && g++, v === ")" && g--, f++;
              }
              t.unshift(new i.default({ type: "url", value: c.substring(0, f).trim(), sourceIndex: s[1].length, before: s[1], after: /^(\s*)/.exec(c.substring(f))[1] })), r = f;
            }
            for (var y = r; y < c.length; y++) {
              var w = c[y];
              if (w === "(" && a++, w === ")" && a--, a === 0 && w === ",") {
                var d = c.substring(r, y), _ = /^(\s*)/.exec(d)[1];
                t.push(new o.default({ type: "media-query", value: d.trim(), sourceIndex: r + _.length, nodes: p(d, r), before: _, after: /(\s*)$/.exec(d)[1] })), r = y + 1;
              }
            }
            var k = c.substring(r), x2 = /^(\s*)/.exec(k)[1];
            return t.push(new o.default({ type: "media-query", value: k.trim(), sourceIndex: r + x2.length, nodes: p(k, r), before: x2, after: /(\s*)$/.exec(k)[1] })), t;
          }
        } }), kf = P({ "node_modules/postcss-media-query-parser/dist/index.js"(e2) {
          "use strict";
          A(), Object.defineProperty(e2, "__esModule", { value: true }), e2.default = h3;
          var n2 = Yo(), i = o(n2), u = Sf();
          function o(l) {
            return l && l.__esModule ? l : { default: l };
          }
          function h3(l) {
            return new i.default({ nodes: (0, u.parseMediaList)(l), type: "media-query-list", value: l.trim() });
          }
        } }), Xo = {};
        At(Xo, { basename: () => na, default: () => sa, delimiter: () => kt, dirname: () => ta, extname: () => ia, isAbsolute: () => zt, join: () => ea, normalize: () => Lt, relative: () => ra, resolve: () => yr, sep: () => St });
        function Zo(e2, n2) {
          for (var i = 0, u = e2.length - 1; u >= 0; u--) {
            var o = e2[u];
            o === "." ? e2.splice(u, 1) : o === ".." ? (e2.splice(u, 1), i++) : i && (e2.splice(u, 1), i--);
          }
          if (n2) for (; i--; i) e2.unshift("..");
          return e2;
        }
        function yr() {
          for (var e2 = "", n2 = false, i = arguments.length - 1; i >= -1 && !n2; i--) {
            var u = i >= 0 ? arguments[i] : "/";
            if (typeof u != "string") throw new TypeError("Arguments to path.resolve must be strings");
            if (!u) continue;
            e2 = u + "/" + e2, n2 = u.charAt(0) === "/";
          }
          return e2 = Zo(Bt(e2.split("/"), function(o) {
            return !!o;
          }), !n2).join("/"), (n2 ? "/" : "") + e2 || ".";
        }
        function Lt(e2) {
          var n2 = zt(e2), i = oa(e2, -1) === "/";
          return e2 = Zo(Bt(e2.split("/"), function(u) {
            return !!u;
          }), !n2).join("/"), !e2 && !n2 && (e2 = "."), e2 && i && (e2 += "/"), (n2 ? "/" : "") + e2;
        }
        function zt(e2) {
          return e2.charAt(0) === "/";
        }
        function ea() {
          var e2 = Array.prototype.slice.call(arguments, 0);
          return Lt(Bt(e2, function(n2, i) {
            if (typeof n2 != "string") throw new TypeError("Arguments to path.join must be strings");
            return n2;
          }).join("/"));
        }
        function ra(e2, n2) {
          e2 = yr(e2).substr(1), n2 = yr(n2).substr(1);
          function i(c) {
            for (var t = 0; t < c.length && c[t] === ""; t++) ;
            for (var r = c.length - 1; r >= 0 && c[r] === ""; r--) ;
            return t > r ? [] : c.slice(t, r - t + 1);
          }
          for (var u = i(e2.split("/")), o = i(n2.split("/")), h3 = Math.min(u.length, o.length), l = h3, p = 0; p < h3; p++) if (u[p] !== o[p]) {
            l = p;
            break;
          }
          for (var m = [], p = l; p < u.length; p++) m.push("..");
          return m = m.concat(o.slice(l)), m.join("/");
        }
        function ta(e2) {
          var n2 = br(e2), i = n2[0], u = n2[1];
          return !i && !u ? "." : (u && (u = u.substr(0, u.length - 1)), i + u);
        }
        function na(e2, n2) {
          var i = br(e2)[2];
          return n2 && i.substr(-1 * n2.length) === n2 && (i = i.substr(0, i.length - n2.length)), i;
        }
        function ia(e2) {
          return br(e2)[3];
        }
        function Bt(e2, n2) {
          if (e2.filter) return e2.filter(n2);
          for (var i = [], u = 0; u < e2.length; u++) n2(e2[u], u, e2) && i.push(e2[u]);
          return i;
        }
        var Fs, br, St, kt, sa, oa, Of = Le({ "node-modules-polyfills:path"() {
          A(), Fs = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, br = function(e2) {
            return Fs.exec(e2).slice(1);
          }, St = "/", kt = ":", sa = { extname: ia, basename: na, dirname: ta, sep: St, delimiter: kt, relative: ra, join: ea, isAbsolute: zt, normalize: Lt, resolve: yr }, oa = "ab".substr(-1) === "b" ? function(e2, n2, i) {
            return e2.substr(n2, i);
          } : function(e2, n2, i) {
            return n2 < 0 && (n2 = e2.length + n2), e2.substr(n2, i);
          };
        } }), Tf = P({ "node-modules-polyfills-commonjs:path"(e2, n2) {
          A();
          var i = (Of(), Pt(Xo));
          if (i && i.default) {
            n2.exports = i.default;
            for (let u in i) n2.exports[u] = i[u];
          } else i && (n2.exports = i);
        } }), Ef = P({ "node_modules/picocolors/picocolors.browser.js"(e2, n2) {
          A();
          var i = String, u = function() {
            return { isColorSupported: false, reset: i, bold: i, dim: i, italic: i, underline: i, inverse: i, hidden: i, strikethrough: i, black: i, red: i, green: i, yellow: i, blue: i, magenta: i, cyan: i, white: i, gray: i, bgBlack: i, bgRed: i, bgGreen: i, bgYellow: i, bgBlue: i, bgMagenta: i, bgCyan: i, bgWhite: i };
          };
          n2.exports = u(), n2.exports.createColors = u;
        } }), qf = P({ "(disabled):node_modules/postcss/lib/terminal-highlight"() {
          A();
        } }), aa = P({ "node_modules/postcss/lib/css-syntax-error.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var i = o(Ef()), u = o(qf());
          function o(g) {
            return g && g.__esModule ? g : { default: g };
          }
          function h3(g) {
            if (g === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return g;
          }
          function l(g, v) {
            g.prototype = Object.create(v.prototype), g.prototype.constructor = g, g.__proto__ = v;
          }
          function p(g) {
            var v = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
            return p = function(w) {
              if (w === null || !t(w)) return w;
              if (typeof w != "function") throw new TypeError("Super expression must either be null or a function");
              if (typeof v < "u") {
                if (v.has(w)) return v.get(w);
                v.set(w, d);
              }
              function d() {
                return m(w, arguments, a(this).constructor);
              }
              return d.prototype = Object.create(w.prototype, { constructor: { value: d, enumerable: false, writable: true, configurable: true } }), r(d, w);
            }, p(g);
          }
          function m(g, v, y) {
            return c() ? m = Reflect.construct : m = function(d, _, k) {
              var x2 = [null];
              x2.push.apply(x2, _);
              var N = Function.bind.apply(d, x2), I = new N();
              return k && r(I, k.prototype), I;
            }, m.apply(null, arguments);
          }
          function c() {
            if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return false;
            if (typeof Proxy == "function") return true;
            try {
              return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
              })), true;
            } catch (e3) {
              return false;
            }
          }
          function t(g) {
            return Function.toString.call(g).indexOf("[native code]") !== -1;
          }
          function r(g, v) {
            return r = Object.setPrototypeOf || function(w, d) {
              return w.__proto__ = d, w;
            }, r(g, v);
          }
          function a(g) {
            return a = Object.setPrototypeOf ? Object.getPrototypeOf : function(y) {
              return y.__proto__ || Object.getPrototypeOf(y);
            }, a(g);
          }
          var s = function(g) {
            l(v, g);
            function v(w, d, _, k, x2, N) {
              var I;
              return I = g.call(this, w) || this, I.name = "CssSyntaxError", I.reason = w, x2 && (I.file = x2), k && (I.source = k), N && (I.plugin = N), typeof d < "u" && typeof _ < "u" && (I.line = d, I.column = _), I.setMessage(), Error.captureStackTrace && Error.captureStackTrace(h3(I), v), I;
            }
            var y = v.prototype;
            return y.setMessage = function() {
              this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
            }, y.showSourceCode = function(d) {
              var _ = this;
              if (!this.source) return "";
              var k = this.source;
              u.default && (typeof d > "u" && (d = i.default.isColorSupported), d && (k = (0, u.default)(k)));
              var x2 = k.split(/\r?\n/), N = Math.max(this.line - 3, 0), I = Math.min(this.line + 2, x2.length), W = String(I).length;
              function $(D) {
                return d && i.default.red ? i.default.red(i.default.bold(D)) : D;
              }
              function H(D) {
                return d && i.default.gray ? i.default.gray(D) : D;
              }
              return x2.slice(N, I).map(function(D, V) {
                var B = N + 1 + V, O = " " + (" " + B).slice(-W) + " | ";
                if (B === _.line) {
                  var j = H(O.replace(/\d/g, " ")) + D.slice(0, _.column - 1).replace(/[^\t]/g, " ");
                  return $(">") + H(O) + D + `
 ` + j + $("^");
                }
                return " " + H(O) + D;
              }).join(`
`);
            }, y.toString = function() {
              var d = this.showSourceCode();
              return d && (d = `

` + d + `
`), this.name + ": " + this.message + d;
            }, v;
          }(p(Error)), f = s;
          e2.default = f, n2.exports = e2.default;
        } }), Af = P({ "node_modules/postcss/lib/previous-map.js"(e2, n2) {
          A(), n2.exports = class {
          };
        } }), xr = P({ "node_modules/postcss/lib/input.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var i = h3(Tf()), u = h3(aa()), o = h3(Af());
          function h3(r) {
            return r && r.__esModule ? r : { default: r };
          }
          function l(r, a) {
            for (var s = 0; s < a.length; s++) {
              var f = a[s];
              f.enumerable = f.enumerable || false, f.configurable = true, "value" in f && (f.writable = true), Object.defineProperty(r, f.key, f);
            }
          }
          function p(r, a, s) {
            return a && l(r.prototype, a), s && l(r, s), r;
          }
          var m = 0, c = function() {
            function r(s, f) {
              if (f === void 0 && (f = {}), s === null || typeof s > "u" || typeof s == "object" && !s.toString) throw new Error("PostCSS received " + s + " instead of CSS string");
              this.css = s.toString(), this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, f.from && (/^\w+:\/\//.test(f.from) || i.default.isAbsolute(f.from) ? this.file = f.from : this.file = i.default.resolve(f.from));
              var g = new o.default(this.css, f);
              if (g.text) {
                this.map = g;
                var v = g.consumer().file;
                !this.file && v && (this.file = this.mapResolve(v));
              }
              this.file || (m += 1, this.id = "<input css " + m + ">"), this.map && (this.map.file = this.from);
            }
            var a = r.prototype;
            return a.error = function(f, g, v, y) {
              y === void 0 && (y = {});
              var w, d = this.origin(g, v);
              return d ? w = new u.default(f, d.line, d.column, d.source, d.file, y.plugin) : w = new u.default(f, g, v, this.css, this.file, y.plugin), w.input = { line: g, column: v, source: this.css }, this.file && (w.input.file = this.file), w;
            }, a.origin = function(f, g) {
              if (!this.map) return false;
              var v = this.map.consumer(), y = v.originalPositionFor({ line: f, column: g });
              if (!y.source) return false;
              var w = { file: this.mapResolve(y.source), line: y.line, column: y.column }, d = v.sourceContentFor(y.source);
              return d && (w.source = d), w;
            }, a.mapResolve = function(f) {
              return /^\w+:\/\//.test(f) ? f : i.default.resolve(this.map.consumer().sourceRoot || ".", f);
            }, p(r, [{ key: "from", get: function() {
              return this.file || this.id;
            } }]), r;
          }(), t = c;
          e2.default = t, n2.exports = e2.default;
        } }), Sr = P({ "node_modules/postcss/lib/stringifier.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var i = { colon: ": ", indent: "    ", beforeDecl: `
`, beforeRule: `
`, beforeOpen: " ", beforeClose: `
`, beforeComment: `
`, after: `
`, emptyBody: "", commentLeft: " ", commentRight: " ", semicolon: false };
          function u(l) {
            return l[0].toUpperCase() + l.slice(1);
          }
          var o = function() {
            function l(m) {
              this.builder = m;
            }
            var p = l.prototype;
            return p.stringify = function(c, t) {
              this[c.type](c, t);
            }, p.root = function(c) {
              this.body(c), c.raws.after && this.builder(c.raws.after);
            }, p.comment = function(c) {
              var t = this.raw(c, "left", "commentLeft"), r = this.raw(c, "right", "commentRight");
              this.builder("/*" + t + c.text + r + "*/", c);
            }, p.decl = function(c, t) {
              var r = this.raw(c, "between", "colon"), a = c.prop + r + this.rawValue(c, "value");
              c.important && (a += c.raws.important || " !important"), t && (a += ";"), this.builder(a, c);
            }, p.rule = function(c) {
              this.block(c, this.rawValue(c, "selector")), c.raws.ownSemicolon && this.builder(c.raws.ownSemicolon, c, "end");
            }, p.atrule = function(c, t) {
              var r = "@" + c.name, a = c.params ? this.rawValue(c, "params") : "";
              if (typeof c.raws.afterName < "u" ? r += c.raws.afterName : a && (r += " "), c.nodes) this.block(c, r + a);
              else {
                var s = (c.raws.between || "") + (t ? ";" : "");
                this.builder(r + a + s, c);
              }
            }, p.body = function(c) {
              for (var t = c.nodes.length - 1; t > 0 && c.nodes[t].type === "comment"; ) t -= 1;
              for (var r = this.raw(c, "semicolon"), a = 0; a < c.nodes.length; a++) {
                var s = c.nodes[a], f = this.raw(s, "before");
                f && this.builder(f), this.stringify(s, t !== a || r);
              }
            }, p.block = function(c, t) {
              var r = this.raw(c, "between", "beforeOpen");
              this.builder(t + r + "{", c, "start");
              var a;
              c.nodes && c.nodes.length ? (this.body(c), a = this.raw(c, "after")) : a = this.raw(c, "after", "emptyBody"), a && this.builder(a), this.builder("}", c, "end");
            }, p.raw = function(c, t, r) {
              var a;
              if (r || (r = t), t && (a = c.raws[t], typeof a < "u")) return a;
              var s = c.parent;
              if (r === "before" && (!s || s.type === "root" && s.first === c)) return "";
              if (!s) return i[r];
              var f = c.root();
              if (f.rawCache || (f.rawCache = {}), typeof f.rawCache[r] < "u") return f.rawCache[r];
              if (r === "before" || r === "after") return this.beforeAfter(c, r);
              var g = "raw" + u(r);
              return this[g] ? a = this[g](f, c) : f.walk(function(v) {
                if (a = v.raws[t], typeof a < "u") return false;
              }), typeof a > "u" && (a = i[r]), f.rawCache[r] = a, a;
            }, p.rawSemicolon = function(c) {
              var t;
              return c.walk(function(r) {
                if (r.nodes && r.nodes.length && r.last.type === "decl" && (t = r.raws.semicolon, typeof t < "u")) return false;
              }), t;
            }, p.rawEmptyBody = function(c) {
              var t;
              return c.walk(function(r) {
                if (r.nodes && r.nodes.length === 0 && (t = r.raws.after, typeof t < "u")) return false;
              }), t;
            }, p.rawIndent = function(c) {
              if (c.raws.indent) return c.raws.indent;
              var t;
              return c.walk(function(r) {
                var a = r.parent;
                if (a && a !== c && a.parent && a.parent === c && typeof r.raws.before < "u") {
                  var s = r.raws.before.split(`
`);
                  return t = s[s.length - 1], t = t.replace(/[^\s]/g, ""), false;
                }
              }), t;
            }, p.rawBeforeComment = function(c, t) {
              var r;
              return c.walkComments(function(a) {
                if (typeof a.raws.before < "u") return r = a.raws.before, r.indexOf(`
`) !== -1 && (r = r.replace(/[^\n]+$/, "")), false;
              }), typeof r > "u" ? r = this.raw(t, null, "beforeDecl") : r && (r = r.replace(/[^\s]/g, "")), r;
            }, p.rawBeforeDecl = function(c, t) {
              var r;
              return c.walkDecls(function(a) {
                if (typeof a.raws.before < "u") return r = a.raws.before, r.indexOf(`
`) !== -1 && (r = r.replace(/[^\n]+$/, "")), false;
              }), typeof r > "u" ? r = this.raw(t, null, "beforeRule") : r && (r = r.replace(/[^\s]/g, "")), r;
            }, p.rawBeforeRule = function(c) {
              var t;
              return c.walk(function(r) {
                if (r.nodes && (r.parent !== c || c.first !== r) && typeof r.raws.before < "u") return t = r.raws.before, t.indexOf(`
`) !== -1 && (t = t.replace(/[^\n]+$/, "")), false;
              }), t && (t = t.replace(/[^\s]/g, "")), t;
            }, p.rawBeforeClose = function(c) {
              var t;
              return c.walk(function(r) {
                if (r.nodes && r.nodes.length > 0 && typeof r.raws.after < "u") return t = r.raws.after, t.indexOf(`
`) !== -1 && (t = t.replace(/[^\n]+$/, "")), false;
              }), t && (t = t.replace(/[^\s]/g, "")), t;
            }, p.rawBeforeOpen = function(c) {
              var t;
              return c.walk(function(r) {
                if (r.type !== "decl" && (t = r.raws.between, typeof t < "u")) return false;
              }), t;
            }, p.rawColon = function(c) {
              var t;
              return c.walkDecls(function(r) {
                if (typeof r.raws.between < "u") return t = r.raws.between.replace(/[^\s:]/g, ""), false;
              }), t;
            }, p.beforeAfter = function(c, t) {
              var r;
              c.type === "decl" ? r = this.raw(c, null, "beforeDecl") : c.type === "comment" ? r = this.raw(c, null, "beforeComment") : t === "before" ? r = this.raw(c, null, "beforeRule") : r = this.raw(c, null, "beforeClose");
              for (var a = c.parent, s = 0; a && a.type !== "root"; ) s += 1, a = a.parent;
              if (r.indexOf(`
`) !== -1) {
                var f = this.raw(c, null, "indent");
                if (f.length) for (var g = 0; g < s; g++) r += f;
              }
              return r;
            }, p.rawValue = function(c, t) {
              var r = c[t], a = c.raws[t];
              return a && a.value === r ? a.raw : r;
            }, l;
          }(), h3 = o;
          e2.default = h3, n2.exports = e2.default;
        } }), ua = P({ "node_modules/postcss/lib/stringify.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var i = u(Sr());
          function u(l) {
            return l && l.__esModule ? l : { default: l };
          }
          function o(l, p) {
            var m = new i.default(p);
            m.stringify(l);
          }
          var h3 = o;
          e2.default = h3, n2.exports = e2.default;
        } }), Ft = P({ "node_modules/postcss/lib/node.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var i = h3(aa()), u = h3(Sr()), o = h3(ua());
          function h3(c) {
            return c && c.__esModule ? c : { default: c };
          }
          function l(c, t) {
            var r = new c.constructor();
            for (var a in c) if (c.hasOwnProperty(a)) {
              var s = c[a], f = typeof s;
              a === "parent" && f === "object" ? t && (r[a] = t) : a === "source" ? r[a] = s : s instanceof Array ? r[a] = s.map(function(g) {
                return l(g, r);
              }) : (f === "object" && s !== null && (s = l(s)), r[a] = s);
            }
            return r;
          }
          var p = function() {
            function c(r) {
              r === void 0 && (r = {}), this.raws = {};
              for (var a in r) this[a] = r[a];
            }
            var t = c.prototype;
            return t.error = function(a, s) {
              if (s === void 0 && (s = {}), this.source) {
                var f = this.positionBy(s);
                return this.source.input.error(a, f.line, f.column, s);
              }
              return new i.default(a);
            }, t.warn = function(a, s, f) {
              var g = { node: this };
              for (var v in f) g[v] = f[v];
              return a.warn(s, g);
            }, t.remove = function() {
              return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
            }, t.toString = function(a) {
              a === void 0 && (a = o.default), a.stringify && (a = a.stringify);
              var s = "";
              return a(this, function(f) {
                s += f;
              }), s;
            }, t.clone = function(a) {
              a === void 0 && (a = {});
              var s = l(this);
              for (var f in a) s[f] = a[f];
              return s;
            }, t.cloneBefore = function(a) {
              a === void 0 && (a = {});
              var s = this.clone(a);
              return this.parent.insertBefore(this, s), s;
            }, t.cloneAfter = function(a) {
              a === void 0 && (a = {});
              var s = this.clone(a);
              return this.parent.insertAfter(this, s), s;
            }, t.replaceWith = function() {
              if (this.parent) {
                for (var a = arguments.length, s = new Array(a), f = 0; f < a; f++) s[f] = arguments[f];
                for (var g = 0, v = s; g < v.length; g++) {
                  var y = v[g];
                  this.parent.insertBefore(this, y);
                }
                this.remove();
              }
              return this;
            }, t.next = function() {
              if (this.parent) {
                var a = this.parent.index(this);
                return this.parent.nodes[a + 1];
              }
            }, t.prev = function() {
              if (this.parent) {
                var a = this.parent.index(this);
                return this.parent.nodes[a - 1];
              }
            }, t.before = function(a) {
              return this.parent.insertBefore(this, a), this;
            }, t.after = function(a) {
              return this.parent.insertAfter(this, a), this;
            }, t.toJSON = function() {
              var a = {};
              for (var s in this) if (this.hasOwnProperty(s) && s !== "parent") {
                var f = this[s];
                f instanceof Array ? a[s] = f.map(function(g) {
                  return typeof g == "object" && g.toJSON ? g.toJSON() : g;
                }) : typeof f == "object" && f.toJSON ? a[s] = f.toJSON() : a[s] = f;
              }
              return a;
            }, t.raw = function(a, s) {
              var f = new u.default();
              return f.raw(this, a, s);
            }, t.root = function() {
              for (var a = this; a.parent; ) a = a.parent;
              return a;
            }, t.cleanRaws = function(a) {
              delete this.raws.before, delete this.raws.after, a || delete this.raws.between;
            }, t.positionInside = function(a) {
              for (var s = this.toString(), f = this.source.start.column, g = this.source.start.line, v = 0; v < a; v++) s[v] === `
` ? (f = 1, g += 1) : f += 1;
              return { line: g, column: f };
            }, t.positionBy = function(a) {
              var s = this.source.start;
              if (a.index) s = this.positionInside(a.index);
              else if (a.word) {
                var f = this.toString().indexOf(a.word);
                f !== -1 && (s = this.positionInside(f));
              }
              return s;
            }, c;
          }(), m = p;
          e2.default = m, n2.exports = e2.default;
        } }), kr = P({ "node_modules/postcss/lib/comment.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var i = u(Ft());
          function u(p) {
            return p && p.__esModule ? p : { default: p };
          }
          function o(p, m) {
            p.prototype = Object.create(m.prototype), p.prototype.constructor = p, p.__proto__ = m;
          }
          var h3 = function(p) {
            o(m, p);
            function m(c) {
              var t;
              return t = p.call(this, c) || this, t.type = "comment", t;
            }
            return m;
          }(i.default), l = h3;
          e2.default = l, n2.exports = e2.default;
        } }), ca = P({ "node_modules/postcss/lib/declaration.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var i = u(Ft());
          function u(p) {
            return p && p.__esModule ? p : { default: p };
          }
          function o(p, m) {
            p.prototype = Object.create(m.prototype), p.prototype.constructor = p, p.__proto__ = m;
          }
          var h3 = function(p) {
            o(m, p);
            function m(c) {
              var t;
              return t = p.call(this, c) || this, t.type = "decl", t;
            }
            return m;
          }(i.default), l = h3;
          e2.default = l, n2.exports = e2.default;
        } }), Ut = P({ "node_modules/postcss/lib/tokenize.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true, e2.default = W;
          var i = "'".charCodeAt(0), u = '"'.charCodeAt(0), o = "\\".charCodeAt(0), h3 = "/".charCodeAt(0), l = `
`.charCodeAt(0), p = " ".charCodeAt(0), m = "\f".charCodeAt(0), c = "	".charCodeAt(0), t = "\r".charCodeAt(0), r = "[".charCodeAt(0), a = "]".charCodeAt(0), s = "(".charCodeAt(0), f = ")".charCodeAt(0), g = "{".charCodeAt(0), v = "}".charCodeAt(0), y = ";".charCodeAt(0), w = "*".charCodeAt(0), d = ":".charCodeAt(0), _ = "@".charCodeAt(0), k = /[ \n\t\r\f{}()'"\\;/[\]#]/g, x2 = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g, N = /.[\\/("'\n]/, I = /[a-f0-9]/i;
          function W($, H) {
            H === void 0 && (H = {});
            var D = $.css.valueOf(), V = H.ignoreErrors, B, O, j, C, R, X, Z, Q, K, J, M, Y, G, E, S = D.length, b = -1, L = 1, q = 0, T = [], F = [];
            function z() {
              return q;
            }
            function ee(re) {
              throw $.error("Unclosed " + re, L, q - b);
            }
            function te() {
              return F.length === 0 && q >= S;
            }
            function ue(re) {
              if (F.length) return F.pop();
              if (!(q >= S)) {
                var ne = re ? re.ignoreUnclosed : false;
                switch (B = D.charCodeAt(q), (B === l || B === m || B === t && D.charCodeAt(q + 1) !== l) && (b = q, L += 1), B) {
                  case l:
                  case p:
                  case c:
                  case t:
                  case m:
                    O = q;
                    do
                      O += 1, B = D.charCodeAt(O), B === l && (b = O, L += 1);
                    while (B === p || B === l || B === c || B === t || B === m);
                    E = ["space", D.slice(q, O)], q = O - 1;
                    break;
                  case r:
                  case a:
                  case g:
                  case v:
                  case d:
                  case y:
                  case f:
                    var oe = String.fromCharCode(B);
                    E = [oe, oe, L, q - b];
                    break;
                  case s:
                    if (Y = T.length ? T.pop()[1] : "", G = D.charCodeAt(q + 1), Y === "url" && G !== i && G !== u && G !== p && G !== l && G !== c && G !== m && G !== t) {
                      O = q;
                      do {
                        if (J = false, O = D.indexOf(")", O + 1), O === -1) if (V || ne) {
                          O = q;
                          break;
                        } else ee("bracket");
                        for (M = O; D.charCodeAt(M - 1) === o; ) M -= 1, J = !J;
                      } while (J);
                      E = ["brackets", D.slice(q, O + 1), L, q - b, L, O - b], q = O;
                    } else O = D.indexOf(")", q + 1), X = D.slice(q, O + 1), O === -1 || N.test(X) ? E = ["(", "(", L, q - b] : (E = ["brackets", X, L, q - b, L, O - b], q = O);
                    break;
                  case i:
                  case u:
                    j = B === i ? "'" : '"', O = q;
                    do {
                      if (J = false, O = D.indexOf(j, O + 1), O === -1) if (V || ne) {
                        O = q + 1;
                        break;
                      } else ee("string");
                      for (M = O; D.charCodeAt(M - 1) === o; ) M -= 1, J = !J;
                    } while (J);
                    X = D.slice(q, O + 1), C = X.split(`
`), R = C.length - 1, R > 0 ? (Q = L + R, K = O - C[R].length) : (Q = L, K = b), E = ["string", D.slice(q, O + 1), L, q - b, Q, O - K], b = K, L = Q, q = O;
                    break;
                  case _:
                    k.lastIndex = q + 1, k.test(D), k.lastIndex === 0 ? O = D.length - 1 : O = k.lastIndex - 2, E = ["at-word", D.slice(q, O + 1), L, q - b, L, O - b], q = O;
                    break;
                  case o:
                    for (O = q, Z = true; D.charCodeAt(O + 1) === o; ) O += 1, Z = !Z;
                    if (B = D.charCodeAt(O + 1), Z && B !== h3 && B !== p && B !== l && B !== c && B !== t && B !== m && (O += 1, I.test(D.charAt(O)))) {
                      for (; I.test(D.charAt(O + 1)); ) O += 1;
                      D.charCodeAt(O + 1) === p && (O += 1);
                    }
                    E = ["word", D.slice(q, O + 1), L, q - b, L, O - b], q = O;
                    break;
                  default:
                    B === h3 && D.charCodeAt(q + 1) === w ? (O = D.indexOf("*/", q + 2) + 1, O === 0 && (V || ne ? O = D.length : ee("comment")), X = D.slice(q, O + 1), C = X.split(`
`), R = C.length - 1, R > 0 ? (Q = L + R, K = O - C[R].length) : (Q = L, K = b), E = ["comment", X, L, q - b, Q, O - K], b = K, L = Q, q = O) : (x2.lastIndex = q + 1, x2.test(D), x2.lastIndex === 0 ? O = D.length - 1 : O = x2.lastIndex - 2, E = ["word", D.slice(q, O + 1), L, q - b, L, O - b], T.push(E), q = O);
                    break;
                }
                return q++, E;
              }
            }
            function le(re) {
              F.push(re);
            }
            return { back: le, nextToken: ue, endOfFile: te, position: z };
          }
          n2.exports = e2.default;
        } }), la = P({ "node_modules/postcss/lib/parse.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var i = o($t()), u = o(xr());
          function o(p) {
            return p && p.__esModule ? p : { default: p };
          }
          function h3(p, m) {
            var c = new u.default(p, m), t = new i.default(c);
            try {
              t.parse();
            } catch (r) {
              throw r;
            }
            return t.root;
          }
          var l = h3;
          e2.default = l, n2.exports = e2.default;
        } }), Pf = P({ "node_modules/postcss/lib/list.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var i = { split: function(h3, l, p) {
            for (var m = [], c = "", t = false, r = 0, a = false, s = false, f = 0; f < h3.length; f++) {
              var g = h3[f];
              a ? s ? s = false : g === "\\" ? s = true : g === a && (a = false) : g === '"' || g === "'" ? a = g : g === "(" ? r += 1 : g === ")" ? r > 0 && (r -= 1) : r === 0 && l.indexOf(g) !== -1 && (t = true), t ? (c !== "" && m.push(c.trim()), c = "", t = false) : c += g;
            }
            return (p || c !== "") && m.push(c.trim()), m;
          }, space: function(h3) {
            var l = [" ", `
`, "	"];
            return i.split(h3, l);
          }, comma: function(h3) {
            return i.split(h3, [","], true);
          } }, u = i;
          e2.default = u, n2.exports = e2.default;
        } }), fa = P({ "node_modules/postcss/lib/rule.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var i = o(Or()), u = o(Pf());
          function o(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function h3(t, r) {
            for (var a = 0; a < r.length; a++) {
              var s = r[a];
              s.enumerable = s.enumerable || false, s.configurable = true, "value" in s && (s.writable = true), Object.defineProperty(t, s.key, s);
            }
          }
          function l(t, r, a) {
            return r && h3(t.prototype, r), a && h3(t, a), t;
          }
          function p(t, r) {
            t.prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r;
          }
          var m = function(t) {
            p(r, t);
            function r(a) {
              var s;
              return s = t.call(this, a) || this, s.type = "rule", s.nodes || (s.nodes = []), s;
            }
            return l(r, [{ key: "selectors", get: function() {
              return u.default.comma(this.selector);
            }, set: function(s) {
              var f = this.selector ? this.selector.match(/,\s*/) : null, g = f ? f[0] : "," + this.raw("between", "beforeOpen");
              this.selector = s.join(g);
            } }]), r;
          }(i.default), c = m;
          e2.default = c, n2.exports = e2.default;
        } }), Or = P({ "node_modules/postcss/lib/container.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var i = h3(ca()), u = h3(kr()), o = h3(Ft());
          function h3(g) {
            return g && g.__esModule ? g : { default: g };
          }
          function l(g, v) {
            var y;
            if (typeof Symbol > "u" || g[Symbol.iterator] == null) {
              if (Array.isArray(g) || (y = p(g)) || v && g && typeof g.length == "number") {
                y && (g = y);
                var w = 0;
                return function() {
                  return w >= g.length ? { done: true } : { done: false, value: g[w++] };
                };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            return y = g[Symbol.iterator](), y.next.bind(y);
          }
          function p(g, v) {
            if (g) {
              if (typeof g == "string") return m(g, v);
              var y = Object.prototype.toString.call(g).slice(8, -1);
              if (y === "Object" && g.constructor && (y = g.constructor.name), y === "Map" || y === "Set") return Array.from(g);
              if (y === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(y)) return m(g, v);
            }
          }
          function m(g, v) {
            (v == null || v > g.length) && (v = g.length);
            for (var y = 0, w = new Array(v); y < v; y++) w[y] = g[y];
            return w;
          }
          function c(g, v) {
            for (var y = 0; y < v.length; y++) {
              var w = v[y];
              w.enumerable = w.enumerable || false, w.configurable = true, "value" in w && (w.writable = true), Object.defineProperty(g, w.key, w);
            }
          }
          function t(g, v, y) {
            return v && c(g.prototype, v), y && c(g, y), g;
          }
          function r(g, v) {
            g.prototype = Object.create(v.prototype), g.prototype.constructor = g, g.__proto__ = v;
          }
          function a(g) {
            return g.map(function(v) {
              return v.nodes && (v.nodes = a(v.nodes)), delete v.source, v;
            });
          }
          var s = function(g) {
            r(v, g);
            function v() {
              return g.apply(this, arguments) || this;
            }
            var y = v.prototype;
            return y.push = function(d) {
              return d.parent = this, this.nodes.push(d), this;
            }, y.each = function(d) {
              this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
              var _ = this.lastEach;
              if (this.indexes[_] = 0, !!this.nodes) {
                for (var k, x2; this.indexes[_] < this.nodes.length && (k = this.indexes[_], x2 = d(this.nodes[k], k), x2 !== false); ) this.indexes[_] += 1;
                return delete this.indexes[_], x2;
              }
            }, y.walk = function(d) {
              return this.each(function(_, k) {
                var x2;
                try {
                  x2 = d(_, k);
                } catch (I) {
                  if (I.postcssNode = _, I.stack && _.source && /\n\s{4}at /.test(I.stack)) {
                    var N = _.source;
                    I.stack = I.stack.replace(/\n\s{4}at /, "$&" + N.input.from + ":" + N.start.line + ":" + N.start.column + "$&");
                  }
                  throw I;
                }
                return x2 !== false && _.walk && (x2 = _.walk(d)), x2;
              });
            }, y.walkDecls = function(d, _) {
              return _ ? d instanceof RegExp ? this.walk(function(k, x2) {
                if (k.type === "decl" && d.test(k.prop)) return _(k, x2);
              }) : this.walk(function(k, x2) {
                if (k.type === "decl" && k.prop === d) return _(k, x2);
              }) : (_ = d, this.walk(function(k, x2) {
                if (k.type === "decl") return _(k, x2);
              }));
            }, y.walkRules = function(d, _) {
              return _ ? d instanceof RegExp ? this.walk(function(k, x2) {
                if (k.type === "rule" && d.test(k.selector)) return _(k, x2);
              }) : this.walk(function(k, x2) {
                if (k.type === "rule" && k.selector === d) return _(k, x2);
              }) : (_ = d, this.walk(function(k, x2) {
                if (k.type === "rule") return _(k, x2);
              }));
            }, y.walkAtRules = function(d, _) {
              return _ ? d instanceof RegExp ? this.walk(function(k, x2) {
                if (k.type === "atrule" && d.test(k.name)) return _(k, x2);
              }) : this.walk(function(k, x2) {
                if (k.type === "atrule" && k.name === d) return _(k, x2);
              }) : (_ = d, this.walk(function(k, x2) {
                if (k.type === "atrule") return _(k, x2);
              }));
            }, y.walkComments = function(d) {
              return this.walk(function(_, k) {
                if (_.type === "comment") return d(_, k);
              });
            }, y.append = function() {
              for (var d = arguments.length, _ = new Array(d), k = 0; k < d; k++) _[k] = arguments[k];
              for (var x2 = 0, N = _; x2 < N.length; x2++) for (var I = N[x2], W = this.normalize(I, this.last), $ = l(W), H; !(H = $()).done; ) {
                var D = H.value;
                this.nodes.push(D);
              }
              return this;
            }, y.prepend = function() {
              for (var d = arguments.length, _ = new Array(d), k = 0; k < d; k++) _[k] = arguments[k];
              _ = _.reverse();
              for (var x2 = l(_), N; !(N = x2()).done; ) {
                for (var I = N.value, W = this.normalize(I, this.first, "prepend").reverse(), $ = l(W), H; !(H = $()).done; ) {
                  var D = H.value;
                  this.nodes.unshift(D);
                }
                for (var V in this.indexes) this.indexes[V] = this.indexes[V] + W.length;
              }
              return this;
            }, y.cleanRaws = function(d) {
              if (g.prototype.cleanRaws.call(this, d), this.nodes) for (var _ = l(this.nodes), k; !(k = _()).done; ) {
                var x2 = k.value;
                x2.cleanRaws(d);
              }
            }, y.insertBefore = function(d, _) {
              d = this.index(d);
              for (var k = d === 0 ? "prepend" : false, x2 = this.normalize(_, this.nodes[d], k).reverse(), N = l(x2), I; !(I = N()).done; ) {
                var W = I.value;
                this.nodes.splice(d, 0, W);
              }
              var $;
              for (var H in this.indexes) $ = this.indexes[H], d <= $ && (this.indexes[H] = $ + x2.length);
              return this;
            }, y.insertAfter = function(d, _) {
              d = this.index(d);
              for (var k = this.normalize(_, this.nodes[d]).reverse(), x2 = l(k), N; !(N = x2()).done; ) {
                var I = N.value;
                this.nodes.splice(d + 1, 0, I);
              }
              var W;
              for (var $ in this.indexes) W = this.indexes[$], d < W && (this.indexes[$] = W + k.length);
              return this;
            }, y.removeChild = function(d) {
              d = this.index(d), this.nodes[d].parent = void 0, this.nodes.splice(d, 1);
              var _;
              for (var k in this.indexes) _ = this.indexes[k], _ >= d && (this.indexes[k] = _ - 1);
              return this;
            }, y.removeAll = function() {
              for (var d = l(this.nodes), _; !(_ = d()).done; ) {
                var k = _.value;
                k.parent = void 0;
              }
              return this.nodes = [], this;
            }, y.replaceValues = function(d, _, k) {
              return k || (k = _, _ = {}), this.walkDecls(function(x2) {
                _.props && _.props.indexOf(x2.prop) === -1 || _.fast && x2.value.indexOf(_.fast) === -1 || (x2.value = x2.value.replace(d, k));
              }), this;
            }, y.every = function(d) {
              return this.nodes.every(d);
            }, y.some = function(d) {
              return this.nodes.some(d);
            }, y.index = function(d) {
              return typeof d == "number" ? d : this.nodes.indexOf(d);
            }, y.normalize = function(d, _) {
              var k = this;
              if (typeof d == "string") {
                var x2 = la();
                d = a(x2(d).nodes);
              } else if (Array.isArray(d)) {
                d = d.slice(0);
                for (var N = l(d), I; !(I = N()).done; ) {
                  var W = I.value;
                  W.parent && W.parent.removeChild(W, "ignore");
                }
              } else if (d.type === "root") {
                d = d.nodes.slice(0);
                for (var $ = l(d), H; !(H = $()).done; ) {
                  var D = H.value;
                  D.parent && D.parent.removeChild(D, "ignore");
                }
              } else if (d.type) d = [d];
              else if (d.prop) {
                if (typeof d.value > "u") throw new Error("Value field is missed in node creation");
                typeof d.value != "string" && (d.value = String(d.value)), d = [new i.default(d)];
              } else if (d.selector) {
                var V = fa();
                d = [new V(d)];
              } else if (d.name) {
                var B = pa();
                d = [new B(d)];
              } else if (d.text) d = [new u.default(d)];
              else throw new Error("Unknown node type in node creation");
              var O = d.map(function(j) {
                return j.parent && j.parent.removeChild(j), typeof j.raws.before > "u" && _ && typeof _.raws.before < "u" && (j.raws.before = _.raws.before.replace(/[^\s]/g, "")), j.parent = k, j;
              });
              return O;
            }, t(v, [{ key: "first", get: function() {
              if (this.nodes) return this.nodes[0];
            } }, { key: "last", get: function() {
              if (this.nodes) return this.nodes[this.nodes.length - 1];
            } }]), v;
          }(o.default), f = s;
          e2.default = f, n2.exports = e2.default;
        } }), pa = P({ "node_modules/postcss/lib/at-rule.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var i = u(Or());
          function u(p) {
            return p && p.__esModule ? p : { default: p };
          }
          function o(p, m) {
            p.prototype = Object.create(m.prototype), p.prototype.constructor = p, p.__proto__ = m;
          }
          var h3 = function(p) {
            o(m, p);
            function m(t) {
              var r;
              return r = p.call(this, t) || this, r.type = "atrule", r;
            }
            var c = m.prototype;
            return c.append = function() {
              var r;
              this.nodes || (this.nodes = []);
              for (var a = arguments.length, s = new Array(a), f = 0; f < a; f++) s[f] = arguments[f];
              return (r = p.prototype.append).call.apply(r, [this].concat(s));
            }, c.prepend = function() {
              var r;
              this.nodes || (this.nodes = []);
              for (var a = arguments.length, s = new Array(a), f = 0; f < a; f++) s[f] = arguments[f];
              return (r = p.prototype.prepend).call.apply(r, [this].concat(s));
            }, m;
          }(i.default), l = h3;
          e2.default = l, n2.exports = e2.default;
        } }), If = P({ "node_modules/postcss/lib/map-generator.js"(e2, n2) {
          A(), n2.exports = class {
            generate() {
            }
          };
        } }), Rf = P({ "node_modules/postcss/lib/warn-once.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true, e2.default = u;
          var i = {};
          function u(o) {
            i[o] || (i[o] = true, typeof console < "u" && console.warn && console.warn(o));
          }
          n2.exports = e2.default;
        } }), Cf = P({ "node_modules/postcss/lib/warning.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var i = function() {
            function o(l, p) {
              if (p === void 0 && (p = {}), this.type = "warning", this.text = l, p.node && p.node.source) {
                var m = p.node.positionBy(p);
                this.line = m.line, this.column = m.column;
              }
              for (var c in p) this[c] = p[c];
            }
            var h3 = o.prototype;
            return h3.toString = function() {
              return this.node ? this.node.error(this.text, { plugin: this.plugin, index: this.index, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
            }, o;
          }(), u = i;
          e2.default = u, n2.exports = e2.default;
        } }), Nf = P({ "node_modules/postcss/lib/result.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var i = u(Cf());
          function u(m) {
            return m && m.__esModule ? m : { default: m };
          }
          function o(m, c) {
            for (var t = 0; t < c.length; t++) {
              var r = c[t];
              r.enumerable = r.enumerable || false, r.configurable = true, "value" in r && (r.writable = true), Object.defineProperty(m, r.key, r);
            }
          }
          function h3(m, c, t) {
            return c && o(m.prototype, c), t && o(m, t), m;
          }
          var l = function() {
            function m(t, r, a) {
              this.processor = t, this.messages = [], this.root = r, this.opts = a, this.css = void 0, this.map = void 0;
            }
            var c = m.prototype;
            return c.toString = function() {
              return this.css;
            }, c.warn = function(r, a) {
              a === void 0 && (a = {}), a.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (a.plugin = this.lastPlugin.postcssPlugin);
              var s = new i.default(r, a);
              return this.messages.push(s), s;
            }, c.warnings = function() {
              return this.messages.filter(function(r) {
                return r.type === "warning";
              });
            }, h3(m, [{ key: "content", get: function() {
              return this.css;
            } }]), m;
          }(), p = l;
          e2.default = p, n2.exports = e2.default;
        } }), ha = P({ "node_modules/postcss/lib/lazy-result.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var i = p(If()), u = p(ua()), o = p(Rf()), h3 = p(Nf()), l = p(la());
          function p(v) {
            return v && v.__esModule ? v : { default: v };
          }
          function m(v, y) {
            var w;
            if (typeof Symbol > "u" || v[Symbol.iterator] == null) {
              if (Array.isArray(v) || (w = c(v)) || y && v && typeof v.length == "number") {
                w && (v = w);
                var d = 0;
                return function() {
                  return d >= v.length ? { done: true } : { done: false, value: v[d++] };
                };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            return w = v[Symbol.iterator](), w.next.bind(w);
          }
          function c(v, y) {
            if (v) {
              if (typeof v == "string") return t(v, y);
              var w = Object.prototype.toString.call(v).slice(8, -1);
              if (w === "Object" && v.constructor && (w = v.constructor.name), w === "Map" || w === "Set") return Array.from(v);
              if (w === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(w)) return t(v, y);
            }
          }
          function t(v, y) {
            (y == null || y > v.length) && (y = v.length);
            for (var w = 0, d = new Array(y); w < y; w++) d[w] = v[w];
            return d;
          }
          function r(v, y) {
            for (var w = 0; w < y.length; w++) {
              var d = y[w];
              d.enumerable = d.enumerable || false, d.configurable = true, "value" in d && (d.writable = true), Object.defineProperty(v, d.key, d);
            }
          }
          function a(v, y, w) {
            return y && r(v.prototype, y), w && r(v, w), v;
          }
          function s(v) {
            return typeof v == "object" && typeof v.then == "function";
          }
          var f = function() {
            function v(w, d, _) {
              this.stringified = false, this.processed = false;
              var k;
              if (typeof d == "object" && d !== null && d.type === "root") k = d;
              else if (d instanceof v || d instanceof h3.default) k = d.root, d.map && (typeof _.map > "u" && (_.map = {}), _.map.inline || (_.map.inline = false), _.map.prev = d.map);
              else {
                var x2 = l.default;
                _.syntax && (x2 = _.syntax.parse), _.parser && (x2 = _.parser), x2.parse && (x2 = x2.parse);
                try {
                  k = x2(d, _);
                } catch (N) {
                  this.error = N;
                }
              }
              this.result = new h3.default(w, k, _);
            }
            var y = v.prototype;
            return y.warnings = function() {
              return this.sync().warnings();
            }, y.toString = function() {
              return this.css;
            }, y.then = function(d, _) {
              return this.async().then(d, _);
            }, y.catch = function(d) {
              return this.async().catch(d);
            }, y.finally = function(d) {
              return this.async().then(d, d);
            }, y.handleError = function(d, _) {
              try {
                if (this.error = d, d.name === "CssSyntaxError" && !d.plugin) d.plugin = _.postcssPlugin, d.setMessage();
                else if (_.postcssVersion && false) var k, x2, N, I, W;
              } catch ($) {
                console && console.error && console.error($);
              }
            }, y.asyncTick = function(d, _) {
              var k = this;
              if (this.plugin >= this.processor.plugins.length) return this.processed = true, d();
              try {
                var x2 = this.processor.plugins[this.plugin], N = this.run(x2);
                this.plugin += 1, s(N) ? N.then(function() {
                  k.asyncTick(d, _);
                }).catch(function(I) {
                  k.handleError(I, x2), k.processed = true, _(I);
                }) : this.asyncTick(d, _);
              } catch (I) {
                this.processed = true, _(I);
              }
            }, y.async = function() {
              var d = this;
              return this.processed ? new Promise(function(_, k) {
                d.error ? k(d.error) : _(d.stringify());
              }) : this.processing ? this.processing : (this.processing = new Promise(function(_, k) {
                if (d.error) return k(d.error);
                d.plugin = 0, d.asyncTick(_, k);
              }).then(function() {
                return d.processed = true, d.stringify();
              }), this.processing);
            }, y.sync = function() {
              if (this.processed) return this.result;
              if (this.processed = true, this.processing) throw new Error("Use process(css).then(cb) to work with async plugins");
              if (this.error) throw this.error;
              for (var d = m(this.result.processor.plugins), _; !(_ = d()).done; ) {
                var k = _.value, x2 = this.run(k);
                if (s(x2)) throw new Error("Use process(css).then(cb) to work with async plugins");
              }
              return this.result;
            }, y.run = function(d) {
              this.result.lastPlugin = d;
              try {
                return d(this.result.root, this.result);
              } catch (_) {
                throw this.handleError(_, d), _;
              }
            }, y.stringify = function() {
              if (this.stringified) return this.result;
              this.stringified = true, this.sync();
              var d = this.result.opts, _ = u.default;
              d.syntax && (_ = d.syntax.stringify), d.stringifier && (_ = d.stringifier), _.stringify && (_ = _.stringify);
              var k = new i.default(_, this.result.root, this.result.opts), x2 = k.generate();
              return this.result.css = x2[0], this.result.map = x2[1], this.result;
            }, a(v, [{ key: "processor", get: function() {
              return this.result.processor;
            } }, { key: "opts", get: function() {
              return this.result.opts;
            } }, { key: "css", get: function() {
              return this.stringify().css;
            } }, { key: "content", get: function() {
              return this.stringify().content;
            } }, { key: "map", get: function() {
              return this.stringify().map;
            } }, { key: "root", get: function() {
              return this.sync().root;
            } }, { key: "messages", get: function() {
              return this.sync().messages;
            } }]), v;
          }(), g = f;
          e2.default = g, n2.exports = e2.default;
        } }), jf = P({ "node_modules/postcss/lib/processor.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var i = u(ha());
          function u(c) {
            return c && c.__esModule ? c : { default: c };
          }
          function o(c, t) {
            var r;
            if (typeof Symbol > "u" || c[Symbol.iterator] == null) {
              if (Array.isArray(c) || (r = h3(c)) || t && c && typeof c.length == "number") {
                r && (c = r);
                var a = 0;
                return function() {
                  return a >= c.length ? { done: true } : { done: false, value: c[a++] };
                };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            return r = c[Symbol.iterator](), r.next.bind(r);
          }
          function h3(c, t) {
            if (c) {
              if (typeof c == "string") return l(c, t);
              var r = Object.prototype.toString.call(c).slice(8, -1);
              if (r === "Object" && c.constructor && (r = c.constructor.name), r === "Map" || r === "Set") return Array.from(c);
              if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return l(c, t);
            }
          }
          function l(c, t) {
            (t == null || t > c.length) && (t = c.length);
            for (var r = 0, a = new Array(t); r < t; r++) a[r] = c[r];
            return a;
          }
          var p = function() {
            function c(r) {
              r === void 0 && (r = []), this.version = "7.0.39", this.plugins = this.normalize(r);
            }
            var t = c.prototype;
            return t.use = function(a) {
              return this.plugins = this.plugins.concat(this.normalize([a])), this;
            }, t.process = function(r) {
              function a(s) {
                return r.apply(this, arguments);
              }
              return a.toString = function() {
                return r.toString();
              }, a;
            }(function(r, a) {
              return a === void 0 && (a = {}), this.plugins.length === 0 && (a.parser, a.stringifier), new i.default(this, r, a);
            }), t.normalize = function(a) {
              for (var s = [], f = o(a), g; !(g = f()).done; ) {
                var v = g.value;
                if (v.postcss === true) {
                  var y = v();
                  throw new Error("PostCSS plugin " + y.postcssPlugin + ` requires PostCSS 8.
Migration guide for end-users:
https://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users`);
                }
                if (v.postcss && (v = v.postcss), typeof v == "object" && Array.isArray(v.plugins)) s = s.concat(v.plugins);
                else if (typeof v == "function") s.push(v);
                else if (!(typeof v == "object" && (v.parse || v.stringify))) throw typeof v == "object" && v.postcssPlugin ? new Error("PostCSS plugin " + v.postcssPlugin + ` requires PostCSS 8.
Migration guide for end-users:
https://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users`) : new Error(v + " is not a PostCSS plugin");
              }
              return s;
            }, c;
          }(), m = p;
          e2.default = m, n2.exports = e2.default;
        } }), Mf = P({ "node_modules/postcss/lib/root.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var i = u(Or());
          function u(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function o(t, r) {
            var a;
            if (typeof Symbol > "u" || t[Symbol.iterator] == null) {
              if (Array.isArray(t) || (a = h3(t)) || r && t && typeof t.length == "number") {
                a && (t = a);
                var s = 0;
                return function() {
                  return s >= t.length ? { done: true } : { done: false, value: t[s++] };
                };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            return a = t[Symbol.iterator](), a.next.bind(a);
          }
          function h3(t, r) {
            if (t) {
              if (typeof t == "string") return l(t, r);
              var a = Object.prototype.toString.call(t).slice(8, -1);
              if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
              if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return l(t, r);
            }
          }
          function l(t, r) {
            (r == null || r > t.length) && (r = t.length);
            for (var a = 0, s = new Array(r); a < r; a++) s[a] = t[a];
            return s;
          }
          function p(t, r) {
            t.prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r;
          }
          var m = function(t) {
            p(r, t);
            function r(s) {
              var f;
              return f = t.call(this, s) || this, f.type = "root", f.nodes || (f.nodes = []), f;
            }
            var a = r.prototype;
            return a.removeChild = function(f, g) {
              var v = this.index(f);
              return !g && v === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[v].raws.before), t.prototype.removeChild.call(this, f);
            }, a.normalize = function(f, g, v) {
              var y = t.prototype.normalize.call(this, f);
              if (g) {
                if (v === "prepend") this.nodes.length > 1 ? g.raws.before = this.nodes[1].raws.before : delete g.raws.before;
                else if (this.first !== g) for (var w = o(y), d; !(d = w()).done; ) {
                  var _ = d.value;
                  _.raws.before = g.raws.before;
                }
              }
              return y;
            }, a.toResult = function(f) {
              f === void 0 && (f = {});
              var g = ha(), v = jf(), y = new g(new v(), this, f);
              return y.stringify();
            }, r;
          }(i.default), c = m;
          e2.default = c, n2.exports = e2.default;
        } }), $t = P({ "node_modules/postcss/lib/parser.js"(e2, n2) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var i = m(ca()), u = m(Ut()), o = m(kr()), h3 = m(pa()), l = m(Mf()), p = m(fa());
          function m(t) {
            return t && t.__esModule ? t : { default: t };
          }
          var c = function() {
            function t(a) {
              this.input = a, this.root = new l.default(), this.current = this.root, this.spaces = "", this.semicolon = false, this.createTokenizer(), this.root.source = { input: a, start: { line: 1, column: 1 } };
            }
            var r = t.prototype;
            return r.createTokenizer = function() {
              this.tokenizer = (0, u.default)(this.input);
            }, r.parse = function() {
              for (var s; !this.tokenizer.endOfFile(); ) switch (s = this.tokenizer.nextToken(), s[0]) {
                case "space":
                  this.spaces += s[1];
                  break;
                case ";":
                  this.freeSemicolon(s);
                  break;
                case "}":
                  this.end(s);
                  break;
                case "comment":
                  this.comment(s);
                  break;
                case "at-word":
                  this.atrule(s);
                  break;
                case "{":
                  this.emptyRule(s);
                  break;
                default:
                  this.other(s);
                  break;
              }
              this.endFile();
            }, r.comment = function(s) {
              var f = new o.default();
              this.init(f, s[2], s[3]), f.source.end = { line: s[4], column: s[5] };
              var g = s[1].slice(2, -2);
              if (/^\s*$/.test(g)) f.text = "", f.raws.left = g, f.raws.right = "";
              else {
                var v = g.match(/^(\s*)([^]*[^\s])(\s*)$/);
                f.text = v[2], f.raws.left = v[1], f.raws.right = v[3];
              }
            }, r.emptyRule = function(s) {
              var f = new p.default();
              this.init(f, s[2], s[3]), f.selector = "", f.raws.between = "", this.current = f;
            }, r.other = function(s) {
              for (var f = false, g = null, v = false, y = null, w = [], d = [], _ = s; _; ) {
                if (g = _[0], d.push(_), g === "(" || g === "[") y || (y = _), w.push(g === "(" ? ")" : "]");
                else if (w.length === 0) if (g === ";") if (v) {
                  this.decl(d);
                  return;
                } else break;
                else if (g === "{") {
                  this.rule(d);
                  return;
                } else if (g === "}") {
                  this.tokenizer.back(d.pop()), f = true;
                  break;
                } else g === ":" && (v = true);
                else g === w[w.length - 1] && (w.pop(), w.length === 0 && (y = null));
                _ = this.tokenizer.nextToken();
              }
              if (this.tokenizer.endOfFile() && (f = true), w.length > 0 && this.unclosedBracket(y), f && v) {
                for (; d.length && (_ = d[d.length - 1][0], !(_ !== "space" && _ !== "comment")); ) this.tokenizer.back(d.pop());
                this.decl(d);
              } else this.unknownWord(d);
            }, r.rule = function(s) {
              s.pop();
              var f = new p.default();
              this.init(f, s[0][2], s[0][3]), f.raws.between = this.spacesAndCommentsFromEnd(s), this.raw(f, "selector", s), this.current = f;
            }, r.decl = function(s) {
              var f = new i.default();
              this.init(f);
              var g = s[s.length - 1];
              for (g[0] === ";" && (this.semicolon = true, s.pop()), g[4] ? f.source.end = { line: g[4], column: g[5] } : f.source.end = { line: g[2], column: g[3] }; s[0][0] !== "word"; ) s.length === 1 && this.unknownWord(s), f.raws.before += s.shift()[1];
              for (f.source.start = { line: s[0][2], column: s[0][3] }, f.prop = ""; s.length; ) {
                var v = s[0][0];
                if (v === ":" || v === "space" || v === "comment") break;
                f.prop += s.shift()[1];
              }
              f.raws.between = "";
              for (var y; s.length; ) if (y = s.shift(), y[0] === ":") {
                f.raws.between += y[1];
                break;
              } else y[0] === "word" && /\w/.test(y[1]) && this.unknownWord([y]), f.raws.between += y[1];
              (f.prop[0] === "_" || f.prop[0] === "*") && (f.raws.before += f.prop[0], f.prop = f.prop.slice(1)), f.raws.between += this.spacesAndCommentsFromStart(s), this.precheckMissedSemicolon(s);
              for (var w = s.length - 1; w > 0; w--) {
                if (y = s[w], y[1].toLowerCase() === "!important") {
                  f.important = true;
                  var d = this.stringFrom(s, w);
                  d = this.spacesFromEnd(s) + d, d !== " !important" && (f.raws.important = d);
                  break;
                } else if (y[1].toLowerCase() === "important") {
                  for (var _ = s.slice(0), k = "", x2 = w; x2 > 0; x2--) {
                    var N = _[x2][0];
                    if (k.trim().indexOf("!") === 0 && N !== "space") break;
                    k = _.pop()[1] + k;
                  }
                  k.trim().indexOf("!") === 0 && (f.important = true, f.raws.important = k, s = _);
                }
                if (y[0] !== "space" && y[0] !== "comment") break;
              }
              this.raw(f, "value", s), f.value.indexOf(":") !== -1 && this.checkMissedSemicolon(s);
            }, r.atrule = function(s) {
              var f = new h3.default();
              f.name = s[1].slice(1), f.name === "" && this.unnamedAtrule(f, s), this.init(f, s[2], s[3]);
              for (var g, v, y = false, w = false, d = []; !this.tokenizer.endOfFile(); ) {
                if (s = this.tokenizer.nextToken(), s[0] === ";") {
                  f.source.end = { line: s[2], column: s[3] }, this.semicolon = true;
                  break;
                } else if (s[0] === "{") {
                  w = true;
                  break;
                } else if (s[0] === "}") {
                  if (d.length > 0) {
                    for (v = d.length - 1, g = d[v]; g && g[0] === "space"; ) g = d[--v];
                    g && (f.source.end = { line: g[4], column: g[5] });
                  }
                  this.end(s);
                  break;
                } else d.push(s);
                if (this.tokenizer.endOfFile()) {
                  y = true;
                  break;
                }
              }
              f.raws.between = this.spacesAndCommentsFromEnd(d), d.length ? (f.raws.afterName = this.spacesAndCommentsFromStart(d), this.raw(f, "params", d), y && (s = d[d.length - 1], f.source.end = { line: s[4], column: s[5] }, this.spaces = f.raws.between, f.raws.between = "")) : (f.raws.afterName = "", f.params = ""), w && (f.nodes = [], this.current = f);
            }, r.end = function(s) {
              this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = { line: s[2], column: s[3] }, this.current = this.current.parent) : this.unexpectedClose(s);
            }, r.endFile = function() {
              this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces;
            }, r.freeSemicolon = function(s) {
              if (this.spaces += s[1], this.current.nodes) {
                var f = this.current.nodes[this.current.nodes.length - 1];
                f && f.type === "rule" && !f.raws.ownSemicolon && (f.raws.ownSemicolon = this.spaces, this.spaces = "");
              }
            }, r.init = function(s, f, g) {
              this.current.push(s), s.source = { start: { line: f, column: g }, input: this.input }, s.raws.before = this.spaces, this.spaces = "", s.type !== "comment" && (this.semicolon = false);
            }, r.raw = function(s, f, g) {
              for (var v, y, w = g.length, d = "", _ = true, k, x2, N = /^([.|#])?([\w])+/i, I = 0; I < w; I += 1) {
                if (v = g[I], y = v[0], y === "comment" && s.type === "rule") {
                  x2 = g[I - 1], k = g[I + 1], x2[0] !== "space" && k[0] !== "space" && N.test(x2[1]) && N.test(k[1]) ? d += v[1] : _ = false;
                  continue;
                }
                y === "comment" || y === "space" && I === w - 1 ? _ = false : d += v[1];
              }
              if (!_) {
                var W = g.reduce(function($, H) {
                  return $ + H[1];
                }, "");
                s.raws[f] = { value: d, raw: W };
              }
              s[f] = d;
            }, r.spacesAndCommentsFromEnd = function(s) {
              for (var f, g = ""; s.length && (f = s[s.length - 1][0], !(f !== "space" && f !== "comment")); ) g = s.pop()[1] + g;
              return g;
            }, r.spacesAndCommentsFromStart = function(s) {
              for (var f, g = ""; s.length && (f = s[0][0], !(f !== "space" && f !== "comment")); ) g += s.shift()[1];
              return g;
            }, r.spacesFromEnd = function(s) {
              for (var f, g = ""; s.length && (f = s[s.length - 1][0], f === "space"); ) g = s.pop()[1] + g;
              return g;
            }, r.stringFrom = function(s, f) {
              for (var g = "", v = f; v < s.length; v++) g += s[v][1];
              return s.splice(f, s.length - f), g;
            }, r.colon = function(s) {
              for (var f = 0, g, v, y, w = 0; w < s.length; w++) {
                if (g = s[w], v = g[0], v === "(" && (f += 1), v === ")" && (f -= 1), f === 0 && v === ":") if (!y) this.doubleColon(g);
                else {
                  if (y[0] === "word" && y[1] === "progid") continue;
                  return w;
                }
                y = g;
              }
              return false;
            }, r.unclosedBracket = function(s) {
              throw this.input.error("Unclosed bracket", s[2], s[3]);
            }, r.unknownWord = function(s) {
              throw this.input.error("Unknown word", s[0][2], s[0][3]);
            }, r.unexpectedClose = function(s) {
              throw this.input.error("Unexpected }", s[2], s[3]);
            }, r.unclosedBlock = function() {
              var s = this.current.source.start;
              throw this.input.error("Unclosed block", s.line, s.column);
            }, r.doubleColon = function(s) {
              throw this.input.error("Double colon", s[2], s[3]);
            }, r.unnamedAtrule = function(s, f) {
              throw this.input.error("At-rule without name", f[2], f[3]);
            }, r.precheckMissedSemicolon = function() {
            }, r.checkMissedSemicolon = function(s) {
              var f = this.colon(s);
              if (f !== false) {
                for (var g = 0, v, y = f - 1; y >= 0 && (v = s[y], !(v[0] !== "space" && (g += 1, g === 2))); y--) ;
                throw this.input.error("Missed semicolon", v[2], v[3]);
              }
            }, t;
          }();
          e2.default = c, n2.exports = e2.default;
        } }), Df = P({ "node_modules/postcss-less/lib/nodes/inline-comment.js"(e2, n2) {
          A();
          var i = Ut(), u = xr();
          n2.exports = { isInlineComment(o) {
            if (o[0] === "word" && o[1].slice(0, 2) === "//") {
              let h3 = o, l = [], p;
              for (; o; ) {
                if (/\r?\n/.test(o[1])) {
                  if (/['"].*\r?\n/.test(o[1])) {
                    l.push(o[1].substring(0, o[1].indexOf(`
`)));
                    let c = o[1].substring(o[1].indexOf(`
`));
                    c += this.input.css.valueOf().substring(this.tokenizer.position()), this.input = new u(c), this.tokenizer = i(this.input);
                  } else this.tokenizer.back(o);
                  break;
                }
                l.push(o[1]), p = o, o = this.tokenizer.nextToken({ ignoreUnclosed: true });
              }
              let m = ["comment", l.join(""), h3[2], h3[3], p[2], p[3]];
              return this.inlineComment(m), true;
            } else if (o[1] === "/") {
              let h3 = this.tokenizer.nextToken({ ignoreUnclosed: true });
              if (h3[0] === "comment" && /^\/\*/.test(h3[1])) return h3[0] = "word", h3[1] = h3[1].slice(1), o[1] = "//", this.tokenizer.back(h3), n2.exports.isInlineComment.bind(this)(o);
            }
            return false;
          } };
        } }), Lf = P({ "node_modules/postcss-less/lib/nodes/interpolation.js"(e2, n2) {
          A(), n2.exports = { interpolation(i) {
            let u = i, o = [i], h3 = ["word", "{", "}"];
            if (i = this.tokenizer.nextToken(), u[1].length > 1 || i[0] !== "{") return this.tokenizer.back(i), false;
            for (; i && h3.includes(i[0]); ) o.push(i), i = this.tokenizer.nextToken();
            let l = o.map((r) => r[1]);
            [u] = o;
            let p = o.pop(), m = [u[2], u[3]], c = [p[4] || p[2], p[5] || p[3]], t = ["word", l.join("")].concat(m, c);
            return this.tokenizer.back(i), this.tokenizer.back(t), true;
          } };
        } }), zf = P({ "node_modules/postcss-less/lib/nodes/mixin.js"(e2, n2) {
          A();
          var i = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/, u = /\.[0-9]/, o = (h3) => {
            let [, l] = h3, [p] = l;
            return (p === "." || p === "#") && i.test(l) === false && u.test(l) === false;
          };
          n2.exports = { isMixinToken: o };
        } }), Bf = P({ "node_modules/postcss-less/lib/nodes/import.js"(e2, n2) {
          A();
          var i = Ut(), u = /^url\((.+)\)/;
          n2.exports = (o) => {
            let { name: h3, params: l = "" } = o;
            if (h3 === "import" && l.length) {
              o.import = true;
              let p = i({ css: l });
              for (o.filename = l.replace(u, "$1"); !p.endOfFile(); ) {
                let [m, c] = p.nextToken();
                if (m === "word" && c === "url") return;
                if (m === "brackets") {
                  o.options = c, o.filename = l.replace(c, "").trim();
                  break;
                }
              }
            }
          };
        } }), Ff = P({ "node_modules/postcss-less/lib/nodes/variable.js"(e2, n2) {
          A();
          var i = /:$/, u = /^:(\s+)?/;
          n2.exports = (o) => {
            let { name: h3, params: l = "" } = o;
            if (o.name.slice(-1) === ":") {
              if (i.test(h3)) {
                let [p] = h3.match(i);
                o.name = h3.replace(p, ""), o.raws.afterName = p + (o.raws.afterName || ""), o.variable = true, o.value = o.params;
              }
              if (u.test(l)) {
                let [p] = l.match(u);
                o.value = l.replace(p, ""), o.raws.afterName = (o.raws.afterName || "") + p, o.variable = true;
              }
            }
          };
        } }), Uf = P({ "node_modules/postcss-less/lib/LessParser.js"(e2, n2) {
          A();
          var i = kr(), u = $t(), { isInlineComment: o } = Df(), { interpolation: h3 } = Lf(), { isMixinToken: l } = zf(), p = Bf(), m = Ff(), c = /(!\s*important)$/i;
          n2.exports = class extends u {
            constructor() {
              super(...arguments), this.lastNode = null;
            }
            atrule(r) {
              h3.bind(this)(r) || (super.atrule(r), p(this.lastNode), m(this.lastNode));
            }
            decl() {
              super.decl(...arguments), /extend\(.+\)/i.test(this.lastNode.value) && (this.lastNode.extend = true);
            }
            each(r) {
              r[0][1] = ` ${r[0][1]}`;
              let a = r.findIndex((y) => y[0] === "("), s = r.reverse().find((y) => y[0] === ")"), f = r.reverse().indexOf(s), v = r.splice(a, f).map((y) => y[1]).join("");
              for (let y of r.reverse()) this.tokenizer.back(y);
              this.atrule(this.tokenizer.nextToken()), this.lastNode.function = true, this.lastNode.params = v;
            }
            init(r, a, s) {
              super.init(r, a, s), this.lastNode = r;
            }
            inlineComment(r) {
              let a = new i(), s = r[1].slice(2);
              if (this.init(a, r[2], r[3]), a.source.end = { line: r[4], column: r[5] }, a.inline = true, a.raws.begin = "//", /^\s*$/.test(s)) a.text = "", a.raws.left = s, a.raws.right = "";
              else {
                let f = s.match(/^(\s*)([^]*[^\s])(\s*)$/);
                [, a.raws.left, a.text, a.raws.right] = f;
              }
            }
            mixin(r) {
              let [a] = r, s = a[1].slice(0, 1), f = r.findIndex((d) => d[0] === "brackets"), g = r.findIndex((d) => d[0] === "("), v = "";
              if ((f < 0 || f > 3) && g > 0) {
                let d = r.reduce((V, B, O) => B[0] === ")" ? O : V), k = r.slice(g, d + g).map((V) => V[1]).join(""), [x2] = r.slice(g), N = [x2[2], x2[3]], [I] = r.slice(d, d + 1), W = [I[2], I[3]], $ = ["brackets", k].concat(N, W), H = r.slice(0, g), D = r.slice(d + 1);
                r = H, r.push($), r = r.concat(D);
              }
              let y = [];
              for (let d of r) if ((d[1] === "!" || y.length) && y.push(d), d[1] === "important") break;
              if (y.length) {
                let [d] = y, _ = r.indexOf(d), k = y[y.length - 1], x2 = [d[2], d[3]], N = [k[4], k[5]], W = ["word", y.map(($) => $[1]).join("")].concat(x2, N);
                r.splice(_, y.length, W);
              }
              let w = r.findIndex((d) => c.test(d[1]));
              w > 0 && ([, v] = r[w], r.splice(w, 1));
              for (let d of r.reverse()) this.tokenizer.back(d);
              this.atrule(this.tokenizer.nextToken()), this.lastNode.mixin = true, this.lastNode.raws.identifier = s, v && (this.lastNode.important = true, this.lastNode.raws.important = v);
            }
            other(r) {
              o.bind(this)(r) || super.other(r);
            }
            rule(r) {
              let a = r[r.length - 1], s = r[r.length - 2];
              if (s[0] === "at-word" && a[0] === "{" && (this.tokenizer.back(a), h3.bind(this)(s))) {
                let g = this.tokenizer.nextToken();
                r = r.slice(0, r.length - 2).concat([g]);
                for (let v of r.reverse()) this.tokenizer.back(v);
                return;
              }
              super.rule(r), /:extend\(.+\)/i.test(this.lastNode.selector) && (this.lastNode.extend = true);
            }
            unknownWord(r) {
              let [a] = r;
              if (r[0][1] === "each" && r[1][0] === "(") {
                this.each(r);
                return;
              }
              if (l(a)) {
                this.mixin(r);
                return;
              }
              super.unknownWord(r);
            }
          };
        } }), $f = P({ "node_modules/postcss-less/lib/LessStringifier.js"(e2, n2) {
          A();
          var i = Sr();
          n2.exports = class extends i {
            atrule(o, h3) {
              if (!o.mixin && !o.variable && !o.function) {
                super.atrule(o, h3);
                return;
              }
              let p = `${o.function ? "" : o.raws.identifier || "@"}${o.name}`, m = o.params ? this.rawValue(o, "params") : "", c = o.raws.important || "";
              if (o.variable && (m = o.value), typeof o.raws.afterName < "u" ? p += o.raws.afterName : m && (p += " "), o.nodes) this.block(o, p + m + c);
              else {
                let t = (o.raws.between || "") + c + (h3 ? ";" : "");
                this.builder(p + m + t, o);
              }
            }
            comment(o) {
              if (o.inline) {
                let h3 = this.raw(o, "left", "commentLeft"), l = this.raw(o, "right", "commentRight");
                this.builder(`//${h3}${o.text}${l}`, o);
              } else super.comment(o);
            }
          };
        } }), Wf = P({ "node_modules/postcss-less/lib/index.js"(e2, n2) {
          A();
          var i = xr(), u = Uf(), o = $f();
          n2.exports = { parse(h3, l) {
            let p = new i(h3, l), m = new u(p);
            return m.parse(), m.root;
          }, stringify(h3, l) {
            new o(l).stringify(h3);
          }, nodeToString(h3) {
            let l = "";
            return n2.exports.stringify(h3, (p) => {
              l += p;
            }), l;
          } };
        } }), Vf = P({ "node_modules/postcss-scss/lib/scss-stringifier.js"(e2, n2) {
          "use strict";
          A();
          function i(h3, l) {
            h3.prototype = Object.create(l.prototype), h3.prototype.constructor = h3, h3.__proto__ = l;
          }
          var u = Sr(), o = function(h3) {
            i(l, h3);
            function l() {
              return h3.apply(this, arguments) || this;
            }
            var p = l.prototype;
            return p.comment = function(c) {
              var t = this.raw(c, "left", "commentLeft"), r = this.raw(c, "right", "commentRight");
              if (c.raws.inline) {
                var a = c.raws.text || c.text;
                this.builder("//" + t + a + r, c);
              } else this.builder("/*" + t + c.text + r + "*/", c);
            }, p.decl = function(c, t) {
              if (!c.isNested) h3.prototype.decl.call(this, c, t);
              else {
                var r = this.raw(c, "between", "colon"), a = c.prop + r + this.rawValue(c, "value");
                c.important && (a += c.raws.important || " !important"), this.builder(a + "{", c, "start");
                var s;
                c.nodes && c.nodes.length ? (this.body(c), s = this.raw(c, "after")) : s = this.raw(c, "after", "emptyBody"), s && this.builder(s), this.builder("}", c, "end");
              }
            }, p.rawValue = function(c, t) {
              var r = c[t], a = c.raws[t];
              return a && a.value === r ? a.scss ? a.scss : a.raw : r;
            }, l;
          }(u);
          n2.exports = o;
        } }), Gf = P({ "node_modules/postcss-scss/lib/scss-stringify.js"(e2, n2) {
          "use strict";
          A();
          var i = Vf();
          n2.exports = function(o, h3) {
            var l = new i(h3);
            l.stringify(o);
          };
        } }), Hf = P({ "node_modules/postcss-scss/lib/nested-declaration.js"(e2, n2) {
          "use strict";
          A();
          function i(h3, l) {
            h3.prototype = Object.create(l.prototype), h3.prototype.constructor = h3, h3.__proto__ = l;
          }
          var u = Or(), o = function(h3) {
            i(l, h3);
            function l(p) {
              var m;
              return m = h3.call(this, p) || this, m.type = "decl", m.isNested = true, m.nodes || (m.nodes = []), m;
            }
            return l;
          }(u);
          n2.exports = o;
        } }), Jf = P({ "node_modules/postcss-scss/lib/scss-tokenize.js"(e2, n2) {
          "use strict";
          A();
          var i = "'".charCodeAt(0), u = '"'.charCodeAt(0), o = "\\".charCodeAt(0), h3 = "/".charCodeAt(0), l = `
`.charCodeAt(0), p = " ".charCodeAt(0), m = "\f".charCodeAt(0), c = "	".charCodeAt(0), t = "\r".charCodeAt(0), r = "[".charCodeAt(0), a = "]".charCodeAt(0), s = "(".charCodeAt(0), f = ")".charCodeAt(0), g = "{".charCodeAt(0), v = "}".charCodeAt(0), y = ";".charCodeAt(0), w = "*".charCodeAt(0), d = ":".charCodeAt(0), _ = "@".charCodeAt(0), k = ",".charCodeAt(0), x2 = "#".charCodeAt(0), N = /[ \n\t\r\f{}()'"\\;/[\]#]/g, I = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g, W = /.[\\/("'\n]/, $ = /[a-f0-9]/i, H = /[\r\f\n]/g;
          n2.exports = function(V, B) {
            B === void 0 && (B = {});
            var O = V.css.valueOf(), j = B.ignoreErrors, C, R, X, Z, Q, K, J, M, Y, G, E, S, b, L, q = O.length, T = -1, F = 1, z = 0, ee = [], te = [];
            function ue(ie) {
              throw V.error("Unclosed " + ie, F, z - T);
            }
            function le() {
              return te.length === 0 && z >= q;
            }
            function re() {
              for (var ie = 1, ce = false, fe = false; ie > 0; ) R += 1, O.length <= R && ue("interpolation"), C = O.charCodeAt(R), S = O.charCodeAt(R + 1), ce ? !fe && C === ce ? (ce = false, fe = false) : C === o ? fe = !G : fe && (fe = false) : C === i || C === u ? ce = C : C === v ? ie -= 1 : C === x2 && S === g && (ie += 1);
            }
            function ne() {
              if (te.length) return te.pop();
              if (!(z >= q)) {
                switch (C = O.charCodeAt(z), (C === l || C === m || C === t && O.charCodeAt(z + 1) !== l) && (T = z, F += 1), C) {
                  case l:
                  case p:
                  case c:
                  case t:
                  case m:
                    R = z;
                    do
                      R += 1, C = O.charCodeAt(R), C === l && (T = R, F += 1);
                    while (C === p || C === l || C === c || C === t || C === m);
                    b = ["space", O.slice(z, R)], z = R - 1;
                    break;
                  case r:
                    b = ["[", "[", F, z - T];
                    break;
                  case a:
                    b = ["]", "]", F, z - T];
                    break;
                  case g:
                    b = ["{", "{", F, z - T];
                    break;
                  case v:
                    b = ["}", "}", F, z - T];
                    break;
                  case k:
                    b = ["word", ",", F, z - T, F, z - T + 1];
                    break;
                  case d:
                    b = [":", ":", F, z - T];
                    break;
                  case y:
                    b = [";", ";", F, z - T];
                    break;
                  case s:
                    if (E = ee.length ? ee.pop()[1] : "", S = O.charCodeAt(z + 1), E === "url" && S !== i && S !== u) {
                      for (L = 1, G = false, R = z + 1; R <= O.length - 1; ) {
                        if (S = O.charCodeAt(R), S === o) G = !G;
                        else if (S === s) L += 1;
                        else if (S === f && (L -= 1, L === 0)) break;
                        R += 1;
                      }
                      K = O.slice(z, R + 1), Z = K.split(`
`), Q = Z.length - 1, Q > 0 ? (M = F + Q, Y = R - Z[Q].length) : (M = F, Y = T), b = ["brackets", K, F, z - T, M, R - Y], T = Y, F = M, z = R;
                    } else R = O.indexOf(")", z + 1), K = O.slice(z, R + 1), R === -1 || W.test(K) ? b = ["(", "(", F, z - T] : (b = ["brackets", K, F, z - T, F, R - T], z = R);
                    break;
                  case f:
                    b = [")", ")", F, z - T];
                    break;
                  case i:
                  case u:
                    for (X = C, R = z, G = false; R < q && (R++, R === q && ue("string"), C = O.charCodeAt(R), S = O.charCodeAt(R + 1), !(!G && C === X)); ) C === o ? G = !G : G ? G = false : C === x2 && S === g && re();
                    K = O.slice(z, R + 1), Z = K.split(`
`), Q = Z.length - 1, Q > 0 ? (M = F + Q, Y = R - Z[Q].length) : (M = F, Y = T), b = ["string", O.slice(z, R + 1), F, z - T, M, R - Y], T = Y, F = M, z = R;
                    break;
                  case _:
                    N.lastIndex = z + 1, N.test(O), N.lastIndex === 0 ? R = O.length - 1 : R = N.lastIndex - 2, b = ["at-word", O.slice(z, R + 1), F, z - T, F, R - T], z = R;
                    break;
                  case o:
                    for (R = z, J = true; O.charCodeAt(R + 1) === o; ) R += 1, J = !J;
                    if (C = O.charCodeAt(R + 1), J && C !== h3 && C !== p && C !== l && C !== c && C !== t && C !== m && (R += 1, $.test(O.charAt(R)))) {
                      for (; $.test(O.charAt(R + 1)); ) R += 1;
                      O.charCodeAt(R + 1) === p && (R += 1);
                    }
                    b = ["word", O.slice(z, R + 1), F, z - T, F, R - T], z = R;
                    break;
                  default:
                    S = O.charCodeAt(z + 1), C === x2 && S === g ? (R = z, re(), K = O.slice(z, R + 1), Z = K.split(`
`), Q = Z.length - 1, Q > 0 ? (M = F + Q, Y = R - Z[Q].length) : (M = F, Y = T), b = ["word", K, F, z - T, M, R - Y], T = Y, F = M, z = R) : C === h3 && S === w ? (R = O.indexOf("*/", z + 2) + 1, R === 0 && (j ? R = O.length : ue("comment")), K = O.slice(z, R + 1), Z = K.split(`
`), Q = Z.length - 1, Q > 0 ? (M = F + Q, Y = R - Z[Q].length) : (M = F, Y = T), b = ["comment", K, F, z - T, M, R - Y], T = Y, F = M, z = R) : C === h3 && S === h3 ? (H.lastIndex = z + 1, H.test(O), H.lastIndex === 0 ? R = O.length - 1 : R = H.lastIndex - 2, K = O.slice(z, R + 1), b = ["comment", K, F, z - T, F, R - T, "inline"], z = R) : (I.lastIndex = z + 1, I.test(O), I.lastIndex === 0 ? R = O.length - 1 : R = I.lastIndex - 2, b = ["word", O.slice(z, R + 1), F, z - T, F, R - T], ee.push(b), z = R);
                    break;
                }
                return z++, b;
              }
            }
            function oe(ie) {
              te.push(ie);
            }
            return { back: oe, nextToken: ne, endOfFile: le };
          };
        } }), Kf = P({ "node_modules/postcss-scss/lib/scss-parser.js"(e2, n2) {
          "use strict";
          A();
          function i(m, c) {
            m.prototype = Object.create(c.prototype), m.prototype.constructor = m, m.__proto__ = c;
          }
          var u = kr(), o = $t(), h3 = Hf(), l = Jf(), p = function(m) {
            i(c, m);
            function c() {
              return m.apply(this, arguments) || this;
            }
            var t = c.prototype;
            return t.createTokenizer = function() {
              this.tokenizer = l(this.input);
            }, t.rule = function(a) {
              for (var s = false, f = 0, g = "", w = a, v = Array.isArray(w), y = 0, w = v ? w : w[Symbol.iterator](); ; ) {
                var d;
                if (v) {
                  if (y >= w.length) break;
                  d = w[y++];
                } else {
                  if (y = w.next(), y.done) break;
                  d = y.value;
                }
                var _ = d;
                if (s) _[0] !== "comment" && _[0] !== "{" && (g += _[1]);
                else {
                  if (_[0] === "space" && _[1].indexOf(`
`) !== -1) break;
                  _[0] === "(" ? f += 1 : _[0] === ")" ? f -= 1 : f === 0 && _[0] === ":" && (s = true);
                }
              }
              if (!s || g.trim() === "" || /^[a-zA-Z-:#]/.test(g)) m.prototype.rule.call(this, a);
              else {
                a.pop();
                var k = new h3();
                this.init(k);
                var x2 = a[a.length - 1];
                for (x2[4] ? k.source.end = { line: x2[4], column: x2[5] } : k.source.end = { line: x2[2], column: x2[3] }; a[0][0] !== "word"; ) k.raws.before += a.shift()[1];
                for (k.source.start = { line: a[0][2], column: a[0][3] }, k.prop = ""; a.length; ) {
                  var N = a[0][0];
                  if (N === ":" || N === "space" || N === "comment") break;
                  k.prop += a.shift()[1];
                }
                k.raws.between = "";
                for (var I; a.length; ) if (I = a.shift(), I[0] === ":") {
                  k.raws.between += I[1];
                  break;
                } else k.raws.between += I[1];
                (k.prop[0] === "_" || k.prop[0] === "*") && (k.raws.before += k.prop[0], k.prop = k.prop.slice(1)), k.raws.between += this.spacesAndCommentsFromStart(a), this.precheckMissedSemicolon(a);
                for (var W = a.length - 1; W > 0; W--) {
                  if (I = a[W], I[1] === "!important") {
                    k.important = true;
                    var $ = this.stringFrom(a, W);
                    $ = this.spacesFromEnd(a) + $, $ !== " !important" && (k.raws.important = $);
                    break;
                  } else if (I[1] === "important") {
                    for (var H = a.slice(0), D = "", V = W; V > 0; V--) {
                      var B = H[V][0];
                      if (D.trim().indexOf("!") === 0 && B !== "space") break;
                      D = H.pop()[1] + D;
                    }
                    D.trim().indexOf("!") === 0 && (k.important = true, k.raws.important = D, a = H);
                  }
                  if (I[0] !== "space" && I[0] !== "comment") break;
                }
                this.raw(k, "value", a), k.value.indexOf(":") !== -1 && this.checkMissedSemicolon(a), this.current = k;
              }
            }, t.comment = function(a) {
              if (a[6] === "inline") {
                var s = new u();
                this.init(s, a[2], a[3]), s.raws.inline = true, s.source.end = { line: a[4], column: a[5] };
                var f = a[1].slice(2);
                if (/^\s*$/.test(f)) s.text = "", s.raws.left = f, s.raws.right = "";
                else {
                  var g = f.match(/^(\s*)([^]*[^\s])(\s*)$/), v = g[2].replace(/(\*\/|\/\*)/g, "*//*");
                  s.text = v, s.raws.left = g[1], s.raws.right = g[3], s.raws.text = g[2];
                }
              } else m.prototype.comment.call(this, a);
            }, t.raw = function(a, s, f) {
              if (m.prototype.raw.call(this, a, s, f), a.raws[s]) {
                var g = a.raws[s].raw;
                a.raws[s].raw = f.reduce(function(v, y) {
                  if (y[0] === "comment" && y[6] === "inline") {
                    var w = y[1].slice(2).replace(/(\*\/|\/\*)/g, "*//*");
                    return v + "/*" + w + "*/";
                  } else return v + y[1];
                }, ""), g !== a.raws[s].raw && (a.raws[s].scss = g);
              }
            }, c;
          }(o);
          n2.exports = p;
        } }), Qf = P({ "node_modules/postcss-scss/lib/scss-parse.js"(e2, n2) {
          "use strict";
          A();
          var i = xr(), u = Kf();
          n2.exports = function(h3, l) {
            var p = new i(h3, l), m = new u(p);
            return m.parse(), m.root;
          };
        } }), Yf = P({ "node_modules/postcss-scss/lib/scss-syntax.js"(e2, n2) {
          "use strict";
          A();
          var i = Gf(), u = Qf();
          n2.exports = { parse: u, stringify: i };
        } });
        A();
        var Xf = Sl(), mt = Us(), Zf = $s(), { hasPragma: ep } = Cl(), { locStart: rp, locEnd: tp } = no(), { calculateLoc: np, replaceQuotesInInlineComments: ip } = no(), sp = Dl(), op = Ll(), gt = zl(), da = Bl(), ap = Fl(), up = Ul(), cp = $l(), lp = Wl(), fp = (e2) => {
          for (; e2.parent; ) e2 = e2.parent;
          return e2;
        };
        function pp(e2, n2) {
          let { nodes: i } = e2, u = { open: null, close: null, groups: [], type: "paren_group" }, o = [u], h3 = u, l = { groups: [], type: "comma_group" }, p = [l];
          for (let m = 0; m < i.length; ++m) {
            let c = i[m];
            if (da(n2.parser, c.value) && c.type === "number" && c.unit === ".." && mt(c.value) === "." && (c.value = c.value.slice(0, -1), c.unit = "..."), c.type === "func" && c.value === "selector" && (c.group.groups = [Re(fp(e2).text.slice(c.group.open.sourceIndex + 1, c.group.close.sourceIndex))]), c.type === "func" && c.value === "url") {
              let t = c.group && c.group.groups || [], r = [];
              for (let a = 0; a < t.length; a++) {
                let s = t[a];
                s.type === "comma_group" ? r = [...r, ...s.groups] : r.push(s);
              }
              if (sp(r) || !op(r) && !up(r[0])) {
                let a = cp({ groups: c.group.groups });
                c.group.groups = [a.trim()];
              }
            }
            if (c.type === "paren" && c.value === "(") u = { open: c, close: null, groups: [], type: "paren_group" }, o.push(u), l = { groups: [], type: "comma_group" }, p.push(l);
            else if (c.type === "paren" && c.value === ")") {
              if (l.groups.length > 0 && u.groups.push(l), u.close = c, p.length === 1) throw new Error("Unbalanced parenthesis");
              p.pop(), l = mt(p), l.groups.push(u), o.pop(), u = mt(o);
            } else c.type === "comma" ? (u.groups.push(l), l = { groups: [], type: "comma_group" }, p[p.length - 1] = l) : l.groups.push(c);
          }
          return l.groups.length > 0 && u.groups.push(l), h3;
        }
        function vr(e2) {
          return e2.type === "paren_group" && !e2.open && !e2.close && e2.groups.length === 1 || e2.type === "comma_group" && e2.groups.length === 1 ? vr(e2.groups[0]) : e2.type === "paren_group" || e2.type === "comma_group" ? Object.assign(Object.assign({}, e2), {}, { groups: e2.groups.map(vr) }) : e2;
        }
        function Xe(e2, n2, i) {
          if (e2 && typeof e2 == "object") {
            delete e2.parent;
            for (let u in e2) Xe(e2[u], n2, i), u === "type" && typeof e2[u] == "string" && !e2[u].startsWith(n2) && (!i || !i.test(e2[u])) && (e2[u] = n2 + e2[u]);
          }
          return e2;
        }
        function va(e2) {
          if (e2 && typeof e2 == "object") {
            delete e2.parent;
            for (let n2 in e2) va(e2[n2]);
            !Array.isArray(e2) && e2.value && !e2.type && (e2.type = "unknown");
          }
          return e2;
        }
        function ma(e2, n2) {
          if (e2 && typeof e2 == "object") {
            for (let i in e2) i !== "parent" && (ma(e2[i], n2), i === "nodes" && (e2.group = vr(pp(e2, n2)), delete e2[i]));
            delete e2.parent;
          }
          return e2;
        }
        function Pe(e2, n2) {
          let i = gf(), u = null;
          try {
            u = i(e2, { loose: true }).parse();
          } catch (e3) {
            return { type: "value-unknown", value: e2 };
          }
          u.text = e2;
          let o = ma(u, n2);
          return Xe(o, "value-", /^selector-/);
        }
        function Re(e2) {
          if (/\/\/|\/\*/.test(e2)) return { type: "selector-unknown", value: e2.trim() };
          let n2 = xf(), i = null;
          try {
            n2((u) => {
              i = u;
            }).process(e2);
          } catch (e3) {
            return { type: "selector-unknown", value: e2 };
          }
          return Xe(i, "selector-");
        }
        function hp(e2) {
          let n2 = kf().default, i = null;
          try {
            i = n2(e2);
          } catch (e3) {
            return { type: "selector-unknown", value: e2 };
          }
          return Xe(va(i), "media-");
        }
        var dp = /(\s*)(!default).*$/, vp = /(\s*)(!global).*$/;
        function ga(e2, n2) {
          if (e2 && typeof e2 == "object") {
            delete e2.parent;
            for (let m in e2) ga(e2[m], n2);
            if (!e2.type) return e2;
            e2.raws || (e2.raws = {});
            let h3 = "";
            if (typeof e2.selector == "string") {
              var i;
              h3 = e2.raws.selector ? (i = e2.raws.selector.scss) !== null && i !== void 0 ? i : e2.raws.selector.raw : e2.selector, e2.raws.between && e2.raws.between.trim().length > 0 && (h3 += e2.raws.between), e2.raws.selector = h3;
            }
            let l = "";
            if (typeof e2.value == "string") {
              var u;
              l = e2.raws.value ? (u = e2.raws.value.scss) !== null && u !== void 0 ? u : e2.raws.value.raw : e2.value, l = l.trim(), e2.raws.value = l;
            }
            let p = "";
            if (typeof e2.params == "string") {
              var o;
              p = e2.raws.params ? (o = e2.raws.params.scss) !== null && o !== void 0 ? o : e2.raws.params.raw : e2.params, e2.raws.afterName && e2.raws.afterName.trim().length > 0 && (p = e2.raws.afterName + p), e2.raws.between && e2.raws.between.trim().length > 0 && (p = p + e2.raws.between), p = p.trim(), e2.raws.params = p;
            }
            if (h3.trim().length > 0) return h3.startsWith("@") && h3.endsWith(":") ? e2 : e2.mixin ? (e2.selector = Pe(h3, n2), e2) : (ap(e2) && (e2.isSCSSNesterProperty = true), e2.selector = Re(h3), e2);
            if (l.length > 0) {
              let m = l.match(dp);
              m && (l = l.slice(0, m.index), e2.scssDefault = true, m[0].trim() !== "!default" && (e2.raws.scssDefault = m[0]));
              let c = l.match(vp);
              if (c && (l = l.slice(0, c.index), e2.scssGlobal = true, c[0].trim() !== "!global" && (e2.raws.scssGlobal = c[0])), l.startsWith("progid:")) return { type: "value-unknown", value: l };
              e2.value = Pe(l, n2);
            }
            if (gt(n2) && e2.type === "css-decl" && l.startsWith("extend(") && (e2.extend || (e2.extend = e2.raws.between === ":"), e2.extend && !e2.selector && (delete e2.value, e2.selector = Re(l.slice(7, -1)))), e2.type === "css-atrule") {
              if (gt(n2)) {
                if (e2.mixin) {
                  let m = e2.raws.identifier + e2.name + e2.raws.afterName + e2.raws.params;
                  return e2.selector = Re(m), delete e2.params, e2;
                }
                if (e2.function) return e2;
              }
              if (n2.parser === "css" && e2.name === "custom-selector") {
                let m = e2.params.match(/:--\S+\s+/)[0].trim();
                return e2.customSelector = m, e2.selector = Re(e2.params.slice(m.length).trim()), delete e2.params, e2;
              }
              if (gt(n2)) {
                if (e2.name.includes(":") && !e2.params) {
                  e2.variable = true;
                  let m = e2.name.split(":");
                  e2.name = m[0], e2.value = Pe(m.slice(1).join(":"), n2);
                }
                if (!["page", "nest", "keyframes"].includes(e2.name) && e2.params && e2.params[0] === ":") {
                  e2.variable = true;
                  let m = e2.params.slice(1);
                  m && (e2.value = Pe(m, n2)), e2.raws.afterName += ":";
                }
                if (e2.variable) return delete e2.params, e2.value || delete e2.value, e2;
              }
            }
            if (e2.type === "css-atrule" && p.length > 0) {
              let { name: m } = e2, c = e2.name.toLowerCase();
              return m === "warn" || m === "error" ? (e2.params = { type: "media-unknown", value: p }, e2) : m === "extend" || m === "nest" ? (e2.selector = Re(p), delete e2.params, e2) : m === "at-root" ? (/^\(\s*(?:without|with)\s*:.+\)$/s.test(p) ? e2.params = Pe(p, n2) : (e2.selector = Re(p), delete e2.params), e2) : lp(c) ? (e2.import = true, delete e2.filename, e2.params = Pe(p, n2), e2) : ["namespace", "supports", "if", "else", "for", "each", "while", "debug", "mixin", "include", "function", "return", "define-mixin", "add-mixin"].includes(m) ? (p = p.replace(/(\$\S+?)(\s+)?\.{3}/, "$1...$2"), p = p.replace(/^(?!if)(\S+)(\s+)\(/, "$1($2"), e2.value = Pe(p, n2), delete e2.params, e2) : ["media", "custom-media"].includes(c) ? p.includes("#{") ? { type: "media-unknown", value: p } : (e2.params = hp(p), e2) : (e2.params = p, e2);
            }
          }
          return e2;
        }
        function ya(e2, n2, i) {
          let u = Zf(n2), { frontMatter: o } = u;
          n2 = u.content;
          let h3;
          try {
            h3 = e2(n2);
          } catch (l) {
            let { name: p, reason: m, line: c, column: t } = l;
            throw typeof c != "number" ? l : Xf(`${p}: ${m}`, { start: { line: c, column: t } });
          }
          return h3 = ga(Xe(h3, "css-"), i), np(h3, n2), o && (o.source = { startOffset: 0, endOffset: o.raw.length }, h3.nodes.unshift(o)), h3;
        }
        function mp(e2, n2) {
          let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = da(i.parser, e2) ? [Tt, Ot] : [Ot, Tt], h3;
          for (let l of o) try {
            return l(e2, n2, i);
          } catch (p) {
            h3 = h3 || p;
          }
          if (h3) throw h3;
        }
        function Ot(e2, n2) {
          let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, u = Wf();
          return ya((o) => u.parse(ip(o)), e2, i);
        }
        function Tt(e2, n2) {
          let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, { parse: u } = Yf();
          return ya(u, e2, i);
        }
        var yt = { astFormat: "postcss", hasPragma: ep, locStart: rp, locEnd: tp };
        wa.exports = { parsers: { css: Object.assign(Object.assign({}, yt), {}, { parse: mp }), less: Object.assign(Object.assign({}, yt), {}, { parse: Ot }), scss: Object.assign(Object.assign({}, yt), {}, { parse: Tt }) } };
      });
      return gp();
    });
  }
});

// ../../node_modules/.pnpm/prettier@2.8.8/node_modules/prettier/standalone.js
var require_standalone = _chunk42PBKAQTcjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/prettier@2.8.8/node_modules/prettier/standalone.js"(exports, module) {
    "use strict";
    (function(e2) {
      if (typeof exports == "object" && typeof module == "object") module.exports = e2();
      else if (typeof define == "function" && define.amd) define(e2);
      else {
        var f = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
        f.prettier = e2();
      }
    })(function() {
      "use strict";
      var xe = (e2, r) => () => (r || e2((r = { exports: {} }).exports, r), r.exports);
      var pt = xe((r0, pu) => {
        var ir = function(e2) {
          return e2 && e2.Math == Math && e2;
        };
        pu.exports = ir(typeof globalThis == "object" && globalThis) || ir(typeof window == "object" && window) || ir(typeof self == "object" && self) || ir(typeof global == "object" && global) || /* @__PURE__ */ function() {
          return this;
        }() || Function("return this")();
      });
      var Dt = xe((n0, fu) => {
        fu.exports = function(e2) {
          try {
            return !!e2();
          } catch (e3) {
            return true;
          }
        };
      });
      var yt = xe((u0, Du) => {
        var Mo = Dt();
        Du.exports = !Mo(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      });
      var ar = xe((s0, mu) => {
        var Ro = Dt();
        mu.exports = !Ro(function() {
          var e2 = function() {
          }.bind();
          return typeof e2 != "function" || e2.hasOwnProperty("prototype");
        });
      });
      var At = xe((i0, du) => {
        var $o = ar(), or = Function.prototype.call;
        du.exports = $o ? or.bind(or) : function() {
          return or.apply(or, arguments);
        };
      });
      var vu = xe((hu) => {
        "use strict";
        var gu = {}.propertyIsEnumerable, yu = Object.getOwnPropertyDescriptor, Vo = yu && !gu.call({ 1: 2 }, 1);
        hu.f = Vo ? function(r) {
          var t = yu(this, r);
          return !!t && t.enumerable;
        } : gu;
      });
      var lr = xe((o0, Cu) => {
        Cu.exports = function(e2, r) {
          return { enumerable: !(e2 & 1), configurable: !(e2 & 2), writable: !(e2 & 4), value: r };
        };
      });
      var mt = xe((l0, Au) => {
        var Eu = ar(), Fu = Function.prototype, Wr = Fu.call, Wo = Eu && Fu.bind.bind(Wr, Wr);
        Au.exports = Eu ? Wo : function(e2) {
          return function() {
            return Wr.apply(e2, arguments);
          };
        };
      });
      var Vt = xe((c0, xu) => {
        var Su = mt(), Ho = Su({}.toString), Go = Su("".slice);
        xu.exports = function(e2) {
          return Go(Ho(e2), 8, -1);
        };
      });
      var Tu = xe((p0, bu) => {
        var Uo = mt(), Jo = Dt(), zo = Vt(), Hr = Object, Xo = Uo("".split);
        bu.exports = Jo(function() {
          return !Hr("z").propertyIsEnumerable(0);
        }) ? function(e2) {
          return zo(e2) == "String" ? Xo(e2, "") : Hr(e2);
        } : Hr;
      });
      var cr = xe((f0, Bu) => {
        Bu.exports = function(e2) {
          return e2 == null;
        };
      });
      var Gr = xe((D0, Nu) => {
        var Ko = cr(), Yo = TypeError;
        Nu.exports = function(e2) {
          if (Ko(e2)) throw Yo("Can't call method on " + e2);
          return e2;
        };
      });
      var pr = xe((m0, wu) => {
        var Qo = Tu(), Zo = Gr();
        wu.exports = function(e2) {
          return Qo(Zo(e2));
        };
      });
      var Jr = xe((d0, _u) => {
        var Ur = typeof document == "object" && document.all, el = typeof Ur > "u" && Ur !== void 0;
        _u.exports = { all: Ur, IS_HTMLDDA: el };
      });
      var ot = xe((g0, Iu) => {
        var Pu = Jr(), tl = Pu.all;
        Iu.exports = Pu.IS_HTMLDDA ? function(e2) {
          return typeof e2 == "function" || e2 === tl;
        } : function(e2) {
          return typeof e2 == "function";
        };
      });
      var St = xe((y0, Ou) => {
        var ku = ot(), Lu = Jr(), rl = Lu.all;
        Ou.exports = Lu.IS_HTMLDDA ? function(e2) {
          return typeof e2 == "object" ? e2 !== null : ku(e2) || e2 === rl;
        } : function(e2) {
          return typeof e2 == "object" ? e2 !== null : ku(e2);
        };
      });
      var Wt = xe((h0, ju) => {
        var zr = pt(), nl = ot(), ul = function(e2) {
          return nl(e2) ? e2 : void 0;
        };
        ju.exports = function(e2, r) {
          return arguments.length < 2 ? ul(zr[e2]) : zr[e2] && zr[e2][r];
        };
      });
      var Xr = xe((v0, qu) => {
        var sl = mt();
        qu.exports = sl({}.isPrototypeOf);
      });
      var Ru = xe((C0, Mu) => {
        var il = Wt();
        Mu.exports = il("navigator", "userAgent") || "";
      });
      var Ju = xe((E0, Uu) => {
        var Gu = pt(), Kr = Ru(), $u = Gu.process, Vu = Gu.Deno, Wu = $u && $u.versions || Vu && Vu.version, Hu = Wu && Wu.v8, dt, fr;
        Hu && (dt = Hu.split("."), fr = dt[0] > 0 && dt[0] < 4 ? 1 : +(dt[0] + dt[1]));
        !fr && Kr && (dt = Kr.match(/Edge\/(\d+)/), (!dt || dt[1] >= 74) && (dt = Kr.match(/Chrome\/(\d+)/), dt && (fr = +dt[1])));
        Uu.exports = fr;
      });
      var Yr = xe((F0, Xu) => {
        var zu = Ju(), al = Dt();
        Xu.exports = !!Object.getOwnPropertySymbols && !al(function() {
          var e2 = Symbol();
          return !String(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && zu && zu < 41;
        });
      });
      var Qr = xe((A0, Ku) => {
        var ol = Yr();
        Ku.exports = ol && !Symbol.sham && typeof Symbol.iterator == "symbol";
      });
      var Zr = xe((S0, Yu) => {
        var ll = Wt(), cl = ot(), pl = Xr(), fl = Qr(), Dl = Object;
        Yu.exports = fl ? function(e2) {
          return typeof e2 == "symbol";
        } : function(e2) {
          var r = ll("Symbol");
          return cl(r) && pl(r.prototype, Dl(e2));
        };
      });
      var Dr = xe((x0, Qu) => {
        var ml = String;
        Qu.exports = function(e2) {
          try {
            return ml(e2);
          } catch (e3) {
            return "Object";
          }
        };
      });
      var Ht = xe((b0, Zu) => {
        var dl = ot(), gl = Dr(), yl = TypeError;
        Zu.exports = function(e2) {
          if (dl(e2)) return e2;
          throw yl(gl(e2) + " is not a function");
        };
      });
      var mr = xe((T0, es) => {
        var hl = Ht(), vl = cr();
        es.exports = function(e2, r) {
          var t = e2[r];
          return vl(t) ? void 0 : hl(t);
        };
      });
      var rs = xe((B0, ts) => {
        var en = At(), tn = ot(), rn = St(), Cl = TypeError;
        ts.exports = function(e2, r) {
          var t, s;
          if (r === "string" && tn(t = e2.toString) && !rn(s = en(t, e2)) || tn(t = e2.valueOf) && !rn(s = en(t, e2)) || r !== "string" && tn(t = e2.toString) && !rn(s = en(t, e2))) return s;
          throw Cl("Can't convert object to primitive value");
        };
      });
      var us = xe((N0, ns) => {
        ns.exports = false;
      });
      var dr = xe((w0, is) => {
        var ss = pt(), El = Object.defineProperty;
        is.exports = function(e2, r) {
          try {
            El(ss, e2, { value: r, configurable: true, writable: true });
          } catch (e3) {
            ss[e2] = r;
          }
          return r;
        };
      });
      var gr = xe((_0, os) => {
        var Fl = pt(), Al = dr(), as = "__core-js_shared__", Sl = Fl[as] || Al(as, {});
        os.exports = Sl;
      });
      var nn = xe((P0, cs) => {
        var xl = us(), ls = gr();
        (cs.exports = function(e2, r) {
          return ls[e2] || (ls[e2] = r !== void 0 ? r : {});
        })("versions", []).push({ version: "3.26.1", mode: xl ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" });
      });
      var yr = xe((I0, ps) => {
        var bl = Gr(), Tl = Object;
        ps.exports = function(e2) {
          return Tl(bl(e2));
        };
      });
      var Ct = xe((k0, fs5) => {
        var Bl = mt(), Nl = yr(), wl = Bl({}.hasOwnProperty);
        fs5.exports = Object.hasOwn || function(r, t) {
          return wl(Nl(r), t);
        };
      });
      var un = xe((L0, Ds) => {
        var _l = mt(), Pl = 0, Il = Math.random(), kl = _l(1 .toString);
        Ds.exports = function(e2) {
          return "Symbol(" + (e2 === void 0 ? "" : e2) + ")_" + kl(++Pl + Il, 36);
        };
      });
      var bt = xe((O0, hs) => {
        var Ll = pt(), Ol = nn(), ms = Ct(), jl = un(), ds = Yr(), ys = Qr(), It = Ol("wks"), xt = Ll.Symbol, gs = xt && xt.for, ql = ys ? xt : xt && xt.withoutSetter || jl;
        hs.exports = function(e2) {
          if (!ms(It, e2) || !(ds || typeof It[e2] == "string")) {
            var r = "Symbol." + e2;
            ds && ms(xt, e2) ? It[e2] = xt[e2] : ys && gs ? It[e2] = gs(r) : It[e2] = ql(r);
          }
          return It[e2];
        };
      });
      var Fs = xe((j0, Es) => {
        var Ml = At(), vs = St(), Cs = Zr(), Rl = mr(), $l = rs(), Vl = bt(), Wl = TypeError, Hl = Vl("toPrimitive");
        Es.exports = function(e2, r) {
          if (!vs(e2) || Cs(e2)) return e2;
          var t = Rl(e2, Hl), s;
          if (t) {
            if (r === void 0 && (r = "default"), s = Ml(t, e2, r), !vs(s) || Cs(s)) return s;
            throw Wl("Can't convert object to primitive value");
          }
          return r === void 0 && (r = "number"), $l(e2, r);
        };
      });
      var hr = xe((q0, As) => {
        var Gl = Fs(), Ul = Zr();
        As.exports = function(e2) {
          var r = Gl(e2, "string");
          return Ul(r) ? r : r + "";
        };
      });
      var bs = xe((M0, xs) => {
        var Jl = pt(), Ss = St(), sn = Jl.document, zl = Ss(sn) && Ss(sn.createElement);
        xs.exports = function(e2) {
          return zl ? sn.createElement(e2) : {};
        };
      });
      var an = xe((R0, Ts) => {
        var Xl = yt(), Kl = Dt(), Yl = bs();
        Ts.exports = !Xl && !Kl(function() {
          return Object.defineProperty(Yl("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      });
      var on = xe((Ns) => {
        var Ql = yt(), Zl = At(), ec = vu(), tc = lr(), rc = pr(), nc = hr(), uc = Ct(), sc = an(), Bs = Object.getOwnPropertyDescriptor;
        Ns.f = Ql ? Bs : function(r, t) {
          if (r = rc(r), t = nc(t), sc) try {
            return Bs(r, t);
          } catch (e2) {
          }
          if (uc(r, t)) return tc(!Zl(ec.f, r, t), r[t]);
        };
      });
      var _s = xe((V0, ws) => {
        var ic = yt(), ac = Dt();
        ws.exports = ic && ac(function() {
          return Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype != 42;
        });
      });
      var Tt = xe((W0, Ps) => {
        var oc = St(), lc = String, cc = TypeError;
        Ps.exports = function(e2) {
          if (oc(e2)) return e2;
          throw cc(lc(e2) + " is not an object");
        };
      });
      var kt = xe((ks) => {
        var pc = yt(), fc = an(), Dc = _s(), vr = Tt(), Is = hr(), mc = TypeError, ln = Object.defineProperty, dc = Object.getOwnPropertyDescriptor, cn = "enumerable", pn = "configurable", fn = "writable";
        ks.f = pc ? Dc ? function(r, t, s) {
          if (vr(r), t = Is(t), vr(s), typeof r == "function" && t === "prototype" && "value" in s && fn in s && !s[fn]) {
            var a = dc(r, t);
            a && a[fn] && (r[t] = s.value, s = { configurable: pn in s ? s[pn] : a[pn], enumerable: cn in s ? s[cn] : a[cn], writable: false });
          }
          return ln(r, t, s);
        } : ln : function(r, t, s) {
          if (vr(r), t = Is(t), vr(s), fc) try {
            return ln(r, t, s);
          } catch (e2) {
          }
          if ("get" in s || "set" in s) throw mc("Accessors not supported");
          return "value" in s && (r[t] = s.value), r;
        };
      });
      var Dn = xe((G0, Ls) => {
        var gc = yt(), yc = kt(), hc = lr();
        Ls.exports = gc ? function(e2, r, t) {
          return yc.f(e2, r, hc(1, t));
        } : function(e2, r, t) {
          return e2[r] = t, e2;
        };
      });
      var qs = xe((U0, js) => {
        var mn = yt(), vc = Ct(), Os = Function.prototype, Cc = mn && Object.getOwnPropertyDescriptor, dn = vc(Os, "name"), Ec = dn && function() {
        }.name === "something", Fc = dn && (!mn || mn && Cc(Os, "name").configurable);
        js.exports = { EXISTS: dn, PROPER: Ec, CONFIGURABLE: Fc };
      });
      var yn = xe((J0, Ms) => {
        var Ac = mt(), Sc = ot(), gn = gr(), xc = Ac(Function.toString);
        Sc(gn.inspectSource) || (gn.inspectSource = function(e2) {
          return xc(e2);
        });
        Ms.exports = gn.inspectSource;
      });
      var Vs = xe((z0, $s) => {
        var bc = pt(), Tc = ot(), Rs = bc.WeakMap;
        $s.exports = Tc(Rs) && /native code/.test(String(Rs));
      });
      var Gs = xe((X0, Hs) => {
        var Bc = nn(), Nc = un(), Ws = Bc("keys");
        Hs.exports = function(e2) {
          return Ws[e2] || (Ws[e2] = Nc(e2));
        };
      });
      var hn = xe((K0, Us) => {
        Us.exports = {};
      });
      var Ks = xe((Y0, Xs) => {
        var wc = Vs(), zs = pt(), _c = St(), Pc = Dn(), vn = Ct(), Cn = gr(), Ic = Gs(), kc = hn(), Js = "Object already initialized", En = zs.TypeError, Lc = zs.WeakMap, Cr, Gt, Er, Oc = function(e2) {
          return Er(e2) ? Gt(e2) : Cr(e2, {});
        }, jc = function(e2) {
          return function(r) {
            var t;
            if (!_c(r) || (t = Gt(r)).type !== e2) throw En("Incompatible receiver, " + e2 + " required");
            return t;
          };
        };
        wc || Cn.state ? (gt = Cn.state || (Cn.state = new Lc()), gt.get = gt.get, gt.has = gt.has, gt.set = gt.set, Cr = function(e2, r) {
          if (gt.has(e2)) throw En(Js);
          return r.facade = e2, gt.set(e2, r), r;
        }, Gt = function(e2) {
          return gt.get(e2) || {};
        }, Er = function(e2) {
          return gt.has(e2);
        }) : (Bt = Ic("state"), kc[Bt] = true, Cr = function(e2, r) {
          if (vn(e2, Bt)) throw En(Js);
          return r.facade = e2, Pc(e2, Bt, r), r;
        }, Gt = function(e2) {
          return vn(e2, Bt) ? e2[Bt] : {};
        }, Er = function(e2) {
          return vn(e2, Bt);
        });
        var gt, Bt;
        Xs.exports = { set: Cr, get: Gt, has: Er, enforce: Oc, getterFor: jc };
      });
      var An = xe((Q0, Qs) => {
        var qc = Dt(), Mc = ot(), Fr = Ct(), Fn = yt(), Rc = qs().CONFIGURABLE, $c = yn(), Ys = Ks(), Vc = Ys.enforce, Wc = Ys.get, Ar = Object.defineProperty, Hc = Fn && !qc(function() {
          return Ar(function() {
          }, "length", { value: 8 }).length !== 8;
        }), Gc = String(String).split("String"), Uc = Qs.exports = function(e2, r, t) {
          String(r).slice(0, 7) === "Symbol(" && (r = "[" + String(r).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), t && t.getter && (r = "get " + r), t && t.setter && (r = "set " + r), (!Fr(e2, "name") || Rc && e2.name !== r) && (Fn ? Ar(e2, "name", { value: r, configurable: true }) : e2.name = r), Hc && t && Fr(t, "arity") && e2.length !== t.arity && Ar(e2, "length", { value: t.arity });
          try {
            t && Fr(t, "constructor") && t.constructor ? Fn && Ar(e2, "prototype", { writable: false }) : e2.prototype && (e2.prototype = void 0);
          } catch (e3) {
          }
          var s = Vc(e2);
          return Fr(s, "source") || (s.source = Gc.join(typeof r == "string" ? r : "")), e2;
        };
        Function.prototype.toString = Uc(function() {
          return Mc(this) && Wc(this).source || $c(this);
        }, "toString");
      });
      var ei = xe((Z0, Zs) => {
        var Jc = ot(), zc = kt(), Xc = An(), Kc = dr();
        Zs.exports = function(e2, r, t, s) {
          s || (s = {});
          var a = s.enumerable, n2 = s.name !== void 0 ? s.name : r;
          if (Jc(t) && Xc(t, n2, s), s.global) a ? e2[r] = t : Kc(r, t);
          else {
            try {
              s.unsafe ? e2[r] && (a = true) : delete e2[r];
            } catch (e3) {
            }
            a ? e2[r] = t : zc.f(e2, r, { value: t, enumerable: false, configurable: !s.nonConfigurable, writable: !s.nonWritable });
          }
          return e2;
        };
      });
      var ri = xe((ey, ti) => {
        var Yc = Math.ceil, Qc = Math.floor;
        ti.exports = Math.trunc || function(r) {
          var t = +r;
          return (t > 0 ? Qc : Yc)(t);
        };
      });
      var Sr = xe((ty, ni) => {
        var Zc = ri();
        ni.exports = function(e2) {
          var r = +e2;
          return r !== r || r === 0 ? 0 : Zc(r);
        };
      });
      var si = xe((ry, ui) => {
        var ep = Sr(), tp = Math.max, rp = Math.min;
        ui.exports = function(e2, r) {
          var t = ep(e2);
          return t < 0 ? tp(t + r, 0) : rp(t, r);
        };
      });
      var ai = xe((ny, ii) => {
        var np = Sr(), up = Math.min;
        ii.exports = function(e2) {
          return e2 > 0 ? up(np(e2), 9007199254740991) : 0;
        };
      });
      var Lt = xe((uy, oi) => {
        var sp = ai();
        oi.exports = function(e2) {
          return sp(e2.length);
        };
      });
      var pi = xe((sy, ci) => {
        var ip = pr(), ap = si(), op = Lt(), li = function(e2) {
          return function(r, t, s) {
            var a = ip(r), n2 = op(a), u = ap(s, n2), i;
            if (e2 && t != t) {
              for (; n2 > u; ) if (i = a[u++], i != i) return true;
            } else for (; n2 > u; u++) if ((e2 || u in a) && a[u] === t) return e2 || u || 0;
            return !e2 && -1;
          };
        };
        ci.exports = { includes: li(true), indexOf: li(false) };
      });
      var mi = xe((iy, Di) => {
        var lp = mt(), Sn = Ct(), cp = pr(), pp = pi().indexOf, fp = hn(), fi = lp([].push);
        Di.exports = function(e2, r) {
          var t = cp(e2), s = 0, a = [], n2;
          for (n2 in t) !Sn(fp, n2) && Sn(t, n2) && fi(a, n2);
          for (; r.length > s; ) Sn(t, n2 = r[s++]) && (~pp(a, n2) || fi(a, n2));
          return a;
        };
      });
      var gi = xe((ay, di) => {
        di.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      });
      var hi = xe((yi) => {
        var Dp = mi(), mp = gi(), dp = mp.concat("length", "prototype");
        yi.f = Object.getOwnPropertyNames || function(r) {
          return Dp(r, dp);
        };
      });
      var Ci = xe((vi) => {
        vi.f = Object.getOwnPropertySymbols;
      });
      var Fi = xe((cy, Ei) => {
        var gp = Wt(), yp = mt(), hp = hi(), vp = Ci(), Cp = Tt(), Ep = yp([].concat);
        Ei.exports = gp("Reflect", "ownKeys") || function(r) {
          var t = hp.f(Cp(r)), s = vp.f;
          return s ? Ep(t, s(r)) : t;
        };
      });
      var xi = xe((py, Si) => {
        var Ai = Ct(), Fp = Fi(), Ap = on(), Sp = kt();
        Si.exports = function(e2, r, t) {
          for (var s = Fp(r), a = Sp.f, n2 = Ap.f, u = 0; u < s.length; u++) {
            var i = s[u];
            !Ai(e2, i) && !(t && Ai(t, i)) && a(e2, i, n2(r, i));
          }
        };
      });
      var Ti = xe((fy, bi) => {
        var xp = Dt(), bp = ot(), Tp = /#|\.prototype\./, Ut = function(e2, r) {
          var t = Np[Bp(e2)];
          return t == _p ? true : t == wp ? false : bp(r) ? xp(r) : !!r;
        }, Bp = Ut.normalize = function(e2) {
          return String(e2).replace(Tp, ".").toLowerCase();
        }, Np = Ut.data = {}, wp = Ut.NATIVE = "N", _p = Ut.POLYFILL = "P";
        bi.exports = Ut;
      });
      var Jt = xe((Dy, Bi) => {
        var xn = pt(), Pp = on().f, Ip = Dn(), kp = ei(), Lp = dr(), Op = xi(), jp = Ti();
        Bi.exports = function(e2, r) {
          var t = e2.target, s = e2.global, a = e2.stat, n2, u, i, l, p, y;
          if (s ? u = xn : a ? u = xn[t] || Lp(t, {}) : u = (xn[t] || {}).prototype, u) for (i in r) {
            if (p = r[i], e2.dontCallGetSet ? (y = Pp(u, i), l = y && y.value) : l = u[i], n2 = jp(s ? i : t + (a ? "." : "#") + i, e2.forced), !n2 && l !== void 0) {
              if (typeof p == typeof l) continue;
              Op(p, l);
            }
            (e2.sham || l && l.sham) && Ip(p, "sham", true), kp(u, i, p, e2);
          }
        };
      });
      var bn = xe((my, Ni) => {
        var qp = Vt();
        Ni.exports = Array.isArray || function(r) {
          return qp(r) == "Array";
        };
      });
      var _i = xe((dy, wi) => {
        var Mp = TypeError, Rp = 9007199254740991;
        wi.exports = function(e2) {
          if (e2 > Rp) throw Mp("Maximum allowed index exceeded");
          return e2;
        };
      });
      var Ii = xe((gy, Pi) => {
        var $p = Vt(), Vp = mt();
        Pi.exports = function(e2) {
          if ($p(e2) === "Function") return Vp(e2);
        };
      });
      var Tn = xe((yy, Li) => {
        var ki = Ii(), Wp = Ht(), Hp = ar(), Gp = ki(ki.bind);
        Li.exports = function(e2, r) {
          return Wp(e2), r === void 0 ? e2 : Hp ? Gp(e2, r) : function() {
            return e2.apply(r, arguments);
          };
        };
      });
      var Bn = xe((hy, ji) => {
        "use strict";
        var Up = bn(), Jp = Lt(), zp = _i(), Xp = Tn(), Oi = function(e2, r, t, s, a, n2, u, i) {
          for (var l = a, p = 0, y = u ? Xp(u, i) : false, h3, g; p < s; ) p in t && (h3 = y ? y(t[p], p, r) : t[p], n2 > 0 && Up(h3) ? (g = Jp(h3), l = Oi(e2, r, h3, g, l, n2 - 1) - 1) : (zp(l + 1), e2[l] = h3), l++), p++;
          return l;
        };
        ji.exports = Oi;
      });
      var Ri = xe((vy, Mi) => {
        var Kp = bt(), Yp = Kp("toStringTag"), qi = {};
        qi[Yp] = "z";
        Mi.exports = String(qi) === "[object z]";
      });
      var Nn = xe((Cy, $i) => {
        var Qp = Ri(), Zp = ot(), xr = Vt(), ef = bt(), tf = ef("toStringTag"), rf = Object, nf = xr(/* @__PURE__ */ function() {
          return arguments;
        }()) == "Arguments", uf = function(e2, r) {
          try {
            return e2[r];
          } catch (e3) {
          }
        };
        $i.exports = Qp ? xr : function(e2) {
          var r, t, s;
          return e2 === void 0 ? "Undefined" : e2 === null ? "Null" : typeof (t = uf(r = rf(e2), tf)) == "string" ? t : nf ? xr(r) : (s = xr(r)) == "Object" && Zp(r.callee) ? "Arguments" : s;
        };
      });
      var Ji = xe((Ey, Ui) => {
        var sf = mt(), af = Dt(), Vi = ot(), of = Nn(), lf = Wt(), cf = yn(), Wi = function() {
        }, pf = [], Hi = lf("Reflect", "construct"), wn = /^\s*(?:class|function)\b/, ff = sf(wn.exec), Df = !wn.exec(Wi), zt = function(r) {
          if (!Vi(r)) return false;
          try {
            return Hi(Wi, pf, r), true;
          } catch (e2) {
            return false;
          }
        }, Gi = function(r) {
          if (!Vi(r)) return false;
          switch (of(r)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          try {
            return Df || !!ff(wn, cf(r));
          } catch (e2) {
            return true;
          }
        };
        Gi.sham = true;
        Ui.exports = !Hi || af(function() {
          var e2;
          return zt(zt.call) || !zt(Object) || !zt(function() {
            e2 = true;
          }) || e2;
        }) ? Gi : zt;
      });
      var Yi = xe((Fy, Ki) => {
        var zi = bn(), mf = Ji(), df = St(), gf = bt(), yf = gf("species"), Xi = Array;
        Ki.exports = function(e2) {
          var r;
          return zi(e2) && (r = e2.constructor, mf(r) && (r === Xi || zi(r.prototype)) ? r = void 0 : df(r) && (r = r[yf], r === null && (r = void 0))), r === void 0 ? Xi : r;
        };
      });
      var _n = xe((Ay, Qi) => {
        var hf = Yi();
        Qi.exports = function(e2, r) {
          return new (hf(e2))(r === 0 ? 0 : r);
        };
      });
      var Zi = xe(() => {
        "use strict";
        var vf = Jt(), Cf = Bn(), Ef = Ht(), Ff = yr(), Af = Lt(), Sf = _n();
        vf({ target: "Array", proto: true }, { flatMap: function(r) {
          var t = Ff(this), s = Af(t), a;
          return Ef(r), a = Sf(t, 0), a.length = Cf(a, t, t, s, 0, 1, r, arguments.length > 1 ? arguments[1] : void 0), a;
        } });
      });
      var Pn = xe((by, ea) => {
        ea.exports = {};
      });
      var ra = xe((Ty, ta) => {
        var xf = bt(), bf = Pn(), Tf = xf("iterator"), Bf = Array.prototype;
        ta.exports = function(e2) {
          return e2 !== void 0 && (bf.Array === e2 || Bf[Tf] === e2);
        };
      });
      var In = xe((By, ua) => {
        var Nf = Nn(), na = mr(), wf = cr(), _f = Pn(), Pf = bt(), If = Pf("iterator");
        ua.exports = function(e2) {
          if (!wf(e2)) return na(e2, If) || na(e2, "@@iterator") || _f[Nf(e2)];
        };
      });
      var ia = xe((Ny, sa) => {
        var kf = At(), Lf = Ht(), Of = Tt(), jf = Dr(), qf = In(), Mf = TypeError;
        sa.exports = function(e2, r) {
          var t = arguments.length < 2 ? qf(e2) : r;
          if (Lf(t)) return Of(kf(t, e2));
          throw Mf(jf(e2) + " is not iterable");
        };
      });
      var la = xe((wy, oa) => {
        var Rf = At(), aa = Tt(), $f = mr();
        oa.exports = function(e2, r, t) {
          var s, a;
          aa(e2);
          try {
            if (s = $f(e2, "return"), !s) {
              if (r === "throw") throw t;
              return t;
            }
            s = Rf(s, e2);
          } catch (n2) {
            a = true, s = n2;
          }
          if (r === "throw") throw t;
          if (a) throw s;
          return aa(s), t;
        };
      });
      var ma = xe((_y, Da) => {
        var Vf = Tn(), Wf = At(), Hf = Tt(), Gf = Dr(), Uf = ra(), Jf = Lt(), ca = Xr(), zf = ia(), Xf = In(), pa = la(), Kf = TypeError, br = function(e2, r) {
          this.stopped = e2, this.result = r;
        }, fa = br.prototype;
        Da.exports = function(e2, r, t) {
          var s = t && t.that, a = !!(t && t.AS_ENTRIES), n2 = !!(t && t.IS_RECORD), u = !!(t && t.IS_ITERATOR), i = !!(t && t.INTERRUPTED), l = Vf(r, s), p, y, h3, g, c, f, F, _ = function(E) {
            return p && pa(p, "normal", E), new br(true, E);
          }, w = function(E) {
            return a ? (Hf(E), i ? l(E[0], E[1], _) : l(E[0], E[1])) : i ? l(E, _) : l(E);
          };
          if (n2) p = e2.iterator;
          else if (u) p = e2;
          else {
            if (y = Xf(e2), !y) throw Kf(Gf(e2) + " is not iterable");
            if (Uf(y)) {
              for (h3 = 0, g = Jf(e2); g > h3; h3++) if (c = w(e2[h3]), c && ca(fa, c)) return c;
              return new br(false);
            }
            p = zf(e2, y);
          }
          for (f = n2 ? e2.next : p.next; !(F = Wf(f, p)).done; ) {
            try {
              c = w(F.value);
            } catch (E) {
              pa(p, "throw", E);
            }
            if (typeof c == "object" && c && ca(fa, c)) return c;
          }
          return new br(false);
        };
      });
      var ga = xe((Py, da) => {
        "use strict";
        var Yf = hr(), Qf = kt(), Zf = lr();
        da.exports = function(e2, r, t) {
          var s = Yf(r);
          s in e2 ? Qf.f(e2, s, Zf(0, t)) : e2[s] = t;
        };
      });
      var ya = xe(() => {
        var eD = Jt(), tD = ma(), rD = ga();
        eD({ target: "Object", stat: true }, { fromEntries: function(r) {
          var t = {};
          return tD(r, function(s, a) {
            rD(t, s, a);
          }, { AS_ENTRIES: true }), t;
        } });
      });
      var Ca = xe((Ly, va) => {
        var ha = An(), nD = kt();
        va.exports = function(e2, r, t) {
          return t.get && ha(t.get, r, { getter: true }), t.set && ha(t.set, r, { setter: true }), nD.f(e2, r, t);
        };
      });
      var Fa = xe((Oy, Ea) => {
        "use strict";
        var uD = Tt();
        Ea.exports = function() {
          var e2 = uD(this), r = "";
          return e2.hasIndices && (r += "d"), e2.global && (r += "g"), e2.ignoreCase && (r += "i"), e2.multiline && (r += "m"), e2.dotAll && (r += "s"), e2.unicode && (r += "u"), e2.unicodeSets && (r += "v"), e2.sticky && (r += "y"), r;
        };
      });
      var xa = xe(() => {
        var sD = pt(), iD = yt(), aD = Ca(), oD = Fa(), lD = Dt(), Aa = sD.RegExp, Sa = Aa.prototype, cD = iD && lD(function() {
          var e2 = true;
          try {
            Aa(".", "d");
          } catch (e3) {
            e2 = false;
          }
          var r = {}, t = "", s = e2 ? "dgimsy" : "gimsy", a = function(l, p) {
            Object.defineProperty(r, l, { get: function() {
              return t += p, true;
            } });
          }, n2 = { dotAll: "s", global: "g", ignoreCase: "i", multiline: "m", sticky: "y" };
          e2 && (n2.hasIndices = "d");
          for (var u in n2) a(u, n2[u]);
          var i = Object.getOwnPropertyDescriptor(Sa, "flags").get.call(r);
          return i !== s || t !== s;
        });
        cD && aD(Sa, "flags", { configurable: true, get: oD });
      });
      var ba = xe(() => {
        var pD = Jt(), kn = pt();
        pD({ global: true, forced: kn.globalThis !== kn }, { globalThis: kn });
      });
      var Ta = xe(() => {
        ba();
      });
      var Ba = xe(() => {
        "use strict";
        var fD = Jt(), DD = Bn(), mD = yr(), dD = Lt(), gD = Sr(), yD = _n();
        fD({ target: "Array", proto: true }, { flat: function() {
          var r = arguments.length ? arguments[0] : void 0, t = mD(this), s = dD(t), a = yD(t, 0);
          return a.length = DD(a, t, t, s, 0, r === void 0 ? 1 : gD(r)), a;
        } });
      });
      var e0 = xe((Uy, jo) => {
        var hD = ["cliName", "cliCategory", "cliDescription"], vD = ["_"], CD = ["languageId"];
        function Hn(e2, r) {
          if (e2 == null) return {};
          var t = ED(e2, r), s, a;
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            for (a = 0; a < n2.length; a++) s = n2[a], !(r.indexOf(s) >= 0) && Object.prototype.propertyIsEnumerable.call(e2, s) && (t[s] = e2[s]);
          }
          return t;
        }
        function ED(e2, r) {
          if (e2 == null) return {};
          var t = {}, s = Object.keys(e2), a, n2;
          for (n2 = 0; n2 < s.length; n2++) a = s[n2], !(r.indexOf(a) >= 0) && (t[a] = e2[a]);
          return t;
        }
        Zi();
        ya();
        xa();
        Ta();
        Ba();
        var FD = Object.create, _r = Object.defineProperty, AD = Object.getOwnPropertyDescriptor, Gn = Object.getOwnPropertyNames, SD = Object.getPrototypeOf, xD = Object.prototype.hasOwnProperty, ht = (e2, r) => function() {
          return e2 && (r = (0, e2[Gn(e2)[0]])(e2 = 0)), r;
        }, te = (e2, r) => function() {
          return r || (0, e2[Gn(e2)[0]])((r = { exports: {} }).exports, r), r.exports;
        }, Kt = (e2, r) => {
          for (var t in r) _r(e2, t, { get: r[t], enumerable: true });
        }, Pa = (e2, r, t, s) => {
          if (r && typeof r == "object" || typeof r == "function") for (let a of Gn(r)) !xD.call(e2, a) && a !== t && _r(e2, a, { get: () => r[a], enumerable: !(s = AD(r, a)) || s.enumerable });
          return e2;
        }, bD = (e2, r, t) => (t = e2 != null ? FD(SD(e2)) : {}, Pa(r || !e2 || !e2.__esModule ? _r(t, "default", { value: e2, enumerable: true }) : t, e2)), ft = (e2) => Pa(_r({}, "__esModule", { value: true }), e2), wt, ne = ht({ "<define:process>"() {
          wt = { env: {}, argv: [] };
        } }), Ia = te({ "package.json"(e2, r) {
          r.exports = { version: "2.8.8" };
        } }), TD = te({ "node_modules/diff/lib/diff/base.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true }), e2.default = r;
          function r() {
          }
          r.prototype = { diff: function(n2, u) {
            var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, l = i.callback;
            typeof i == "function" && (l = i, i = {}), this.options = i;
            var p = this;
            function y(N) {
              return l ? (setTimeout(function() {
                l(void 0, N);
              }, 0), true) : N;
            }
            n2 = this.castInput(n2), u = this.castInput(u), n2 = this.removeEmpty(this.tokenize(n2)), u = this.removeEmpty(this.tokenize(u));
            var h3 = u.length, g = n2.length, c = 1, f = h3 + g, F = [{ newPos: -1, components: [] }], _ = this.extractCommon(F[0], u, n2, 0);
            if (F[0].newPos + 1 >= h3 && _ + 1 >= g) return y([{ value: this.join(u), count: u.length }]);
            function w() {
              for (var N = -1 * c; N <= c; N += 2) {
                var x2 = void 0, I = F[N - 1], P = F[N + 1], $ = (P ? P.newPos : 0) - N;
                I && (F[N - 1] = void 0);
                var D = I && I.newPos + 1 < h3, T = P && 0 <= $ && $ < g;
                if (!D && !T) {
                  F[N] = void 0;
                  continue;
                }
                if (!D || T && I.newPos < P.newPos ? (x2 = s(P), p.pushComponent(x2.components, void 0, true)) : (x2 = I, x2.newPos++, p.pushComponent(x2.components, true, void 0)), $ = p.extractCommon(x2, u, n2, N), x2.newPos + 1 >= h3 && $ + 1 >= g) return y(t(p, x2.components, u, n2, p.useLongestToken));
                F[N] = x2;
              }
              c++;
            }
            if (l) (function N() {
              setTimeout(function() {
                if (c > f) return l();
                w() || N();
              }, 0);
            })();
            else for (; c <= f; ) {
              var E = w();
              if (E) return E;
            }
          }, pushComponent: function(n2, u, i) {
            var l = n2[n2.length - 1];
            l && l.added === u && l.removed === i ? n2[n2.length - 1] = { count: l.count + 1, added: u, removed: i } : n2.push({ count: 1, added: u, removed: i });
          }, extractCommon: function(n2, u, i, l) {
            for (var p = u.length, y = i.length, h3 = n2.newPos, g = h3 - l, c = 0; h3 + 1 < p && g + 1 < y && this.equals(u[h3 + 1], i[g + 1]); ) h3++, g++, c++;
            return c && n2.components.push({ count: c }), n2.newPos = h3, g;
          }, equals: function(n2, u) {
            return this.options.comparator ? this.options.comparator(n2, u) : n2 === u || this.options.ignoreCase && n2.toLowerCase() === u.toLowerCase();
          }, removeEmpty: function(n2) {
            for (var u = [], i = 0; i < n2.length; i++) n2[i] && u.push(n2[i]);
            return u;
          }, castInput: function(n2) {
            return n2;
          }, tokenize: function(n2) {
            return n2.split("");
          }, join: function(n2) {
            return n2.join("");
          } };
          function t(a, n2, u, i, l) {
            for (var p = 0, y = n2.length, h3 = 0, g = 0; p < y; p++) {
              var c = n2[p];
              if (c.removed) {
                if (c.value = a.join(i.slice(g, g + c.count)), g += c.count, p && n2[p - 1].added) {
                  var F = n2[p - 1];
                  n2[p - 1] = n2[p], n2[p] = F;
                }
              } else {
                if (!c.added && l) {
                  var f = u.slice(h3, h3 + c.count);
                  f = f.map(function(w, E) {
                    var N = i[g + E];
                    return N.length > w.length ? N : w;
                  }), c.value = a.join(f);
                } else c.value = a.join(u.slice(h3, h3 + c.count));
                h3 += c.count, c.added || (g += c.count);
              }
            }
            var _ = n2[y - 1];
            return y > 1 && typeof _.value == "string" && (_.added || _.removed) && a.equals("", _.value) && (n2[y - 2].value += _.value, n2.pop()), n2;
          }
          function s(a) {
            return { newPos: a.newPos, components: a.components.slice(0) };
          }
        } }), BD = te({ "node_modules/diff/lib/diff/array.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true }), e2.diffArrays = a, e2.arrayDiff = void 0;
          var r = t(TD());
          function t(n2) {
            return n2 && n2.__esModule ? n2 : { default: n2 };
          }
          var s = new r.default();
          e2.arrayDiff = s, s.tokenize = function(n2) {
            return n2.slice();
          }, s.join = s.removeEmpty = function(n2) {
            return n2;
          };
          function a(n2, u, i) {
            return s.diff(n2, u, i);
          }
        } }), Un = te({ "src/document/doc-builders.js"(e2, r) {
          "use strict";
          ne();
          function t(C) {
            return { type: "concat", parts: C };
          }
          function s(C) {
            return { type: "indent", contents: C };
          }
          function a(C, o) {
            return { type: "align", contents: o, n: C };
          }
          function n2(C) {
            let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return { type: "group", id: o.id, contents: C, break: Boolean(o.shouldBreak), expandedStates: o.expandedStates };
          }
          function u(C) {
            return a(Number.NEGATIVE_INFINITY, C);
          }
          function i(C) {
            return a({ type: "root" }, C);
          }
          function l(C) {
            return a(-1, C);
          }
          function p(C, o) {
            return n2(C[0], Object.assign(Object.assign({}, o), {}, { expandedStates: C }));
          }
          function y(C) {
            return { type: "fill", parts: C };
          }
          function h3(C, o) {
            let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return { type: "if-break", breakContents: C, flatContents: o, groupId: d.groupId };
          }
          function g(C, o) {
            return { type: "indent-if-break", contents: C, groupId: o.groupId, negate: o.negate };
          }
          function c(C) {
            return { type: "line-suffix", contents: C };
          }
          var f = { type: "line-suffix-boundary" }, F = { type: "break-parent" }, _ = { type: "trim" }, w = { type: "line", hard: true }, E = { type: "line", hard: true, literal: true }, N = { type: "line" }, x2 = { type: "line", soft: true }, I = t([w, F]), P = t([E, F]), $ = { type: "cursor", placeholder: Symbol("cursor") };
          function D(C, o) {
            let d = [];
            for (let v = 0; v < o.length; v++) v !== 0 && d.push(C), d.push(o[v]);
            return t(d);
          }
          function T(C, o, d) {
            let v = C;
            if (o > 0) {
              for (let S = 0; S < Math.floor(o / d); ++S) v = s(v);
              v = a(o % d, v), v = a(Number.NEGATIVE_INFINITY, v);
            }
            return v;
          }
          function m(C, o) {
            return { type: "label", label: C, contents: o };
          }
          r.exports = { concat: t, join: D, line: N, softline: x2, hardline: I, literalline: P, group: n2, conditionalGroup: p, fill: y, lineSuffix: c, lineSuffixBoundary: f, cursor: $, breakParent: F, ifBreak: h3, trim: _, indent: s, indentIfBreak: g, align: a, addAlignmentToDoc: T, markAsRoot: i, dedentToRoot: u, dedent: l, hardlineWithoutBreakParent: w, literallineWithoutBreakParent: E, label: m };
        } }), Jn = te({ "src/common/end-of-line.js"(e2, r) {
          "use strict";
          ne();
          function t(u) {
            let i = u.indexOf("\r");
            return i >= 0 ? u.charAt(i + 1) === `
` ? "crlf" : "cr" : "lf";
          }
          function s(u) {
            switch (u) {
              case "cr":
                return "\r";
              case "crlf":
                return `\r
`;
              default:
                return `
`;
            }
          }
          function a(u, i) {
            let l;
            switch (i) {
              case `
`:
                l = /\n/g;
                break;
              case "\r":
                l = /\r/g;
                break;
              case `\r
`:
                l = /\r\n/g;
                break;
              default:
                throw new Error(`Unexpected "eol" ${JSON.stringify(i)}.`);
            }
            let p = u.match(l);
            return p ? p.length : 0;
          }
          function n2(u) {
            return u.replace(/\r\n?/g, `
`);
          }
          r.exports = { guessEndOfLine: t, convertEndOfLineToChars: s, countEndOfLineChars: a, normalizeEndOfLine: n2 };
        } }), lt = te({ "src/utils/get-last.js"(e2, r) {
          "use strict";
          ne();
          var t = (s) => s[s.length - 1];
          r.exports = t;
        } });
        function ND() {
          let { onlyFirst: e2 = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
          return new RegExp(r, e2 ? void 0 : "g");
        }
        var wD = ht({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
          ne();
        } });
        function _D(e2) {
          if (typeof e2 != "string") throw new TypeError(`Expected a \`string\`, got \`${typeof e2}\``);
          return e2.replace(ND(), "");
        }
        var PD = ht({ "node_modules/strip-ansi/index.js"() {
          ne(), wD();
        } });
        function ID(e2) {
          return Number.isInteger(e2) ? e2 >= 4352 && (e2 <= 4447 || e2 === 9001 || e2 === 9002 || 11904 <= e2 && e2 <= 12871 && e2 !== 12351 || 12880 <= e2 && e2 <= 19903 || 19968 <= e2 && e2 <= 42182 || 43360 <= e2 && e2 <= 43388 || 44032 <= e2 && e2 <= 55203 || 63744 <= e2 && e2 <= 64255 || 65040 <= e2 && e2 <= 65049 || 65072 <= e2 && e2 <= 65131 || 65281 <= e2 && e2 <= 65376 || 65504 <= e2 && e2 <= 65510 || 110592 <= e2 && e2 <= 110593 || 127488 <= e2 && e2 <= 127569 || 131072 <= e2 && e2 <= 262141) : false;
        }
        var kD = ht({ "node_modules/is-fullwidth-code-point/index.js"() {
          ne();
        } }), LD = te({ "node_modules/emoji-regex/index.js"(e2, r) {
          "use strict";
          ne(), r.exports = function() {
            return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
          };
        } }), ka = {};
        Kt(ka, { default: () => OD });
        function OD(e2) {
          if (typeof e2 != "string" || e2.length === 0 || (e2 = _D(e2), e2.length === 0)) return 0;
          e2 = e2.replace((0, La.default)(), "  ");
          let r = 0;
          for (let t = 0; t < e2.length; t++) {
            let s = e2.codePointAt(t);
            s <= 31 || s >= 127 && s <= 159 || s >= 768 && s <= 879 || (s > 65535 && t++, r += ID(s) ? 2 : 1);
          }
          return r;
        }
        var La, jD = ht({ "node_modules/string-width/index.js"() {
          ne(), PD(), kD(), La = bD(LD());
        } }), Oa = te({ "src/utils/get-string-width.js"(e2, r) {
          "use strict";
          ne();
          var t = (jD(), ft(ka)).default, s = /[^\x20-\x7F]/;
          function a(n2) {
            return n2 ? s.test(n2) ? t(n2) : n2.length : 0;
          }
          r.exports = a;
        } }), Yt = te({ "src/document/doc-utils.js"(e2, r) {
          "use strict";
          ne();
          var t = lt(), { literalline: s, join: a } = Un(), n2 = (o) => Array.isArray(o) || o && o.type === "concat", u = (o) => {
            if (Array.isArray(o)) return o;
            if (o.type !== "concat" && o.type !== "fill") throw new Error("Expect doc type to be `concat` or `fill`.");
            return o.parts;
          }, i = {};
          function l(o, d, v, S) {
            let b = [o];
            for (; b.length > 0; ) {
              let B = b.pop();
              if (B === i) {
                v(b.pop());
                continue;
              }
              if (v && b.push(B, i), !d || d(B) !== false) if (n2(B) || B.type === "fill") {
                let k = u(B);
                for (let M = k.length, R = M - 1; R >= 0; --R) b.push(k[R]);
              } else if (B.type === "if-break") B.flatContents && b.push(B.flatContents), B.breakContents && b.push(B.breakContents);
              else if (B.type === "group" && B.expandedStates) if (S) for (let k = B.expandedStates.length, M = k - 1; M >= 0; --M) b.push(B.expandedStates[M]);
              else b.push(B.contents);
              else B.contents && b.push(B.contents);
            }
          }
          function p(o, d) {
            let v = /* @__PURE__ */ new Map();
            return S(o);
            function S(B) {
              if (v.has(B)) return v.get(B);
              let k = b(B);
              return v.set(B, k), k;
            }
            function b(B) {
              if (Array.isArray(B)) return d(B.map(S));
              if (B.type === "concat" || B.type === "fill") {
                let k = B.parts.map(S);
                return d(Object.assign(Object.assign({}, B), {}, { parts: k }));
              }
              if (B.type === "if-break") {
                let k = B.breakContents && S(B.breakContents), M = B.flatContents && S(B.flatContents);
                return d(Object.assign(Object.assign({}, B), {}, { breakContents: k, flatContents: M }));
              }
              if (B.type === "group" && B.expandedStates) {
                let k = B.expandedStates.map(S), M = k[0];
                return d(Object.assign(Object.assign({}, B), {}, { contents: M, expandedStates: k }));
              }
              if (B.contents) {
                let k = S(B.contents);
                return d(Object.assign(Object.assign({}, B), {}, { contents: k }));
              }
              return d(B);
            }
          }
          function y(o, d, v) {
            let S = v, b = false;
            function B(k) {
              let M = d(k);
              if (M !== void 0 && (b = true, S = M), b) return false;
            }
            return l(o, B), S;
          }
          function h3(o) {
            if (o.type === "group" && o.break || o.type === "line" && o.hard || o.type === "break-parent") return true;
          }
          function g(o) {
            return y(o, h3, false);
          }
          function c(o) {
            if (o.length > 0) {
              let d = t(o);
              !d.expandedStates && !d.break && (d.break = "propagated");
            }
            return null;
          }
          function f(o) {
            let d = /* @__PURE__ */ new Set(), v = [];
            function S(B) {
              if (B.type === "break-parent" && c(v), B.type === "group") {
                if (v.push(B), d.has(B)) return false;
                d.add(B);
              }
            }
            function b(B) {
              B.type === "group" && v.pop().break && c(v);
            }
            l(o, S, b, true);
          }
          function F(o) {
            return o.type === "line" && !o.hard ? o.soft ? "" : " " : o.type === "if-break" ? o.flatContents || "" : o;
          }
          function _(o) {
            return p(o, F);
          }
          var w = (o, d) => o && o.type === "line" && o.hard && d && d.type === "break-parent";
          function E(o) {
            if (!o) return o;
            if (n2(o) || o.type === "fill") {
              let d = u(o);
              for (; d.length > 1 && w(...d.slice(-2)); ) d.length -= 2;
              if (d.length > 0) {
                let v = E(t(d));
                d[d.length - 1] = v;
              }
              return Array.isArray(o) ? d : Object.assign(Object.assign({}, o), {}, { parts: d });
            }
            switch (o.type) {
              case "align":
              case "indent":
              case "indent-if-break":
              case "group":
              case "line-suffix":
              case "label": {
                let d = E(o.contents);
                return Object.assign(Object.assign({}, o), {}, { contents: d });
              }
              case "if-break": {
                let d = E(o.breakContents), v = E(o.flatContents);
                return Object.assign(Object.assign({}, o), {}, { breakContents: d, flatContents: v });
              }
            }
            return o;
          }
          function N(o) {
            return E(I(o));
          }
          function x2(o) {
            switch (o.type) {
              case "fill":
                if (o.parts.every((v) => v === "")) return "";
                break;
              case "group":
                if (!o.contents && !o.id && !o.break && !o.expandedStates) return "";
                if (o.contents.type === "group" && o.contents.id === o.id && o.contents.break === o.break && o.contents.expandedStates === o.expandedStates) return o.contents;
                break;
              case "align":
              case "indent":
              case "indent-if-break":
              case "line-suffix":
                if (!o.contents) return "";
                break;
              case "if-break":
                if (!o.flatContents && !o.breakContents) return "";
                break;
            }
            if (!n2(o)) return o;
            let d = [];
            for (let v of u(o)) {
              if (!v) continue;
              let [S, ...b] = n2(v) ? u(v) : [v];
              typeof S == "string" && typeof t(d) == "string" ? d[d.length - 1] += S : d.push(S), d.push(...b);
            }
            return d.length === 0 ? "" : d.length === 1 ? d[0] : Array.isArray(o) ? d : Object.assign(Object.assign({}, o), {}, { parts: d });
          }
          function I(o) {
            return p(o, (d) => x2(d));
          }
          function P(o) {
            let d = [], v = o.filter(Boolean);
            for (; v.length > 0; ) {
              let S = v.shift();
              if (S) {
                if (n2(S)) {
                  v.unshift(...u(S));
                  continue;
                }
                if (d.length > 0 && typeof t(d) == "string" && typeof S == "string") {
                  d[d.length - 1] += S;
                  continue;
                }
                d.push(S);
              }
            }
            return d;
          }
          function $(o) {
            return p(o, (d) => Array.isArray(d) ? P(d) : d.parts ? Object.assign(Object.assign({}, d), {}, { parts: P(d.parts) }) : d);
          }
          function D(o) {
            return p(o, (d) => typeof d == "string" && d.includes(`
`) ? T(d) : d);
          }
          function T(o) {
            let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s;
            return a(d, o.split(`
`)).parts;
          }
          function m(o) {
            if (o.type === "line") return true;
          }
          function C(o) {
            return y(o, m, false);
          }
          r.exports = { isConcat: n2, getDocParts: u, willBreak: g, traverseDoc: l, findInDoc: y, mapDoc: p, propagateBreaks: f, removeLines: _, stripTrailingHardline: N, normalizeParts: P, normalizeDoc: $, cleanDoc: I, replaceTextEndOfLine: T, replaceEndOfLine: D, canBreak: C };
        } }), qD = te({ "src/document/doc-printer.js"(e2, r) {
          "use strict";
          ne();
          var { convertEndOfLineToChars: t } = Jn(), s = lt(), a = Oa(), { fill: n2, cursor: u, indent: i } = Un(), { isConcat: l, getDocParts: p } = Yt(), y, h3 = 1, g = 2;
          function c() {
            return { value: "", length: 0, queue: [] };
          }
          function f(x2, I) {
            return _(x2, { type: "indent" }, I);
          }
          function F(x2, I, P) {
            return I === Number.NEGATIVE_INFINITY ? x2.root || c() : I < 0 ? _(x2, { type: "dedent" }, P) : I ? I.type === "root" ? Object.assign(Object.assign({}, x2), {}, { root: x2 }) : _(x2, { type: typeof I == "string" ? "stringAlign" : "numberAlign", n: I }, P) : x2;
          }
          function _(x2, I, P) {
            let $ = I.type === "dedent" ? x2.queue.slice(0, -1) : [...x2.queue, I], D = "", T = 0, m = 0, C = 0;
            for (let k of $) switch (k.type) {
              case "indent":
                v(), P.useTabs ? o(1) : d(P.tabWidth);
                break;
              case "stringAlign":
                v(), D += k.n, T += k.n.length;
                break;
              case "numberAlign":
                m += 1, C += k.n;
                break;
              default:
                throw new Error(`Unexpected type '${k.type}'`);
            }
            return b(), Object.assign(Object.assign({}, x2), {}, { value: D, length: T, queue: $ });
            function o(k) {
              D += "	".repeat(k), T += P.tabWidth * k;
            }
            function d(k) {
              D += " ".repeat(k), T += k;
            }
            function v() {
              P.useTabs ? S() : b();
            }
            function S() {
              m > 0 && o(m), B();
            }
            function b() {
              C > 0 && d(C), B();
            }
            function B() {
              m = 0, C = 0;
            }
          }
          function w(x2) {
            if (x2.length === 0) return 0;
            let I = 0;
            for (; x2.length > 0 && typeof s(x2) == "string" && /^[\t ]*$/.test(s(x2)); ) I += x2.pop().length;
            if (x2.length > 0 && typeof s(x2) == "string") {
              let P = s(x2).replace(/[\t ]*$/, "");
              I += s(x2).length - P.length, x2[x2.length - 1] = P;
            }
            return I;
          }
          function E(x2, I, P, $, D) {
            let T = I.length, m = [x2], C = [];
            for (; P >= 0; ) {
              if (m.length === 0) {
                if (T === 0) return true;
                m.push(I[--T]);
                continue;
              }
              let { mode: o, doc: d } = m.pop();
              if (typeof d == "string") C.push(d), P -= a(d);
              else if (l(d) || d.type === "fill") {
                let v = p(d);
                for (let S = v.length - 1; S >= 0; S--) m.push({ mode: o, doc: v[S] });
              } else switch (d.type) {
                case "indent":
                case "align":
                case "indent-if-break":
                case "label":
                  m.push({ mode: o, doc: d.contents });
                  break;
                case "trim":
                  P += w(C);
                  break;
                case "group": {
                  if (D && d.break) return false;
                  let v = d.break ? h3 : o, S = d.expandedStates && v === h3 ? s(d.expandedStates) : d.contents;
                  m.push({ mode: v, doc: S });
                  break;
                }
                case "if-break": {
                  let S = (d.groupId ? y[d.groupId] || g : o) === h3 ? d.breakContents : d.flatContents;
                  S && m.push({ mode: o, doc: S });
                  break;
                }
                case "line":
                  if (o === h3 || d.hard) return true;
                  d.soft || (C.push(" "), P--);
                  break;
                case "line-suffix":
                  $ = true;
                  break;
                case "line-suffix-boundary":
                  if ($) return false;
                  break;
              }
            }
            return false;
          }
          function N(x2, I) {
            y = {};
            let P = I.printWidth, $ = t(I.endOfLine), D = 0, T = [{ ind: c(), mode: h3, doc: x2 }], m = [], C = false, o = [];
            for (; T.length > 0; ) {
              let { ind: v, mode: S, doc: b } = T.pop();
              if (typeof b == "string") {
                let B = $ !== `
` ? b.replace(/\n/g, $) : b;
                m.push(B), D += a(B);
              } else if (l(b)) {
                let B = p(b);
                for (let k = B.length - 1; k >= 0; k--) T.push({ ind: v, mode: S, doc: B[k] });
              } else switch (b.type) {
                case "cursor":
                  m.push(u.placeholder);
                  break;
                case "indent":
                  T.push({ ind: f(v, I), mode: S, doc: b.contents });
                  break;
                case "align":
                  T.push({ ind: F(v, b.n, I), mode: S, doc: b.contents });
                  break;
                case "trim":
                  D -= w(m);
                  break;
                case "group":
                  switch (S) {
                    case g:
                      if (!C) {
                        T.push({ ind: v, mode: b.break ? h3 : g, doc: b.contents });
                        break;
                      }
                    case h3: {
                      C = false;
                      let B = { ind: v, mode: g, doc: b.contents }, k = P - D, M = o.length > 0;
                      if (!b.break && E(B, T, k, M)) T.push(B);
                      else if (b.expandedStates) {
                        let R = s(b.expandedStates);
                        if (b.break) {
                          T.push({ ind: v, mode: h3, doc: R });
                          break;
                        } else for (let q = 1; q < b.expandedStates.length + 1; q++) if (q >= b.expandedStates.length) {
                          T.push({ ind: v, mode: h3, doc: R });
                          break;
                        } else {
                          let J = b.expandedStates[q], L = { ind: v, mode: g, doc: J };
                          if (E(L, T, k, M)) {
                            T.push(L);
                            break;
                          }
                        }
                      } else T.push({ ind: v, mode: h3, doc: b.contents });
                      break;
                    }
                  }
                  b.id && (y[b.id] = s(T).mode);
                  break;
                case "fill": {
                  let B = P - D, { parts: k } = b;
                  if (k.length === 0) break;
                  let [M, R] = k, q = { ind: v, mode: g, doc: M }, J = { ind: v, mode: h3, doc: M }, L = E(q, [], B, o.length > 0, true);
                  if (k.length === 1) {
                    L ? T.push(q) : T.push(J);
                    break;
                  }
                  let Q = { ind: v, mode: g, doc: R }, V = { ind: v, mode: h3, doc: R };
                  if (k.length === 2) {
                    L ? T.push(Q, q) : T.push(V, J);
                    break;
                  }
                  k.splice(0, 2);
                  let j = { ind: v, mode: S, doc: n2(k) }, Y = k[0];
                  E({ ind: v, mode: g, doc: [M, R, Y] }, [], B, o.length > 0, true) ? T.push(j, Q, q) : L ? T.push(j, V, q) : T.push(j, V, J);
                  break;
                }
                case "if-break":
                case "indent-if-break": {
                  let B = b.groupId ? y[b.groupId] : S;
                  if (B === h3) {
                    let k = b.type === "if-break" ? b.breakContents : b.negate ? b.contents : i(b.contents);
                    k && T.push({ ind: v, mode: S, doc: k });
                  }
                  if (B === g) {
                    let k = b.type === "if-break" ? b.flatContents : b.negate ? i(b.contents) : b.contents;
                    k && T.push({ ind: v, mode: S, doc: k });
                  }
                  break;
                }
                case "line-suffix":
                  o.push({ ind: v, mode: S, doc: b.contents });
                  break;
                case "line-suffix-boundary":
                  o.length > 0 && T.push({ ind: v, mode: S, doc: { type: "line", hard: true } });
                  break;
                case "line":
                  switch (S) {
                    case g:
                      if (b.hard) C = true;
                      else {
                        b.soft || (m.push(" "), D += 1);
                        break;
                      }
                    case h3:
                      if (o.length > 0) {
                        T.push({ ind: v, mode: S, doc: b }, ...o.reverse()), o.length = 0;
                        break;
                      }
                      b.literal ? v.root ? (m.push($, v.root.value), D = v.root.length) : (m.push($), D = 0) : (D -= w(m), m.push($ + v.value), D = v.length);
                      break;
                  }
                  break;
                case "label":
                  T.push({ ind: v, mode: S, doc: b.contents });
                  break;
                default:
              }
              T.length === 0 && o.length > 0 && (T.push(...o.reverse()), o.length = 0);
            }
            let d = m.indexOf(u.placeholder);
            if (d !== -1) {
              let v = m.indexOf(u.placeholder, d + 1), S = m.slice(0, d).join(""), b = m.slice(d + 1, v).join(""), B = m.slice(v + 1).join("");
              return { formatted: S + b + B, cursorNodeStart: S.length, cursorNodeText: b };
            }
            return { formatted: m.join("") };
          }
          r.exports = { printDocToString: N };
        } }), MD = te({ "src/document/doc-debug.js"(e2, r) {
          "use strict";
          ne();
          var { isConcat: t, getDocParts: s } = Yt();
          function a(u) {
            if (!u) return "";
            if (t(u)) {
              let i = [];
              for (let l of s(u)) if (t(l)) i.push(...a(l).parts);
              else {
                let p = a(l);
                p !== "" && i.push(p);
              }
              return { type: "concat", parts: i };
            }
            return u.type === "if-break" ? Object.assign(Object.assign({}, u), {}, { breakContents: a(u.breakContents), flatContents: a(u.flatContents) }) : u.type === "group" ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents), expandedStates: u.expandedStates && u.expandedStates.map(a) }) : u.type === "fill" ? { type: "fill", parts: u.parts.map(a) } : u.contents ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents) }) : u;
          }
          function n2(u) {
            let i = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ new Set();
            return p(a(u));
            function p(h3, g, c) {
              if (typeof h3 == "string") return JSON.stringify(h3);
              if (t(h3)) {
                let f = s(h3).map(p).filter(Boolean);
                return f.length === 1 ? f[0] : `[${f.join(", ")}]`;
              }
              if (h3.type === "line") {
                let f = Array.isArray(c) && c[g + 1] && c[g + 1].type === "break-parent";
                return h3.literal ? f ? "literalline" : "literallineWithoutBreakParent" : h3.hard ? f ? "hardline" : "hardlineWithoutBreakParent" : h3.soft ? "softline" : "line";
              }
              if (h3.type === "break-parent") return Array.isArray(c) && c[g - 1] && c[g - 1].type === "line" && c[g - 1].hard ? void 0 : "breakParent";
              if (h3.type === "trim") return "trim";
              if (h3.type === "indent") return "indent(" + p(h3.contents) + ")";
              if (h3.type === "align") return h3.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + p(h3.contents) + ")" : h3.n < 0 ? "dedent(" + p(h3.contents) + ")" : h3.n.type === "root" ? "markAsRoot(" + p(h3.contents) + ")" : "align(" + JSON.stringify(h3.n) + ", " + p(h3.contents) + ")";
              if (h3.type === "if-break") return "ifBreak(" + p(h3.breakContents) + (h3.flatContents ? ", " + p(h3.flatContents) : "") + (h3.groupId ? (h3.flatContents ? "" : ', ""') + `, { groupId: ${y(h3.groupId)} }` : "") + ")";
              if (h3.type === "indent-if-break") {
                let f = [];
                h3.negate && f.push("negate: true"), h3.groupId && f.push(`groupId: ${y(h3.groupId)}`);
                let F = f.length > 0 ? `, { ${f.join(", ")} }` : "";
                return `indentIfBreak(${p(h3.contents)}${F})`;
              }
              if (h3.type === "group") {
                let f = [];
                h3.break && h3.break !== "propagated" && f.push("shouldBreak: true"), h3.id && f.push(`id: ${y(h3.id)}`);
                let F = f.length > 0 ? `, { ${f.join(", ")} }` : "";
                return h3.expandedStates ? `conditionalGroup([${h3.expandedStates.map((_) => p(_)).join(",")}]${F})` : `group(${p(h3.contents)}${F})`;
              }
              if (h3.type === "fill") return `fill([${h3.parts.map((f) => p(f)).join(", ")}])`;
              if (h3.type === "line-suffix") return "lineSuffix(" + p(h3.contents) + ")";
              if (h3.type === "line-suffix-boundary") return "lineSuffixBoundary";
              if (h3.type === "label") return `label(${JSON.stringify(h3.label)}, ${p(h3.contents)})`;
              throw new Error("Unknown doc type " + h3.type);
            }
            function y(h3) {
              if (typeof h3 != "symbol") return JSON.stringify(String(h3));
              if (h3 in i) return i[h3];
              let g = String(h3).slice(7, -1) || "symbol";
              for (let c = 0; ; c++) {
                let f = g + (c > 0 ? ` #${c}` : "");
                if (!l.has(f)) return l.add(f), i[h3] = `Symbol.for(${JSON.stringify(f)})`;
              }
            }
          }
          r.exports = { printDocToDebug: n2 };
        } }), qe = te({ "src/document/index.js"(e2, r) {
          "use strict";
          ne(), r.exports = { builders: Un(), printer: qD(), utils: Yt(), debug: MD() };
        } }), ja = {};
        Kt(ja, { default: () => RD });
        function RD(e2) {
          if (typeof e2 != "string") throw new TypeError("Expected a string");
          return e2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        }
        var $D = ht({ "node_modules/escape-string-regexp/index.js"() {
          ne();
        } }), qa = te({ "node_modules/semver/internal/debug.js"(e2, r) {
          ne();
          var t = typeof wt == "object" && wt.env && wt.env.NODE_DEBUG && /\bsemver\b/i.test(wt.env.NODE_DEBUG) ? function() {
            for (var s = arguments.length, a = new Array(s), n2 = 0; n2 < s; n2++) a[n2] = arguments[n2];
            return console.error("SEMVER", ...a);
          } : () => {
          };
          r.exports = t;
        } }), Ma = te({ "node_modules/semver/internal/constants.js"(e2, r) {
          ne();
          var t = "2.0.0", s = 256, a = Number.MAX_SAFE_INTEGER || 9007199254740991, n2 = 16;
          r.exports = { SEMVER_SPEC_VERSION: t, MAX_LENGTH: s, MAX_SAFE_INTEGER: a, MAX_SAFE_COMPONENT_LENGTH: n2 };
        } }), VD = te({ "node_modules/semver/internal/re.js"(e2, r) {
          ne();
          var { MAX_SAFE_COMPONENT_LENGTH: t } = Ma(), s = qa();
          e2 = r.exports = {};
          var a = e2.re = [], n2 = e2.src = [], u = e2.t = {}, i = 0, l = (p, y, h3) => {
            let g = i++;
            s(p, g, y), u[p] = g, n2[g] = y, a[g] = new RegExp(y, h3 ? "g" : void 0);
          };
          l("NUMERICIDENTIFIER", "0|[1-9]\\d*"), l("NUMERICIDENTIFIERLOOSE", "[0-9]+"), l("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), l("MAINVERSION", `(${n2[u.NUMERICIDENTIFIER]})\\.(${n2[u.NUMERICIDENTIFIER]})\\.(${n2[u.NUMERICIDENTIFIER]})`), l("MAINVERSIONLOOSE", `(${n2[u.NUMERICIDENTIFIERLOOSE]})\\.(${n2[u.NUMERICIDENTIFIERLOOSE]})\\.(${n2[u.NUMERICIDENTIFIERLOOSE]})`), l("PRERELEASEIDENTIFIER", `(?:${n2[u.NUMERICIDENTIFIER]}|${n2[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASEIDENTIFIERLOOSE", `(?:${n2[u.NUMERICIDENTIFIERLOOSE]}|${n2[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASE", `(?:-(${n2[u.PRERELEASEIDENTIFIER]}(?:\\.${n2[u.PRERELEASEIDENTIFIER]})*))`), l("PRERELEASELOOSE", `(?:-?(${n2[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${n2[u.PRERELEASEIDENTIFIERLOOSE]})*))`), l("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), l("BUILD", `(?:\\+(${n2[u.BUILDIDENTIFIER]}(?:\\.${n2[u.BUILDIDENTIFIER]})*))`), l("FULLPLAIN", `v?${n2[u.MAINVERSION]}${n2[u.PRERELEASE]}?${n2[u.BUILD]}?`), l("FULL", `^${n2[u.FULLPLAIN]}$`), l("LOOSEPLAIN", `[v=\\s]*${n2[u.MAINVERSIONLOOSE]}${n2[u.PRERELEASELOOSE]}?${n2[u.BUILD]}?`), l("LOOSE", `^${n2[u.LOOSEPLAIN]}$`), l("GTLT", "((?:<|>)?=?)"), l("XRANGEIDENTIFIERLOOSE", `${n2[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), l("XRANGEIDENTIFIER", `${n2[u.NUMERICIDENTIFIER]}|x|X|\\*`), l("XRANGEPLAIN", `[v=\\s]*(${n2[u.XRANGEIDENTIFIER]})(?:\\.(${n2[u.XRANGEIDENTIFIER]})(?:\\.(${n2[u.XRANGEIDENTIFIER]})(?:${n2[u.PRERELEASE]})?${n2[u.BUILD]}?)?)?`), l("XRANGEPLAINLOOSE", `[v=\\s]*(${n2[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n2[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n2[u.XRANGEIDENTIFIERLOOSE]})(?:${n2[u.PRERELEASELOOSE]})?${n2[u.BUILD]}?)?)?`), l("XRANGE", `^${n2[u.GTLT]}\\s*${n2[u.XRANGEPLAIN]}$`), l("XRANGELOOSE", `^${n2[u.GTLT]}\\s*${n2[u.XRANGEPLAINLOOSE]}$`), l("COERCE", `(^|[^\\d])(\\d{1,${t}})(?:\\.(\\d{1,${t}}))?(?:\\.(\\d{1,${t}}))?(?:$|[^\\d])`), l("COERCERTL", n2[u.COERCE], true), l("LONETILDE", "(?:~>?)"), l("TILDETRIM", `(\\s*)${n2[u.LONETILDE]}\\s+`, true), e2.tildeTrimReplace = "$1~", l("TILDE", `^${n2[u.LONETILDE]}${n2[u.XRANGEPLAIN]}$`), l("TILDELOOSE", `^${n2[u.LONETILDE]}${n2[u.XRANGEPLAINLOOSE]}$`), l("LONECARET", "(?:\\^)"), l("CARETTRIM", `(\\s*)${n2[u.LONECARET]}\\s+`, true), e2.caretTrimReplace = "$1^", l("CARET", `^${n2[u.LONECARET]}${n2[u.XRANGEPLAIN]}$`), l("CARETLOOSE", `^${n2[u.LONECARET]}${n2[u.XRANGEPLAINLOOSE]}$`), l("COMPARATORLOOSE", `^${n2[u.GTLT]}\\s*(${n2[u.LOOSEPLAIN]})$|^$`), l("COMPARATOR", `^${n2[u.GTLT]}\\s*(${n2[u.FULLPLAIN]})$|^$`), l("COMPARATORTRIM", `(\\s*)${n2[u.GTLT]}\\s*(${n2[u.LOOSEPLAIN]}|${n2[u.XRANGEPLAIN]})`, true), e2.comparatorTrimReplace = "$1$2$3", l("HYPHENRANGE", `^\\s*(${n2[u.XRANGEPLAIN]})\\s+-\\s+(${n2[u.XRANGEPLAIN]})\\s*$`), l("HYPHENRANGELOOSE", `^\\s*(${n2[u.XRANGEPLAINLOOSE]})\\s+-\\s+(${n2[u.XRANGEPLAINLOOSE]})\\s*$`), l("STAR", "(<|>)?=?\\s*\\*"), l("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), l("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
        } }), WD = te({ "node_modules/semver/internal/parse-options.js"(e2, r) {
          ne();
          var t = ["includePrerelease", "loose", "rtl"], s = (a) => a ? typeof a != "object" ? { loose: true } : t.filter((n2) => a[n2]).reduce((n2, u) => (n2[u] = true, n2), {}) : {};
          r.exports = s;
        } }), HD = te({ "node_modules/semver/internal/identifiers.js"(e2, r) {
          ne();
          var t = /^[0-9]+$/, s = (n2, u) => {
            let i = t.test(n2), l = t.test(u);
            return i && l && (n2 = +n2, u = +u), n2 === u ? 0 : i && !l ? -1 : l && !i ? 1 : n2 < u ? -1 : 1;
          }, a = (n2, u) => s(u, n2);
          r.exports = { compareIdentifiers: s, rcompareIdentifiers: a };
        } }), GD = te({ "node_modules/semver/classes/semver.js"(e2, r) {
          ne();
          var t = qa(), { MAX_LENGTH: s, MAX_SAFE_INTEGER: a } = Ma(), { re: n2, t: u } = VD(), i = WD(), { compareIdentifiers: l } = HD(), p = class {
            constructor(y, h3) {
              if (h3 = i(h3), y instanceof p) {
                if (y.loose === !!h3.loose && y.includePrerelease === !!h3.includePrerelease) return y;
                y = y.version;
              } else if (typeof y != "string") throw new TypeError(`Invalid Version: ${y}`);
              if (y.length > s) throw new TypeError(`version is longer than ${s} characters`);
              t("SemVer", y, h3), this.options = h3, this.loose = !!h3.loose, this.includePrerelease = !!h3.includePrerelease;
              let g = y.trim().match(h3.loose ? n2[u.LOOSE] : n2[u.FULL]);
              if (!g) throw new TypeError(`Invalid Version: ${y}`);
              if (this.raw = y, this.major = +g[1], this.minor = +g[2], this.patch = +g[3], this.major > a || this.major < 0) throw new TypeError("Invalid major version");
              if (this.minor > a || this.minor < 0) throw new TypeError("Invalid minor version");
              if (this.patch > a || this.patch < 0) throw new TypeError("Invalid patch version");
              g[4] ? this.prerelease = g[4].split(".").map((c) => {
                if (/^[0-9]+$/.test(c)) {
                  let f = +c;
                  if (f >= 0 && f < a) return f;
                }
                return c;
              }) : this.prerelease = [], this.build = g[5] ? g[5].split(".") : [], this.format();
            }
            format() {
              return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
            }
            toString() {
              return this.version;
            }
            compare(y) {
              if (t("SemVer.compare", this.version, this.options, y), !(y instanceof p)) {
                if (typeof y == "string" && y === this.version) return 0;
                y = new p(y, this.options);
              }
              return y.version === this.version ? 0 : this.compareMain(y) || this.comparePre(y);
            }
            compareMain(y) {
              return y instanceof p || (y = new p(y, this.options)), l(this.major, y.major) || l(this.minor, y.minor) || l(this.patch, y.patch);
            }
            comparePre(y) {
              if (y instanceof p || (y = new p(y, this.options)), this.prerelease.length && !y.prerelease.length) return -1;
              if (!this.prerelease.length && y.prerelease.length) return 1;
              if (!this.prerelease.length && !y.prerelease.length) return 0;
              let h3 = 0;
              do {
                let g = this.prerelease[h3], c = y.prerelease[h3];
                if (t("prerelease compare", h3, g, c), g === void 0 && c === void 0) return 0;
                if (c === void 0) return 1;
                if (g === void 0) return -1;
                if (g === c) continue;
                return l(g, c);
              } while (++h3);
            }
            compareBuild(y) {
              y instanceof p || (y = new p(y, this.options));
              let h3 = 0;
              do {
                let g = this.build[h3], c = y.build[h3];
                if (t("prerelease compare", h3, g, c), g === void 0 && c === void 0) return 0;
                if (c === void 0) return 1;
                if (g === void 0) return -1;
                if (g === c) continue;
                return l(g, c);
              } while (++h3);
            }
            inc(y, h3) {
              switch (y) {
                case "premajor":
                  this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", h3);
                  break;
                case "preminor":
                  this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", h3);
                  break;
                case "prepatch":
                  this.prerelease.length = 0, this.inc("patch", h3), this.inc("pre", h3);
                  break;
                case "prerelease":
                  this.prerelease.length === 0 && this.inc("patch", h3), this.inc("pre", h3);
                  break;
                case "major":
                  (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                  break;
                case "minor":
                  (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                  break;
                case "patch":
                  this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                  break;
                case "pre":
                  if (this.prerelease.length === 0) this.prerelease = [0];
                  else {
                    let g = this.prerelease.length;
                    for (; --g >= 0; ) typeof this.prerelease[g] == "number" && (this.prerelease[g]++, g = -2);
                    g === -1 && this.prerelease.push(0);
                  }
                  h3 && (l(this.prerelease[0], h3) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [h3, 0]) : this.prerelease = [h3, 0]);
                  break;
                default:
                  throw new Error(`invalid increment argument: ${y}`);
              }
              return this.format(), this.raw = this.version, this;
            }
          };
          r.exports = p;
        } }), zn = te({ "node_modules/semver/functions/compare.js"(e2, r) {
          ne();
          var t = GD(), s = (a, n2, u) => new t(a, u).compare(new t(n2, u));
          r.exports = s;
        } }), UD = te({ "node_modules/semver/functions/lt.js"(e2, r) {
          ne();
          var t = zn(), s = (a, n2, u) => t(a, n2, u) < 0;
          r.exports = s;
        } }), JD = te({ "node_modules/semver/functions/gte.js"(e2, r) {
          ne();
          var t = zn(), s = (a, n2, u) => t(a, n2, u) >= 0;
          r.exports = s;
        } }), zD = te({ "src/utils/arrayify.js"(e2, r) {
          "use strict";
          ne(), r.exports = (t, s) => Object.entries(t).map((a) => {
            let [n2, u] = a;
            return Object.assign({ [s]: n2 }, u);
          });
        } }), XD = te({ "node_modules/outdent/lib/index.js"(e2, r) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true }), e2.outdent = void 0;
          function t() {
            for (var E = [], N = 0; N < arguments.length; N++) E[N] = arguments[N];
          }
          function s() {
            return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : a();
          }
          function a() {
            return { add: t, delete: t, get: t, set: t, has: function(E) {
              return false;
            } };
          }
          var n2 = Object.prototype.hasOwnProperty, u = function(E, N) {
            return n2.call(E, N);
          };
          function i(E, N) {
            for (var x2 in N) u(N, x2) && (E[x2] = N[x2]);
            return E;
          }
          var l = /^[ \t]*(?:\r\n|\r|\n)/, p = /(?:\r\n|\r|\n)[ \t]*$/, y = /^(?:[\r\n]|$)/, h3 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, g = /^[ \t]*[\r\n][ \t\r\n]*$/;
          function c(E, N, x2) {
            var I = 0, P = E[0].match(h3);
            P && (I = P[1].length);
            var $ = "(\\r\\n|\\r|\\n).{0," + I + "}", D = new RegExp($, "g");
            N && (E = E.slice(1));
            var T = x2.newline, m = x2.trimLeadingNewline, C = x2.trimTrailingNewline, o = typeof T == "string", d = E.length, v = E.map(function(S, b) {
              return S = S.replace(D, "$1"), b === 0 && m && (S = S.replace(l, "")), b === d - 1 && C && (S = S.replace(p, "")), o && (S = S.replace(/\r\n|\n|\r/g, function(B) {
                return T;
              })), S;
            });
            return v;
          }
          function f(E, N) {
            for (var x2 = "", I = 0, P = E.length; I < P; I++) x2 += E[I], I < P - 1 && (x2 += N[I]);
            return x2;
          }
          function F(E) {
            return u(E, "raw") && u(E, "length");
          }
          function _(E) {
            var N = s(), x2 = s();
            function I($) {
              for (var D = [], T = 1; T < arguments.length; T++) D[T - 1] = arguments[T];
              if (F($)) {
                var m = $, C = (D[0] === I || D[0] === w) && g.test(m[0]) && y.test(m[1]), o = C ? x2 : N, d = o.get(m);
                if (d || (d = c(m, C, E), o.set(m, d)), D.length === 0) return d[0];
                var v = f(d, C ? D.slice(1) : D);
                return v;
              } else return _(i(i({}, E), $ || {}));
            }
            var P = i(I, { string: function($) {
              return c([$], false, E)[0];
            } });
            return P;
          }
          var w = _({ trimLeadingNewline: true, trimTrailingNewline: true });
          if (e2.outdent = w, e2.default = w, typeof r < "u") try {
            r.exports = w, Object.defineProperty(w, "__esModule", { value: true }), w.default = w, w.outdent = w;
          } catch (e3) {
          }
        } }), KD = te({ "src/main/core-options.js"(e2, r) {
          "use strict";
          ne();
          var { outdent: t } = XD(), s = "Config", a = "Editor", n2 = "Format", u = "Other", i = "Output", l = "Global", p = "Special", y = { cursorOffset: { since: "1.4.0", category: p, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: a }, endOfLine: { since: "1.15.0", category: l, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: t`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: p, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: u, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: p, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: u }, parser: { since: "0.0.10", category: l, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (h3) => typeof h3 == "string" || typeof h3 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: l, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (h3) => typeof h3 == "string" || typeof h3 == "object", cliName: "plugin", cliCategory: s }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: l, description: t`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (h3) => typeof h3 == "string" || typeof h3 == "object", cliName: "plugin-search-dir", cliCategory: s }, printWidth: { since: "0.0.0", category: l, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: p, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a }, rangeStart: { since: "1.4.0", category: p, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a }, requirePragma: { since: "1.7.0", category: p, type: "boolean", default: false, description: t`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: u }, tabWidth: { type: "int", category: l, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: l, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: l, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
          r.exports = { CATEGORY_CONFIG: s, CATEGORY_EDITOR: a, CATEGORY_FORMAT: n2, CATEGORY_OTHER: u, CATEGORY_OUTPUT: i, CATEGORY_GLOBAL: l, CATEGORY_SPECIAL: p, options: y };
        } }), Xn = te({ "src/main/support.js"(e2, r) {
          "use strict";
          ne();
          var t = { compare: zn(), lt: UD(), gte: JD() }, s = zD(), a = Ia().version, n2 = KD().options;
          function u() {
            let { plugins: l = [], showUnreleased: p = false, showDeprecated: y = false, showInternal: h3 = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, g = a.split("-", 1)[0], c = l.flatMap((E) => E.languages || []).filter(F), f = s(Object.assign({}, ...l.map((E) => {
              let { options: N } = E;
              return N;
            }), n2), "name").filter((E) => F(E) && _(E)).sort((E, N) => E.name === N.name ? 0 : E.name < N.name ? -1 : 1).map(w).map((E) => {
              E = Object.assign({}, E), Array.isArray(E.default) && (E.default = E.default.length === 1 ? E.default[0].value : E.default.filter(F).sort((x2, I) => t.compare(I.since, x2.since))[0].value), Array.isArray(E.choices) && (E.choices = E.choices.filter((x2) => F(x2) && _(x2)), E.name === "parser" && i(E, c, l));
              let N = Object.fromEntries(l.filter((x2) => x2.defaultOptions && x2.defaultOptions[E.name] !== void 0).map((x2) => [x2.name, x2.defaultOptions[E.name]]));
              return Object.assign(Object.assign({}, E), {}, { pluginDefaults: N });
            });
            return { languages: c, options: f };
            function F(E) {
              return p || !("since" in E) || E.since && t.gte(g, E.since);
            }
            function _(E) {
              return y || !("deprecated" in E) || E.deprecated && t.lt(g, E.deprecated);
            }
            function w(E) {
              if (h3) return E;
              let { cliName: N, cliCategory: x2, cliDescription: I } = E;
              return Hn(E, hD);
            }
          }
          function i(l, p, y) {
            let h3 = new Set(l.choices.map((g) => g.value));
            for (let g of p) if (g.parsers) {
              for (let c of g.parsers) if (!h3.has(c)) {
                h3.add(c);
                let f = y.find((_) => _.parsers && _.parsers[c]), F = g.name;
                f && f.name && (F += ` (plugin: ${f.name})`), l.choices.push({ value: c, description: F });
              }
            }
          }
          r.exports = { getSupportInfo: u };
        } }), Kn = te({ "src/utils/is-non-empty-array.js"(e2, r) {
          "use strict";
          ne();
          function t(s) {
            return Array.isArray(s) && s.length > 0;
          }
          r.exports = t;
        } }), Pr = te({ "src/utils/text/skip.js"(e2, r) {
          "use strict";
          ne();
          function t(i) {
            return (l, p, y) => {
              let h3 = y && y.backwards;
              if (p === false) return false;
              let { length: g } = l, c = p;
              for (; c >= 0 && c < g; ) {
                let f = l.charAt(c);
                if (i instanceof RegExp) {
                  if (!i.test(f)) return c;
                } else if (!i.includes(f)) return c;
                h3 ? c-- : c++;
              }
              return c === -1 || c === g ? c : false;
            };
          }
          var s = t(/\s/), a = t(" 	"), n2 = t(",; 	"), u = t(/[^\n\r]/);
          r.exports = { skipWhitespace: s, skipSpaces: a, skipToLineEnd: n2, skipEverythingButNewLine: u };
        } }), Ra = te({ "src/utils/text/skip-inline-comment.js"(e2, r) {
          "use strict";
          ne();
          function t(s, a) {
            if (a === false) return false;
            if (s.charAt(a) === "/" && s.charAt(a + 1) === "*") {
              for (let n2 = a + 2; n2 < s.length; ++n2) if (s.charAt(n2) === "*" && s.charAt(n2 + 1) === "/") return n2 + 2;
            }
            return a;
          }
          r.exports = t;
        } }), $a = te({ "src/utils/text/skip-trailing-comment.js"(e2, r) {
          "use strict";
          ne();
          var { skipEverythingButNewLine: t } = Pr();
          function s(a, n2) {
            return n2 === false ? false : a.charAt(n2) === "/" && a.charAt(n2 + 1) === "/" ? t(a, n2) : n2;
          }
          r.exports = s;
        } }), Va = te({ "src/utils/text/skip-newline.js"(e2, r) {
          "use strict";
          ne();
          function t(s, a, n2) {
            let u = n2 && n2.backwards;
            if (a === false) return false;
            let i = s.charAt(a);
            if (u) {
              if (s.charAt(a - 1) === "\r" && i === `
`) return a - 2;
              if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029") return a - 1;
            } else {
              if (i === "\r" && s.charAt(a + 1) === `
`) return a + 2;
              if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029") return a + 1;
            }
            return a;
          }
          r.exports = t;
        } }), YD = te({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e2, r) {
          "use strict";
          ne();
          var t = Ra(), s = Va(), a = $a(), { skipSpaces: n2 } = Pr();
          function u(i, l) {
            let p = null, y = l;
            for (; y !== p; ) p = y, y = n2(i, y), y = t(i, y), y = a(i, y), y = s(i, y);
            return y;
          }
          r.exports = u;
        } }), Ue = te({ "src/common/util.js"(e2, r) {
          "use strict";
          ne();
          var { default: t } = ($D(), ft(ja)), s = lt(), { getSupportInfo: a } = Xn(), n2 = Kn(), u = Oa(), { skipWhitespace: i, skipSpaces: l, skipToLineEnd: p, skipEverythingButNewLine: y } = Pr(), h3 = Ra(), g = $a(), c = Va(), f = YD(), F = (V) => V[V.length - 2];
          function _(V) {
            return (j, Y, ie) => {
              let ee = ie && ie.backwards;
              if (Y === false) return false;
              let { length: ce } = j, W = Y;
              for (; W >= 0 && W < ce; ) {
                let K = j.charAt(W);
                if (V instanceof RegExp) {
                  if (!V.test(K)) return W;
                } else if (!V.includes(K)) return W;
                ee ? W-- : W++;
              }
              return W === -1 || W === ce ? W : false;
            };
          }
          function w(V, j) {
            let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, ie = l(V, Y.backwards ? j - 1 : j, Y), ee = c(V, ie, Y);
            return ie !== ee;
          }
          function E(V, j, Y) {
            for (let ie = j; ie < Y; ++ie) if (V.charAt(ie) === `
`) return true;
            return false;
          }
          function N(V, j, Y) {
            let ie = Y(j) - 1;
            ie = l(V, ie, { backwards: true }), ie = c(V, ie, { backwards: true }), ie = l(V, ie, { backwards: true });
            let ee = c(V, ie, { backwards: true });
            return ie !== ee;
          }
          function x2(V, j) {
            let Y = null, ie = j;
            for (; ie !== Y; ) Y = ie, ie = p(V, ie), ie = h3(V, ie), ie = l(V, ie);
            return ie = g(V, ie), ie = c(V, ie), ie !== false && w(V, ie);
          }
          function I(V, j, Y) {
            return x2(V, Y(j));
          }
          function P(V, j, Y) {
            return f(V, Y(j));
          }
          function $(V, j, Y) {
            return V.charAt(P(V, j, Y));
          }
          function D(V, j) {
            let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return l(V, Y.backwards ? j - 1 : j, Y) !== j;
          }
          function T(V, j) {
            let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, ie = 0;
            for (let ee = Y; ee < V.length; ++ee) V[ee] === "	" ? ie = ie + j - ie % j : ie++;
            return ie;
          }
          function m(V, j) {
            let Y = V.lastIndexOf(`
`);
            return Y === -1 ? 0 : T(V.slice(Y + 1).match(/^[\t ]*/)[0], j);
          }
          function C(V, j) {
            let Y = { quote: '"', regex: /"/g, escaped: "&quot;" }, ie = { quote: "'", regex: /'/g, escaped: "&apos;" }, ee = j === "'" ? ie : Y, ce = ee === ie ? Y : ie, W = ee;
            if (V.includes(ee.quote) || V.includes(ce.quote)) {
              let K = (V.match(ee.regex) || []).length, de = (V.match(ce.regex) || []).length;
              W = K > de ? ce : ee;
            }
            return W;
          }
          function o(V, j) {
            let Y = V.slice(1, -1), ie = j.parser === "json" || j.parser === "json5" && j.quoteProps === "preserve" && !j.singleQuote ? '"' : j.__isInHtmlAttribute ? "'" : C(Y, j.singleQuote ? "'" : '"').quote;
            return d(Y, ie, !(j.parser === "css" || j.parser === "less" || j.parser === "scss" || j.__embeddedInHtml));
          }
          function d(V, j, Y) {
            let ie = j === '"' ? "'" : '"', ee = /\\(.)|(["'])/gs, ce = V.replace(ee, (W, K, de) => K === ie ? K : de === j ? "\\" + de : de || (Y && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(K) ? K : "\\" + K));
            return j + ce + j;
          }
          function v(V) {
            return V.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
          }
          function S(V, j) {
            let Y = V.match(new RegExp(`(${t(j)})+`, "g"));
            return Y === null ? 0 : Y.reduce((ie, ee) => Math.max(ie, ee.length / j.length), 0);
          }
          function b(V, j) {
            let Y = V.match(new RegExp(`(${t(j)})+`, "g"));
            if (Y === null) return 0;
            let ie = /* @__PURE__ */ new Map(), ee = 0;
            for (let ce of Y) {
              let W = ce.length / j.length;
              ie.set(W, true), W > ee && (ee = W);
            }
            for (let ce = 1; ce < ee; ce++) if (!ie.get(ce)) return ce;
            return ee + 1;
          }
          function B(V, j) {
            (V.comments || (V.comments = [])).push(j), j.printed = false, j.nodeDescription = Q(V);
          }
          function k(V, j) {
            j.leading = true, j.trailing = false, B(V, j);
          }
          function M(V, j, Y) {
            j.leading = false, j.trailing = false, Y && (j.marker = Y), B(V, j);
          }
          function R(V, j) {
            j.leading = false, j.trailing = true, B(V, j);
          }
          function q(V, j) {
            let { languages: Y } = a({ plugins: j.plugins }), ie = Y.find((ee) => {
              let { name: ce } = ee;
              return ce.toLowerCase() === V;
            }) || Y.find((ee) => {
              let { aliases: ce } = ee;
              return Array.isArray(ce) && ce.includes(V);
            }) || Y.find((ee) => {
              let { extensions: ce } = ee;
              return Array.isArray(ce) && ce.includes(`.${V}`);
            });
            return ie && ie.parsers[0];
          }
          function J(V) {
            return V && V.type === "front-matter";
          }
          function L(V) {
            let j = /* @__PURE__ */ new WeakMap();
            return function(Y) {
              return j.has(Y) || j.set(Y, Symbol(V)), j.get(Y);
            };
          }
          function Q(V) {
            let j = V.type || V.kind || "(unknown type)", Y = String(V.name || V.id && (typeof V.id == "object" ? V.id.name : V.id) || V.key && (typeof V.key == "object" ? V.key.name : V.key) || V.value && (typeof V.value == "object" ? "" : String(V.value)) || V.operator || "");
            return Y.length > 20 && (Y = Y.slice(0, 19) + "\u2026"), j + (Y ? " " + Y : "");
          }
          r.exports = { inferParserByLanguage: q, getStringWidth: u, getMaxContinuousCount: S, getMinNotPresentContinuousCount: b, getPenultimate: F, getLast: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f, getNextNonSpaceNonCommentCharacterIndex: P, getNextNonSpaceNonCommentCharacter: $, skip: _, skipWhitespace: i, skipSpaces: l, skipToLineEnd: p, skipEverythingButNewLine: y, skipInlineComment: h3, skipTrailingComment: g, skipNewline: c, isNextLineEmptyAfterIndex: x2, isNextLineEmpty: I, isPreviousLineEmpty: N, hasNewline: w, hasNewlineInRange: E, hasSpaces: D, getAlignmentSize: T, getIndentSize: m, getPreferredQuote: C, printString: o, printNumber: v, makeString: d, addLeadingComment: k, addDanglingComment: M, addTrailingComment: R, isFrontMatterNode: J, isNonEmptyArray: n2, createGroupIdMapper: L };
        } }), Wa = {};
        Kt(Wa, { basename: () => za, default: () => Ka, delimiter: () => Mn, dirname: () => Ja, extname: () => Xa, isAbsolute: () => Qn, join: () => Ga, normalize: () => Yn, relative: () => Ua, resolve: () => wr, sep: () => qn });
        function Ha(e2, r) {
          for (var t = 0, s = e2.length - 1; s >= 0; s--) {
            var a = e2[s];
            a === "." ? e2.splice(s, 1) : a === ".." ? (e2.splice(s, 1), t++) : t && (e2.splice(s, 1), t--);
          }
          if (r) for (; t--; t) e2.unshift("..");
          return e2;
        }
        function wr() {
          for (var e2 = "", r = false, t = arguments.length - 1; t >= -1 && !r; t--) {
            var s = t >= 0 ? arguments[t] : "/";
            if (typeof s != "string") throw new TypeError("Arguments to path.resolve must be strings");
            if (!s) continue;
            e2 = s + "/" + e2, r = s.charAt(0) === "/";
          }
          return e2 = Ha(Zn(e2.split("/"), function(a) {
            return !!a;
          }), !r).join("/"), (r ? "/" : "") + e2 || ".";
        }
        function Yn(e2) {
          var r = Qn(e2), t = Ya(e2, -1) === "/";
          return e2 = Ha(Zn(e2.split("/"), function(s) {
            return !!s;
          }), !r).join("/"), !e2 && !r && (e2 = "."), e2 && t && (e2 += "/"), (r ? "/" : "") + e2;
        }
        function Qn(e2) {
          return e2.charAt(0) === "/";
        }
        function Ga() {
          var e2 = Array.prototype.slice.call(arguments, 0);
          return Yn(Zn(e2, function(r, t) {
            if (typeof r != "string") throw new TypeError("Arguments to path.join must be strings");
            return r;
          }).join("/"));
        }
        function Ua(e2, r) {
          e2 = wr(e2).substr(1), r = wr(r).substr(1);
          function t(p) {
            for (var y = 0; y < p.length && p[y] === ""; y++) ;
            for (var h3 = p.length - 1; h3 >= 0 && p[h3] === ""; h3--) ;
            return y > h3 ? [] : p.slice(y, h3 - y + 1);
          }
          for (var s = t(e2.split("/")), a = t(r.split("/")), n2 = Math.min(s.length, a.length), u = n2, i = 0; i < n2; i++) if (s[i] !== a[i]) {
            u = i;
            break;
          }
          for (var l = [], i = u; i < s.length; i++) l.push("..");
          return l = l.concat(a.slice(u)), l.join("/");
        }
        function Ja(e2) {
          var r = Ir(e2), t = r[0], s = r[1];
          return !t && !s ? "." : (s && (s = s.substr(0, s.length - 1)), t + s);
        }
        function za(e2, r) {
          var t = Ir(e2)[2];
          return r && t.substr(-1 * r.length) === r && (t = t.substr(0, t.length - r.length)), t;
        }
        function Xa(e2) {
          return Ir(e2)[3];
        }
        function Zn(e2, r) {
          if (e2.filter) return e2.filter(r);
          for (var t = [], s = 0; s < e2.length; s++) r(e2[s], s, e2) && t.push(e2[s]);
          return t;
        }
        var Na, Ir, qn, Mn, Ka, Ya, QD = ht({ "node-modules-polyfills:path"() {
          ne(), Na = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, Ir = function(e2) {
            return Na.exec(e2).slice(1);
          }, qn = "/", Mn = ":", Ka = { extname: Xa, basename: za, dirname: Ja, sep: qn, delimiter: Mn, relative: Ua, join: Ga, isAbsolute: Qn, normalize: Yn, resolve: wr }, Ya = "ab".substr(-1) === "b" ? function(e2, r, t) {
            return e2.substr(r, t);
          } : function(e2, r, t) {
            return r < 0 && (r = e2.length + r), e2.substr(r, t);
          };
        } }), ZD = te({ "node-modules-polyfills-commonjs:path"(e2, r) {
          ne();
          var t = (QD(), ft(Wa));
          if (t && t.default) {
            r.exports = t.default;
            for (let s in t) r.exports[s] = t[s];
          } else t && (r.exports = t);
        } }), Qt = te({ "src/common/errors.js"(e2, r) {
          "use strict";
          ne();
          var t = class extends Error {
          }, s = class extends Error {
          }, a = class extends Error {
          }, n2 = class extends Error {
          };
          r.exports = { ConfigError: t, DebugError: s, UndefinedParserError: a, ArgExpansionBailout: n2 };
        } }), vt = {};
        Kt(vt, { __assign: () => Nr, __asyncDelegator: () => fm, __asyncGenerator: () => pm2, __asyncValues: () => Dm, __await: () => Xt, __awaiter: () => sm, __classPrivateFieldGet: () => ym, __classPrivateFieldSet: () => hm, __createBinding: () => am, __decorate: () => rm, __exportStar: () => om, __extends: () => em, __generator: () => im, __importDefault: () => gm, __importStar: () => dm, __makeTemplateObject: () => mm, __metadata: () => um, __param: () => nm, __read: () => Qa, __rest: () => tm, __spread: () => lm, __spreadArrays: () => cm, __values: () => Rn });
        function em(e2, r) {
          Br(e2, r);
          function t() {
            this.constructor = e2;
          }
          e2.prototype = r === null ? Object.create(r) : (t.prototype = r.prototype, new t());
        }
        function tm(e2, r) {
          var t = {};
          for (var s in e2) Object.prototype.hasOwnProperty.call(e2, s) && r.indexOf(s) < 0 && (t[s] = e2[s]);
          if (e2 != null && typeof Object.getOwnPropertySymbols == "function") for (var a = 0, s = Object.getOwnPropertySymbols(e2); a < s.length; a++) r.indexOf(s[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, s[a]) && (t[s[a]] = e2[s[a]]);
          return t;
        }
        function rm(e2, r, t, s) {
          var a = arguments.length, n2 = a < 3 ? r : s === null ? s = Object.getOwnPropertyDescriptor(r, t) : s, u;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") n2 = Reflect.decorate(e2, r, t, s);
          else for (var i = e2.length - 1; i >= 0; i--) (u = e2[i]) && (n2 = (a < 3 ? u(n2) : a > 3 ? u(r, t, n2) : u(r, t)) || n2);
          return a > 3 && n2 && Object.defineProperty(r, t, n2), n2;
        }
        function nm(e2, r) {
          return function(t, s) {
            r(t, s, e2);
          };
        }
        function um(e2, r) {
          if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(e2, r);
        }
        function sm(e2, r, t, s) {
          function a(n2) {
            return n2 instanceof t ? n2 : new t(function(u) {
              u(n2);
            });
          }
          return new (t || (t = Promise))(function(n2, u) {
            function i(y) {
              try {
                p(s.next(y));
              } catch (h3) {
                u(h3);
              }
            }
            function l(y) {
              try {
                p(s.throw(y));
              } catch (h3) {
                u(h3);
              }
            }
            function p(y) {
              y.done ? n2(y.value) : a(y.value).then(i, l);
            }
            p((s = s.apply(e2, r || [])).next());
          });
        }
        function im(e2, r) {
          var t = { label: 0, sent: function() {
            if (n2[0] & 1) throw n2[1];
            return n2[1];
          }, trys: [], ops: [] }, s, a, n2, u;
          return u = { next: i(0), throw: i(1), return: i(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
            return this;
          }), u;
          function i(p) {
            return function(y) {
              return l([p, y]);
            };
          }
          function l(p) {
            if (s) throw new TypeError("Generator is already executing.");
            for (; t; ) try {
              if (s = 1, a && (n2 = p[0] & 2 ? a.return : p[0] ? a.throw || ((n2 = a.return) && n2.call(a), 0) : a.next) && !(n2 = n2.call(a, p[1])).done) return n2;
              switch (a = 0, n2 && (p = [p[0] & 2, n2.value]), p[0]) {
                case 0:
                case 1:
                  n2 = p;
                  break;
                case 4:
                  return t.label++, { value: p[1], done: false };
                case 5:
                  t.label++, a = p[1], p = [0];
                  continue;
                case 7:
                  p = t.ops.pop(), t.trys.pop();
                  continue;
                default:
                  if (n2 = t.trys, !(n2 = n2.length > 0 && n2[n2.length - 1]) && (p[0] === 6 || p[0] === 2)) {
                    t = 0;
                    continue;
                  }
                  if (p[0] === 3 && (!n2 || p[1] > n2[0] && p[1] < n2[3])) {
                    t.label = p[1];
                    break;
                  }
                  if (p[0] === 6 && t.label < n2[1]) {
                    t.label = n2[1], n2 = p;
                    break;
                  }
                  if (n2 && t.label < n2[2]) {
                    t.label = n2[2], t.ops.push(p);
                    break;
                  }
                  n2[2] && t.ops.pop(), t.trys.pop();
                  continue;
              }
              p = r.call(e2, t);
            } catch (y) {
              p = [6, y], a = 0;
            } finally {
              s = n2 = 0;
            }
            if (p[0] & 5) throw p[1];
            return { value: p[0] ? p[1] : void 0, done: true };
          }
        }
        function am(e2, r, t, s) {
          s === void 0 && (s = t), e2[s] = r[t];
        }
        function om(e2, r) {
          for (var t in e2) t !== "default" && !r.hasOwnProperty(t) && (r[t] = e2[t]);
        }
        function Rn(e2) {
          var r = typeof Symbol == "function" && Symbol.iterator, t = r && e2[r], s = 0;
          if (t) return t.call(e2);
          if (e2 && typeof e2.length == "number") return { next: function() {
            return e2 && s >= e2.length && (e2 = void 0), { value: e2 && e2[s++], done: !e2 };
          } };
          throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        function Qa(e2, r) {
          var t = typeof Symbol == "function" && e2[Symbol.iterator];
          if (!t) return e2;
          var s = t.call(e2), a, n2 = [], u;
          try {
            for (; (r === void 0 || r-- > 0) && !(a = s.next()).done; ) n2.push(a.value);
          } catch (i) {
            u = { error: i };
          } finally {
            try {
              a && !a.done && (t = s.return) && t.call(s);
            } finally {
              if (u) throw u.error;
            }
          }
          return n2;
        }
        function lm() {
          for (var e2 = [], r = 0; r < arguments.length; r++) e2 = e2.concat(Qa(arguments[r]));
          return e2;
        }
        function cm() {
          for (var e2 = 0, r = 0, t = arguments.length; r < t; r++) e2 += arguments[r].length;
          for (var s = Array(e2), a = 0, r = 0; r < t; r++) for (var n2 = arguments[r], u = 0, i = n2.length; u < i; u++, a++) s[a] = n2[u];
          return s;
        }
        function Xt(e2) {
          return this instanceof Xt ? (this.v = e2, this) : new Xt(e2);
        }
        function pm2(e2, r, t) {
          if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
          var s = t.apply(e2, r || []), a, n2 = [];
          return a = {}, u("next"), u("throw"), u("return"), a[Symbol.asyncIterator] = function() {
            return this;
          }, a;
          function u(g) {
            s[g] && (a[g] = function(c) {
              return new Promise(function(f, F) {
                n2.push([g, c, f, F]) > 1 || i(g, c);
              });
            });
          }
          function i(g, c) {
            try {
              l(s[g](c));
            } catch (f) {
              h3(n2[0][3], f);
            }
          }
          function l(g) {
            g.value instanceof Xt ? Promise.resolve(g.value.v).then(p, y) : h3(n2[0][2], g);
          }
          function p(g) {
            i("next", g);
          }
          function y(g) {
            i("throw", g);
          }
          function h3(g, c) {
            g(c), n2.shift(), n2.length && i(n2[0][0], n2[0][1]);
          }
        }
        function fm(e2) {
          var r, t;
          return r = {}, s("next"), s("throw", function(a) {
            throw a;
          }), s("return"), r[Symbol.iterator] = function() {
            return this;
          }, r;
          function s(a, n2) {
            r[a] = e2[a] ? function(u) {
              return (t = !t) ? { value: Xt(e2[a](u)), done: a === "return" } : n2 ? n2(u) : u;
            } : n2;
          }
        }
        function Dm(e2) {
          if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
          var r = e2[Symbol.asyncIterator], t;
          return r ? r.call(e2) : (e2 = typeof Rn == "function" ? Rn(e2) : e2[Symbol.iterator](), t = {}, s("next"), s("throw"), s("return"), t[Symbol.asyncIterator] = function() {
            return this;
          }, t);
          function s(n2) {
            t[n2] = e2[n2] && function(u) {
              return new Promise(function(i, l) {
                u = e2[n2](u), a(i, l, u.done, u.value);
              });
            };
          }
          function a(n2, u, i, l) {
            Promise.resolve(l).then(function(p) {
              n2({ value: p, done: i });
            }, u);
          }
        }
        function mm(e2, r) {
          return Object.defineProperty ? Object.defineProperty(e2, "raw", { value: r }) : e2.raw = r, e2;
        }
        function dm(e2) {
          if (e2 && e2.__esModule) return e2;
          var r = {};
          if (e2 != null) for (var t in e2) Object.hasOwnProperty.call(e2, t) && (r[t] = e2[t]);
          return r.default = e2, r;
        }
        function gm(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        function ym(e2, r) {
          if (!r.has(e2)) throw new TypeError("attempted to get private field on non-instance");
          return r.get(e2);
        }
        function hm(e2, r, t) {
          if (!r.has(e2)) throw new TypeError("attempted to set private field on non-instance");
          return r.set(e2, t), t;
        }
        var Br, Nr, Et = ht({ "node_modules/tslib/tslib.es6.js"() {
          ne(), Br = function(e2, r) {
            return Br = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, s) {
              t.__proto__ = s;
            } || function(t, s) {
              for (var a in s) s.hasOwnProperty(a) && (t[a] = s[a]);
            }, Br(e2, r);
          }, Nr = function() {
            return Nr = Object.assign || function(r) {
              for (var t, s = 1, a = arguments.length; s < a; s++) {
                t = arguments[s];
                for (var n2 in t) Object.prototype.hasOwnProperty.call(t, n2) && (r[n2] = t[n2]);
              }
              return r;
            }, Nr.apply(this, arguments);
          };
        } }), Za = te({ "node_modules/vnopts/lib/descriptors/api.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true }), e2.apiDescriptor = { key: (r) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(r) ? r : JSON.stringify(r), value(r) {
            if (r === null || typeof r != "object") return JSON.stringify(r);
            if (Array.isArray(r)) return `[${r.map((s) => e2.apiDescriptor.value(s)).join(", ")}]`;
            let t = Object.keys(r);
            return t.length === 0 ? "{}" : `{ ${t.map((s) => `${e2.apiDescriptor.key(s)}: ${e2.apiDescriptor.value(r[s])}`).join(", ")} }`;
          }, pair: (r) => {
            let { key: t, value: s } = r;
            return e2.apiDescriptor.value({ [t]: s });
          } };
        } }), vm = te({ "node_modules/vnopts/lib/descriptors/index.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = (Et(), ft(vt));
          r.__exportStar(Za(), e2);
        } }), kr = te({ "scripts/build/shims/chalk.cjs"(e2, r) {
          "use strict";
          ne();
          var t = (s) => s;
          t.grey = t, t.red = t, t.bold = t, t.yellow = t, t.blue = t, t.default = t, r.exports = t;
        } }), eo = te({ "node_modules/vnopts/lib/handlers/deprecated/common.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = kr();
          e2.commonDeprecatedHandler = (t, s, a) => {
            let { descriptor: n2 } = a, u = [`${r.default.yellow(typeof t == "string" ? n2.key(t) : n2.pair(t))} is deprecated`];
            return s && u.push(`we now treat it as ${r.default.blue(typeof s == "string" ? n2.key(s) : n2.pair(s))}`), u.join("; ") + ".";
          };
        } }), Cm = te({ "node_modules/vnopts/lib/handlers/deprecated/index.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = (Et(), ft(vt));
          r.__exportStar(eo(), e2);
        } }), Em = te({ "node_modules/vnopts/lib/handlers/invalid/common.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = kr();
          e2.commonInvalidHandler = (t, s, a) => [`Invalid ${r.default.red(a.descriptor.key(t))} value.`, `Expected ${r.default.blue(a.schemas[t].expected(a))},`, `but received ${r.default.red(a.descriptor.value(s))}.`].join(" ");
        } }), to = te({ "node_modules/vnopts/lib/handlers/invalid/index.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = (Et(), ft(vt));
          r.__exportStar(Em(), e2);
        } }), Fm = te({ "node_modules/vnopts/node_modules/leven/index.js"(e2, r) {
          "use strict";
          ne();
          var t = [], s = [];
          r.exports = function(a, n2) {
            if (a === n2) return 0;
            var u = a;
            a.length > n2.length && (a = n2, n2 = u);
            var i = a.length, l = n2.length;
            if (i === 0) return l;
            if (l === 0) return i;
            for (; i > 0 && a.charCodeAt(~-i) === n2.charCodeAt(~-l); ) i--, l--;
            if (i === 0) return l;
            for (var p = 0; p < i && a.charCodeAt(p) === n2.charCodeAt(p); ) p++;
            if (i -= p, l -= p, i === 0) return l;
            for (var y, h3, g, c, f = 0, F = 0; f < i; ) s[p + f] = a.charCodeAt(p + f), t[f] = ++f;
            for (; F < l; ) for (y = n2.charCodeAt(p + F), g = F++, h3 = F, f = 0; f < i; f++) c = y === s[p + f] ? g : g + 1, g = t[f], h3 = t[f] = g > h3 ? c > h3 ? h3 + 1 : c : c > g ? g + 1 : c;
            return h3;
          };
        } }), ro = te({ "node_modules/vnopts/lib/handlers/unknown/leven.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = kr(), t = Fm();
          e2.levenUnknownHandler = (s, a, n2) => {
            let { descriptor: u, logger: i, schemas: l } = n2, p = [`Ignored unknown option ${r.default.yellow(u.pair({ key: s, value: a }))}.`], y = Object.keys(l).sort().find((h3) => t(s, h3) < 3);
            y && p.push(`Did you mean ${r.default.blue(u.key(y))}?`), i.warn(p.join(" "));
          };
        } }), Am = te({ "node_modules/vnopts/lib/handlers/unknown/index.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = (Et(), ft(vt));
          r.__exportStar(ro(), e2);
        } }), Sm = te({ "node_modules/vnopts/lib/handlers/index.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = (Et(), ft(vt));
          r.__exportStar(Cm(), e2), r.__exportStar(to(), e2), r.__exportStar(Am(), e2);
        } }), Ft = te({ "node_modules/vnopts/lib/schema.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
          function t(n2, u) {
            let i = new n2(u), l = Object.create(i);
            for (let p of r) p in u && (l[p] = a(u[p], i, s.prototype[p].length));
            return l;
          }
          e2.createSchema = t;
          var s = class {
            constructor(n2) {
              this.name = n2.name;
            }
            static create(n2) {
              return t(this, n2);
            }
            default(n2) {
            }
            expected(n2) {
              return "nothing";
            }
            validate(n2, u) {
              return false;
            }
            deprecated(n2, u) {
              return false;
            }
            forward(n2, u) {
            }
            redirect(n2, u) {
            }
            overlap(n2, u, i) {
              return n2;
            }
            preprocess(n2, u) {
              return n2;
            }
            postprocess(n2, u) {
              return n2;
            }
          };
          e2.Schema = s;
          function a(n2, u, i) {
            return typeof n2 == "function" ? function() {
              for (var l = arguments.length, p = new Array(l), y = 0; y < l; y++) p[y] = arguments[y];
              return n2(...p.slice(0, i - 1), u, ...p.slice(i - 1));
            } : () => n2;
          }
        } }), xm = te({ "node_modules/vnopts/lib/schemas/alias.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = Ft(), t = class extends r.Schema {
            constructor(s) {
              super(s), this._sourceName = s.sourceName;
            }
            expected(s) {
              return s.schemas[this._sourceName].expected(s);
            }
            validate(s, a) {
              return a.schemas[this._sourceName].validate(s, a);
            }
            redirect(s, a) {
              return this._sourceName;
            }
          };
          e2.AliasSchema = t;
        } }), bm = te({ "node_modules/vnopts/lib/schemas/any.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = Ft(), t = class extends r.Schema {
            expected() {
              return "anything";
            }
            validate() {
              return true;
            }
          };
          e2.AnySchema = t;
        } }), Tm = te({ "node_modules/vnopts/lib/schemas/array.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = (Et(), ft(vt)), t = Ft(), s = class extends t.Schema {
            constructor(n2) {
              var { valueSchema: u, name: i = u.name } = n2, l = r.__rest(n2, ["valueSchema", "name"]);
              super(Object.assign({}, l, { name: i })), this._valueSchema = u;
            }
            expected(n2) {
              return `an array of ${this._valueSchema.expected(n2)}`;
            }
            validate(n2, u) {
              if (!Array.isArray(n2)) return false;
              let i = [];
              for (let l of n2) {
                let p = u.normalizeValidateResult(this._valueSchema.validate(l, u), l);
                p !== true && i.push(p.value);
              }
              return i.length === 0 ? true : { value: i };
            }
            deprecated(n2, u) {
              let i = [];
              for (let l of n2) {
                let p = u.normalizeDeprecatedResult(this._valueSchema.deprecated(l, u), l);
                p !== false && i.push(...p.map((y) => {
                  let { value: h3 } = y;
                  return { value: [h3] };
                }));
              }
              return i;
            }
            forward(n2, u) {
              let i = [];
              for (let l of n2) {
                let p = u.normalizeForwardResult(this._valueSchema.forward(l, u), l);
                i.push(...p.map(a));
              }
              return i;
            }
            redirect(n2, u) {
              let i = [], l = [];
              for (let p of n2) {
                let y = u.normalizeRedirectResult(this._valueSchema.redirect(p, u), p);
                "remain" in y && i.push(y.remain), l.push(...y.redirect.map(a));
              }
              return i.length === 0 ? { redirect: l } : { redirect: l, remain: i };
            }
            overlap(n2, u) {
              return n2.concat(u);
            }
          };
          e2.ArraySchema = s;
          function a(n2) {
            let { from: u, to: i } = n2;
            return { from: [u], to: i };
          }
        } }), Bm = te({ "node_modules/vnopts/lib/schemas/boolean.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = Ft(), t = class extends r.Schema {
            expected() {
              return "true or false";
            }
            validate(s) {
              return typeof s == "boolean";
            }
          };
          e2.BooleanSchema = t;
        } }), eu = te({ "node_modules/vnopts/lib/utils.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          function r(c, f) {
            let F = /* @__PURE__ */ Object.create(null);
            for (let _ of c) {
              let w = _[f];
              if (F[w]) throw new Error(`Duplicate ${f} ${JSON.stringify(w)}`);
              F[w] = _;
            }
            return F;
          }
          e2.recordFromArray = r;
          function t(c, f) {
            let F = /* @__PURE__ */ new Map();
            for (let _ of c) {
              let w = _[f];
              if (F.has(w)) throw new Error(`Duplicate ${f} ${JSON.stringify(w)}`);
              F.set(w, _);
            }
            return F;
          }
          e2.mapFromArray = t;
          function s() {
            let c = /* @__PURE__ */ Object.create(null);
            return (f) => {
              let F = JSON.stringify(f);
              return c[F] ? true : (c[F] = true, false);
            };
          }
          e2.createAutoChecklist = s;
          function a(c, f) {
            let F = [], _ = [];
            for (let w of c) f(w) ? F.push(w) : _.push(w);
            return [F, _];
          }
          e2.partition = a;
          function n2(c) {
            return c === Math.floor(c);
          }
          e2.isInt = n2;
          function u(c, f) {
            if (c === f) return 0;
            let F = typeof c, _ = typeof f, w = ["undefined", "object", "boolean", "number", "string"];
            return F !== _ ? w.indexOf(F) - w.indexOf(_) : F !== "string" ? Number(c) - Number(f) : c.localeCompare(f);
          }
          e2.comparePrimitive = u;
          function i(c) {
            return c === void 0 ? {} : c;
          }
          e2.normalizeDefaultResult = i;
          function l(c, f) {
            return c === true ? true : c === false ? { value: f } : c;
          }
          e2.normalizeValidateResult = l;
          function p(c, f) {
            let F = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            return c === false ? false : c === true ? F ? true : [{ value: f }] : "value" in c ? [c] : c.length === 0 ? false : c;
          }
          e2.normalizeDeprecatedResult = p;
          function y(c, f) {
            return typeof c == "string" || "key" in c ? { from: f, to: c } : "from" in c ? { from: c.from, to: c.to } : { from: f, to: c.to };
          }
          e2.normalizeTransferResult = y;
          function h3(c, f) {
            return c === void 0 ? [] : Array.isArray(c) ? c.map((F) => y(F, f)) : [y(c, f)];
          }
          e2.normalizeForwardResult = h3;
          function g(c, f) {
            let F = h3(typeof c == "object" && "redirect" in c ? c.redirect : c, f);
            return F.length === 0 ? { remain: f, redirect: F } : typeof c == "object" && "remain" in c ? { remain: c.remain, redirect: F } : { redirect: F };
          }
          e2.normalizeRedirectResult = g;
        } }), Nm = te({ "node_modules/vnopts/lib/schemas/choice.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = Ft(), t = eu(), s = class extends r.Schema {
            constructor(a) {
              super(a), this._choices = t.mapFromArray(a.choices.map((n2) => n2 && typeof n2 == "object" ? n2 : { value: n2 }), "value");
            }
            expected(a) {
              let { descriptor: n2 } = a, u = Array.from(this._choices.keys()).map((p) => this._choices.get(p)).filter((p) => !p.deprecated).map((p) => p.value).sort(t.comparePrimitive).map(n2.value), i = u.slice(0, -2), l = u.slice(-2);
              return i.concat(l.join(" or ")).join(", ");
            }
            validate(a) {
              return this._choices.has(a);
            }
            deprecated(a) {
              let n2 = this._choices.get(a);
              return n2 && n2.deprecated ? { value: a } : false;
            }
            forward(a) {
              let n2 = this._choices.get(a);
              return n2 ? n2.forward : void 0;
            }
            redirect(a) {
              let n2 = this._choices.get(a);
              return n2 ? n2.redirect : void 0;
            }
          };
          e2.ChoiceSchema = s;
        } }), no = te({ "node_modules/vnopts/lib/schemas/number.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = Ft(), t = class extends r.Schema {
            expected() {
              return "a number";
            }
            validate(s, a) {
              return typeof s == "number";
            }
          };
          e2.NumberSchema = t;
        } }), wm = te({ "node_modules/vnopts/lib/schemas/integer.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = eu(), t = no(), s = class extends t.NumberSchema {
            expected() {
              return "an integer";
            }
            validate(a, n2) {
              return n2.normalizeValidateResult(super.validate(a, n2), a) === true && r.isInt(a);
            }
          };
          e2.IntegerSchema = s;
        } }), _m = te({ "node_modules/vnopts/lib/schemas/string.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = Ft(), t = class extends r.Schema {
            expected() {
              return "a string";
            }
            validate(s) {
              return typeof s == "string";
            }
          };
          e2.StringSchema = t;
        } }), Pm = te({ "node_modules/vnopts/lib/schemas/index.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = (Et(), ft(vt));
          r.__exportStar(xm(), e2), r.__exportStar(bm(), e2), r.__exportStar(Tm(), e2), r.__exportStar(Bm(), e2), r.__exportStar(Nm(), e2), r.__exportStar(wm(), e2), r.__exportStar(no(), e2), r.__exportStar(_m(), e2);
        } }), Im = te({ "node_modules/vnopts/lib/defaults.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = Za(), t = eo(), s = to(), a = ro();
          e2.defaultDescriptor = r.apiDescriptor, e2.defaultUnknownHandler = a.levenUnknownHandler, e2.defaultInvalidHandler = s.commonInvalidHandler, e2.defaultDeprecatedHandler = t.commonDeprecatedHandler;
        } }), km = te({ "node_modules/vnopts/lib/normalize.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = Im(), t = eu();
          e2.normalize = (a, n2, u) => new s(n2, u).normalize(a);
          var s = class {
            constructor(a, n2) {
              let { logger: u = console, descriptor: i = r.defaultDescriptor, unknown: l = r.defaultUnknownHandler, invalid: p = r.defaultInvalidHandler, deprecated: y = r.defaultDeprecatedHandler } = n2 || {};
              this._utils = { descriptor: i, logger: u || { warn: () => {
              } }, schemas: t.recordFromArray(a, "name"), normalizeDefaultResult: t.normalizeDefaultResult, normalizeDeprecatedResult: t.normalizeDeprecatedResult, normalizeForwardResult: t.normalizeForwardResult, normalizeRedirectResult: t.normalizeRedirectResult, normalizeValidateResult: t.normalizeValidateResult }, this._unknownHandler = l, this._invalidHandler = p, this._deprecatedHandler = y, this.cleanHistory();
            }
            cleanHistory() {
              this._hasDeprecationWarned = t.createAutoChecklist();
            }
            normalize(a) {
              let n2 = {}, u = [a], i = () => {
                for (; u.length !== 0; ) {
                  let l = u.shift(), p = this._applyNormalization(l, n2);
                  u.push(...p);
                }
              };
              i();
              for (let l of Object.keys(this._utils.schemas)) {
                let p = this._utils.schemas[l];
                if (!(l in n2)) {
                  let y = t.normalizeDefaultResult(p.default(this._utils));
                  "value" in y && u.push({ [l]: y.value });
                }
              }
              i();
              for (let l of Object.keys(this._utils.schemas)) {
                let p = this._utils.schemas[l];
                l in n2 && (n2[l] = p.postprocess(n2[l], this._utils));
              }
              return n2;
            }
            _applyNormalization(a, n2) {
              let u = [], [i, l] = t.partition(Object.keys(a), (p) => p in this._utils.schemas);
              for (let p of i) {
                let y = this._utils.schemas[p], h3 = y.preprocess(a[p], this._utils), g = t.normalizeValidateResult(y.validate(h3, this._utils), h3);
                if (g !== true) {
                  let { value: w } = g, E = this._invalidHandler(p, w, this._utils);
                  throw typeof E == "string" ? new Error(E) : E;
                }
                let c = (w) => {
                  let { from: E, to: N } = w;
                  u.push(typeof N == "string" ? { [N]: E } : { [N.key]: N.value });
                }, f = (w) => {
                  let { value: E, redirectTo: N } = w, x2 = t.normalizeDeprecatedResult(y.deprecated(E, this._utils), h3, true);
                  if (x2 !== false) if (x2 === true) this._hasDeprecationWarned(p) || this._utils.logger.warn(this._deprecatedHandler(p, N, this._utils));
                  else for (let { value: I } of x2) {
                    let P = { key: p, value: I };
                    if (!this._hasDeprecationWarned(P)) {
                      let $ = typeof N == "string" ? { key: N, value: I } : N;
                      this._utils.logger.warn(this._deprecatedHandler(P, $, this._utils));
                    }
                  }
                };
                t.normalizeForwardResult(y.forward(h3, this._utils), h3).forEach(c);
                let _ = t.normalizeRedirectResult(y.redirect(h3, this._utils), h3);
                if (_.redirect.forEach(c), "remain" in _) {
                  let w = _.remain;
                  n2[p] = p in n2 ? y.overlap(n2[p], w, this._utils) : w, f({ value: w });
                }
                for (let { from: w, to: E } of _.redirect) f({ value: w, redirectTo: E });
              }
              for (let p of l) {
                let y = a[p], h3 = this._unknownHandler(p, y, this._utils);
                if (h3) for (let g of Object.keys(h3)) {
                  let c = { [g]: h3[g] };
                  g in this._utils.schemas ? u.push(c) : Object.assign(n2, c);
                }
              }
              return u;
            }
          };
          e2.Normalizer = s;
        } }), Lm = te({ "node_modules/vnopts/lib/index.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = (Et(), ft(vt));
          r.__exportStar(vm(), e2), r.__exportStar(Sm(), e2), r.__exportStar(Pm(), e2), r.__exportStar(km(), e2), r.__exportStar(Ft(), e2);
        } }), Om = te({ "src/main/options-normalizer.js"(e2, r) {
          "use strict";
          ne();
          var t = Lm(), s = lt(), a = { key: (g) => g.length === 1 ? `-${g}` : `--${g}`, value: (g) => t.apiDescriptor.value(g), pair: (g) => {
            let { key: c, value: f } = g;
            return f === false ? `--no-${c}` : f === true ? a.key(c) : f === "" ? `${a.key(c)} without an argument` : `${a.key(c)}=${f}`;
          } }, n2 = (g) => {
            let { colorsModule: c, levenshteinDistance: f } = g;
            return class extends t.ChoiceSchema {
              constructor(_) {
                let { name: w, flags: E } = _;
                super({ name: w, choices: E }), this._flags = [...E].sort();
              }
              preprocess(_, w) {
                if (typeof _ == "string" && _.length > 0 && !this._flags.includes(_)) {
                  let E = this._flags.find((N) => f(N, _) < 3);
                  if (E) return w.logger.warn([`Unknown flag ${c.yellow(w.descriptor.value(_))},`, `did you mean ${c.blue(w.descriptor.value(E))}?`].join(" ")), E;
                }
                return _;
              }
              expected() {
                return "a flag";
              }
            };
          }, u;
          function i(g, c) {
            let { logger: f = false, isCLI: F = false, passThrough: _ = false, colorsModule: w = null, levenshteinDistance: E = null } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, N = _ ? Array.isArray(_) ? (T, m) => _.includes(T) ? { [T]: m } : void 0 : (T, m) => ({ [T]: m }) : (T, m, C) => {
              let o = C.schemas, { _: d } = o, v = Hn(o, vD);
              return t.levenUnknownHandler(T, m, Object.assign(Object.assign({}, C), {}, { schemas: v }));
            }, x2 = F ? a : t.apiDescriptor, I = l(c, { isCLI: F, colorsModule: w, levenshteinDistance: E }), P = new t.Normalizer(I, { logger: f, unknown: N, descriptor: x2 }), $ = f !== false;
            $ && u && (P._hasDeprecationWarned = u);
            let D = P.normalize(g);
            return $ && (u = P._hasDeprecationWarned), F && D["plugin-search"] === false && (D["plugin-search-dir"] = false), D;
          }
          function l(g, c) {
            let { isCLI: f, colorsModule: F, levenshteinDistance: _ } = c, w = [];
            f && w.push(t.AnySchema.create({ name: "_" }));
            for (let E of g) w.push(p(E, { isCLI: f, optionInfos: g, colorsModule: F, levenshteinDistance: _ })), E.alias && f && w.push(t.AliasSchema.create({ name: E.alias, sourceName: E.name }));
            return w;
          }
          function p(g, c) {
            let { isCLI: f, optionInfos: F, colorsModule: _, levenshteinDistance: w } = c, { name: E } = g;
            if (E === "plugin-search-dir" || E === "pluginSearchDirs") return t.AnySchema.create({ name: E, preprocess(P) {
              return P === false || (P = Array.isArray(P) ? P : [P]), P;
            }, validate(P) {
              return P === false ? true : P.every(($) => typeof $ == "string");
            }, expected() {
              return "false or paths to plugin search dir";
            } });
            let N = { name: E }, x2, I = {};
            switch (g.type) {
              case "int":
                x2 = t.IntegerSchema, f && (N.preprocess = Number);
                break;
              case "string":
                x2 = t.StringSchema;
                break;
              case "choice":
                x2 = t.ChoiceSchema, N.choices = g.choices.map((P) => typeof P == "object" && P.redirect ? Object.assign(Object.assign({}, P), {}, { redirect: { to: { key: g.name, value: P.redirect } } }) : P);
                break;
              case "boolean":
                x2 = t.BooleanSchema;
                break;
              case "flag":
                x2 = n2({ colorsModule: _, levenshteinDistance: w }), N.flags = F.flatMap((P) => [P.alias, P.description && P.name, P.oppositeDescription && `no-${P.name}`].filter(Boolean));
                break;
              case "path":
                x2 = t.StringSchema;
                break;
              default:
                throw new Error(`Unexpected type ${g.type}`);
            }
            if (g.exception ? N.validate = (P, $, D) => g.exception(P) || $.validate(P, D) : N.validate = (P, $, D) => P === void 0 || $.validate(P, D), g.redirect && (I.redirect = (P) => P ? { to: { key: g.redirect.option, value: g.redirect.value } } : void 0), g.deprecated && (I.deprecated = true), f && !g.array) {
              let P = N.preprocess || (($) => $);
              N.preprocess = ($, D, T) => D.preprocess(P(Array.isArray($) ? s($) : $), T);
            }
            return g.array ? t.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, f ? { preprocess: (P) => Array.isArray(P) ? P : [P] } : {}), I), {}, { valueSchema: x2.create(N) })) : x2.create(Object.assign(Object.assign({}, N), I));
          }
          function y(g, c, f) {
            return i(g, c, f);
          }
          function h3(g, c, f) {
            return i(g, c, Object.assign({ isCLI: true }, f));
          }
          r.exports = { normalizeApiOptions: y, normalizeCliOptions: h3 };
        } }), ut = te({ "src/language-js/loc.js"(e2, r) {
          "use strict";
          ne();
          var t = Kn();
          function s(l) {
            var p, y;
            let h3 = l.range ? l.range[0] : l.start, g = (p = (y = l.declaration) === null || y === void 0 ? void 0 : y.decorators) !== null && p !== void 0 ? p : l.decorators;
            return t(g) ? Math.min(s(g[0]), h3) : h3;
          }
          function a(l) {
            return l.range ? l.range[1] : l.end;
          }
          function n2(l, p) {
            let y = s(l);
            return Number.isInteger(y) && y === s(p);
          }
          function u(l, p) {
            let y = a(l);
            return Number.isInteger(y) && y === a(p);
          }
          function i(l, p) {
            return n2(l, p) && u(l, p);
          }
          r.exports = { locStart: s, locEnd: a, hasSameLocStart: n2, hasSameLoc: i };
        } }), jm = te({ "src/main/load-parser.js"(e2, r) {
          ne(), r.exports = () => {
          };
        } }), qm = te({ "scripts/build/shims/babel-highlight.cjs"(e2, r) {
          "use strict";
          ne();
          var t = kr(), s = { shouldHighlight: () => false, getChalk: () => t };
          r.exports = s;
        } }), Mm = te({ "node_modules/@babel/code-frame/lib/index.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true }), e2.codeFrameColumns = u, e2.default = i;
          var r = qm(), t = false;
          function s(l) {
            return { gutter: l.grey, marker: l.red.bold, message: l.red.bold };
          }
          var a = /\r\n|[\n\r\u2028\u2029]/;
          function n2(l, p, y) {
            let h3 = Object.assign({ column: 0, line: -1 }, l.start), g = Object.assign({}, h3, l.end), { linesAbove: c = 2, linesBelow: f = 3 } = y || {}, F = h3.line, _ = h3.column, w = g.line, E = g.column, N = Math.max(F - (c + 1), 0), x2 = Math.min(p.length, w + f);
            F === -1 && (N = 0), w === -1 && (x2 = p.length);
            let I = w - F, P = {};
            if (I) for (let $ = 0; $ <= I; $++) {
              let D = $ + F;
              if (!_) P[D] = true;
              else if ($ === 0) {
                let T = p[D - 1].length;
                P[D] = [_, T - _ + 1];
              } else if ($ === I) P[D] = [0, E];
              else {
                let T = p[D - $].length;
                P[D] = [0, T];
              }
            }
            else _ === E ? _ ? P[F] = [_, 0] : P[F] = true : P[F] = [_, E - _];
            return { start: N, end: x2, markerLines: P };
          }
          function u(l, p) {
            let y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, h3 = (y.highlightCode || y.forceColor) && (0, r.shouldHighlight)(y), g = (0, r.getChalk)(y), c = s(g), f = ($, D) => h3 ? $(D) : D, F = l.split(a), { start: _, end: w, markerLines: E } = n2(p, F, y), N = p.start && typeof p.start.column == "number", x2 = String(w).length, P = (h3 ? (0, r.default)(l, y) : l).split(a, w).slice(_, w).map(($, D) => {
              let T = _ + 1 + D, C = ` ${` ${T}`.slice(-x2)} |`, o = E[T], d = !E[T + 1];
              if (o) {
                let v = "";
                if (Array.isArray(o)) {
                  let S = $.slice(0, Math.max(o[0] - 1, 0)).replace(/[^\t]/g, " "), b = o[1] || 1;
                  v = [`
 `, f(c.gutter, C.replace(/\d/g, " ")), " ", S, f(c.marker, "^").repeat(b)].join(""), d && y.message && (v += " " + f(c.message, y.message));
                }
                return [f(c.marker, ">"), f(c.gutter, C), $.length > 0 ? ` ${$}` : "", v].join("");
              } else return ` ${f(c.gutter, C)}${$.length > 0 ? ` ${$}` : ""}`;
            }).join(`
`);
            return y.message && !N && (P = `${" ".repeat(x2 + 1)}${y.message}
${P}`), h3 ? g.reset(P) : P;
          }
          function i(l, p, y) {
            let h3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            if (!t) {
              t = true;
              let c = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
              if (wt.emitWarning) wt.emitWarning(c, "DeprecationWarning");
              else {
                let f = new Error(c);
                f.name = "DeprecationWarning", console.warn(new Error(c));
              }
            }
            return y = Math.max(y, 0), u(l, { start: { column: y, line: p } }, h3);
          }
        } }), tu = te({ "src/main/parser.js"(e2, r) {
          "use strict";
          ne();
          var { ConfigError: t } = Qt(), s = ut(), a = jm(), { locStart: n2, locEnd: u } = s, i = Object.getOwnPropertyNames, l = Object.getOwnPropertyDescriptor;
          function p(g) {
            let c = {};
            for (let f of g.plugins) if (f.parsers) for (let F of i(f.parsers)) Object.defineProperty(c, F, l(f.parsers, F));
            return c;
          }
          function y(g) {
            let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : p(g);
            if (typeof g.parser == "function") return { parse: g.parser, astFormat: "estree", locStart: n2, locEnd: u };
            if (typeof g.parser == "string") {
              if (Object.prototype.hasOwnProperty.call(c, g.parser)) return c[g.parser];
              throw new t(`Couldn't resolve parser "${g.parser}". Parsers must be explicitly added to the standalone bundle.`);
            }
          }
          function h3(g, c) {
            let f = p(c), F = Object.defineProperties({}, Object.fromEntries(Object.keys(f).map((w) => [w, { enumerable: true, get() {
              return f[w].parse;
            } }]))), _ = y(c, f);
            try {
              return _.preprocess && (g = _.preprocess(g, c)), { text: g, ast: _.parse(g, F, c) };
            } catch (w) {
              let { loc: E } = w;
              if (E) {
                let { codeFrameColumns: N } = Mm();
                throw w.codeFrame = N(g, E, { highlightCode: true }), w.message += `
` + w.codeFrame, w;
              }
              throw w;
            }
          }
          r.exports = { parse: h3, resolveParser: y };
        } }), uo = te({ "src/main/options.js"(e2, r) {
          "use strict";
          ne();
          var t = ZD(), { UndefinedParserError: s } = Qt(), { getSupportInfo: a } = Xn(), n2 = Om(), { resolveParser: u } = tu(), i = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
          function l(h3) {
            let g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, c = Object.assign({}, h3), f = a({ plugins: h3.plugins, showUnreleased: true, showDeprecated: true }).options, F = Object.assign(Object.assign({}, i), Object.fromEntries(f.filter((x2) => x2.default !== void 0).map((x2) => [x2.name, x2.default])));
            if (!c.parser) {
              if (!c.filepath) (g.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), c.parser = "babel";
              else if (c.parser = y(c.filepath, c.plugins), !c.parser) throw new s(`No parser could be inferred for file: ${c.filepath}`);
            }
            let _ = u(n2.normalizeApiOptions(c, [f.find((x2) => x2.name === "parser")], { passThrough: true, logger: false }));
            c.astFormat = _.astFormat, c.locEnd = _.locEnd, c.locStart = _.locStart;
            let w = p(c);
            c.printer = w.printers[c.astFormat];
            let E = Object.fromEntries(f.filter((x2) => x2.pluginDefaults && x2.pluginDefaults[w.name] !== void 0).map((x2) => [x2.name, x2.pluginDefaults[w.name]])), N = Object.assign(Object.assign({}, F), E);
            for (let [x2, I] of Object.entries(N)) (c[x2] === null || c[x2] === void 0) && (c[x2] = I);
            return c.parser === "json" && (c.trailingComma = "none"), n2.normalizeApiOptions(c, f, Object.assign({ passThrough: Object.keys(i) }, g));
          }
          function p(h3) {
            let { astFormat: g } = h3;
            if (!g) throw new Error("getPlugin() requires astFormat to be set");
            let c = h3.plugins.find((f) => f.printers && f.printers[g]);
            if (!c) throw new Error(`Couldn't find plugin for AST format "${g}"`);
            return c;
          }
          function y(h3, g) {
            let c = t.basename(h3).toLowerCase(), F = a({ plugins: g }).languages.filter((_) => _.since !== null).find((_) => _.extensions && _.extensions.some((w) => c.endsWith(w)) || _.filenames && _.filenames.some((w) => w.toLowerCase() === c));
            return F && F.parsers[0];
          }
          r.exports = { normalize: l, hiddenDefaults: i, inferParser: y };
        } }), Rm = te({ "src/main/massage-ast.js"(e2, r) {
          "use strict";
          ne();
          function t(s, a, n2) {
            if (Array.isArray(s)) return s.map((p) => t(p, a, n2)).filter(Boolean);
            if (!s || typeof s != "object") return s;
            let u = a.printer.massageAstNode, i;
            u && u.ignoredProperties ? i = u.ignoredProperties : i = /* @__PURE__ */ new Set();
            let l = {};
            for (let [p, y] of Object.entries(s)) !i.has(p) && typeof y != "function" && (l[p] = t(y, a, s));
            if (u) {
              let p = u(s, l, n2);
              if (p === null) return;
              if (p) return p;
            }
            return l;
          }
          r.exports = t;
        } }), Zt = te({ "scripts/build/shims/assert.cjs"(e2, r) {
          "use strict";
          ne();
          var t = () => {
          };
          t.ok = t, t.strictEqual = t, r.exports = t;
        } }), et = te({ "src/main/comments.js"(e2, r) {
          "use strict";
          ne();
          var t = Zt(), { builders: { line: s, hardline: a, breakParent: n2, indent: u, lineSuffix: i, join: l, cursor: p } } = qe(), { hasNewline: y, skipNewline: h3, skipSpaces: g, isPreviousLineEmpty: c, addLeadingComment: f, addDanglingComment: F, addTrailingComment: _ } = Ue(), w = /* @__PURE__ */ new WeakMap();
          function E(k, M, R) {
            if (!k) return;
            let { printer: q, locStart: J, locEnd: L } = M;
            if (R) {
              if (q.canAttachComment && q.canAttachComment(k)) {
                let V;
                for (V = R.length - 1; V >= 0 && !(J(R[V]) <= J(k) && L(R[V]) <= L(k)); --V) ;
                R.splice(V + 1, 0, k);
                return;
              }
            } else if (w.has(k)) return w.get(k);
            let Q = q.getCommentChildNodes && q.getCommentChildNodes(k, M) || typeof k == "object" && Object.entries(k).filter((V) => {
              let [j] = V;
              return j !== "enclosingNode" && j !== "precedingNode" && j !== "followingNode" && j !== "tokens" && j !== "comments" && j !== "parent";
            }).map((V) => {
              let [, j] = V;
              return j;
            });
            if (Q) {
              R || (R = [], w.set(k, R));
              for (let V of Q) E(V, M, R);
              return R;
            }
          }
          function N(k, M, R, q) {
            let { locStart: J, locEnd: L } = R, Q = J(M), V = L(M), j = E(k, R), Y, ie, ee = 0, ce = j.length;
            for (; ee < ce; ) {
              let W = ee + ce >> 1, K = j[W], de = J(K), ue = L(K);
              if (de <= Q && V <= ue) return N(K, M, R, K);
              if (ue <= Q) {
                Y = K, ee = W + 1;
                continue;
              }
              if (V <= de) {
                ie = K, ce = W;
                continue;
              }
              throw new Error("Comment location overlaps with node location");
            }
            if (q && q.type === "TemplateLiteral") {
              let { quasis: W } = q, K = C(W, M, R);
              Y && C(W, Y, R) !== K && (Y = null), ie && C(W, ie, R) !== K && (ie = null);
            }
            return { enclosingNode: q, precedingNode: Y, followingNode: ie };
          }
          var x2 = () => false;
          function I(k, M, R, q) {
            if (!Array.isArray(k)) return;
            let J = [], { locStart: L, locEnd: Q, printer: { handleComments: V = {} } } = q, { avoidAstMutation: j, ownLine: Y = x2, endOfLine: ie = x2, remaining: ee = x2 } = V, ce = k.map((W, K) => Object.assign(Object.assign({}, N(M, W, q)), {}, { comment: W, text: R, options: q, ast: M, isLastComment: k.length - 1 === K }));
            for (let [W, K] of ce.entries()) {
              let { comment: de, precedingNode: ue, enclosingNode: Fe, followingNode: z, text: U, options: Z, ast: se, isLastComment: fe } = K;
              if (Z.parser === "json" || Z.parser === "json5" || Z.parser === "__js_expression" || Z.parser === "__vue_expression" || Z.parser === "__vue_ts_expression") {
                if (L(de) - L(se) <= 0) {
                  f(se, de);
                  continue;
                }
                if (Q(de) - Q(se) >= 0) {
                  _(se, de);
                  continue;
                }
              }
              let ge;
              if (j ? ge = [K] : (de.enclosingNode = Fe, de.precedingNode = ue, de.followingNode = z, ge = [de, U, Z, se, fe]), $(U, Z, ce, W)) de.placement = "ownLine", Y(...ge) || (z ? f(z, de) : ue ? _(ue, de) : F(Fe || se, de));
              else if (D(U, Z, ce, W)) de.placement = "endOfLine", ie(...ge) || (ue ? _(ue, de) : z ? f(z, de) : F(Fe || se, de));
              else if (de.placement = "remaining", !ee(...ge)) if (ue && z) {
                let he = J.length;
                he > 0 && J[he - 1].followingNode !== z && T(J, U, Z), J.push(K);
              } else ue ? _(ue, de) : z ? f(z, de) : F(Fe || se, de);
            }
            if (T(J, R, q), !j) for (let W of k) delete W.precedingNode, delete W.enclosingNode, delete W.followingNode;
          }
          var P = (k) => !/[\S\n\u2028\u2029]/.test(k);
          function $(k, M, R, q) {
            let { comment: J, precedingNode: L } = R[q], { locStart: Q, locEnd: V } = M, j = Q(J);
            if (L) for (let Y = q - 1; Y >= 0; Y--) {
              let { comment: ie, precedingNode: ee } = R[Y];
              if (ee !== L || !P(k.slice(V(ie), j))) break;
              j = Q(ie);
            }
            return y(k, j, { backwards: true });
          }
          function D(k, M, R, q) {
            let { comment: J, followingNode: L } = R[q], { locStart: Q, locEnd: V } = M, j = V(J);
            if (L) for (let Y = q + 1; Y < R.length; Y++) {
              let { comment: ie, followingNode: ee } = R[Y];
              if (ee !== L || !P(k.slice(j, Q(ie)))) break;
              j = V(ie);
            }
            return y(k, j);
          }
          function T(k, M, R) {
            let q = k.length;
            if (q === 0) return;
            let { precedingNode: J, followingNode: L, enclosingNode: Q } = k[0], V = R.printer.getGapRegex && R.printer.getGapRegex(Q) || /^[\s(]*$/, j = R.locStart(L), Y;
            for (Y = q; Y > 0; --Y) {
              let { comment: ie, precedingNode: ee, followingNode: ce } = k[Y - 1];
              t.strictEqual(ee, J), t.strictEqual(ce, L);
              let W = M.slice(R.locEnd(ie), j);
              if (V.test(W)) j = R.locStart(ie);
              else break;
            }
            for (let [ie, { comment: ee }] of k.entries()) ie < Y ? _(J, ee) : f(L, ee);
            for (let ie of [J, L]) ie.comments && ie.comments.length > 1 && ie.comments.sort((ee, ce) => R.locStart(ee) - R.locStart(ce));
            k.length = 0;
          }
          function m(k, M) {
            let R = k.getValue();
            return R.printed = true, M.printer.printComment(k, M);
          }
          function C(k, M, R) {
            let q = R.locStart(M) - 1;
            for (let J = 1; J < k.length; ++J) if (q < R.locStart(k[J])) return J - 1;
            return 0;
          }
          function o(k, M) {
            let R = k.getValue(), q = [m(k, M)], { printer: J, originalText: L, locStart: Q, locEnd: V } = M;
            if (J.isBlockComment && J.isBlockComment(R)) {
              let ie = y(L, V(R)) ? y(L, Q(R), { backwards: true }) ? a : s : " ";
              q.push(ie);
            } else q.push(a);
            let Y = h3(L, g(L, V(R)));
            return Y !== false && y(L, Y) && q.push(a), q;
          }
          function d(k, M) {
            let R = k.getValue(), q = m(k, M), { printer: J, originalText: L, locStart: Q } = M, V = J.isBlockComment && J.isBlockComment(R);
            if (y(L, Q(R), { backwards: true })) {
              let Y = c(L, R, Q);
              return i([a, Y ? a : "", q]);
            }
            let j = [" ", q];
            return V || (j = [i(j), n2]), j;
          }
          function v(k, M, R, q) {
            let J = [], L = k.getValue();
            return !L || !L.comments || (k.each(() => {
              let Q = k.getValue();
              !Q.leading && !Q.trailing && (!q || q(Q)) && J.push(m(k, M));
            }, "comments"), J.length === 0) ? "" : R ? l(a, J) : u([a, l(a, J)]);
          }
          function S(k, M, R) {
            let q = k.getValue();
            if (!q) return {};
            let J = q.comments || [];
            R && (J = J.filter((j) => !R.has(j)));
            let L = q === M.cursorNode;
            if (J.length === 0) {
              let j = L ? p : "";
              return { leading: j, trailing: j };
            }
            let Q = [], V = [];
            return k.each(() => {
              let j = k.getValue();
              if (R && R.has(j)) return;
              let { leading: Y, trailing: ie } = j;
              Y ? Q.push(o(k, M)) : ie && V.push(d(k, M));
            }, "comments"), L && (Q.unshift(p), V.push(p)), { leading: Q, trailing: V };
          }
          function b(k, M, R, q) {
            let { leading: J, trailing: L } = S(k, R, q);
            return !J && !L ? M : [J, M, L];
          }
          function B(k) {
            if (k) for (let M of k) {
              if (!M.printed) throw new Error('Comment "' + M.value.trim() + '" was not printed. Please report this error!');
              delete M.printed;
            }
          }
          r.exports = { attach: I, printComments: b, printCommentsSeparately: S, printDanglingComments: v, getSortedChildNodes: E, ensureAllCommentsPrinted: B };
        } }), $m = te({ "src/common/ast-path.js"(e2, r) {
          "use strict";
          ne();
          var t = lt();
          function s(u, i) {
            let l = a(u.stack, i);
            return l === -1 ? null : u.stack[l];
          }
          function a(u, i) {
            for (let l = u.length - 1; l >= 0; l -= 2) {
              let p = u[l];
              if (p && !Array.isArray(p) && --i < 0) return l;
            }
            return -1;
          }
          var n2 = class {
            constructor(u) {
              this.stack = [u];
            }
            getName() {
              let { stack: u } = this, { length: i } = u;
              return i > 1 ? u[i - 2] : null;
            }
            getValue() {
              return t(this.stack);
            }
            getNode() {
              let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return s(this, u);
            }
            getParentNode() {
              let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return s(this, u + 1);
            }
            call(u) {
              let { stack: i } = this, { length: l } = i, p = t(i);
              for (var y = arguments.length, h3 = new Array(y > 1 ? y - 1 : 0), g = 1; g < y; g++) h3[g - 1] = arguments[g];
              for (let f of h3) p = p[f], i.push(f, p);
              let c = u(this);
              return i.length = l, c;
            }
            callParent(u) {
              let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, l = a(this.stack, i + 1), p = this.stack.splice(l + 1), y = u(this);
              return this.stack.push(...p), y;
            }
            each(u) {
              let { stack: i } = this, { length: l } = i, p = t(i);
              for (var y = arguments.length, h3 = new Array(y > 1 ? y - 1 : 0), g = 1; g < y; g++) h3[g - 1] = arguments[g];
              for (let c of h3) p = p[c], i.push(c, p);
              for (let c = 0; c < p.length; ++c) i.push(c, p[c]), u(this, c, p), i.length -= 2;
              i.length = l;
            }
            map(u) {
              let i = [];
              for (var l = arguments.length, p = new Array(l > 1 ? l - 1 : 0), y = 1; y < l; y++) p[y - 1] = arguments[y];
              return this.each((h3, g, c) => {
                i[g] = u(h3, g, c);
              }, ...p), i;
            }
            try(u) {
              let { stack: i } = this, l = [...i];
              try {
                return u();
              } finally {
                i.length = 0, i.push(...l);
              }
            }
            match() {
              let u = this.stack.length - 1, i = null, l = this.stack[u--];
              for (var p = arguments.length, y = new Array(p), h3 = 0; h3 < p; h3++) y[h3] = arguments[h3];
              for (let g of y) {
                if (l === void 0) return false;
                let c = null;
                if (typeof i == "number" && (c = i, i = this.stack[u--], l = this.stack[u--]), g && !g(l, i, c)) return false;
                i = this.stack[u--], l = this.stack[u--];
              }
              return true;
            }
            findAncestor(u) {
              let i = this.stack.length - 1, l = null, p = this.stack[i--];
              for (; p; ) {
                let y = null;
                if (typeof l == "number" && (y = l, l = this.stack[i--], p = this.stack[i--]), l !== null && u(p, l, y)) return p;
                l = this.stack[i--], p = this.stack[i--];
              }
            }
          };
          r.exports = n2;
        } }), Vm = te({ "src/main/multiparser.js"(e2, r) {
          "use strict";
          ne();
          var { utils: { stripTrailingHardline: t } } = qe(), { normalize: s } = uo(), a = et();
          function n2(i, l, p, y) {
            if (p.printer.embed && p.embeddedLanguageFormatting === "auto") return p.printer.embed(i, l, (h3, g, c) => u(h3, g, p, y, c), p);
          }
          function u(i, l, p, y) {
            let { stripTrailingHardline: h3 = false } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, g = s(Object.assign(Object.assign(Object.assign({}, p), l), {}, { parentParser: p.parser, originalText: i }), { passThrough: true }), c = tu().parse(i, g), { ast: f } = c;
            i = c.text;
            let F = f.comments;
            delete f.comments, a.attach(F, f, i, g), g[Symbol.for("comments")] = F || [], g[Symbol.for("tokens")] = f.tokens || [];
            let _ = y(f, g);
            return a.ensureAllCommentsPrinted(F), h3 ? typeof _ == "string" ? _.replace(/(?:\r?\n)*$/, "") : t(_) : _;
          }
          r.exports = { printSubtree: n2 };
        } }), Wm = te({ "src/main/ast-to-doc.js"(e2, r) {
          "use strict";
          ne();
          var t = $m(), { builders: { hardline: s, addAlignmentToDoc: a }, utils: { propagateBreaks: n2 } } = qe(), { printComments: u } = et(), i = Vm();
          function l(h3, g) {
            let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, { printer: f } = g;
            f.preprocess && (h3 = f.preprocess(h3, g));
            let F = /* @__PURE__ */ new Map(), _ = new t(h3), w = E();
            return c > 0 && (w = a([s, w], c, g.tabWidth)), n2(w), w;
            function E(x2, I) {
              return x2 === void 0 || x2 === _ ? N(I) : Array.isArray(x2) ? _.call(() => N(I), ...x2) : _.call(() => N(I), x2);
            }
            function N(x2) {
              let I = _.getValue(), P = I && typeof I == "object" && x2 === void 0;
              if (P && F.has(I)) return F.get(I);
              let $ = y(_, g, E, x2);
              return P && F.set(I, $), $;
            }
          }
          function p(h3, g) {
            let { originalText: c, [Symbol.for("comments")]: f, locStart: F, locEnd: _ } = g, w = F(h3), E = _(h3), N = /* @__PURE__ */ new Set();
            for (let x2 of f) F(x2) >= w && _(x2) <= E && (x2.printed = true, N.add(x2));
            return { doc: c.slice(w, E), printedComments: N };
          }
          function y(h3, g, c, f) {
            let F = h3.getValue(), { printer: _ } = g, w, E;
            if (_.hasPrettierIgnore && _.hasPrettierIgnore(h3)) ({ doc: w, printedComments: E } = p(F, g));
            else {
              if (F) try {
                w = i.printSubtree(h3, c, g, l);
              } catch (N) {
                if (globalThis.PRETTIER_DEBUG) throw N;
              }
              w || (w = _.print(h3, g, c, f));
            }
            return (!_.willPrintOwnComments || !_.willPrintOwnComments(h3, g)) && (w = u(h3, w, g, E)), w;
          }
          r.exports = l;
        } }), Hm = te({ "src/main/range-util.js"(e2, r) {
          "use strict";
          ne();
          var t = Zt(), s = et(), a = (f) => {
            let { parser: F } = f;
            return F === "json" || F === "json5" || F === "json-stringify";
          };
          function n2(f, F) {
            let _ = [f.node, ...f.parentNodes], w = /* @__PURE__ */ new Set([F.node, ...F.parentNodes]);
            return _.find((E) => y.has(E.type) && w.has(E));
          }
          function u(f) {
            let F = f.length - 1;
            for (; ; ) {
              let _ = f[F];
              if (_ && (_.type === "Program" || _.type === "File")) F--;
              else break;
            }
            return f.slice(0, F + 1);
          }
          function i(f, F, _) {
            let { locStart: w, locEnd: E } = _, N = f.node, x2 = F.node;
            if (N === x2) return { startNode: N, endNode: x2 };
            let I = w(f.node);
            for (let $ of u(F.parentNodes)) if (w($) >= I) x2 = $;
            else break;
            let P = E(F.node);
            for (let $ of u(f.parentNodes)) {
              if (E($) <= P) N = $;
              else break;
              if (N === x2) break;
            }
            return { startNode: N, endNode: x2 };
          }
          function l(f, F, _, w) {
            let E = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], N = arguments.length > 5 ? arguments[5] : void 0, { locStart: x2, locEnd: I } = _, P = x2(f), $ = I(f);
            if (!(F > $ || F < P || N === "rangeEnd" && F === P || N === "rangeStart" && F === $)) {
              for (let D of s.getSortedChildNodes(f, _)) {
                let T = l(D, F, _, w, [f, ...E], N);
                if (T) return T;
              }
              if (!w || w(f, E[0])) return { node: f, parentNodes: E };
            }
          }
          function p(f, F) {
            return F !== "DeclareExportDeclaration" && f !== "TypeParameterDeclaration" && (f === "Directive" || f === "TypeAlias" || f === "TSExportAssignment" || f.startsWith("Declare") || f.startsWith("TSDeclare") || f.endsWith("Statement") || f.endsWith("Declaration"));
          }
          var y = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), h3 = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
          function g(f, F, _) {
            if (!F) return false;
            switch (f.parser) {
              case "flow":
              case "babel":
              case "babel-flow":
              case "babel-ts":
              case "typescript":
              case "acorn":
              case "espree":
              case "meriyah":
              case "__babel_estree":
                return p(F.type, _ && _.type);
              case "json":
              case "json5":
              case "json-stringify":
                return y.has(F.type);
              case "graphql":
                return h3.has(F.kind);
              case "vue":
                return F.tag !== "root";
            }
            return false;
          }
          function c(f, F, _) {
            let { rangeStart: w, rangeEnd: E, locStart: N, locEnd: x2 } = F;
            t.ok(E > w);
            let I = f.slice(w, E).search(/\S/), P = I === -1;
            if (!P) for (w += I; E > w && !/\S/.test(f[E - 1]); --E) ;
            let $ = l(_, w, F, (C, o) => g(F, C, o), [], "rangeStart"), D = P ? $ : l(_, E, F, (C) => g(F, C), [], "rangeEnd");
            if (!$ || !D) return { rangeStart: 0, rangeEnd: 0 };
            let T, m;
            if (a(F)) {
              let C = n2($, D);
              T = C, m = C;
            } else ({ startNode: T, endNode: m } = i($, D, F));
            return { rangeStart: Math.min(N(T), N(m)), rangeEnd: Math.max(x2(T), x2(m)) };
          }
          r.exports = { calculateRange: c, findNodeAtOffset: l };
        } }), Gm = te({ "src/main/core.js"(e2, r) {
          "use strict";
          ne();
          var { diffArrays: t } = BD(), { printer: { printDocToString: s }, debug: { printDocToDebug: a } } = qe(), { getAlignmentSize: n2 } = Ue(), { guessEndOfLine: u, convertEndOfLineToChars: i, countEndOfLineChars: l, normalizeEndOfLine: p } = Jn(), y = uo().normalize, h3 = Rm(), g = et(), c = tu(), f = Wm(), F = Hm(), _ = "\uFEFF", w = Symbol("cursor");
          function E(m, C, o) {
            let d = C.comments;
            return d && (delete C.comments, g.attach(d, C, m, o)), o[Symbol.for("comments")] = d || [], o[Symbol.for("tokens")] = C.tokens || [], o.originalText = m, d;
          }
          function N(m, C) {
            let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            if (!m || m.trim().length === 0) return { formatted: "", cursorOffset: -1, comments: [] };
            let { ast: d, text: v } = c.parse(m, C);
            if (C.cursorOffset >= 0) {
              let k = F.findNodeAtOffset(d, C.cursorOffset, C);
              k && k.node && (C.cursorNode = k.node);
            }
            let S = E(v, d, C), b = f(d, C, o), B = s(b, C);
            if (g.ensureAllCommentsPrinted(S), o > 0) {
              let k = B.formatted.trim();
              B.cursorNodeStart !== void 0 && (B.cursorNodeStart -= B.formatted.indexOf(k)), B.formatted = k + i(C.endOfLine);
            }
            if (C.cursorOffset >= 0) {
              let k, M, R, q, J;
              if (C.cursorNode && B.cursorNodeText ? (k = C.locStart(C.cursorNode), M = v.slice(k, C.locEnd(C.cursorNode)), R = C.cursorOffset - k, q = B.cursorNodeStart, J = B.cursorNodeText) : (k = 0, M = v, R = C.cursorOffset, q = 0, J = B.formatted), M === J) return { formatted: B.formatted, cursorOffset: q + R, comments: S };
              let L = [...M];
              L.splice(R, 0, w);
              let Q = [...J], V = t(L, Q), j = q;
              for (let Y of V) if (Y.removed) {
                if (Y.value.includes(w)) break;
              } else j += Y.count;
              return { formatted: B.formatted, cursorOffset: j, comments: S };
            }
            return { formatted: B.formatted, cursorOffset: -1, comments: S };
          }
          function x2(m, C) {
            let { ast: o, text: d } = c.parse(m, C), { rangeStart: v, rangeEnd: S } = F.calculateRange(d, C, o), b = d.slice(v, S), B = Math.min(v, d.lastIndexOf(`
`, v) + 1), k = d.slice(B, v).match(/^\s*/)[0], M = n2(k, C.tabWidth), R = N(b, Object.assign(Object.assign({}, C), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: C.cursorOffset > v && C.cursorOffset <= S ? C.cursorOffset - v : -1, endOfLine: "lf" }), M), q = R.formatted.trimEnd(), { cursorOffset: J } = C;
            J > S ? J += q.length - b.length : R.cursorOffset >= 0 && (J = R.cursorOffset + v);
            let L = d.slice(0, v) + q + d.slice(S);
            if (C.endOfLine !== "lf") {
              let Q = i(C.endOfLine);
              J >= 0 && Q === `\r
` && (J += l(L.slice(0, J), `
`)), L = L.replace(/\n/g, Q);
            }
            return { formatted: L, cursorOffset: J, comments: R.comments };
          }
          function I(m, C, o) {
            return typeof C != "number" || Number.isNaN(C) || C < 0 || C > m.length ? o : C;
          }
          function P(m, C) {
            let { cursorOffset: o, rangeStart: d, rangeEnd: v } = C;
            return o = I(m, o, -1), d = I(m, d, 0), v = I(m, v, m.length), Object.assign(Object.assign({}, C), {}, { cursorOffset: o, rangeStart: d, rangeEnd: v });
          }
          function $(m, C) {
            let { cursorOffset: o, rangeStart: d, rangeEnd: v, endOfLine: S } = P(m, C), b = m.charAt(0) === _;
            if (b && (m = m.slice(1), o--, d--, v--), S === "auto" && (S = u(m)), m.includes("\r")) {
              let B = (k) => l(m.slice(0, Math.max(k, 0)), `\r
`);
              o -= B(o), d -= B(d), v -= B(v), m = p(m);
            }
            return { hasBOM: b, text: m, options: P(m, Object.assign(Object.assign({}, C), {}, { cursorOffset: o, rangeStart: d, rangeEnd: v, endOfLine: S })) };
          }
          function D(m, C) {
            let o = c.resolveParser(C);
            return !o.hasPragma || o.hasPragma(m);
          }
          function T(m, C) {
            let { hasBOM: o, text: d, options: v } = $(m, y(C));
            if (v.rangeStart >= v.rangeEnd && d !== "" || v.requirePragma && !D(d, v)) return { formatted: m, cursorOffset: C.cursorOffset, comments: [] };
            let S;
            return v.rangeStart > 0 || v.rangeEnd < d.length ? S = x2(d, v) : (!v.requirePragma && v.insertPragma && v.printer.insertPragma && !D(d, v) && (d = v.printer.insertPragma(d)), S = N(d, v)), o && (S.formatted = _ + S.formatted, S.cursorOffset >= 0 && S.cursorOffset++), S;
          }
          r.exports = { formatWithCursor: T, parse(m, C, o) {
            let { text: d, options: v } = $(m, y(C)), S = c.parse(d, v);
            return o && (S.ast = h3(S.ast, v)), S;
          }, formatAST(m, C) {
            C = y(C);
            let o = f(m, C);
            return s(o, C);
          }, formatDoc(m, C) {
            return T(a(m), Object.assign(Object.assign({}, C), {}, { parser: "__js_expression" })).formatted;
          }, printToDoc(m, C) {
            C = y(C);
            let { ast: o, text: d } = c.parse(m, C);
            return E(d, o, C), f(o, C);
          }, printDocToString(m, C) {
            return s(m, y(C));
          } };
        } }), Um = te({ "src/common/util-shared.js"(e2, r) {
          "use strict";
          ne();
          var { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: a, getIndentSize: n2, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: p, skipToLineEnd: y, skipEverythingButNewLine: h3, skipInlineComment: g, skipTrailingComment: c, hasNewline: f, hasNewlineInRange: F, hasSpaces: _, isNextLineEmpty: w, isNextLineEmptyAfterIndex: E, isPreviousLineEmpty: N, getNextNonSpaceNonCommentCharacterIndex: x2, makeString: I, addLeadingComment: P, addDanglingComment: $, addTrailingComment: D } = Ue();
          r.exports = { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: a, getIndentSize: n2, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: p, skipToLineEnd: y, skipEverythingButNewLine: h3, skipInlineComment: g, skipTrailingComment: c, hasNewline: f, hasNewlineInRange: F, hasSpaces: _, isNextLineEmpty: w, isNextLineEmptyAfterIndex: E, isPreviousLineEmpty: N, getNextNonSpaceNonCommentCharacterIndex: x2, makeString: I, addLeadingComment: P, addDanglingComment: $, addTrailingComment: D };
        } }), _t = te({ "src/utils/create-language.js"(e2, r) {
          "use strict";
          ne(), r.exports = function(t, s) {
            let { languageId: a } = t, n2 = Hn(t, CD);
            return Object.assign(Object.assign({ linguistLanguageId: a }, n2), s(t));
          };
        } }), Jm = te({ "node_modules/esutils/lib/ast.js"(e2, r) {
          ne(), function() {
            "use strict";
            function t(l) {
              if (l == null) return false;
              switch (l.type) {
                case "ArrayExpression":
                case "AssignmentExpression":
                case "BinaryExpression":
                case "CallExpression":
                case "ConditionalExpression":
                case "FunctionExpression":
                case "Identifier":
                case "Literal":
                case "LogicalExpression":
                case "MemberExpression":
                case "NewExpression":
                case "ObjectExpression":
                case "SequenceExpression":
                case "ThisExpression":
                case "UnaryExpression":
                case "UpdateExpression":
                  return true;
              }
              return false;
            }
            function s(l) {
              if (l == null) return false;
              switch (l.type) {
                case "DoWhileStatement":
                case "ForInStatement":
                case "ForStatement":
                case "WhileStatement":
                  return true;
              }
              return false;
            }
            function a(l) {
              if (l == null) return false;
              switch (l.type) {
                case "BlockStatement":
                case "BreakStatement":
                case "ContinueStatement":
                case "DebuggerStatement":
                case "DoWhileStatement":
                case "EmptyStatement":
                case "ExpressionStatement":
                case "ForInStatement":
                case "ForStatement":
                case "IfStatement":
                case "LabeledStatement":
                case "ReturnStatement":
                case "SwitchStatement":
                case "ThrowStatement":
                case "TryStatement":
                case "VariableDeclaration":
                case "WhileStatement":
                case "WithStatement":
                  return true;
              }
              return false;
            }
            function n2(l) {
              return a(l) || l != null && l.type === "FunctionDeclaration";
            }
            function u(l) {
              switch (l.type) {
                case "IfStatement":
                  return l.alternate != null ? l.alternate : l.consequent;
                case "LabeledStatement":
                case "ForStatement":
                case "ForInStatement":
                case "WhileStatement":
                case "WithStatement":
                  return l.body;
              }
              return null;
            }
            function i(l) {
              var p;
              if (l.type !== "IfStatement" || l.alternate == null) return false;
              p = l.consequent;
              do {
                if (p.type === "IfStatement" && p.alternate == null) return true;
                p = u(p);
              } while (p);
              return false;
            }
            r.exports = { isExpression: t, isStatement: a, isIterationStatement: s, isSourceElement: n2, isProblematicIfStatement: i, trailingStatement: u };
          }();
        } }), so = te({ "node_modules/esutils/lib/code.js"(e2, r) {
          ne(), function() {
            "use strict";
            var t, s, a, n2, u, i;
            s = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };
            function l(E) {
              return 48 <= E && E <= 57;
            }
            function p(E) {
              return 48 <= E && E <= 57 || 97 <= E && E <= 102 || 65 <= E && E <= 70;
            }
            function y(E) {
              return E >= 48 && E <= 55;
            }
            a = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
            function h3(E) {
              return E === 32 || E === 9 || E === 11 || E === 12 || E === 160 || E >= 5760 && a.indexOf(E) >= 0;
            }
            function g(E) {
              return E === 10 || E === 13 || E === 8232 || E === 8233;
            }
            function c(E) {
              if (E <= 65535) return String.fromCharCode(E);
              var N = String.fromCharCode(Math.floor((E - 65536) / 1024) + 55296), x2 = String.fromCharCode((E - 65536) % 1024 + 56320);
              return N + x2;
            }
            for (n2 = new Array(128), i = 0; i < 128; ++i) n2[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i === 36 || i === 95;
            for (u = new Array(128), i = 0; i < 128; ++i) u[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || i === 36 || i === 95;
            function f(E) {
              return E < 128 ? n2[E] : s.NonAsciiIdentifierStart.test(c(E));
            }
            function F(E) {
              return E < 128 ? u[E] : s.NonAsciiIdentifierPart.test(c(E));
            }
            function _(E) {
              return E < 128 ? n2[E] : t.NonAsciiIdentifierStart.test(c(E));
            }
            function w(E) {
              return E < 128 ? u[E] : t.NonAsciiIdentifierPart.test(c(E));
            }
            r.exports = { isDecimalDigit: l, isHexDigit: p, isOctalDigit: y, isWhiteSpace: h3, isLineTerminator: g, isIdentifierStartES5: f, isIdentifierPartES5: F, isIdentifierStartES6: _, isIdentifierPartES6: w };
          }();
        } }), zm = te({ "node_modules/esutils/lib/keyword.js"(e2, r) {
          ne(), function() {
            "use strict";
            var t = so();
            function s(f) {
              switch (f) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "let":
                  return true;
                default:
                  return false;
              }
            }
            function a(f, F) {
              return !F && f === "yield" ? false : n2(f, F);
            }
            function n2(f, F) {
              if (F && s(f)) return true;
              switch (f.length) {
                case 2:
                  return f === "if" || f === "in" || f === "do";
                case 3:
                  return f === "var" || f === "for" || f === "new" || f === "try";
                case 4:
                  return f === "this" || f === "else" || f === "case" || f === "void" || f === "with" || f === "enum";
                case 5:
                  return f === "while" || f === "break" || f === "catch" || f === "throw" || f === "const" || f === "yield" || f === "class" || f === "super";
                case 6:
                  return f === "return" || f === "typeof" || f === "delete" || f === "switch" || f === "export" || f === "import";
                case 7:
                  return f === "default" || f === "finally" || f === "extends";
                case 8:
                  return f === "function" || f === "continue" || f === "debugger";
                case 10:
                  return f === "instanceof";
                default:
                  return false;
              }
            }
            function u(f, F) {
              return f === "null" || f === "true" || f === "false" || a(f, F);
            }
            function i(f, F) {
              return f === "null" || f === "true" || f === "false" || n2(f, F);
            }
            function l(f) {
              return f === "eval" || f === "arguments";
            }
            function p(f) {
              var F, _, w;
              if (f.length === 0 || (w = f.charCodeAt(0), !t.isIdentifierStartES5(w))) return false;
              for (F = 1, _ = f.length; F < _; ++F) if (w = f.charCodeAt(F), !t.isIdentifierPartES5(w)) return false;
              return true;
            }
            function y(f, F) {
              return (f - 55296) * 1024 + (F - 56320) + 65536;
            }
            function h3(f) {
              var F, _, w, E, N;
              if (f.length === 0) return false;
              for (N = t.isIdentifierStartES6, F = 0, _ = f.length; F < _; ++F) {
                if (w = f.charCodeAt(F), 55296 <= w && w <= 56319) {
                  if (++F, F >= _ || (E = f.charCodeAt(F), !(56320 <= E && E <= 57343))) return false;
                  w = y(w, E);
                }
                if (!N(w)) return false;
                N = t.isIdentifierPartES6;
              }
              return true;
            }
            function g(f, F) {
              return p(f) && !u(f, F);
            }
            function c(f, F) {
              return h3(f) && !i(f, F);
            }
            r.exports = { isKeywordES5: a, isKeywordES6: n2, isReservedWordES5: u, isReservedWordES6: i, isRestrictedWord: l, isIdentifierNameES5: p, isIdentifierNameES6: h3, isIdentifierES5: g, isIdentifierES6: c };
          }();
        } }), Xm = te({ "node_modules/esutils/lib/utils.js"(e2) {
          ne(), function() {
            "use strict";
            e2.ast = Jm(), e2.code = so(), e2.keyword = zm();
          }();
        } }), Pt = te({ "src/language-js/utils/is-block-comment.js"(e2, r) {
          "use strict";
          ne();
          var t = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), s = (a) => t.has(a == null ? void 0 : a.type);
          r.exports = s;
        } }), Km = te({ "src/language-js/utils/is-node-matches.js"(e2, r) {
          "use strict";
          ne();
          function t(a, n2) {
            let u = n2.split(".");
            for (let i = u.length - 1; i >= 0; i--) {
              let l = u[i];
              if (i === 0) return a.type === "Identifier" && a.name === l;
              if (a.type !== "MemberExpression" || a.optional || a.computed || a.property.type !== "Identifier" || a.property.name !== l) return false;
              a = a.object;
            }
          }
          function s(a, n2) {
            return n2.some((u) => t(a, u));
          }
          r.exports = s;
        } }), Ke = te({ "src/language-js/utils/index.js"(e2, r) {
          "use strict";
          ne();
          var t = Xm().keyword.isIdentifierNameES5, { getLast: s, hasNewline: a, skipWhitespace: n2, isNonEmptyArray: u, isNextLineEmptyAfterIndex: i, getStringWidth: l } = Ue(), { locStart: p, locEnd: y, hasSameLocStart: h3 } = ut(), g = Pt(), c = Km(), f = "(?:(?=.)\\s)", F = new RegExp(`^${f}*:`), _ = new RegExp(`^${f}*::`);
          function w(O) {
            var me, _e;
            return ((me = O.extra) === null || me === void 0 ? void 0 : me.parenthesized) && g((_e = O.trailingComments) === null || _e === void 0 ? void 0 : _e[0]) && F.test(O.trailingComments[0].value);
          }
          function E(O) {
            let me = O == null ? void 0 : O[0];
            return g(me) && _.test(me.value);
          }
          function N(O, me) {
            if (!O || typeof O != "object") return false;
            if (Array.isArray(O)) return O.some((He) => N(He, me));
            let _e = me(O);
            return typeof _e == "boolean" ? _e : Object.values(O).some((He) => N(He, me));
          }
          function x2(O) {
            return O.type === "AssignmentExpression" || O.type === "BinaryExpression" || O.type === "LogicalExpression" || O.type === "NGPipeExpression" || O.type === "ConditionalExpression" || de(O) || ue(O) || O.type === "SequenceExpression" || O.type === "TaggedTemplateExpression" || O.type === "BindExpression" || O.type === "UpdateExpression" && !O.prefix || st(O) || O.type === "TSNonNullExpression";
          }
          function I(O) {
            var me, _e, He, Ge, it, Qe;
            return O.expressions ? O.expressions[0] : (me = (_e = (He = (Ge = (it = (Qe = O.left) !== null && Qe !== void 0 ? Qe : O.test) !== null && it !== void 0 ? it : O.callee) !== null && Ge !== void 0 ? Ge : O.object) !== null && He !== void 0 ? He : O.tag) !== null && _e !== void 0 ? _e : O.argument) !== null && me !== void 0 ? me : O.expression;
          }
          function P(O, me) {
            if (me.expressions) return ["expressions", 0];
            if (me.left) return ["left"];
            if (me.test) return ["test"];
            if (me.object) return ["object"];
            if (me.callee) return ["callee"];
            if (me.tag) return ["tag"];
            if (me.argument) return ["argument"];
            if (me.expression) return ["expression"];
            throw new Error("Unexpected node has no left side.");
          }
          function $(O) {
            return O = new Set(O), (me) => O.has(me == null ? void 0 : me.type);
          }
          var D = $(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose"]), T = $(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
          function m(O) {
            let me = O.getParentNode();
            return O.getName() === "declaration" && T(me) ? me : null;
          }
          var C = $(["BooleanLiteral", "DirectiveLiteral", "Literal", "NullLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "RegExpLiteral", "StringLiteral", "TemplateLiteral", "TSTypeLiteral", "JSXText"]);
          function o(O) {
            return O.type === "NumericLiteral" || O.type === "Literal" && typeof O.value == "number";
          }
          function d(O) {
            return O.type === "UnaryExpression" && (O.operator === "+" || O.operator === "-") && o(O.argument);
          }
          function v(O) {
            return O.type === "StringLiteral" || O.type === "Literal" && typeof O.value == "string";
          }
          var S = $(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), b = $(["FunctionExpression", "ArrowFunctionExpression"]);
          function B(O) {
            return O.type === "FunctionExpression" || O.type === "ArrowFunctionExpression" && O.body.type === "BlockStatement";
          }
          function k(O) {
            return de(O) && O.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(O.callee.name);
          }
          var M = $(["JSXElement", "JSXFragment"]);
          function R(O, me) {
            if (O.parentParser !== "markdown" && O.parentParser !== "mdx") return false;
            let _e = me.getNode();
            if (!_e.expression || !M(_e.expression)) return false;
            let He = me.getParentNode();
            return He.type === "Program" && He.body.length === 1;
          }
          function q(O) {
            return O.kind === "get" || O.kind === "set";
          }
          function J(O) {
            return q(O) || h3(O, O.value);
          }
          function L(O) {
            return (O.type === "ObjectTypeProperty" || O.type === "ObjectTypeInternalSlot") && O.value.type === "FunctionTypeAnnotation" && !O.static && !J(O);
          }
          function Q(O) {
            return (O.type === "TypeAnnotation" || O.type === "TSTypeAnnotation") && O.typeAnnotation.type === "FunctionTypeAnnotation" && !O.static && !h3(O, O.typeAnnotation);
          }
          var V = $(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
          function j(O) {
            return ue(O) || O.type === "BindExpression" && Boolean(O.object);
          }
          var Y = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
          function ie(O) {
            return O ? !!((O.type === "GenericTypeAnnotation" || O.type === "TSTypeReference") && !O.typeParameters || Y.has(O.type)) : false;
          }
          function ee(O) {
            let me = /^(?:before|after)(?:Each|All)$/;
            return O.callee.type === "Identifier" && me.test(O.callee.name) && O.arguments.length === 1;
          }
          var ce = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
          function W(O) {
            return c(O, ce);
          }
          function K(O, me) {
            if (O.type !== "CallExpression") return false;
            if (O.arguments.length === 1) {
              if (k(O) && me && K(me)) return b(O.arguments[0]);
              if (ee(O)) return k(O.arguments[0]);
            } else if ((O.arguments.length === 2 || O.arguments.length === 3) && (O.arguments[0].type === "TemplateLiteral" || v(O.arguments[0])) && W(O.callee)) return O.arguments[2] && !o(O.arguments[2]) ? false : (O.arguments.length === 2 ? b(O.arguments[1]) : B(O.arguments[1]) && ve(O.arguments[1]).length <= 1) || k(O.arguments[1]);
            return false;
          }
          var de = $(["CallExpression", "OptionalCallExpression"]), ue = $(["MemberExpression", "OptionalMemberExpression"]);
          function Fe(O) {
            let me = "expressions";
            O.type === "TSTemplateLiteralType" && (me = "types");
            let _e = O[me];
            return _e.length === 0 ? false : _e.every((He) => {
              if (Me(He)) return false;
              if (He.type === "Identifier" || He.type === "ThisExpression") return true;
              if (ue(He)) {
                let Ge = He;
                for (; ue(Ge); ) if (Ge.property.type !== "Identifier" && Ge.property.type !== "Literal" && Ge.property.type !== "StringLiteral" && Ge.property.type !== "NumericLiteral" || (Ge = Ge.object, Me(Ge))) return false;
                return Ge.type === "Identifier" || Ge.type === "ThisExpression";
              }
              return false;
            });
          }
          function z(O, me) {
            return O === "+" || O === "-" ? O + me : me;
          }
          function U(O, me) {
            let _e = p(me), He = n2(O, y(me));
            return He !== false && O.slice(_e, _e + 2) === "/*" && O.slice(He, He + 2) === "*/";
          }
          function Z(O, me) {
            return M(me) ? Oe(me) : Me(me, Te.Leading, (_e) => a(O, y(_e)));
          }
          function se(O, me) {
            return me.parser !== "json" && v(O.key) && oe(O.key).slice(1, -1) === O.key.value && (t(O.key.value) && !(me.parser === "babel-ts" && O.type === "ClassProperty" || me.parser === "typescript" && O.type === "PropertyDefinition") || fe(O.key.value) && String(Number(O.key.value)) === O.key.value && (me.parser === "babel" || me.parser === "acorn" || me.parser === "espree" || me.parser === "meriyah" || me.parser === "__babel_estree"));
          }
          function fe(O) {
            return /^(?:\d+|\d+\.\d+)$/.test(O);
          }
          function ge(O, me) {
            let _e = /^[fx]?(?:describe|it|test)$/;
            return me.type === "TaggedTemplateExpression" && me.quasi === O && me.tag.type === "MemberExpression" && me.tag.property.type === "Identifier" && me.tag.property.name === "each" && (me.tag.object.type === "Identifier" && _e.test(me.tag.object.name) || me.tag.object.type === "MemberExpression" && me.tag.object.property.type === "Identifier" && (me.tag.object.property.name === "only" || me.tag.object.property.name === "skip") && me.tag.object.object.type === "Identifier" && _e.test(me.tag.object.object.name));
          }
          function he(O) {
            return O.quasis.some((me) => me.value.raw.includes(`
`));
          }
          function we(O, me) {
            return (O.type === "TemplateLiteral" && he(O) || O.type === "TaggedTemplateExpression" && he(O.quasi)) && !a(me, p(O), { backwards: true });
          }
          function ke(O) {
            if (!Me(O)) return false;
            let me = s(ae(O, Te.Dangling));
            return me && !g(me);
          }
          function Re(O) {
            if (O.length <= 1) return false;
            let me = 0;
            for (let _e of O) if (b(_e)) {
              if (me += 1, me > 1) return true;
            } else if (de(_e)) {
              for (let He of _e.arguments) if (b(He)) return true;
            }
            return false;
          }
          function Ne(O) {
            let me = O.getValue(), _e = O.getParentNode();
            return de(me) && de(_e) && _e.callee === me && me.arguments.length > _e.arguments.length && _e.arguments.length > 0;
          }
          function Pe(O, me) {
            if (me >= 2) return false;
            let _e = (Qe) => Pe(Qe, me + 1), He = O.type === "Literal" && "regex" in O && O.regex.pattern || O.type === "RegExpLiteral" && O.pattern;
            if (He && l(He) > 5) return false;
            if (O.type === "Literal" || O.type === "BigIntLiteral" || O.type === "DecimalLiteral" || O.type === "BooleanLiteral" || O.type === "NullLiteral" || O.type === "NumericLiteral" || O.type === "RegExpLiteral" || O.type === "StringLiteral" || O.type === "Identifier" || O.type === "ThisExpression" || O.type === "Super" || O.type === "PrivateName" || O.type === "PrivateIdentifier" || O.type === "ArgumentPlaceholder" || O.type === "Import") return true;
            if (O.type === "TemplateLiteral") return O.quasis.every((Qe) => !Qe.value.raw.includes(`
`)) && O.expressions.every(_e);
            if (O.type === "ObjectExpression") return O.properties.every((Qe) => !Qe.computed && (Qe.shorthand || Qe.value && _e(Qe.value)));
            if (O.type === "ArrayExpression") return O.elements.every((Qe) => Qe === null || _e(Qe));
            if (tt(O)) return (O.type === "ImportExpression" || Pe(O.callee, me)) && Ye(O).every(_e);
            if (ue(O)) return Pe(O.object, me) && Pe(O.property, me);
            let Ge = { "!": true, "-": true, "+": true, "~": true };
            if (O.type === "UnaryExpression" && Ge[O.operator]) return Pe(O.argument, me);
            let it = { "++": true, "--": true };
            return O.type === "UpdateExpression" && it[O.operator] ? Pe(O.argument, me) : O.type === "TSNonNullExpression" ? Pe(O.expression, me) : false;
          }
          function oe(O) {
            var me, _e;
            return (me = (_e = O.extra) === null || _e === void 0 ? void 0 : _e.raw) !== null && me !== void 0 ? me : O.raw;
          }
          function H(O) {
            return O;
          }
          function pe(O) {
            return O.filepath && /\.tsx$/i.test(O.filepath);
          }
          function X(O) {
            let me = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
            return O.trailingComma === "es5" && me === "es5" || O.trailingComma === "all" && (me === "all" || me === "es5");
          }
          function le(O, me) {
            switch (O.type) {
              case "BinaryExpression":
              case "LogicalExpression":
              case "AssignmentExpression":
              case "NGPipeExpression":
                return le(O.left, me);
              case "MemberExpression":
              case "OptionalMemberExpression":
                return le(O.object, me);
              case "TaggedTemplateExpression":
                return O.tag.type === "FunctionExpression" ? false : le(O.tag, me);
              case "CallExpression":
              case "OptionalCallExpression":
                return O.callee.type === "FunctionExpression" ? false : le(O.callee, me);
              case "ConditionalExpression":
                return le(O.test, me);
              case "UpdateExpression":
                return !O.prefix && le(O.argument, me);
              case "BindExpression":
                return O.object && le(O.object, me);
              case "SequenceExpression":
                return le(O.expressions[0], me);
              case "TSSatisfiesExpression":
              case "TSAsExpression":
              case "TSNonNullExpression":
                return le(O.expression, me);
              default:
                return me(O);
            }
          }
          var Ae = { "==": true, "!=": true, "===": true, "!==": true }, Ee = { "*": true, "/": true, "%": true }, De = { ">>": true, ">>>": true, "<<": true };
          function A(O, me) {
            return !(re(me) !== re(O) || O === "**" || Ae[O] && Ae[me] || me === "%" && Ee[O] || O === "%" && Ee[me] || me !== O && Ee[me] && Ee[O] || De[O] && De[me]);
          }
          var G = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((O, me) => O.map((_e) => [_e, me])));
          function re(O) {
            return G.get(O);
          }
          function ye(O) {
            return Boolean(De[O]) || O === "|" || O === "^" || O === "&";
          }
          function Ce(O) {
            var me;
            if (O.rest) return true;
            let _e = ve(O);
            return ((me = s(_e)) === null || me === void 0 ? void 0 : me.type) === "RestElement";
          }
          var Be = /* @__PURE__ */ new WeakMap();
          function ve(O) {
            if (Be.has(O)) return Be.get(O);
            let me = [];
            return O.this && me.push(O.this), Array.isArray(O.parameters) ? me.push(...O.parameters) : Array.isArray(O.params) && me.push(...O.params), O.rest && me.push(O.rest), Be.set(O, me), me;
          }
          function ze(O, me) {
            let _e = O.getValue(), He = 0, Ge = (it) => me(it, He++);
            _e.this && O.call(Ge, "this"), Array.isArray(_e.parameters) ? O.each(Ge, "parameters") : Array.isArray(_e.params) && O.each(Ge, "params"), _e.rest && O.call(Ge, "rest");
          }
          var be = /* @__PURE__ */ new WeakMap();
          function Ye(O) {
            if (be.has(O)) return be.get(O);
            let me = O.arguments;
            return O.type === "ImportExpression" && (me = [O.source], O.attributes && me.push(O.attributes)), be.set(O, me), me;
          }
          function Se(O, me) {
            let _e = O.getValue();
            _e.type === "ImportExpression" ? (O.call((He) => me(He, 0), "source"), _e.attributes && O.call((He) => me(He, 1), "attributes")) : O.each(me, "arguments");
          }
          function Ie(O) {
            return O.value.trim() === "prettier-ignore" && !O.unignore;
          }
          function Oe(O) {
            return O && (O.prettierIgnore || Me(O, Te.PrettierIgnore));
          }
          function Je(O) {
            let me = O.getValue();
            return Oe(me);
          }
          var Te = { Leading: 1 << 1, Trailing: 1 << 2, Dangling: 1 << 3, Block: 1 << 4, Line: 1 << 5, PrettierIgnore: 1 << 6, First: 1 << 7, Last: 1 << 8 }, je = (O, me) => {
            if (typeof O == "function" && (me = O, O = 0), O || me) return (_e, He, Ge) => !(O & Te.Leading && !_e.leading || O & Te.Trailing && !_e.trailing || O & Te.Dangling && (_e.leading || _e.trailing) || O & Te.Block && !g(_e) || O & Te.Line && !D(_e) || O & Te.First && He !== 0 || O & Te.Last && He !== Ge.length - 1 || O & Te.PrettierIgnore && !Ie(_e) || me && !me(_e));
          };
          function Me(O, me, _e) {
            if (!u(O == null ? void 0 : O.comments)) return false;
            let He = je(me, _e);
            return He ? O.comments.some(He) : true;
          }
          function ae(O, me, _e) {
            if (!Array.isArray(O == null ? void 0 : O.comments)) return [];
            let He = je(me, _e);
            return He ? O.comments.filter(He) : O.comments;
          }
          var nt = (O, me) => {
            let { originalText: _e } = me;
            return i(_e, y(O));
          };
          function tt(O) {
            return de(O) || O.type === "NewExpression" || O.type === "ImportExpression";
          }
          function Ve(O) {
            return O && (O.type === "ObjectProperty" || O.type === "Property" && !O.method && O.kind === "init");
          }
          function We(O) {
            return Boolean(O.__isUsingHackPipeline);
          }
          var Xe = Symbol("ifWithoutBlockAndSameLineComment");
          function st(O) {
            return O.type === "TSAsExpression" || O.type === "TSSatisfiesExpression";
          }
          r.exports = { getFunctionParameters: ve, iterateFunctionParametersPath: ze, getCallArguments: Ye, iterateCallArgumentsPath: Se, hasRestParameter: Ce, getLeftSide: I, getLeftSidePathName: P, getParentExportDeclaration: m, getTypeScriptMappedTypeModifier: z, hasFlowAnnotationComment: E, hasFlowShorthandAnnotationComment: w, hasLeadingOwnLineComment: Z, hasNakedLeftSide: x2, hasNode: N, hasIgnoreComment: Je, hasNodeIgnoreComment: Oe, identity: H, isBinaryish: V, isCallLikeExpression: tt, isEnabledHackPipeline: We, isLineComment: D, isPrettierIgnoreComment: Ie, isCallExpression: de, isMemberExpression: ue, isExportDeclaration: T, isFlowAnnotationComment: U, isFunctionCompositionArgs: Re, isFunctionNotation: J, isFunctionOrArrowExpression: b, isGetterOrSetter: q, isJestEachTemplateLiteral: ge, isJsxNode: M, isLiteral: C, isLongCurriedCallExpression: Ne, isSimpleCallArgument: Pe, isMemberish: j, isNumericLiteral: o, isSignedNumericLiteral: d, isObjectProperty: Ve, isObjectType: S, isObjectTypePropertyAFunction: L, isSimpleType: ie, isSimpleNumber: fe, isSimpleTemplateLiteral: Fe, isStringLiteral: v, isStringPropSafeToUnquote: se, isTemplateOnItsOwnLine: we, isTestCall: K, isTheOnlyJsxElementInMarkdown: R, isTSXFile: pe, isTypeAnnotationAFunction: Q, isNextLineEmpty: nt, needsHardlineAfterDanglingComment: ke, rawText: oe, shouldPrintComma: X, isBitwiseOperator: ye, shouldFlatten: A, startsWithNoLookaheadToken: le, getPrecedence: re, hasComment: Me, getComments: ae, CommentCheckFlags: Te, markerForIfWithoutBlockAndSameLineComment: Xe, isTSTypeExpression: st };
        } }), jt = te({ "src/language-js/print/template-literal.js"(e2, r) {
          "use strict";
          ne();
          var t = lt(), { getStringWidth: s, getIndentSize: a } = Ue(), { builders: { join: n2, hardline: u, softline: i, group: l, indent: p, align: y, lineSuffixBoundary: h3, addAlignmentToDoc: g }, printer: { printDocToString: c }, utils: { mapDoc: f } } = qe(), { isBinaryish: F, isJestEachTemplateLiteral: _, isSimpleTemplateLiteral: w, hasComment: E, isMemberExpression: N, isTSTypeExpression: x2 } = Ke();
          function I(C, o, d) {
            let v = C.getValue();
            if (v.type === "TemplateLiteral" && _(v, C.getParentNode())) {
              let R = P(C, d, o);
              if (R) return R;
            }
            let b = "expressions";
            v.type === "TSTemplateLiteralType" && (b = "types");
            let B = [], k = C.map(o, b), M = w(v);
            return M && (k = k.map((R) => c(R, Object.assign(Object.assign({}, d), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), B.push(h3, "`"), C.each((R) => {
              let q = R.getName();
              if (B.push(o()), q < k.length) {
                let { tabWidth: J } = d, L = R.getValue(), Q = a(L.value.raw, J), V = k[q];
                if (!M) {
                  let Y = v[b][q];
                  (E(Y) || N(Y) || Y.type === "ConditionalExpression" || Y.type === "SequenceExpression" || x2(Y) || F(Y)) && (V = [p([i, V]), i]);
                }
                let j = Q === 0 && L.value.raw.endsWith(`
`) ? y(Number.NEGATIVE_INFINITY, V) : g(V, Q, J);
                B.push(l(["${", j, h3, "}"]));
              }
            }, "quasis"), B.push("`"), B;
          }
          function P(C, o, d) {
            let v = C.getNode(), S = v.quasis[0].value.raw.trim().split(/\s*\|\s*/);
            if (S.length > 1 || S.some((b) => b.length > 0)) {
              o.__inJestEach = true;
              let b = C.map(d, "expressions");
              o.__inJestEach = false;
              let B = [], k = b.map((L) => "${" + c(L, Object.assign(Object.assign({}, o), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), M = [{ hasLineBreak: false, cells: [] }];
              for (let L = 1; L < v.quasis.length; L++) {
                let Q = t(M), V = k[L - 1];
                Q.cells.push(V), V.includes(`
`) && (Q.hasLineBreak = true), v.quasis[L].value.raw.includes(`
`) && M.push({ hasLineBreak: false, cells: [] });
              }
              let R = Math.max(S.length, ...M.map((L) => L.cells.length)), q = Array.from({ length: R }).fill(0), J = [{ cells: S }, ...M.filter((L) => L.cells.length > 0)];
              for (let { cells: L } of J.filter((Q) => !Q.hasLineBreak)) for (let [Q, V] of L.entries()) q[Q] = Math.max(q[Q], s(V));
              return B.push(h3, "`", p([u, n2(u, J.map((L) => n2(" | ", L.cells.map((Q, V) => L.hasLineBreak ? Q : Q + " ".repeat(q[V] - s(Q))))))]), u, "`"), B;
            }
          }
          function $(C, o) {
            let d = C.getValue(), v = o();
            return E(d) && (v = l([p([i, v]), i])), ["${", v, h3, "}"];
          }
          function D(C, o) {
            return C.map((d) => $(d, o), "expressions");
          }
          function T(C, o) {
            return f(C, (d) => typeof d == "string" ? o ? d.replace(/(\\*)`/g, "$1$1\\`") : m(d) : d);
          }
          function m(C) {
            return C.replace(/([\\`]|\${)/g, "\\$1");
          }
          r.exports = { printTemplateLiteral: I, printTemplateExpressions: D, escapeTemplateCharacters: T, uncookTemplateElementValue: m };
        } }), Ym = te({ "src/language-js/embed/markdown.js"(e2, r) {
          "use strict";
          ne();
          var { builders: { indent: t, softline: s, literalline: a, dedentToRoot: n2 } } = qe(), { escapeTemplateCharacters: u } = jt();
          function i(p, y, h3) {
            let c = p.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (w, E) => "\\".repeat(E.length / 2) + "`"), f = l(c), F = f !== "";
            F && (c = c.replace(new RegExp(`^${f}`, "gm"), ""));
            let _ = u(h3(c, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
            return ["`", F ? t([s, _]) : [a, n2(_)], s, "`"];
          }
          function l(p) {
            let y = p.match(/^([^\S\n]*)\S/m);
            return y === null ? "" : y[1];
          }
          r.exports = i;
        } }), Qm = te({ "src/language-js/embed/css.js"(e2, r) {
          "use strict";
          ne();
          var { isNonEmptyArray: t } = Ue(), { builders: { indent: s, hardline: a, softline: n2 }, utils: { mapDoc: u, replaceEndOfLine: i, cleanDoc: l } } = qe(), { printTemplateExpressions: p } = jt();
          function y(c, f, F) {
            let _ = c.getValue(), w = _.quasis.map((P) => P.value.raw), E = 0, N = w.reduce((P, $, D) => D === 0 ? $ : P + "@prettier-placeholder-" + E++ + "-id" + $, ""), x2 = F(N, { parser: "scss" }, { stripTrailingHardline: true }), I = p(c, f);
            return h3(x2, _, I);
          }
          function h3(c, f, F) {
            if (f.quasis.length === 1 && !f.quasis[0].value.raw.trim()) return "``";
            let w = g(c, F);
            if (!w) throw new Error("Couldn't insert all the expressions");
            return ["`", s([a, w]), n2, "`"];
          }
          function g(c, f) {
            if (!t(f)) return c;
            let F = 0, _ = u(l(c), (w) => typeof w != "string" || !w.includes("@prettier-placeholder") ? w : w.split(/@prettier-placeholder-(\d+)-id/).map((E, N) => N % 2 === 0 ? i(E) : (F++, f[E])));
            return f.length === F ? _ : null;
          }
          r.exports = y;
        } }), Zm = te({ "src/language-js/embed/graphql.js"(e2, r) {
          "use strict";
          ne();
          var { builders: { indent: t, join: s, hardline: a } } = qe(), { escapeTemplateCharacters: n2, printTemplateExpressions: u } = jt();
          function i(p, y, h3) {
            let g = p.getValue(), c = g.quasis.length;
            if (c === 1 && g.quasis[0].value.raw.trim() === "") return "``";
            let f = u(p, y), F = [];
            for (let _ = 0; _ < c; _++) {
              let w = g.quasis[_], E = _ === 0, N = _ === c - 1, x2 = w.value.cooked, I = x2.split(`
`), P = I.length, $ = f[_], D = P > 2 && I[0].trim() === "" && I[1].trim() === "", T = P > 2 && I[P - 1].trim() === "" && I[P - 2].trim() === "", m = I.every((o) => /^\s*(?:#[^\n\r]*)?$/.test(o));
              if (!N && /#[^\n\r]*$/.test(I[P - 1])) return null;
              let C = null;
              m ? C = l(I) : C = h3(x2, { parser: "graphql" }, { stripTrailingHardline: true }), C ? (C = n2(C, false), !E && D && F.push(""), F.push(C), !N && T && F.push("")) : !E && !N && D && F.push(""), $ && F.push($);
            }
            return ["`", t([a, s(a, F)]), a, "`"];
          }
          function l(p) {
            let y = [], h3 = false, g = p.map((c) => c.trim());
            for (let [c, f] of g.entries()) f !== "" && (g[c - 1] === "" && h3 ? y.push([a, f]) : y.push(f), h3 = true);
            return y.length === 0 ? null : s(a, y);
          }
          r.exports = i;
        } }), ed = te({ "src/language-js/embed/html.js"(e2, r) {
          "use strict";
          ne();
          var { builders: { indent: t, line: s, hardline: a, group: n2 }, utils: { mapDoc: u } } = qe(), { printTemplateExpressions: i, uncookTemplateElementValue: l } = jt(), p = 0;
          function y(h3, g, c, f, F) {
            let { parser: _ } = F, w = h3.getValue(), E = p;
            p = p + 1 >>> 0;
            let N = (d) => `PRETTIER_HTML_PLACEHOLDER_${d}_${E}_IN_JS`, x2 = w.quasis.map((d, v, S) => v === S.length - 1 ? d.value.cooked : d.value.cooked + N(v)).join(""), I = i(h3, g);
            if (I.length === 0 && x2.trim().length === 0) return "``";
            let P = new RegExp(N("(\\d+)"), "g"), $ = 0, D = c(x2, { parser: _, __onHtmlRoot(d) {
              $ = d.children.length;
            } }, { stripTrailingHardline: true }), T = u(D, (d) => {
              if (typeof d != "string") return d;
              let v = [], S = d.split(P);
              for (let b = 0; b < S.length; b++) {
                let B = S[b];
                if (b % 2 === 0) {
                  B && (B = l(B), f.__embeddedInHtml && (B = B.replace(/<\/(script)\b/gi, "<\\/$1")), v.push(B));
                  continue;
                }
                let k = Number(B);
                v.push(I[k]);
              }
              return v;
            }), m = /^\s/.test(x2) ? " " : "", C = /\s$/.test(x2) ? " " : "", o = f.htmlWhitespaceSensitivity === "ignore" ? a : m && C ? s : null;
            return n2(o ? ["`", t([o, n2(T)]), o, "`"] : ["`", m, $ > 1 ? t(n2(T)) : n2(T), C, "`"]);
          }
          r.exports = y;
        } }), td2 = te({ "src/language-js/embed.js"(e2, r) {
          "use strict";
          ne();
          var { hasComment: t, CommentCheckFlags: s, isObjectProperty: a } = Ke(), n2 = Ym(), u = Qm(), i = Zm(), l = ed();
          function p(D) {
            if (g(D) || _(D) || w(D) || c(D)) return "css";
            if (x2(D)) return "graphql";
            if (P(D)) return "html";
            if (f(D)) return "angular";
            if (h3(D)) return "markdown";
          }
          function y(D, T, m, C) {
            let o = D.getValue();
            if (o.type !== "TemplateLiteral" || $(o)) return;
            let d = p(D);
            if (d) {
              if (d === "markdown") return n2(D, T, m);
              if (d === "css") return u(D, T, m);
              if (d === "graphql") return i(D, T, m);
              if (d === "html" || d === "angular") return l(D, T, m, C, { parser: d });
            }
          }
          function h3(D) {
            let T = D.getValue(), m = D.getParentNode();
            return m && m.type === "TaggedTemplateExpression" && T.quasis.length === 1 && m.tag.type === "Identifier" && (m.tag.name === "md" || m.tag.name === "markdown");
          }
          function g(D) {
            let T = D.getValue(), m = D.getParentNode(), C = D.getParentNode(1);
            return C && T.quasis && m.type === "JSXExpressionContainer" && C.type === "JSXElement" && C.openingElement.name.name === "style" && C.openingElement.attributes.some((o) => o.name.name === "jsx") || m && m.type === "TaggedTemplateExpression" && m.tag.type === "Identifier" && m.tag.name === "css" || m && m.type === "TaggedTemplateExpression" && m.tag.type === "MemberExpression" && m.tag.object.name === "css" && (m.tag.property.name === "global" || m.tag.property.name === "resolve");
          }
          function c(D) {
            return D.match((T) => T.type === "TemplateLiteral", (T, m) => T.type === "ArrayExpression" && m === "elements", (T, m) => a(T) && T.key.type === "Identifier" && T.key.name === "styles" && m === "value", ...F);
          }
          function f(D) {
            return D.match((T) => T.type === "TemplateLiteral", (T, m) => a(T) && T.key.type === "Identifier" && T.key.name === "template" && m === "value", ...F);
          }
          var F = [(D, T) => D.type === "ObjectExpression" && T === "properties", (D, T) => D.type === "CallExpression" && D.callee.type === "Identifier" && D.callee.name === "Component" && T === "arguments", (D, T) => D.type === "Decorator" && T === "expression"];
          function _(D) {
            let T = D.getParentNode();
            if (!T || T.type !== "TaggedTemplateExpression") return false;
            let m = T.tag.type === "ParenthesizedExpression" ? T.tag.expression : T.tag;
            switch (m.type) {
              case "MemberExpression":
                return E(m.object) || N(m);
              case "CallExpression":
                return E(m.callee) || m.callee.type === "MemberExpression" && (m.callee.object.type === "MemberExpression" && (E(m.callee.object.object) || N(m.callee.object)) || m.callee.object.type === "CallExpression" && E(m.callee.object.callee));
              case "Identifier":
                return m.name === "css";
              default:
                return false;
            }
          }
          function w(D) {
            let T = D.getParentNode(), m = D.getParentNode(1);
            return m && T.type === "JSXExpressionContainer" && m.type === "JSXAttribute" && m.name.type === "JSXIdentifier" && m.name.name === "css";
          }
          function E(D) {
            return D.type === "Identifier" && D.name === "styled";
          }
          function N(D) {
            return /^[A-Z]/.test(D.object.name) && D.property.name === "extend";
          }
          function x2(D) {
            let T = D.getValue(), m = D.getParentNode();
            return I(T, "GraphQL") || m && (m.type === "TaggedTemplateExpression" && (m.tag.type === "MemberExpression" && m.tag.object.name === "graphql" && m.tag.property.name === "experimental" || m.tag.type === "Identifier" && (m.tag.name === "gql" || m.tag.name === "graphql")) || m.type === "CallExpression" && m.callee.type === "Identifier" && m.callee.name === "graphql");
          }
          function I(D, T) {
            return t(D, s.Block | s.Leading, (m) => {
              let { value: C } = m;
              return C === ` ${T} `;
            });
          }
          function P(D) {
            return I(D.getValue(), "HTML") || D.match((T) => T.type === "TemplateLiteral", (T, m) => T.type === "TaggedTemplateExpression" && T.tag.type === "Identifier" && T.tag.name === "html" && m === "quasi");
          }
          function $(D) {
            let { quasis: T } = D;
            return T.some((m) => {
              let { value: { cooked: C } } = m;
              return C === null;
            });
          }
          r.exports = y;
        } }), rd = te({ "src/language-js/clean.js"(e2, r) {
          "use strict";
          ne();
          var t = Pt(), s = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), a = (u) => {
            for (let i of u.quasis) delete i.value;
          };
          function n2(u, i, l) {
            if (u.type === "Program" && delete i.sourceType, (u.type === "BigIntLiteral" || u.type === "BigIntLiteralTypeAnnotation") && i.value && (i.value = i.value.toLowerCase()), (u.type === "BigIntLiteral" || u.type === "Literal") && i.bigint && (i.bigint = i.bigint.toLowerCase()), u.type === "DecimalLiteral" && (i.value = Number(i.value)), u.type === "Literal" && i.decimal && (i.decimal = Number(i.decimal)), u.type === "EmptyStatement" || u.type === "JSXText" || u.type === "JSXExpressionContainer" && (u.expression.type === "Literal" || u.expression.type === "StringLiteral") && u.expression.value === " ") return null;
            if ((u.type === "Property" || u.type === "ObjectProperty" || u.type === "MethodDefinition" || u.type === "ClassProperty" || u.type === "ClassMethod" || u.type === "PropertyDefinition" || u.type === "TSDeclareMethod" || u.type === "TSPropertySignature" || u.type === "ObjectTypeProperty") && typeof u.key == "object" && u.key && (u.key.type === "Literal" || u.key.type === "NumericLiteral" || u.key.type === "StringLiteral" || u.key.type === "Identifier") && delete i.key, u.type === "JSXElement" && u.openingElement.name.name === "style" && u.openingElement.attributes.some((h3) => h3.name.name === "jsx")) for (let { type: h3, expression: g } of i.children) h3 === "JSXExpressionContainer" && g.type === "TemplateLiteral" && a(g);
            u.type === "JSXAttribute" && u.name.name === "css" && u.value.type === "JSXExpressionContainer" && u.value.expression.type === "TemplateLiteral" && a(i.value.expression), u.type === "JSXAttribute" && u.value && u.value.type === "Literal" && /["']|&quot;|&apos;/.test(u.value.value) && (i.value.value = i.value.value.replace(/["']|&quot;|&apos;/g, '"'));
            let p = u.expression || u.callee;
            if (u.type === "Decorator" && p.type === "CallExpression" && p.callee.name === "Component" && p.arguments.length === 1) {
              let h3 = u.expression.arguments[0].properties;
              for (let [g, c] of i.expression.arguments[0].properties.entries()) switch (h3[g].key.name) {
                case "styles":
                  c.value.type === "ArrayExpression" && a(c.value.elements[0]);
                  break;
                case "template":
                  c.value.type === "TemplateLiteral" && a(c.value);
                  break;
              }
            }
            if (u.type === "TaggedTemplateExpression" && (u.tag.type === "MemberExpression" || u.tag.type === "Identifier" && (u.tag.name === "gql" || u.tag.name === "graphql" || u.tag.name === "css" || u.tag.name === "md" || u.tag.name === "markdown" || u.tag.name === "html") || u.tag.type === "CallExpression") && a(i.quasi), u.type === "TemplateLiteral") {
              var y;
              (((y = u.leadingComments) === null || y === void 0 ? void 0 : y.some((g) => t(g) && ["GraphQL", "HTML"].some((c) => g.value === ` ${c} `))) || l.type === "CallExpression" && l.callee.name === "graphql" || !u.leadingComments) && a(i);
            }
            if (u.type === "InterpreterDirective" && (i.value = i.value.trimEnd()), (u.type === "TSIntersectionType" || u.type === "TSUnionType") && u.types.length === 1) return i.types[0];
          }
          n2.ignoredProperties = s, r.exports = n2;
        } }), io = {};
        Kt(io, { EOL: () => Wn, arch: () => nd, cpus: () => Do, default: () => vo, endianness: () => ao, freemem: () => po, getNetworkInterfaces: () => ho, hostname: () => oo, loadavg: () => lo, networkInterfaces: () => yo, platform: () => ud, release: () => go, tmpDir: () => $n, tmpdir: () => Vn, totalmem: () => fo, type: () => mo, uptime: () => co });
        function ao() {
          if (typeof Tr > "u") {
            var e2 = new ArrayBuffer(2), r = new Uint8Array(e2), t = new Uint16Array(e2);
            if (r[0] = 1, r[1] = 2, t[0] === 258) Tr = "BE";
            else if (t[0] === 513) Tr = "LE";
            else throw new Error("unable to figure out endianess");
          }
          return Tr;
        }
        function oo() {
          return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
        }
        function lo() {
          return [];
        }
        function co() {
          return 0;
        }
        function po() {
          return Number.MAX_VALUE;
        }
        function fo() {
          return Number.MAX_VALUE;
        }
        function Do() {
          return [];
        }
        function mo() {
          return "Browser";
        }
        function go() {
          return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
        }
        function yo() {
        }
        function ho() {
        }
        function nd() {
          return "javascript";
        }
        function ud() {
          return "browser";
        }
        function $n() {
          return "/tmp";
        }
        var Tr, Vn, Wn, vo, sd = ht({ "node-modules-polyfills:os"() {
          ne(), Vn = $n, Wn = `
`, vo = { EOL: Wn, tmpdir: Vn, tmpDir: $n, networkInterfaces: yo, getNetworkInterfaces: ho, release: go, type: mo, cpus: Do, totalmem: fo, freemem: po, uptime: co, loadavg: lo, hostname: oo, endianness: ao };
        } }), id = te({ "node-modules-polyfills-commonjs:os"(e2, r) {
          ne();
          var t = (sd(), ft(io));
          if (t && t.default) {
            r.exports = t.default;
            for (let s in t) r.exports[s] = t[s];
          } else t && (r.exports = t);
        } }), ad = te({ "node_modules/detect-newline/index.js"(e2, r) {
          "use strict";
          ne();
          var t = (s) => {
            if (typeof s != "string") throw new TypeError("Expected a string");
            let a = s.match(/(?:\r?\n)/g) || [];
            if (a.length === 0) return;
            let n2 = a.filter((i) => i === `\r
`).length, u = a.length - n2;
            return n2 > u ? `\r
` : `
`;
          };
          r.exports = t, r.exports.graceful = (s) => typeof s == "string" && t(s) || `
`;
        } }), od = te({ "node_modules/jest-docblock/build/index.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true }), e2.extract = c, e2.parse = F, e2.parseWithComments = _, e2.print = w, e2.strip = f;
          function r() {
            let N = id();
            return r = function() {
              return N;
            }, N;
          }
          function t() {
            let N = s(ad());
            return t = function() {
              return N;
            }, N;
          }
          function s(N) {
            return N && N.__esModule ? N : { default: N };
          }
          var a = /\*\/$/, n2 = /^\/\*\*?/, u = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i = /(^|\s+)\/\/([^\r\n]*)/g, l = /^(\r?\n)+/, p = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, y = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, h3 = /(\r?\n|^) *\* ?/g, g = [];
          function c(N) {
            let x2 = N.match(u);
            return x2 ? x2[0].trimLeft() : "";
          }
          function f(N) {
            let x2 = N.match(u);
            return x2 && x2[0] ? N.substring(x2[0].length) : N;
          }
          function F(N) {
            return _(N).pragmas;
          }
          function _(N) {
            let x2 = (0, t().default)(N) || r().EOL;
            N = N.replace(n2, "").replace(a, "").replace(h3, "$1");
            let I = "";
            for (; I !== N; ) I = N, N = N.replace(p, `${x2}$1 $2${x2}`);
            N = N.replace(l, "").trimRight();
            let P = /* @__PURE__ */ Object.create(null), $ = N.replace(y, "").replace(l, "").trimRight(), D;
            for (; D = y.exec(N); ) {
              let T = D[2].replace(i, "");
              typeof P[D[1]] == "string" || Array.isArray(P[D[1]]) ? P[D[1]] = g.concat(P[D[1]], T) : P[D[1]] = T;
            }
            return { comments: $, pragmas: P };
          }
          function w(N) {
            let { comments: x2 = "", pragmas: I = {} } = N, P = (0, t().default)(x2) || r().EOL, $ = "/**", D = " *", T = " */", m = Object.keys(I), C = m.map((d) => E(d, I[d])).reduce((d, v) => d.concat(v), []).map((d) => `${D} ${d}${P}`).join("");
            if (!x2) {
              if (m.length === 0) return "";
              if (m.length === 1 && !Array.isArray(I[m[0]])) {
                let d = I[m[0]];
                return `${$} ${E(m[0], d)[0]}${T}`;
              }
            }
            let o = x2.split(P).map((d) => `${D} ${d}`).join(P) + P;
            return $ + P + (x2 ? o : "") + (x2 && m.length ? D + P : "") + C + T;
          }
          function E(N, x2) {
            return g.concat(x2).map((I) => `@${N} ${I}`.trim());
          }
        } }), ld = te({ "src/language-js/utils/get-shebang.js"(e2, r) {
          "use strict";
          ne();
          function t(s) {
            if (!s.startsWith("#!")) return "";
            let a = s.indexOf(`
`);
            return a === -1 ? s : s.slice(0, a);
          }
          r.exports = t;
        } }), Co = te({ "src/language-js/pragma.js"(e2, r) {
          "use strict";
          ne();
          var { parseWithComments: t, strip: s, extract: a, print: n2 } = od(), { normalizeEndOfLine: u } = Jn(), i = ld();
          function l(h3) {
            let g = i(h3);
            g && (h3 = h3.slice(g.length + 1));
            let c = a(h3), { pragmas: f, comments: F } = t(c);
            return { shebang: g, text: h3, pragmas: f, comments: F };
          }
          function p(h3) {
            let g = Object.keys(l(h3).pragmas);
            return g.includes("prettier") || g.includes("format");
          }
          function y(h3) {
            let { shebang: g, text: c, pragmas: f, comments: F } = l(h3), _ = s(c), w = n2({ pragmas: Object.assign({ format: "" }, f), comments: F.trimStart() });
            return (g ? `${g}
` : "") + u(w) + (_.startsWith(`
`) ? `
` : `

`) + _;
          }
          r.exports = { hasPragma: p, insertPragma: y };
        } }), cd = te({ "src/language-js/utils/is-type-cast-comment.js"(e2, r) {
          "use strict";
          ne();
          var t = Pt();
          function s(a) {
            return t(a) && a.value[0] === "*" && /@(?:type|satisfies)\b/.test(a.value);
          }
          r.exports = s;
        } }), Eo = te({ "src/language-js/comments.js"(e2, r) {
          "use strict";
          ne();
          var { getLast: t, hasNewline: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: a, getNextNonSpaceNonCommentCharacter: n2, hasNewlineInRange: u, addLeadingComment: i, addTrailingComment: l, addDanglingComment: p, getNextNonSpaceNonCommentCharacterIndex: y, isNonEmptyArray: h3 } = Ue(), { getFunctionParameters: g, isPrettierIgnoreComment: c, isJsxNode: f, hasFlowShorthandAnnotationComment: F, hasFlowAnnotationComment: _, hasIgnoreComment: w, isCallLikeExpression: E, getCallArguments: N, isCallExpression: x2, isMemberExpression: I, isObjectProperty: P, isLineComment: $, getComments: D, CommentCheckFlags: T, markerForIfWithoutBlockAndSameLineComment: m } = Ke(), { locStart: C, locEnd: o } = ut(), d = Pt(), v = cd();
          function S(De) {
            return [H, Fe, Q, q, J, L, ie, he, se, ge, we, ke, ce, z, U].some((A) => A(De));
          }
          function b(De) {
            return [R, Fe, V, we, q, J, L, ie, z, Z, fe, ge, Pe, U, X].some((A) => A(De));
          }
          function B(De) {
            return [H, q, J, j, ue, ce, ge, de, K, pe, U, oe].some((A) => A(De));
          }
          function k(De, A) {
            let G = (De.body || De.properties).find((re) => {
              let { type: ye } = re;
              return ye !== "EmptyStatement";
            });
            G ? i(G, A) : p(De, A);
          }
          function M(De, A) {
            De.type === "BlockStatement" ? k(De, A) : i(De, A);
          }
          function R(De) {
            let { comment: A, followingNode: G } = De;
            return G && v(A) ? (i(G, A), true) : false;
          }
          function q(De) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye, text: Ce } = De;
            if ((re == null ? void 0 : re.type) !== "IfStatement" || !ye) return false;
            if (n2(Ce, A, o) === ")") return l(G, A), true;
            if (G === re.consequent && ye === re.alternate) {
              if (G.type === "BlockStatement") l(G, A);
              else {
                let ve = A.type === "SingleLine" || A.loc.start.line === A.loc.end.line, ze = A.loc.start.line === G.loc.start.line;
                ve && ze ? p(G, A, m) : p(re, A);
              }
              return true;
            }
            return ye.type === "BlockStatement" ? (k(ye, A), true) : ye.type === "IfStatement" ? (M(ye.consequent, A), true) : re.consequent === ye ? (i(ye, A), true) : false;
          }
          function J(De) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye, text: Ce } = De;
            return (re == null ? void 0 : re.type) !== "WhileStatement" || !ye ? false : n2(Ce, A, o) === ")" ? (l(G, A), true) : ye.type === "BlockStatement" ? (k(ye, A), true) : re.body === ye ? (i(ye, A), true) : false;
          }
          function L(De) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye } = De;
            return (re == null ? void 0 : re.type) !== "TryStatement" && (re == null ? void 0 : re.type) !== "CatchClause" || !ye ? false : re.type === "CatchClause" && G ? (l(G, A), true) : ye.type === "BlockStatement" ? (k(ye, A), true) : ye.type === "TryStatement" ? (M(ye.finalizer, A), true) : ye.type === "CatchClause" ? (M(ye.body, A), true) : false;
          }
          function Q(De) {
            let { comment: A, enclosingNode: G, followingNode: re } = De;
            return I(G) && (re == null ? void 0 : re.type) === "Identifier" ? (i(G, A), true) : false;
          }
          function V(De) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye, text: Ce } = De, Be = G && !u(Ce, o(G), C(A));
            return (!G || !Be) && ((re == null ? void 0 : re.type) === "ConditionalExpression" || (re == null ? void 0 : re.type) === "TSConditionalType") && ye ? (i(ye, A), true) : false;
          }
          function j(De) {
            let { comment: A, precedingNode: G, enclosingNode: re } = De;
            return P(re) && re.shorthand && re.key === G && re.value.type === "AssignmentPattern" ? (l(re.value.left, A), true) : false;
          }
          var Y = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
          function ie(De) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye } = De;
            if (Y.has(re == null ? void 0 : re.type)) {
              if (h3(re.decorators) && !(ye && ye.type === "Decorator")) return l(t(re.decorators), A), true;
              if (re.body && ye === re.body) return k(re.body, A), true;
              if (ye) {
                if (re.superClass && ye === re.superClass && G && (G === re.id || G === re.typeParameters)) return l(G, A), true;
                for (let Ce of ["implements", "extends", "mixins"]) if (re[Ce] && ye === re[Ce][0]) return G && (G === re.id || G === re.typeParameters || G === re.superClass) ? l(G, A) : p(re, A, Ce), true;
              }
            }
            return false;
          }
          var ee = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty"]);
          function ce(De) {
            let { comment: A, precedingNode: G, enclosingNode: re, text: ye } = De;
            return re && G && n2(ye, A, o) === "(" && (re.type === "Property" || re.type === "TSDeclareMethod" || re.type === "TSAbstractMethodDefinition") && G.type === "Identifier" && re.key === G && n2(ye, G, o) !== ":" || (G == null ? void 0 : G.type) === "Decorator" && ee.has(re == null ? void 0 : re.type) ? (l(G, A), true) : false;
          }
          var W = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
          function K(De) {
            let { comment: A, precedingNode: G, enclosingNode: re, text: ye } = De;
            return n2(ye, A, o) !== "(" ? false : G && W.has(re == null ? void 0 : re.type) ? (l(G, A), true) : false;
          }
          function de(De) {
            let { comment: A, enclosingNode: G, text: re } = De;
            if ((G == null ? void 0 : G.type) !== "ArrowFunctionExpression") return false;
            let ye = y(re, A, o);
            return ye !== false && re.slice(ye, ye + 2) === "=>" ? (p(G, A), true) : false;
          }
          function ue(De) {
            let { comment: A, enclosingNode: G, text: re } = De;
            return n2(re, A, o) !== ")" ? false : G && (le(G) && g(G).length === 0 || E(G) && N(G).length === 0) ? (p(G, A), true) : ((G == null ? void 0 : G.type) === "MethodDefinition" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && g(G.value).length === 0 ? (p(G.value, A), true) : false;
          }
          function Fe(De) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye, text: Ce } = De;
            if ((G == null ? void 0 : G.type) === "FunctionTypeParam" && (re == null ? void 0 : re.type) === "FunctionTypeAnnotation" && (ye == null ? void 0 : ye.type) !== "FunctionTypeParam" || ((G == null ? void 0 : G.type) === "Identifier" || (G == null ? void 0 : G.type) === "AssignmentPattern") && re && le(re) && n2(Ce, A, o) === ")") return l(G, A), true;
            if ((re == null ? void 0 : re.type) === "FunctionDeclaration" && (ye == null ? void 0 : ye.type) === "BlockStatement") {
              let Be = (() => {
                let ve = g(re);
                if (ve.length > 0) return a(Ce, o(t(ve)));
                let ze = a(Ce, o(re.id));
                return ze !== false && a(Ce, ze + 1);
              })();
              if (C(A) > Be) return k(ye, A), true;
            }
            return false;
          }
          function z(De) {
            let { comment: A, enclosingNode: G } = De;
            return (G == null ? void 0 : G.type) === "LabeledStatement" ? (i(G, A), true) : false;
          }
          function U(De) {
            let { comment: A, enclosingNode: G } = De;
            return ((G == null ? void 0 : G.type) === "ContinueStatement" || (G == null ? void 0 : G.type) === "BreakStatement") && !G.label ? (l(G, A), true) : false;
          }
          function Z(De) {
            let { comment: A, precedingNode: G, enclosingNode: re } = De;
            return x2(re) && G && re.callee === G && re.arguments.length > 0 ? (i(re.arguments[0], A), true) : false;
          }
          function se(De) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye } = De;
            return (re == null ? void 0 : re.type) === "UnionTypeAnnotation" || (re == null ? void 0 : re.type) === "TSUnionType" ? (c(A) && (ye.prettierIgnore = true, A.unignore = true), G ? (l(G, A), true) : false) : (((ye == null ? void 0 : ye.type) === "UnionTypeAnnotation" || (ye == null ? void 0 : ye.type) === "TSUnionType") && c(A) && (ye.types[0].prettierIgnore = true, A.unignore = true), false);
          }
          function fe(De) {
            let { comment: A, enclosingNode: G } = De;
            return P(G) ? (i(G, A), true) : false;
          }
          function ge(De) {
            let { comment: A, enclosingNode: G, followingNode: re, ast: ye, isLastComment: Ce } = De;
            return ye && ye.body && ye.body.length === 0 ? (Ce ? p(ye, A) : i(ye, A), true) : (G == null ? void 0 : G.type) === "Program" && (G == null ? void 0 : G.body.length) === 0 && !h3(G.directives) ? (Ce ? p(G, A) : i(G, A), true) : (re == null ? void 0 : re.type) === "Program" && (re == null ? void 0 : re.body.length) === 0 && (G == null ? void 0 : G.type) === "ModuleExpression" ? (p(re, A), true) : false;
          }
          function he(De) {
            let { comment: A, enclosingNode: G } = De;
            return (G == null ? void 0 : G.type) === "ForInStatement" || (G == null ? void 0 : G.type) === "ForOfStatement" ? (i(G, A), true) : false;
          }
          function we(De) {
            let { comment: A, precedingNode: G, enclosingNode: re, text: ye } = De;
            if ((re == null ? void 0 : re.type) === "ImportSpecifier" || (re == null ? void 0 : re.type) === "ExportSpecifier") return i(re, A), true;
            let Ce = (G == null ? void 0 : G.type) === "ImportSpecifier" && (re == null ? void 0 : re.type) === "ImportDeclaration", Be = (G == null ? void 0 : G.type) === "ExportSpecifier" && (re == null ? void 0 : re.type) === "ExportNamedDeclaration";
            return (Ce || Be) && s(ye, o(A)) ? (l(G, A), true) : false;
          }
          function ke(De) {
            let { comment: A, enclosingNode: G } = De;
            return (G == null ? void 0 : G.type) === "AssignmentPattern" ? (i(G, A), true) : false;
          }
          var Re = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), Ne = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
          function Pe(De) {
            let { comment: A, enclosingNode: G, followingNode: re } = De;
            return Re.has(G == null ? void 0 : G.type) && re && (Ne.has(re.type) || d(A)) ? (i(re, A), true) : false;
          }
          function oe(De) {
            let { comment: A, enclosingNode: G, followingNode: re, text: ye } = De;
            return !re && ((G == null ? void 0 : G.type) === "TSMethodSignature" || (G == null ? void 0 : G.type) === "TSDeclareFunction" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && n2(ye, A, o) === ";" ? (l(G, A), true) : false;
          }
          function H(De) {
            let { comment: A, enclosingNode: G, followingNode: re } = De;
            if (c(A) && (G == null ? void 0 : G.type) === "TSMappedType" && (re == null ? void 0 : re.type) === "TSTypeParameter" && re.constraint) return G.prettierIgnore = true, A.unignore = true, true;
          }
          function pe(De) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye } = De;
            return (re == null ? void 0 : re.type) !== "TSMappedType" ? false : (ye == null ? void 0 : ye.type) === "TSTypeParameter" && ye.name ? (i(ye.name, A), true) : (G == null ? void 0 : G.type) === "TSTypeParameter" && G.constraint ? (l(G.constraint, A), true) : false;
          }
          function X(De) {
            let { comment: A, enclosingNode: G, followingNode: re } = De;
            return !G || G.type !== "SwitchCase" || G.test || !re || re !== G.consequent[0] ? false : (re.type === "BlockStatement" && $(A) ? k(re, A) : p(G, A), true);
          }
          function le(De) {
            return De.type === "ArrowFunctionExpression" || De.type === "FunctionExpression" || De.type === "FunctionDeclaration" || De.type === "ObjectMethod" || De.type === "ClassMethod" || De.type === "TSDeclareFunction" || De.type === "TSCallSignatureDeclaration" || De.type === "TSConstructSignatureDeclaration" || De.type === "TSMethodSignature" || De.type === "TSConstructorType" || De.type === "TSFunctionType" || De.type === "TSDeclareMethod";
          }
          function Ae(De, A) {
            if ((A.parser === "typescript" || A.parser === "flow" || A.parser === "acorn" || A.parser === "espree" || A.parser === "meriyah" || A.parser === "__babel_estree") && De.type === "MethodDefinition" && De.value && De.value.type === "FunctionExpression" && g(De.value).length === 0 && !De.value.returnType && !h3(De.value.typeParameters) && De.value.body) return [...De.decorators || [], De.key, De.value.body];
          }
          function Ee(De) {
            let A = De.getValue(), G = De.getParentNode(), re = (ye) => _(D(ye, T.Leading)) || _(D(ye, T.Trailing));
            return (A && (f(A) || F(A) || x2(G) && re(A)) || G && (G.type === "JSXSpreadAttribute" || G.type === "JSXSpreadChild" || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType" || (G.type === "ClassDeclaration" || G.type === "ClassExpression") && G.superClass === A)) && (!w(De) || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType");
          }
          r.exports = { handleOwnLineComment: S, handleEndOfLineComment: b, handleRemainingComment: B, getCommentChildNodes: Ae, willPrintOwnComments: Ee };
        } }), qt = te({ "src/language-js/needs-parens.js"(e2, r) {
          "use strict";
          ne();
          var t = lt(), s = Kn(), { getFunctionParameters: a, getLeftSidePathName: n2, hasFlowShorthandAnnotationComment: u, hasNakedLeftSide: i, hasNode: l, isBitwiseOperator: p, startsWithNoLookaheadToken: y, shouldFlatten: h3, getPrecedence: g, isCallExpression: c, isMemberExpression: f, isObjectProperty: F, isTSTypeExpression: _ } = Ke();
          function w(D, T) {
            let m = D.getParentNode();
            if (!m) return false;
            let C = D.getName(), o = D.getNode();
            if (T.__isInHtmlInterpolation && !T.bracketSpacing && I(o) && P(D)) return true;
            if (E(o)) return false;
            if (T.parser !== "flow" && u(D.getValue())) return true;
            if (o.type === "Identifier") {
              if (o.extra && o.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(o.name) || C === "left" && (o.name === "async" && !m.await || o.name === "let") && m.type === "ForOfStatement") return true;
              if (o.name === "let") {
                var d;
                let S = (d = D.findAncestor((b) => b.type === "ForOfStatement")) === null || d === void 0 ? void 0 : d.left;
                if (S && y(S, (b) => b === o)) return true;
              }
              if (C === "object" && o.name === "let" && m.type === "MemberExpression" && m.computed && !m.optional) {
                let S = D.findAncestor((B) => B.type === "ExpressionStatement" || B.type === "ForStatement" || B.type === "ForInStatement"), b = S ? S.type === "ExpressionStatement" ? S.expression : S.type === "ForStatement" ? S.init : S.left : void 0;
                if (b && y(b, (B) => B === o)) return true;
              }
              return false;
            }
            if (o.type === "ObjectExpression" || o.type === "FunctionExpression" || o.type === "ClassExpression" || o.type === "DoExpression") {
              var v;
              let S = (v = D.findAncestor((b) => b.type === "ExpressionStatement")) === null || v === void 0 ? void 0 : v.expression;
              if (S && y(S, (b) => b === o)) return true;
            }
            switch (m.type) {
              case "ParenthesizedExpression":
                return false;
              case "ClassDeclaration":
              case "ClassExpression": {
                if (C === "superClass" && (o.type === "ArrowFunctionExpression" || o.type === "AssignmentExpression" || o.type === "AwaitExpression" || o.type === "BinaryExpression" || o.type === "ConditionalExpression" || o.type === "LogicalExpression" || o.type === "NewExpression" || o.type === "ObjectExpression" || o.type === "SequenceExpression" || o.type === "TaggedTemplateExpression" || o.type === "UnaryExpression" || o.type === "UpdateExpression" || o.type === "YieldExpression" || o.type === "TSNonNullExpression")) return true;
                break;
              }
              case "ExportDefaultDeclaration":
                return $(D, T) || o.type === "SequenceExpression";
              case "Decorator": {
                if (C === "expression") {
                  if (f(o) && o.computed) return true;
                  let S = false, b = false, B = o;
                  for (; B; ) switch (B.type) {
                    case "MemberExpression":
                      b = true, B = B.object;
                      break;
                    case "CallExpression":
                      if (b || S) return T.parser !== "typescript";
                      S = true, B = B.callee;
                      break;
                    case "Identifier":
                      return false;
                    case "TaggedTemplateExpression":
                      return T.parser !== "typescript";
                    default:
                      return true;
                  }
                  return true;
                }
                break;
              }
              case "ArrowFunctionExpression": {
                if (C === "body" && o.type !== "SequenceExpression" && y(o, (S) => S.type === "ObjectExpression")) return true;
                break;
              }
            }
            switch (o.type) {
              case "UpdateExpression":
                if (m.type === "UnaryExpression") return o.prefix && (o.operator === "++" && m.operator === "+" || o.operator === "--" && m.operator === "-");
              case "UnaryExpression":
                switch (m.type) {
                  case "UnaryExpression":
                    return o.operator === m.operator && (o.operator === "+" || o.operator === "-");
                  case "BindExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C === "object";
                  case "TaggedTemplateExpression":
                    return true;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "BinaryExpression":
                    return C === "left" && m.operator === "**";
                  case "TSNonNullExpression":
                    return true;
                  default:
                    return false;
                }
              case "BinaryExpression": {
                if (m.type === "UpdateExpression" || o.operator === "in" && N(D)) return true;
                if (o.operator === "|>" && o.extra && o.extra.parenthesized) {
                  let S = D.getParentNode(1);
                  if (S.type === "BinaryExpression" && S.operator === "|>") return true;
                }
              }
              case "TSTypeAssertion":
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "LogicalExpression":
                switch (m.type) {
                  case "TSSatisfiesExpression":
                  case "TSAsExpression":
                    return !_(o);
                  case "ConditionalExpression":
                    return _(o);
                  case "CallExpression":
                  case "NewExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "ClassExpression":
                  case "ClassDeclaration":
                    return C === "superClass";
                  case "TSTypeAssertion":
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "JSXSpreadAttribute":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BindExpression":
                  case "AwaitExpression":
                  case "TSNonNullExpression":
                  case "UpdateExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C === "object";
                  case "AssignmentExpression":
                  case "AssignmentPattern":
                    return C === "left" && (o.type === "TSTypeAssertion" || _(o));
                  case "LogicalExpression":
                    if (o.type === "LogicalExpression") return m.operator !== o.operator;
                  case "BinaryExpression": {
                    let { operator: S, type: b } = o;
                    if (!S && b !== "TSTypeAssertion") return true;
                    let B = g(S), k = m.operator, M = g(k);
                    return M > B || C === "right" && M === B || M === B && !h3(k, S) ? true : M < B && S === "%" ? k === "+" || k === "-" : !!p(k);
                  }
                  default:
                    return false;
                }
              case "SequenceExpression":
                switch (m.type) {
                  case "ReturnStatement":
                    return false;
                  case "ForStatement":
                    return false;
                  case "ExpressionStatement":
                    return C !== "expression";
                  case "ArrowFunctionExpression":
                    return C !== "body";
                  default:
                    return true;
                }
              case "YieldExpression":
                if (m.type === "UnaryExpression" || m.type === "AwaitExpression" || _(m) || m.type === "TSNonNullExpression") return true;
              case "AwaitExpression":
                switch (m.type) {
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "LogicalExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                  case "BindExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C === "object";
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "ConditionalExpression":
                    return C === "test";
                  case "BinaryExpression":
                    return !(!o.argument && m.operator === "|>");
                  default:
                    return false;
                }
              case "TSConditionalType":
              case "TSFunctionType":
              case "TSConstructorType":
                if (C === "extendsType" && m.type === "TSConditionalType") {
                  if (o.type === "TSConditionalType") return true;
                  let { typeAnnotation: S } = o.returnType || o.typeAnnotation;
                  if (S.type === "TSTypePredicate" && S.typeAnnotation && (S = S.typeAnnotation.typeAnnotation), S.type === "TSInferType" && S.typeParameter.constraint) return true;
                }
                if (C === "checkType" && m.type === "TSConditionalType") return true;
              case "TSUnionType":
              case "TSIntersectionType":
                if ((m.type === "TSUnionType" || m.type === "TSIntersectionType") && m.types.length > 1 && (!o.types || o.types.length > 1)) return true;
              case "TSInferType":
                if (o.type === "TSInferType" && m.type === "TSRestType") return false;
              case "TSTypeOperator":
                return m.type === "TSArrayType" || m.type === "TSOptionalType" || m.type === "TSRestType" || C === "objectType" && m.type === "TSIndexedAccessType" || m.type === "TSTypeOperator" || m.type === "TSTypeAnnotation" && D.getParentNode(1).type.startsWith("TSJSDoc");
              case "TSTypeQuery":
                return C === "objectType" && m.type === "TSIndexedAccessType" || C === "elementType" && m.type === "TSArrayType";
              case "TypeofTypeAnnotation":
                return C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType") || C === "elementType" && m.type === "ArrayTypeAnnotation";
              case "ArrayTypeAnnotation":
                return m.type === "NullableTypeAnnotation";
              case "IntersectionTypeAnnotation":
              case "UnionTypeAnnotation":
                return m.type === "ArrayTypeAnnotation" || m.type === "NullableTypeAnnotation" || m.type === "IntersectionTypeAnnotation" || m.type === "UnionTypeAnnotation" || C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
              case "NullableTypeAnnotation":
                return m.type === "ArrayTypeAnnotation" || C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
              case "FunctionTypeAnnotation": {
                let S = m.type === "NullableTypeAnnotation" ? D.getParentNode(1) : m;
                return S.type === "UnionTypeAnnotation" || S.type === "IntersectionTypeAnnotation" || S.type === "ArrayTypeAnnotation" || C === "objectType" && (S.type === "IndexedAccessType" || S.type === "OptionalIndexedAccessType") || S.type === "NullableTypeAnnotation" || m.type === "FunctionTypeParam" && m.name === null && a(o).some((b) => b.typeAnnotation && b.typeAnnotation.type === "NullableTypeAnnotation");
              }
              case "OptionalIndexedAccessType":
                return C === "objectType" && m.type === "IndexedAccessType";
              case "StringLiteral":
              case "NumericLiteral":
              case "Literal":
                if (typeof o.value == "string" && m.type === "ExpressionStatement" && !m.directive) {
                  let S = D.getParentNode(1);
                  return S.type === "Program" || S.type === "BlockStatement";
                }
                return C === "object" && m.type === "MemberExpression" && typeof o.value == "number";
              case "AssignmentExpression": {
                let S = D.getParentNode(1);
                return C === "body" && m.type === "ArrowFunctionExpression" ? true : C === "key" && (m.type === "ClassProperty" || m.type === "PropertyDefinition") && m.computed || (C === "init" || C === "update") && m.type === "ForStatement" ? false : m.type === "ExpressionStatement" ? o.left.type === "ObjectPattern" : !(C === "key" && m.type === "TSPropertySignature" || m.type === "AssignmentExpression" || m.type === "SequenceExpression" && S && S.type === "ForStatement" && (S.init === m || S.update === m) || C === "value" && m.type === "Property" && S && S.type === "ObjectPattern" && S.properties.includes(m) || m.type === "NGChainedExpression");
              }
              case "ConditionalExpression":
                switch (m.type) {
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BinaryExpression":
                  case "LogicalExpression":
                  case "NGPipeExpression":
                  case "ExportDefaultDeclaration":
                  case "AwaitExpression":
                  case "JSXSpreadAttribute":
                  case "TSTypeAssertion":
                  case "TypeCastExpression":
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                    return true;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "ConditionalExpression":
                    return C === "test";
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C === "object";
                  default:
                    return false;
                }
              case "FunctionExpression":
                switch (m.type) {
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "TaggedTemplateExpression":
                    return true;
                  default:
                    return false;
                }
              case "ArrowFunctionExpression":
                switch (m.type) {
                  case "BinaryExpression":
                    return m.operator !== "|>" || o.extra && o.extra.parenthesized;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C === "object";
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                  case "BindExpression":
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "LogicalExpression":
                  case "AwaitExpression":
                  case "TSTypeAssertion":
                    return true;
                  case "ConditionalExpression":
                    return C === "test";
                  default:
                    return false;
                }
              case "ClassExpression":
                if (s(o.decorators)) return true;
                switch (m.type) {
                  case "NewExpression":
                    return C === "callee";
                  default:
                    return false;
                }
              case "OptionalMemberExpression":
              case "OptionalCallExpression": {
                let S = D.getParentNode(1);
                if (C === "object" && m.type === "MemberExpression" || C === "callee" && (m.type === "CallExpression" || m.type === "NewExpression") || m.type === "TSNonNullExpression" && S.type === "MemberExpression" && S.object === m) return true;
              }
              case "CallExpression":
              case "MemberExpression":
              case "TaggedTemplateExpression":
              case "TSNonNullExpression":
                if (C === "callee" && (m.type === "BindExpression" || m.type === "NewExpression")) {
                  let S = o;
                  for (; S; ) switch (S.type) {
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return true;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                    case "BindExpression":
                      S = S.object;
                      break;
                    case "TaggedTemplateExpression":
                      S = S.tag;
                      break;
                    case "TSNonNullExpression":
                      S = S.expression;
                      break;
                    default:
                      return false;
                  }
                }
                return false;
              case "BindExpression":
                return C === "callee" && (m.type === "BindExpression" || m.type === "NewExpression") || C === "object" && f(m);
              case "NGPipeExpression":
                return !(m.type === "NGRoot" || m.type === "NGMicrosyntaxExpression" || m.type === "ObjectProperty" && !(o.extra && o.extra.parenthesized) || m.type === "ArrayExpression" || c(m) && m.arguments[C] === o || C === "right" && m.type === "NGPipeExpression" || C === "property" && m.type === "MemberExpression" || m.type === "AssignmentExpression");
              case "JSXFragment":
              case "JSXElement":
                return C === "callee" || C === "left" && m.type === "BinaryExpression" && m.operator === "<" || m.type !== "ArrayExpression" && m.type !== "ArrowFunctionExpression" && m.type !== "AssignmentExpression" && m.type !== "AssignmentPattern" && m.type !== "BinaryExpression" && m.type !== "NewExpression" && m.type !== "ConditionalExpression" && m.type !== "ExpressionStatement" && m.type !== "JsExpressionRoot" && m.type !== "JSXAttribute" && m.type !== "JSXElement" && m.type !== "JSXExpressionContainer" && m.type !== "JSXFragment" && m.type !== "LogicalExpression" && !c(m) && !F(m) && m.type !== "ReturnStatement" && m.type !== "ThrowStatement" && m.type !== "TypeCastExpression" && m.type !== "VariableDeclarator" && m.type !== "YieldExpression";
              case "TypeAnnotation":
                return C === "returnType" && m.type === "ArrowFunctionExpression" && x2(o);
            }
            return false;
          }
          function E(D) {
            return D.type === "BlockStatement" || D.type === "BreakStatement" || D.type === "ClassBody" || D.type === "ClassDeclaration" || D.type === "ClassMethod" || D.type === "ClassProperty" || D.type === "PropertyDefinition" || D.type === "ClassPrivateProperty" || D.type === "ContinueStatement" || D.type === "DebuggerStatement" || D.type === "DeclareClass" || D.type === "DeclareExportAllDeclaration" || D.type === "DeclareExportDeclaration" || D.type === "DeclareFunction" || D.type === "DeclareInterface" || D.type === "DeclareModule" || D.type === "DeclareModuleExports" || D.type === "DeclareVariable" || D.type === "DoWhileStatement" || D.type === "EnumDeclaration" || D.type === "ExportAllDeclaration" || D.type === "ExportDefaultDeclaration" || D.type === "ExportNamedDeclaration" || D.type === "ExpressionStatement" || D.type === "ForInStatement" || D.type === "ForOfStatement" || D.type === "ForStatement" || D.type === "FunctionDeclaration" || D.type === "IfStatement" || D.type === "ImportDeclaration" || D.type === "InterfaceDeclaration" || D.type === "LabeledStatement" || D.type === "MethodDefinition" || D.type === "ReturnStatement" || D.type === "SwitchStatement" || D.type === "ThrowStatement" || D.type === "TryStatement" || D.type === "TSDeclareFunction" || D.type === "TSEnumDeclaration" || D.type === "TSImportEqualsDeclaration" || D.type === "TSInterfaceDeclaration" || D.type === "TSModuleDeclaration" || D.type === "TSNamespaceExportDeclaration" || D.type === "TypeAlias" || D.type === "VariableDeclaration" || D.type === "WhileStatement" || D.type === "WithStatement";
          }
          function N(D) {
            let T = 0, m = D.getValue();
            for (; m; ) {
              let C = D.getParentNode(T++);
              if (C && C.type === "ForStatement" && C.init === m) return true;
              m = C;
            }
            return false;
          }
          function x2(D) {
            return l(D, (T) => T.type === "ObjectTypeAnnotation" && l(T, (m) => m.type === "FunctionTypeAnnotation" || void 0) || void 0);
          }
          function I(D) {
            switch (D.type) {
              case "ObjectExpression":
                return true;
              default:
                return false;
            }
          }
          function P(D) {
            let T = D.getValue(), m = D.getParentNode(), C = D.getName();
            switch (m.type) {
              case "NGPipeExpression":
                if (typeof C == "number" && m.arguments[C] === T && m.arguments.length - 1 === C) return D.callParent(P);
                break;
              case "ObjectProperty":
                if (C === "value") {
                  let o = D.getParentNode(1);
                  return t(o.properties) === m;
                }
                break;
              case "BinaryExpression":
              case "LogicalExpression":
                if (C === "right") return D.callParent(P);
                break;
              case "ConditionalExpression":
                if (C === "alternate") return D.callParent(P);
                break;
              case "UnaryExpression":
                if (m.prefix) return D.callParent(P);
                break;
            }
            return false;
          }
          function $(D, T) {
            let m = D.getValue(), C = D.getParentNode();
            return m.type === "FunctionExpression" || m.type === "ClassExpression" ? C.type === "ExportDefaultDeclaration" || !w(D, T) : !i(m) || C.type !== "ExportDefaultDeclaration" && w(D, T) ? false : D.call((o) => $(o, T), ...n2(D, m));
          }
          r.exports = w;
        } }), Fo = te({ "src/language-js/print-preprocess.js"(e2, r) {
          "use strict";
          ne();
          function t(s, a) {
            switch (a.parser) {
              case "json":
              case "json5":
              case "json-stringify":
              case "__js_expression":
              case "__vue_expression":
              case "__vue_ts_expression":
                return Object.assign(Object.assign({}, s), {}, { type: a.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: s, comments: [], rootMarker: a.rootMarker });
              default:
                return s;
            }
          }
          r.exports = t;
        } }), pd = te({ "src/language-js/print/html-binding.js"(e2, r) {
          "use strict";
          ne();
          var { builders: { join: t, line: s, group: a, softline: n2, indent: u } } = qe();
          function i(p, y, h3) {
            let g = p.getValue();
            if (y.__onHtmlBindingRoot && p.getName() === null && y.__onHtmlBindingRoot(g, y), g.type === "File") {
              if (y.__isVueForBindingLeft) return p.call((c) => {
                let f = t([",", s], c.map(h3, "params")), { params: F } = c.getValue();
                return F.length === 1 ? f : ["(", u([n2, a(f)]), n2, ")"];
              }, "program", "body", 0);
              if (y.__isVueBindings) return p.call((c) => t([",", s], c.map(h3, "params")), "program", "body", 0);
            }
          }
          function l(p) {
            switch (p.type) {
              case "MemberExpression":
                switch (p.property.type) {
                  case "Identifier":
                  case "NumericLiteral":
                  case "StringLiteral":
                    return l(p.object);
                }
                return false;
              case "Identifier":
                return true;
              default:
                return false;
            }
          }
          r.exports = { isVueEventBindingExpression: l, printHtmlBinding: i };
        } }), ru = te({ "src/language-js/print/binaryish.js"(e2, r) {
          "use strict";
          ne();
          var { printComments: t } = et(), { getLast: s } = Ue(), { builders: { join: a, line: n2, softline: u, group: i, indent: l, align: p, indentIfBreak: y }, utils: { cleanDoc: h3, getDocParts: g, isConcat: c } } = qe(), { hasLeadingOwnLineComment: f, isBinaryish: F, isJsxNode: _, shouldFlatten: w, hasComment: E, CommentCheckFlags: N, isCallExpression: x2, isMemberExpression: I, isObjectProperty: P, isEnabledHackPipeline: $ } = Ke(), D = 0;
          function T(o, d, v) {
            let S = o.getValue(), b = o.getParentNode(), B = o.getParentNode(1), k = S !== b.body && (b.type === "IfStatement" || b.type === "WhileStatement" || b.type === "SwitchStatement" || b.type === "DoWhileStatement"), M = $(d) && S.operator === "|>", R = m(o, v, d, false, k);
            if (k) return R;
            if (M) return i(R);
            if (x2(b) && b.callee === S || b.type === "UnaryExpression" || I(b) && !b.computed) return i([l([u, ...R]), u]);
            let q = b.type === "ReturnStatement" || b.type === "ThrowStatement" || b.type === "JSXExpressionContainer" && B.type === "JSXAttribute" || S.operator !== "|" && b.type === "JsExpressionRoot" || S.type !== "NGPipeExpression" && (b.type === "NGRoot" && d.parser === "__ng_binding" || b.type === "NGMicrosyntaxExpression" && B.type === "NGMicrosyntax" && B.body.length === 1) || S === b.body && b.type === "ArrowFunctionExpression" || S !== b.body && b.type === "ForStatement" || b.type === "ConditionalExpression" && B.type !== "ReturnStatement" && B.type !== "ThrowStatement" && !x2(B) || b.type === "TemplateLiteral", J = b.type === "AssignmentExpression" || b.type === "VariableDeclarator" || b.type === "ClassProperty" || b.type === "PropertyDefinition" || b.type === "TSAbstractPropertyDefinition" || b.type === "ClassPrivateProperty" || P(b), L = F(S.left) && w(S.operator, S.left.operator);
            if (q || C(S) && !L || !C(S) && J) return i(R);
            if (R.length === 0) return "";
            let Q = _(S.right), V = R.findIndex((W) => typeof W != "string" && !Array.isArray(W) && W.type === "group"), j = R.slice(0, V === -1 ? 1 : V + 1), Y = R.slice(j.length, Q ? -1 : void 0), ie = Symbol("logicalChain-" + ++D), ee = i([...j, l(Y)], { id: ie });
            if (!Q) return ee;
            let ce = s(R);
            return i([ee, y(ce, { groupId: ie })]);
          }
          function m(o, d, v, S, b) {
            let B = o.getValue();
            if (!F(B)) return [i(d())];
            let k = [];
            w(B.operator, B.left.operator) ? k = o.call((Y) => m(Y, d, v, true, b), "left") : k.push(i(d("left")));
            let M = C(B), R = (B.operator === "|>" || B.type === "NGPipeExpression" || B.operator === "|" && v.parser === "__vue_expression") && !f(v.originalText, B.right), q = B.type === "NGPipeExpression" ? "|" : B.operator, J = B.type === "NGPipeExpression" && B.arguments.length > 0 ? i(l([n2, ": ", a([n2, ": "], o.map(d, "arguments").map((Y) => p(2, i(Y))))])) : "", L;
            if (M) L = [q, " ", d("right"), J];
            else {
              let ie = $(v) && q === "|>" ? o.call((ee) => m(ee, d, v, true, b), "right") : d("right");
              L = [R ? n2 : "", q, R ? " " : n2, ie, J];
            }
            let Q = o.getParentNode(), V = E(B.left, N.Trailing | N.Line), j = V || !(b && B.type === "LogicalExpression") && Q.type !== B.type && B.left.type !== B.type && B.right.type !== B.type;
            if (k.push(R ? "" : " ", j ? i(L, { shouldBreak: V }) : L), S && E(B)) {
              let Y = h3(t(o, k, v));
              return c(Y) || Y.type === "fill" ? g(Y) : [Y];
            }
            return k;
          }
          function C(o) {
            return o.type !== "LogicalExpression" ? false : !!(o.right.type === "ObjectExpression" && o.right.properties.length > 0 || o.right.type === "ArrayExpression" && o.right.elements.length > 0 || _(o.right));
          }
          r.exports = { printBinaryishExpression: T, shouldInlineLogicalExpression: C };
        } }), fd = te({ "src/language-js/print/angular.js"(e2, r) {
          "use strict";
          ne();
          var { builders: { join: t, line: s, group: a } } = qe(), { hasNode: n2, hasComment: u, getComments: i } = Ke(), { printBinaryishExpression: l } = ru();
          function p(g, c, f) {
            let F = g.getValue();
            if (F.type.startsWith("NG")) switch (F.type) {
              case "NGRoot":
                return [f("node"), u(F.node) ? " //" + i(F.node)[0].value.trimEnd() : ""];
              case "NGPipeExpression":
                return l(g, c, f);
              case "NGChainedExpression":
                return a(t([";", s], g.map((_) => h3(_) ? f() : ["(", f(), ")"], "expressions")));
              case "NGEmptyExpression":
                return "";
              case "NGQuotedExpression":
                return [F.prefix, ": ", F.value.trim()];
              case "NGMicrosyntax":
                return g.map((_, w) => [w === 0 ? "" : y(_.getValue(), w, F) ? " " : [";", s], f()], "body");
              case "NGMicrosyntaxKey":
                return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(F.name) ? F.name : JSON.stringify(F.name);
              case "NGMicrosyntaxExpression":
                return [f("expression"), F.alias === null ? "" : [" as ", f("alias")]];
              case "NGMicrosyntaxKeyedExpression": {
                let _ = g.getName(), w = g.getParentNode(), E = y(F, _, w) || (_ === 1 && (F.key.name === "then" || F.key.name === "else") || _ === 2 && F.key.name === "else" && w.body[_ - 1].type === "NGMicrosyntaxKeyedExpression" && w.body[_ - 1].key.name === "then") && w.body[0].type === "NGMicrosyntaxExpression";
                return [f("key"), E ? " " : ": ", f("expression")];
              }
              case "NGMicrosyntaxLet":
                return ["let ", f("key"), F.value === null ? "" : [" = ", f("value")]];
              case "NGMicrosyntaxAs":
                return [f("key"), " as ", f("alias")];
              default:
                throw new Error(`Unknown Angular node type: ${JSON.stringify(F.type)}.`);
            }
          }
          function y(g, c, f) {
            return g.type === "NGMicrosyntaxKeyedExpression" && g.key.name === "of" && c === 1 && f.body[0].type === "NGMicrosyntaxLet" && f.body[0].value === null;
          }
          function h3(g) {
            return n2(g.getValue(), (c) => {
              switch (c.type) {
                case void 0:
                  return false;
                case "CallExpression":
                case "OptionalCallExpression":
                case "AssignmentExpression":
                  return true;
              }
            });
          }
          r.exports = { printAngular: p };
        } }), Dd = te({ "src/language-js/print/jsx.js"(e2, r) {
          "use strict";
          ne();
          var { printComments: t, printDanglingComments: s, printCommentsSeparately: a } = et(), { builders: { line: n2, hardline: u, softline: i, group: l, indent: p, conditionalGroup: y, fill: h3, ifBreak: g, lineSuffixBoundary: c, join: f }, utils: { willBreak: F } } = qe(), { getLast: _, getPreferredQuote: w } = Ue(), { isJsxNode: E, rawText: N, isCallExpression: x2, isStringLiteral: I, isBinaryish: P, hasComment: $, CommentCheckFlags: D, hasNodeIgnoreComment: T } = Ke(), m = qt(), { willPrintOwnComments: C } = Eo(), o = (U) => U === "" || U === n2 || U === u || U === i;
          function d(U, Z, se) {
            let fe = U.getValue();
            if (fe.type === "JSXElement" && de(fe)) return [se("openingElement"), se("closingElement")];
            let ge = fe.type === "JSXElement" ? se("openingElement") : se("openingFragment"), he = fe.type === "JSXElement" ? se("closingElement") : se("closingFragment");
            if (fe.children.length === 1 && fe.children[0].type === "JSXExpressionContainer" && (fe.children[0].expression.type === "TemplateLiteral" || fe.children[0].expression.type === "TaggedTemplateExpression")) return [ge, ...U.map(se, "children"), he];
            fe.children = fe.children.map((A) => Fe(A) ? { type: "JSXText", value: " ", raw: " " } : A);
            let we = fe.children.some(E), ke = fe.children.filter((A) => A.type === "JSXExpressionContainer").length > 1, Re = fe.type === "JSXElement" && fe.openingElement.attributes.length > 1, Ne = F(ge) || we || Re || ke, Pe = U.getParentNode().rootMarker === "mdx", oe = Z.singleQuote ? "{' '}" : '{" "}', H = Pe ? " " : g([oe, i], " "), pe = fe.openingElement && fe.openingElement.name && fe.openingElement.name.name === "fbt", X = v(U, Z, se, H, pe), le = fe.children.some((A) => ue(A));
            for (let A = X.length - 2; A >= 0; A--) {
              let G = X[A] === "" && X[A + 1] === "", re = X[A] === u && X[A + 1] === "" && X[A + 2] === u, ye = (X[A] === i || X[A] === u) && X[A + 1] === "" && X[A + 2] === H, Ce = X[A] === H && X[A + 1] === "" && (X[A + 2] === i || X[A + 2] === u), Be = X[A] === H && X[A + 1] === "" && X[A + 2] === H, ve = X[A] === i && X[A + 1] === "" && X[A + 2] === u || X[A] === u && X[A + 1] === "" && X[A + 2] === i;
              re && le || G || ye || Be || ve ? X.splice(A, 2) : Ce && X.splice(A + 1, 2);
            }
            for (; X.length > 0 && o(_(X)); ) X.pop();
            for (; X.length > 1 && o(X[0]) && o(X[1]); ) X.shift(), X.shift();
            let Ae = [];
            for (let [A, G] of X.entries()) {
              if (G === H) {
                if (A === 1 && X[A - 1] === "") {
                  if (X.length === 2) {
                    Ae.push(oe);
                    continue;
                  }
                  Ae.push([oe, u]);
                  continue;
                } else if (A === X.length - 1) {
                  Ae.push(oe);
                  continue;
                } else if (X[A - 1] === "" && X[A - 2] === u) {
                  Ae.push(oe);
                  continue;
                }
              }
              Ae.push(G), F(G) && (Ne = true);
            }
            let Ee = le ? h3(Ae) : l(Ae, { shouldBreak: true });
            if (Pe) return Ee;
            let De = l([ge, p([u, Ee]), u, he]);
            return Ne ? De : y([l([ge, ...X, he]), De]);
          }
          function v(U, Z, se, fe, ge) {
            let he = [];
            return U.each((we, ke, Re) => {
              let Ne = we.getValue();
              if (Ne.type === "JSXText") {
                let Pe = N(Ne);
                if (ue(Ne)) {
                  let oe = Pe.split(ce);
                  if (oe[0] === "") {
                    if (he.push(""), oe.shift(), /\n/.test(oe[0])) {
                      let pe = Re[ke + 1];
                      he.push(b(ge, oe[1], Ne, pe));
                    } else he.push(fe);
                    oe.shift();
                  }
                  let H;
                  if (_(oe) === "" && (oe.pop(), H = oe.pop()), oe.length === 0) return;
                  for (let [pe, X] of oe.entries()) pe % 2 === 1 ? he.push(n2) : he.push(X);
                  if (H !== void 0) if (/\n/.test(H)) {
                    let pe = Re[ke + 1];
                    he.push(b(ge, _(he), Ne, pe));
                  } else he.push(fe);
                  else {
                    let pe = Re[ke + 1];
                    he.push(S(ge, _(he), Ne, pe));
                  }
                } else /\n/.test(Pe) ? Pe.match(/\n/g).length > 1 && he.push("", u) : he.push("", fe);
              } else {
                let Pe = se();
                he.push(Pe);
                let oe = Re[ke + 1];
                if (oe && ue(oe)) {
                  let pe = K(N(oe)).split(ce)[0];
                  he.push(S(ge, pe, Ne, oe));
                } else he.push(u);
              }
            }, "children"), he;
          }
          function S(U, Z, se, fe) {
            return U ? "" : se.type === "JSXElement" && !se.closingElement || fe && fe.type === "JSXElement" && !fe.closingElement ? Z.length === 1 ? i : u : i;
          }
          function b(U, Z, se, fe) {
            return U ? u : Z.length === 1 ? se.type === "JSXElement" && !se.closingElement || fe && fe.type === "JSXElement" && !fe.closingElement ? u : i : u;
          }
          function B(U, Z, se) {
            let fe = U.getParentNode();
            if (!fe || { ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[fe.type]) return Z;
            let he = U.match(void 0, (ke) => ke.type === "ArrowFunctionExpression", x2, (ke) => ke.type === "JSXExpressionContainer"), we = m(U, se);
            return l([we ? "" : g("("), p([i, Z]), i, we ? "" : g(")")], { shouldBreak: he });
          }
          function k(U, Z, se) {
            let fe = U.getValue(), ge = [];
            if (ge.push(se("name")), fe.value) {
              let he;
              if (I(fe.value)) {
                let ke = N(fe.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"'), { escaped: Re, quote: Ne, regex: Pe } = w(ke, Z.jsxSingleQuote ? "'" : '"');
                ke = ke.replace(Pe, Re);
                let { leading: oe, trailing: H } = U.call(() => a(U, Z), "value");
                he = [oe, Ne, ke, Ne, H];
              } else he = se("value");
              ge.push("=", he);
            }
            return ge;
          }
          function M(U, Z, se) {
            let fe = U.getValue(), ge = (he, we) => he.type === "JSXEmptyExpression" || !$(he) && (he.type === "ArrayExpression" || he.type === "ObjectExpression" || he.type === "ArrowFunctionExpression" || he.type === "AwaitExpression" && (ge(he.argument, he) || he.argument.type === "JSXElement") || x2(he) || he.type === "FunctionExpression" || he.type === "TemplateLiteral" || he.type === "TaggedTemplateExpression" || he.type === "DoExpression" || E(we) && (he.type === "ConditionalExpression" || P(he)));
            return ge(fe.expression, U.getParentNode(0)) ? l(["{", se("expression"), c, "}"]) : l(["{", p([i, se("expression")]), i, c, "}"]);
          }
          function R(U, Z, se) {
            let fe = U.getValue(), ge = fe.name && $(fe.name) || fe.typeParameters && $(fe.typeParameters);
            if (fe.selfClosing && fe.attributes.length === 0 && !ge) return ["<", se("name"), se("typeParameters"), " />"];
            if (fe.attributes && fe.attributes.length === 1 && fe.attributes[0].value && I(fe.attributes[0].value) && !fe.attributes[0].value.value.includes(`
`) && !ge && !$(fe.attributes[0])) return l(["<", se("name"), se("typeParameters"), " ", ...U.map(se, "attributes"), fe.selfClosing ? " />" : ">"]);
            let he = fe.attributes && fe.attributes.some((ke) => ke.value && I(ke.value) && ke.value.value.includes(`
`)), we = Z.singleAttributePerLine && fe.attributes.length > 1 ? u : n2;
            return l(["<", se("name"), se("typeParameters"), p(U.map(() => [we, se()], "attributes")), ...q(fe, Z, ge)], { shouldBreak: he });
          }
          function q(U, Z, se) {
            return U.selfClosing ? [n2, "/>"] : J(U, Z, se) ? [">"] : [i, ">"];
          }
          function J(U, Z, se) {
            let fe = U.attributes.length > 0 && $(_(U.attributes), D.Trailing);
            return U.attributes.length === 0 && !se || (Z.bracketSameLine || Z.jsxBracketSameLine) && (!se || U.attributes.length > 0) && !fe;
          }
          function L(U, Z, se) {
            let fe = U.getValue(), ge = [];
            ge.push("</");
            let he = se("name");
            return $(fe.name, D.Leading | D.Line) ? ge.push(p([u, he]), u) : $(fe.name, D.Leading | D.Block) ? ge.push(" ", he) : ge.push(he), ge.push(">"), ge;
          }
          function Q(U, Z) {
            let se = U.getValue(), fe = $(se), ge = $(se, D.Line), he = se.type === "JSXOpeningFragment";
            return [he ? "<" : "</", p([ge ? u : fe && !he ? " " : "", s(U, Z, true)]), ge ? u : "", ">"];
          }
          function V(U, Z, se) {
            let fe = t(U, d(U, Z, se), Z);
            return B(U, fe, Z);
          }
          function j(U, Z) {
            let se = U.getValue(), fe = $(se, D.Line);
            return [s(U, Z, !fe), fe ? u : ""];
          }
          function Y(U, Z, se) {
            let fe = U.getValue();
            return ["{", U.call((ge) => {
              let he = ["...", se()], we = ge.getValue();
              return !$(we) || !C(ge) ? he : [p([i, t(ge, he, Z)]), i];
            }, fe.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
          }
          function ie(U, Z, se) {
            let fe = U.getValue();
            if (fe.type.startsWith("JSX")) switch (fe.type) {
              case "JSXAttribute":
                return k(U, Z, se);
              case "JSXIdentifier":
                return String(fe.name);
              case "JSXNamespacedName":
                return f(":", [se("namespace"), se("name")]);
              case "JSXMemberExpression":
                return f(".", [se("object"), se("property")]);
              case "JSXSpreadAttribute":
                return Y(U, Z, se);
              case "JSXSpreadChild":
                return Y(U, Z, se);
              case "JSXExpressionContainer":
                return M(U, Z, se);
              case "JSXFragment":
              case "JSXElement":
                return V(U, Z, se);
              case "JSXOpeningElement":
                return R(U, Z, se);
              case "JSXClosingElement":
                return L(U, Z, se);
              case "JSXOpeningFragment":
              case "JSXClosingFragment":
                return Q(U, Z);
              case "JSXEmptyExpression":
                return j(U, Z);
              case "JSXText":
                throw new Error("JSXText should be handled by JSXElement");
              default:
                throw new Error(`Unknown JSX node type: ${JSON.stringify(fe.type)}.`);
            }
          }
          var ee = ` 
\r	`, ce = new RegExp("([" + ee + "]+)"), W = new RegExp("[^" + ee + "]"), K = (U) => U.replace(new RegExp("(?:^" + ce.source + "|" + ce.source + "$)"), "");
          function de(U) {
            if (U.children.length === 0) return true;
            if (U.children.length > 1) return false;
            let Z = U.children[0];
            return Z.type === "JSXText" && !ue(Z);
          }
          function ue(U) {
            return U.type === "JSXText" && (W.test(N(U)) || !/\n/.test(N(U)));
          }
          function Fe(U) {
            return U.type === "JSXExpressionContainer" && I(U.expression) && U.expression.value === " " && !$(U.expression);
          }
          function z(U) {
            let Z = U.getValue(), se = U.getParentNode();
            if (!se || !Z || !E(Z) || !E(se)) return false;
            let fe = se.children.indexOf(Z), ge = null;
            for (let he = fe; he > 0; he--) {
              let we = se.children[he - 1];
              if (!(we.type === "JSXText" && !ue(we))) {
                ge = we;
                break;
              }
            }
            return ge && ge.type === "JSXExpressionContainer" && ge.expression.type === "JSXEmptyExpression" && T(ge.expression);
          }
          r.exports = { hasJsxIgnoreComment: z, printJsx: ie };
        } }), ct = te({ "src/language-js/print/misc.js"(e2, r) {
          "use strict";
          ne();
          var { isNonEmptyArray: t } = Ue(), { builders: { indent: s, join: a, line: n2 } } = qe(), { isFlowAnnotationComment: u } = Ke();
          function i(_) {
            let w = _.getValue();
            return !w.optional || w.type === "Identifier" && w === _.getParentNode().key ? "" : w.type === "OptionalCallExpression" || w.type === "OptionalMemberExpression" && w.computed ? "?." : "?";
          }
          function l(_) {
            return _.getValue().definite || _.match(void 0, (w, E) => E === "id" && w.type === "VariableDeclarator" && w.definite) ? "!" : "";
          }
          function p(_, w, E) {
            let N = _.getValue();
            return N.typeArguments ? E("typeArguments") : N.typeParameters ? E("typeParameters") : "";
          }
          function y(_, w, E) {
            let N = _.getValue();
            if (!N.typeAnnotation) return "";
            let x2 = _.getParentNode(), I = x2.type === "DeclareFunction" && x2.id === N;
            return u(w.originalText, N.typeAnnotation) ? [" /*: ", E("typeAnnotation"), " */"] : [I ? "" : ": ", E("typeAnnotation")];
          }
          function h3(_, w, E) {
            return ["::", E("callee")];
          }
          function g(_, w, E) {
            let N = _.getValue();
            return t(N.modifiers) ? [a(" ", _.map(E, "modifiers")), " "] : "";
          }
          function c(_, w, E) {
            return _.type === "EmptyStatement" ? ";" : _.type === "BlockStatement" || E ? [" ", w] : s([n2, w]);
          }
          function f(_, w, E) {
            return ["...", E("argument"), y(_, w, E)];
          }
          function F(_, w) {
            let E = _.slice(1, -1);
            if (E.includes('"') || E.includes("'")) return _;
            let N = w.singleQuote ? "'" : '"';
            return N + E + N;
          }
          r.exports = { printOptionalToken: i, printDefiniteToken: l, printFunctionTypeParameters: p, printBindExpressionCallee: h3, printTypeScriptModifiers: g, printTypeAnnotation: y, printRestSpread: f, adjustClause: c, printDirective: F };
        } }), er = te({ "src/language-js/print/array.js"(e2, r) {
          "use strict";
          ne();
          var { printDanglingComments: t } = et(), { builders: { line: s, softline: a, hardline: n2, group: u, indent: i, ifBreak: l, fill: p } } = qe(), { getLast: y, hasNewline: h3 } = Ue(), { shouldPrintComma: g, hasComment: c, CommentCheckFlags: f, isNextLineEmpty: F, isNumericLiteral: _, isSignedNumericLiteral: w } = Ke(), { locStart: E } = ut(), { printOptionalToken: N, printTypeAnnotation: x2 } = ct();
          function I(T, m, C) {
            let o = T.getValue(), d = [], v = o.type === "TupleExpression" ? "#[" : "[", S = "]";
            if (o.elements.length === 0) c(o, f.Dangling) ? d.push(u([v, t(T, m), a, S])) : d.push(v, S);
            else {
              let b = y(o.elements), B = !(b && b.type === "RestElement"), k = b === null, M = Symbol("array"), R = !m.__inJestEach && o.elements.length > 1 && o.elements.every((L, Q, V) => {
                let j = L && L.type;
                if (j !== "ArrayExpression" && j !== "ObjectExpression") return false;
                let Y = V[Q + 1];
                if (Y && j !== Y.type) return false;
                let ie = j === "ArrayExpression" ? "elements" : "properties";
                return L[ie] && L[ie].length > 1;
              }), q = P(o, m), J = B ? k ? "," : g(m) ? q ? l(",", "", { groupId: M }) : l(",") : "" : "";
              d.push(u([v, i([a, q ? D(T, m, C, J) : [$(T, m, "elements", C), J], t(T, m, true)]), a, S], { shouldBreak: R, id: M }));
            }
            return d.push(N(T), x2(T, m, C)), d;
          }
          function P(T, m) {
            return T.elements.length > 1 && T.elements.every((C) => C && (_(C) || w(C) && !c(C.argument)) && !c(C, f.Trailing | f.Line, (o) => !h3(m.originalText, E(o), { backwards: true })));
          }
          function $(T, m, C, o) {
            let d = [], v = [];
            return T.each((S) => {
              d.push(v, u(o())), v = [",", s], S.getValue() && F(S.getValue(), m) && v.push(a);
            }, C), d;
          }
          function D(T, m, C, o) {
            let d = [];
            return T.each((v, S, b) => {
              let B = S === b.length - 1;
              d.push([C(), B ? o : ","]), B || d.push(F(v.getValue(), m) ? [n2, n2] : c(b[S + 1], f.Leading | f.Line) ? n2 : s);
            }, "elements"), p(d);
          }
          r.exports = { printArray: I, printArrayItems: $, isConciselyPrintedArray: P };
        } }), Ao = te({ "src/language-js/print/call-arguments.js"(e2, r) {
          "use strict";
          ne();
          var { printDanglingComments: t } = et(), { getLast: s, getPenultimate: a } = Ue(), { getFunctionParameters: n2, hasComment: u, CommentCheckFlags: i, isFunctionCompositionArgs: l, isJsxNode: p, isLongCurriedCallExpression: y, shouldPrintComma: h3, getCallArguments: g, iterateCallArgumentsPath: c, isNextLineEmpty: f, isCallExpression: F, isStringLiteral: _, isObjectProperty: w, isTSTypeExpression: E } = Ke(), { builders: { line: N, hardline: x2, softline: I, group: P, indent: $, conditionalGroup: D, ifBreak: T, breakParent: m }, utils: { willBreak: C } } = qe(), { ArgExpansionBailout: o } = Qt(), { isConciselyPrintedArray: d } = er();
          function v(q, J, L) {
            let Q = q.getValue(), V = Q.type === "ImportExpression", j = g(Q);
            if (j.length === 0) return ["(", t(q, J, true), ")"];
            if (k(j)) return ["(", L(["arguments", 0]), ", ", L(["arguments", 1]), ")"];
            let Y = false, ie = false, ee = j.length - 1, ce = [];
            c(q, (z, U) => {
              let Z = z.getNode(), se = [L()];
              U === ee || (f(Z, J) ? (U === 0 && (ie = true), Y = true, se.push(",", x2, x2)) : se.push(",", N)), ce.push(se);
            });
            let W = !(V || Q.callee && Q.callee.type === "Import") && h3(J, "all") ? "," : "";
            function K() {
              return P(["(", $([N, ...ce]), W, N, ")"], { shouldBreak: true });
            }
            if (Y || q.getParentNode().type !== "Decorator" && l(j)) return K();
            let de = B(j), ue = b(j, J);
            if (de || ue) {
              if (de ? ce.slice(1).some(C) : ce.slice(0, -1).some(C)) return K();
              let z = [];
              try {
                q.try(() => {
                  c(q, (U, Z) => {
                    de && Z === 0 && (z = [[L([], { expandFirstArg: true }), ce.length > 1 ? "," : "", ie ? x2 : N, ie ? x2 : ""], ...ce.slice(1)]), ue && Z === ee && (z = [...ce.slice(0, -1), L([], { expandLastArg: true })]);
                  });
                });
              } catch (U) {
                if (U instanceof o) return K();
                throw U;
              }
              return [ce.some(C) ? m : "", D([["(", ...z, ")"], de ? ["(", P(z[0], { shouldBreak: true }), ...z.slice(1), ")"] : ["(", ...ce.slice(0, -1), P(s(z), { shouldBreak: true }), ")"], K()])];
            }
            let Fe = ["(", $([I, ...ce]), T(W), I, ")"];
            return y(q) ? Fe : P(Fe, { shouldBreak: ce.some(C) || Y });
          }
          function S(q) {
            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            return q.type === "ObjectExpression" && (q.properties.length > 0 || u(q)) || q.type === "ArrayExpression" && (q.elements.length > 0 || u(q)) || q.type === "TSTypeAssertion" && S(q.expression) || E(q) && S(q.expression) || q.type === "FunctionExpression" || q.type === "ArrowFunctionExpression" && (!q.returnType || !q.returnType.typeAnnotation || q.returnType.typeAnnotation.type !== "TSTypeReference" || M(q.body)) && (q.body.type === "BlockStatement" || q.body.type === "ArrowFunctionExpression" && S(q.body, true) || q.body.type === "ObjectExpression" || q.body.type === "ArrayExpression" || !J && (F(q.body) || q.body.type === "ConditionalExpression") || p(q.body)) || q.type === "DoExpression" || q.type === "ModuleExpression";
          }
          function b(q, J) {
            let L = s(q), Q = a(q);
            return !u(L, i.Leading) && !u(L, i.Trailing) && S(L) && (!Q || Q.type !== L.type) && (q.length !== 2 || Q.type !== "ArrowFunctionExpression" || L.type !== "ArrayExpression") && !(q.length > 1 && L.type === "ArrayExpression" && d(L, J));
          }
          function B(q) {
            if (q.length !== 2) return false;
            let [J, L] = q;
            return J.type === "ModuleExpression" && R(L) ? true : !u(J) && (J.type === "FunctionExpression" || J.type === "ArrowFunctionExpression" && J.body.type === "BlockStatement") && L.type !== "FunctionExpression" && L.type !== "ArrowFunctionExpression" && L.type !== "ConditionalExpression" && !S(L);
          }
          function k(q) {
            return q.length === 2 && q[0].type === "ArrowFunctionExpression" && n2(q[0]).length === 0 && q[0].body.type === "BlockStatement" && q[1].type === "ArrayExpression" && !q.some((J) => u(J));
          }
          function M(q) {
            return q.type === "BlockStatement" && (q.body.some((J) => J.type !== "EmptyStatement") || u(q, i.Dangling));
          }
          function R(q) {
            return q.type === "ObjectExpression" && q.properties.length === 1 && w(q.properties[0]) && q.properties[0].key.type === "Identifier" && q.properties[0].key.name === "type" && _(q.properties[0].value) && q.properties[0].value.value === "module";
          }
          r.exports = v;
        } }), So = te({ "src/language-js/print/member.js"(e2, r) {
          "use strict";
          ne();
          var { builders: { softline: t, group: s, indent: a, label: n2 } } = qe(), { isNumericLiteral: u, isMemberExpression: i, isCallExpression: l } = Ke(), { printOptionalToken: p } = ct();
          function y(g, c, f) {
            let F = g.getValue(), _ = g.getParentNode(), w, E = 0;
            do
              w = g.getParentNode(E), E++;
            while (w && (i(w) || w.type === "TSNonNullExpression"));
            let N = f("object"), x2 = h3(g, c, f), I = w && (w.type === "NewExpression" || w.type === "BindExpression" || w.type === "AssignmentExpression" && w.left.type !== "Identifier") || F.computed || F.object.type === "Identifier" && F.property.type === "Identifier" && !i(_) || (_.type === "AssignmentExpression" || _.type === "VariableDeclarator") && (l(F.object) && F.object.arguments.length > 0 || F.object.type === "TSNonNullExpression" && l(F.object.expression) && F.object.expression.arguments.length > 0 || N.label === "member-chain");
            return n2(N.label === "member-chain" ? "member-chain" : "member", [N, I ? x2 : s(a([t, x2]))]);
          }
          function h3(g, c, f) {
            let F = f("property"), _ = g.getValue(), w = p(g);
            return _.computed ? !_.property || u(_.property) ? [w, "[", F, "]"] : s([w, "[", a([t, F]), t, "]"]) : [w, ".", F];
          }
          r.exports = { printMemberExpression: y, printMemberLookup: h3 };
        } }), md = te({ "src/language-js/print/member-chain.js"(e2, r) {
          "use strict";
          ne();
          var { printComments: t } = et(), { getLast: s, isNextLineEmptyAfterIndex: a, getNextNonSpaceNonCommentCharacterIndex: n2 } = Ue(), u = qt(), { isCallExpression: i, isMemberExpression: l, isFunctionOrArrowExpression: p, isLongCurriedCallExpression: y, isMemberish: h3, isNumericLiteral: g, isSimpleCallArgument: c, hasComment: f, CommentCheckFlags: F, isNextLineEmpty: _ } = Ke(), { locEnd: w } = ut(), { builders: { join: E, hardline: N, group: x2, indent: I, conditionalGroup: P, breakParent: $, label: D }, utils: { willBreak: T } } = qe(), m = Ao(), { printMemberLookup: C } = So(), { printOptionalToken: o, printFunctionTypeParameters: d, printBindExpressionCallee: v } = ct();
          function S(b, B, k) {
            let M = b.getParentNode(), R = !M || M.type === "ExpressionStatement", q = [];
            function J(Ne) {
              let { originalText: Pe } = B, oe = n2(Pe, Ne, w);
              return Pe.charAt(oe) === ")" ? oe !== false && a(Pe, oe + 1) : _(Ne, B);
            }
            function L(Ne) {
              let Pe = Ne.getValue();
              i(Pe) && (h3(Pe.callee) || i(Pe.callee)) ? (q.unshift({ node: Pe, printed: [t(Ne, [o(Ne), d(Ne, B, k), m(Ne, B, k)], B), J(Pe) ? N : ""] }), Ne.call((oe) => L(oe), "callee")) : h3(Pe) ? (q.unshift({ node: Pe, needsParens: u(Ne, B), printed: t(Ne, l(Pe) ? C(Ne, B, k) : v(Ne, B, k), B) }), Ne.call((oe) => L(oe), "object")) : Pe.type === "TSNonNullExpression" ? (q.unshift({ node: Pe, printed: t(Ne, "!", B) }), Ne.call((oe) => L(oe), "expression")) : q.unshift({ node: Pe, printed: k() });
            }
            let Q = b.getValue();
            q.unshift({ node: Q, printed: [o(b), d(b, B, k), m(b, B, k)] }), Q.callee && b.call((Ne) => L(Ne), "callee");
            let V = [], j = [q[0]], Y = 1;
            for (; Y < q.length && (q[Y].node.type === "TSNonNullExpression" || i(q[Y].node) || l(q[Y].node) && q[Y].node.computed && g(q[Y].node.property)); ++Y) j.push(q[Y]);
            if (!i(q[0].node)) for (; Y + 1 < q.length && (h3(q[Y].node) && h3(q[Y + 1].node)); ++Y) j.push(q[Y]);
            V.push(j), j = [];
            let ie = false;
            for (; Y < q.length; ++Y) {
              if (ie && h3(q[Y].node)) {
                if (q[Y].node.computed && g(q[Y].node.property)) {
                  j.push(q[Y]);
                  continue;
                }
                V.push(j), j = [], ie = false;
              }
              (i(q[Y].node) || q[Y].node.type === "ImportExpression") && (ie = true), j.push(q[Y]), f(q[Y].node, F.Trailing) && (V.push(j), j = [], ie = false);
            }
            j.length > 0 && V.push(j);
            function ee(Ne) {
              return /^[A-Z]|^[$_]+$/.test(Ne);
            }
            function ce(Ne) {
              return Ne.length <= B.tabWidth;
            }
            function W(Ne) {
              let Pe = Ne[1].length > 0 && Ne[1][0].node.computed;
              if (Ne[0].length === 1) {
                let H = Ne[0][0].node;
                return H.type === "ThisExpression" || H.type === "Identifier" && (ee(H.name) || R && ce(H.name) || Pe);
              }
              let oe = s(Ne[0]).node;
              return l(oe) && oe.property.type === "Identifier" && (ee(oe.property.name) || Pe);
            }
            let K = V.length >= 2 && !f(V[1][0].node) && W(V);
            function de(Ne) {
              let Pe = Ne.map((oe) => oe.printed);
              return Ne.length > 0 && s(Ne).needsParens ? ["(", ...Pe, ")"] : Pe;
            }
            function ue(Ne) {
              return Ne.length === 0 ? "" : I(x2([N, E(N, Ne.map(de))]));
            }
            let Fe = V.map(de), z = Fe, U = K ? 3 : 2, Z = V.flat(), se = Z.slice(1, -1).some((Ne) => f(Ne.node, F.Leading)) || Z.slice(0, -1).some((Ne) => f(Ne.node, F.Trailing)) || V[U] && f(V[U][0].node, F.Leading);
            if (V.length <= U && !se) return y(b) ? z : x2(z);
            let fe = s(V[K ? 1 : 0]).node, ge = !i(fe) && J(fe), he = [de(V[0]), K ? V.slice(1, 2).map(de) : "", ge ? N : "", ue(V.slice(K ? 2 : 1))], we = q.map((Ne) => {
              let { node: Pe } = Ne;
              return Pe;
            }).filter(i);
            function ke() {
              let Ne = s(s(V)).node, Pe = s(Fe);
              return i(Ne) && T(Pe) && we.slice(0, -1).some((oe) => oe.arguments.some(p));
            }
            let Re;
            return se || we.length > 2 && we.some((Ne) => !Ne.arguments.every((Pe) => c(Pe, 0))) || Fe.slice(0, -1).some(T) || ke() ? Re = x2(he) : Re = [T(z) || ge ? $ : "", P([z, he])], D("member-chain", Re);
          }
          r.exports = S;
        } }), xo = te({ "src/language-js/print/call-expression.js"(e2, r) {
          "use strict";
          ne();
          var { builders: { join: t, group: s } } = qe(), a = qt(), { getCallArguments: n2, hasFlowAnnotationComment: u, isCallExpression: i, isMemberish: l, isStringLiteral: p, isTemplateOnItsOwnLine: y, isTestCall: h3, iterateCallArgumentsPath: g } = Ke(), c = md(), f = Ao(), { printOptionalToken: F, printFunctionTypeParameters: _ } = ct();
          function w(N, x2, I) {
            let P = N.getValue(), $ = N.getParentNode(), D = P.type === "NewExpression", T = P.type === "ImportExpression", m = F(N), C = n2(P);
            if (C.length > 0 && (!T && !D && E(P, $) || C.length === 1 && y(C[0], x2.originalText) || !D && h3(P, $))) {
              let v = [];
              return g(N, () => {
                v.push(I());
              }), [D ? "new " : "", I("callee"), m, _(N, x2, I), "(", t(", ", v), ")"];
            }
            let o = (x2.parser === "babel" || x2.parser === "babel-flow") && P.callee && P.callee.type === "Identifier" && u(P.callee.trailingComments);
            if (o && (P.callee.trailingComments[0].printed = true), !T && !D && l(P.callee) && !N.call((v) => a(v, x2), "callee")) return c(N, x2, I);
            let d = [D ? "new " : "", T ? "import" : I("callee"), m, o ? `/*:: ${P.callee.trailingComments[0].value.slice(2).trim()} */` : "", _(N, x2, I), f(N, x2, I)];
            return T || i(P.callee) ? s(d) : d;
          }
          function E(N, x2) {
            if (N.callee.type !== "Identifier") return false;
            if (N.callee.name === "require") return true;
            if (N.callee.name === "define") {
              let I = n2(N);
              return x2.type === "ExpressionStatement" && (I.length === 1 || I.length === 2 && I[0].type === "ArrayExpression" || I.length === 3 && p(I[0]) && I[1].type === "ArrayExpression");
            }
            return false;
          }
          r.exports = { printCallExpression: w };
        } }), tr = te({ "src/language-js/print/assignment.js"(e2, r) {
          "use strict";
          ne();
          var { isNonEmptyArray: t, getStringWidth: s } = Ue(), { builders: { line: a, group: n2, indent: u, indentIfBreak: i, lineSuffixBoundary: l }, utils: { cleanDoc: p, willBreak: y, canBreak: h3 } } = qe(), { hasLeadingOwnLineComment: g, isBinaryish: c, isStringLiteral: f, isLiteral: F, isNumericLiteral: _, isCallExpression: w, isMemberExpression: E, getCallArguments: N, rawText: x2, hasComment: I, isSignedNumericLiteral: P, isObjectProperty: $ } = Ke(), { shouldInlineLogicalExpression: D } = ru(), { printCallExpression: T } = xo();
          function m(W, K, de, ue, Fe, z) {
            let U = d(W, K, de, ue, z), Z = de(z, { assignmentLayout: U });
            switch (U) {
              case "break-after-operator":
                return n2([n2(ue), Fe, n2(u([a, Z]))]);
              case "never-break-after-operator":
                return n2([n2(ue), Fe, " ", Z]);
              case "fluid": {
                let se = Symbol("assignment");
                return n2([n2(ue), Fe, n2(u(a), { id: se }), l, i(Z, { groupId: se })]);
              }
              case "break-lhs":
                return n2([ue, Fe, " ", n2(Z)]);
              case "chain":
                return [n2(ue), Fe, a, Z];
              case "chain-tail":
                return [n2(ue), Fe, u([a, Z])];
              case "chain-tail-arrow-chain":
                return [n2(ue), Fe, Z];
              case "only-left":
                return ue;
            }
          }
          function C(W, K, de) {
            let ue = W.getValue();
            return m(W, K, de, de("left"), [" ", ue.operator], "right");
          }
          function o(W, K, de) {
            return m(W, K, de, de("id"), " =", "init");
          }
          function d(W, K, de, ue, Fe) {
            let z = W.getValue(), U = z[Fe];
            if (!U) return "only-left";
            let Z = !b(U);
            if (W.match(b, B, (he) => !Z || he.type !== "ExpressionStatement" && he.type !== "VariableDeclaration")) return Z ? U.type === "ArrowFunctionExpression" && U.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
            if (!Z && b(U.right) || g(K.originalText, U)) return "break-after-operator";
            if (U.type === "CallExpression" && U.callee.name === "require" || K.parser === "json5" || K.parser === "json") return "never-break-after-operator";
            if (S(z) || k(z) || q(z) || J(z) && h3(ue)) return "break-lhs";
            let ge = ie(z, ue, K);
            return W.call(() => v(W, K, de, ge), Fe) ? "break-after-operator" : ge || U.type === "TemplateLiteral" || U.type === "TaggedTemplateExpression" || U.type === "BooleanLiteral" || _(U) || U.type === "ClassExpression" ? "never-break-after-operator" : "fluid";
          }
          function v(W, K, de, ue) {
            let Fe = W.getValue();
            if (c(Fe) && !D(Fe)) return true;
            switch (Fe.type) {
              case "StringLiteralTypeAnnotation":
              case "SequenceExpression":
                return true;
              case "ConditionalExpression": {
                let { test: Z } = Fe;
                return c(Z) && !D(Z);
              }
              case "ClassExpression":
                return t(Fe.decorators);
            }
            if (ue) return false;
            let z = Fe, U = [];
            for (; ; ) if (z.type === "UnaryExpression") z = z.argument, U.push("argument");
            else if (z.type === "TSNonNullExpression") z = z.expression, U.push("expression");
            else break;
            return !!(f(z) || W.call(() => V(W, K, de), ...U));
          }
          function S(W) {
            if (B(W)) {
              let K = W.left || W.id;
              return K.type === "ObjectPattern" && K.properties.length > 2 && K.properties.some((de) => $(de) && (!de.shorthand || de.value && de.value.type === "AssignmentPattern"));
            }
            return false;
          }
          function b(W) {
            return W.type === "AssignmentExpression";
          }
          function B(W) {
            return b(W) || W.type === "VariableDeclarator";
          }
          function k(W) {
            let K = M(W);
            if (t(K)) {
              let de = W.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
              if (K.length > 1 && K.some((ue) => ue[de] || ue.default)) return true;
            }
            return false;
          }
          function M(W) {
            return R(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
          }
          function R(W) {
            return W.type === "TSTypeAliasDeclaration" || W.type === "TypeAlias";
          }
          function q(W) {
            if (W.type !== "VariableDeclarator") return false;
            let { typeAnnotation: K } = W.id;
            if (!K || !K.typeAnnotation) return false;
            let de = L(K.typeAnnotation);
            return t(de) && de.length > 1 && de.some((ue) => t(L(ue)) || ue.type === "TSConditionalType");
          }
          function J(W) {
            return W.type === "VariableDeclarator" && W.init && W.init.type === "ArrowFunctionExpression";
          }
          function L(W) {
            return Q(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
          }
          function Q(W) {
            return W.type === "TSTypeReference" || W.type === "GenericTypeAnnotation";
          }
          function V(W, K, de) {
            let ue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, Fe = W.getValue(), z = () => V(W, K, de, true);
            if (Fe.type === "TSNonNullExpression") return W.call(z, "expression");
            if (w(Fe)) {
              if (T(W, K, de).label === "member-chain") return false;
              let Z = N(Fe);
              return !(Z.length === 0 || Z.length === 1 && Y(Z[0], K)) || ee(Fe, de) ? false : W.call(z, "callee");
            }
            return E(Fe) ? W.call(z, "object") : ue && (Fe.type === "Identifier" || Fe.type === "ThisExpression");
          }
          var j = 0.25;
          function Y(W, K) {
            let { printWidth: de } = K;
            if (I(W)) return false;
            let ue = de * j;
            if (W.type === "ThisExpression" || W.type === "Identifier" && W.name.length <= ue || P(W) && !I(W.argument)) return true;
            let Fe = W.type === "Literal" && "regex" in W && W.regex.pattern || W.type === "RegExpLiteral" && W.pattern;
            return Fe ? Fe.length <= ue : f(W) ? x2(W).length <= ue : W.type === "TemplateLiteral" ? W.expressions.length === 0 && W.quasis[0].value.raw.length <= ue && !W.quasis[0].value.raw.includes(`
`) : F(W);
          }
          function ie(W, K, de) {
            if (!$(W)) return false;
            K = p(K);
            let ue = 3;
            return typeof K == "string" && s(K) < de.tabWidth + ue;
          }
          function ee(W, K) {
            let de = ce(W);
            if (t(de)) {
              if (de.length > 1) return true;
              if (de.length === 1) {
                let Fe = de[0];
                if (Fe.type === "TSUnionType" || Fe.type === "UnionTypeAnnotation" || Fe.type === "TSIntersectionType" || Fe.type === "IntersectionTypeAnnotation" || Fe.type === "TSTypeLiteral" || Fe.type === "ObjectTypeAnnotation") return true;
              }
              let ue = W.typeParameters ? "typeParameters" : "typeArguments";
              if (y(K(ue))) return true;
            }
            return false;
          }
          function ce(W) {
            return W.typeParameters && W.typeParameters.params || W.typeArguments && W.typeArguments.params;
          }
          r.exports = { printVariableDeclarator: o, printAssignmentExpression: C, printAssignment: m, isArrowFunctionVariableDeclarator: J };
        } }), Lr = te({ "src/language-js/print/function-parameters.js"(e2, r) {
          "use strict";
          ne();
          var { getNextNonSpaceNonCommentCharacter: t } = Ue(), { printDanglingComments: s } = et(), { builders: { line: a, hardline: n2, softline: u, group: i, indent: l, ifBreak: p }, utils: { removeLines: y, willBreak: h3 } } = qe(), { getFunctionParameters: g, iterateFunctionParametersPath: c, isSimpleType: f, isTestCall: F, isTypeAnnotationAFunction: _, isObjectType: w, isObjectTypePropertyAFunction: E, hasRestParameter: N, shouldPrintComma: x2, hasComment: I, isNextLineEmpty: P } = Ke(), { locEnd: $ } = ut(), { ArgExpansionBailout: D } = Qt(), { printFunctionTypeParameters: T } = ct();
          function m(v, S, b, B, k) {
            let M = v.getValue(), R = g(M), q = k ? T(v, b, S) : "";
            if (R.length === 0) return [q, "(", s(v, b, true, (ie) => t(b.originalText, ie, $) === ")"), ")"];
            let J = v.getParentNode(), L = F(J), Q = C(M), V = [];
            if (c(v, (ie, ee) => {
              let ce = ee === R.length - 1;
              ce && M.rest && V.push("..."), V.push(S()), !ce && (V.push(","), L || Q ? V.push(" ") : P(R[ee], b) ? V.push(n2, n2) : V.push(a));
            }), B) {
              if (h3(q) || h3(V)) throw new D();
              return i([y(q), "(", y(V), ")"]);
            }
            let j = R.every((ie) => !ie.decorators);
            return Q && j ? [q, "(", ...V, ")"] : L ? [q, "(", ...V, ")"] : (E(J) || _(J) || J.type === "TypeAlias" || J.type === "UnionTypeAnnotation" || J.type === "TSUnionType" || J.type === "IntersectionTypeAnnotation" || J.type === "FunctionTypeAnnotation" && J.returnType === M) && R.length === 1 && R[0].name === null && M.this !== R[0] && R[0].typeAnnotation && M.typeParameters === null && f(R[0].typeAnnotation) && !M.rest ? b.arrowParens === "always" ? ["(", ...V, ")"] : V : [q, "(", l([u, ...V]), p(!N(M) && x2(b, "all") ? "," : ""), u, ")"];
          }
          function C(v) {
            if (!v) return false;
            let S = g(v);
            if (S.length !== 1) return false;
            let [b] = S;
            return !I(b) && (b.type === "ObjectPattern" || b.type === "ArrayPattern" || b.type === "Identifier" && b.typeAnnotation && (b.typeAnnotation.type === "TypeAnnotation" || b.typeAnnotation.type === "TSTypeAnnotation") && w(b.typeAnnotation.typeAnnotation) || b.type === "FunctionTypeParam" && w(b.typeAnnotation) || b.type === "AssignmentPattern" && (b.left.type === "ObjectPattern" || b.left.type === "ArrayPattern") && (b.right.type === "Identifier" || b.right.type === "ObjectExpression" && b.right.properties.length === 0 || b.right.type === "ArrayExpression" && b.right.elements.length === 0));
          }
          function o(v) {
            let S;
            return v.returnType ? (S = v.returnType, S.typeAnnotation && (S = S.typeAnnotation)) : v.typeAnnotation && (S = v.typeAnnotation), S;
          }
          function d(v, S) {
            let b = o(v);
            if (!b) return false;
            let B = v.typeParameters && v.typeParameters.params;
            if (B) {
              if (B.length > 1) return false;
              if (B.length === 1) {
                let k = B[0];
                if (k.constraint || k.default) return false;
              }
            }
            return g(v).length === 1 && (w(b) || h3(S));
          }
          r.exports = { printFunctionParameters: m, shouldHugFunctionParameters: C, shouldGroupFunctionParameters: d };
        } }), Or = te({ "src/language-js/print/type-annotation.js"(e2, r) {
          "use strict";
          ne();
          var { printComments: t, printDanglingComments: s } = et(), { isNonEmptyArray: a } = Ue(), { builders: { group: n2, join: u, line: i, softline: l, indent: p, align: y, ifBreak: h3 } } = qe(), g = qt(), { locStart: c } = ut(), { isSimpleType: f, isObjectType: F, hasLeadingOwnLineComment: _, isObjectTypePropertyAFunction: w, shouldPrintComma: E } = Ke(), { printAssignment: N } = tr(), { printFunctionParameters: x2, shouldGroupFunctionParameters: I } = Lr(), { printArrayItems: P } = er();
          function $(b) {
            if (f(b) || F(b)) return true;
            if (b.type === "UnionTypeAnnotation" || b.type === "TSUnionType") {
              let B = b.types.filter((M) => M.type === "VoidTypeAnnotation" || M.type === "TSVoidKeyword" || M.type === "NullLiteralTypeAnnotation" || M.type === "TSNullKeyword").length, k = b.types.some((M) => M.type === "ObjectTypeAnnotation" || M.type === "TSTypeLiteral" || M.type === "GenericTypeAnnotation" || M.type === "TSTypeReference");
              if (b.types.length - 1 === B && k) return true;
            }
            return false;
          }
          function D(b, B, k) {
            let M = B.semi ? ";" : "", R = b.getValue(), q = [];
            return q.push("opaque type ", k("id"), k("typeParameters")), R.supertype && q.push(": ", k("supertype")), R.impltype && q.push(" = ", k("impltype")), q.push(M), q;
          }
          function T(b, B, k) {
            let M = B.semi ? ";" : "", R = b.getValue(), q = [];
            R.declare && q.push("declare "), q.push("type ", k("id"), k("typeParameters"));
            let J = R.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
            return [N(b, B, k, q, " =", J), M];
          }
          function m(b, B, k) {
            let M = b.getValue(), R = b.map(k, "types"), q = [], J = false;
            for (let L = 0; L < R.length; ++L) L === 0 ? q.push(R[L]) : F(M.types[L - 1]) && F(M.types[L]) ? q.push([" & ", J ? p(R[L]) : R[L]]) : !F(M.types[L - 1]) && !F(M.types[L]) ? q.push(p([" &", i, R[L]])) : (L > 1 && (J = true), q.push(" & ", L > 1 ? p(R[L]) : R[L]));
            return n2(q);
          }
          function C(b, B, k) {
            let M = b.getValue(), R = b.getParentNode(), q = R.type !== "TypeParameterInstantiation" && R.type !== "TSTypeParameterInstantiation" && R.type !== "GenericTypeAnnotation" && R.type !== "TSTypeReference" && R.type !== "TSTypeAssertion" && R.type !== "TupleTypeAnnotation" && R.type !== "TSTupleType" && !(R.type === "FunctionTypeParam" && !R.name && b.getParentNode(1).this !== R) && !((R.type === "TypeAlias" || R.type === "VariableDeclarator" || R.type === "TSTypeAliasDeclaration") && _(B.originalText, M)), J = $(M), L = b.map((j) => {
              let Y = k();
              return J || (Y = y(2, Y)), t(j, Y, B);
            }, "types");
            if (J) return u(" | ", L);
            let Q = q && !_(B.originalText, M), V = [h3([Q ? i : "", "| "]), u([i, "| "], L)];
            return g(b, B) ? n2([p(V), l]) : R.type === "TupleTypeAnnotation" && R.types.length > 1 || R.type === "TSTupleType" && R.elementTypes.length > 1 ? n2([p([h3(["(", l]), V]), l, h3(")")]) : n2(q ? p(V) : V);
          }
          function o(b, B, k) {
            let M = b.getValue(), R = [], q = b.getParentNode(0), J = b.getParentNode(1), L = b.getParentNode(2), Q = M.type === "TSFunctionType" || !((q.type === "ObjectTypeProperty" || q.type === "ObjectTypeInternalSlot") && !q.variance && !q.optional && c(q) === c(M) || q.type === "ObjectTypeCallProperty" || L && L.type === "DeclareFunction"), V = Q && (q.type === "TypeAnnotation" || q.type === "TSTypeAnnotation"), j = V && Q && (q.type === "TypeAnnotation" || q.type === "TSTypeAnnotation") && J.type === "ArrowFunctionExpression";
            w(q) && (Q = true, V = true), j && R.push("(");
            let Y = x2(b, k, B, false, true), ie = M.returnType || M.predicate || M.typeAnnotation ? [Q ? " => " : ": ", k("returnType"), k("predicate"), k("typeAnnotation")] : "", ee = I(M, ie);
            return R.push(ee ? n2(Y) : Y), ie && R.push(ie), j && R.push(")"), n2(R);
          }
          function d(b, B, k) {
            let M = b.getValue(), R = M.type === "TSTupleType" ? "elementTypes" : "types", q = M[R], J = a(q), L = J ? l : "";
            return n2(["[", p([L, P(b, B, R, k)]), h3(J && E(B, "all") ? "," : ""), s(b, B, true), L, "]"]);
          }
          function v(b, B, k) {
            let M = b.getValue(), R = M.type === "OptionalIndexedAccessType" && M.optional ? "?.[" : "[";
            return [k("objectType"), R, k("indexType"), "]"];
          }
          function S(b, B, k) {
            let M = b.getValue();
            return [M.postfix ? "" : k, B("typeAnnotation"), M.postfix ? k : ""];
          }
          r.exports = { printOpaqueType: D, printTypeAlias: T, printIntersectionType: m, printUnionType: C, printFunctionType: o, printTupleType: d, printIndexedAccessType: v, shouldHugType: $, printJSDocType: S };
        } }), jr = te({ "src/language-js/print/type-parameters.js"(e2, r) {
          "use strict";
          ne();
          var { printDanglingComments: t } = et(), { builders: { join: s, line: a, hardline: n2, softline: u, group: i, indent: l, ifBreak: p } } = qe(), { isTestCall: y, hasComment: h3, CommentCheckFlags: g, isTSXFile: c, shouldPrintComma: f, getFunctionParameters: F, isObjectType: _, getTypeScriptMappedTypeModifier: w } = Ke(), { createGroupIdMapper: E } = Ue(), { shouldHugType: N } = Or(), { isArrowFunctionVariableDeclarator: x2 } = tr(), I = E("typeParameters");
          function P(T, m, C, o) {
            let d = T.getValue();
            if (!d[o]) return "";
            if (!Array.isArray(d[o])) return C(o);
            let v = T.getNode(2), S = v && y(v), b = T.match((M) => !(M[o].length === 1 && _(M[o][0])), void 0, (M, R) => R === "typeAnnotation", (M) => M.type === "Identifier", x2);
            if (d[o].length === 0 || !b && (S || d[o].length === 1 && (d[o][0].type === "NullableTypeAnnotation" || N(d[o][0])))) return ["<", s(", ", T.map(C, o)), $(T, m), ">"];
            let k = d.type === "TSTypeParameterInstantiation" ? "" : F(d).length === 1 && c(m) && !d[o][0].constraint && T.getParentNode().type === "ArrowFunctionExpression" ? "," : f(m, "all") ? p(",") : "";
            return i(["<", l([u, s([",", a], T.map(C, o))]), k, u, ">"], { id: I(d) });
          }
          function $(T, m) {
            let C = T.getValue();
            if (!h3(C, g.Dangling)) return "";
            let o = !h3(C, g.Line), d = t(T, m, o);
            return o ? d : [d, n2];
          }
          function D(T, m, C) {
            let o = T.getValue(), d = [o.type === "TSTypeParameter" && o.const ? "const " : ""], v = T.getParentNode();
            return v.type === "TSMappedType" ? (v.readonly && d.push(w(v.readonly, "readonly"), " "), d.push("[", C("name")), o.constraint && d.push(" in ", C("constraint")), v.nameType && d.push(" as ", T.callParent(() => C("nameType"))), d.push("]"), d) : (o.variance && d.push(C("variance")), o.in && d.push("in "), o.out && d.push("out "), d.push(C("name")), o.bound && d.push(": ", C("bound")), o.constraint && d.push(" extends ", C("constraint")), o.default && d.push(" = ", C("default")), d);
          }
          r.exports = { printTypeParameter: D, printTypeParameters: P, getTypeParametersGroupId: I };
        } }), rr = te({ "src/language-js/print/property.js"(e2, r) {
          "use strict";
          ne();
          var { printComments: t } = et(), { printString: s, printNumber: a } = Ue(), { isNumericLiteral: n2, isSimpleNumber: u, isStringLiteral: i, isStringPropSafeToUnquote: l, rawText: p } = Ke(), { printAssignment: y } = tr(), h3 = /* @__PURE__ */ new WeakMap();
          function g(f, F, _) {
            let w = f.getNode();
            if (w.computed) return ["[", _("key"), "]"];
            let E = f.getParentNode(), { key: N } = w;
            if (F.quoteProps === "consistent" && !h3.has(E)) {
              let x2 = (E.properties || E.body || E.members).some((I) => !I.computed && I.key && i(I.key) && !l(I, F));
              h3.set(E, x2);
            }
            if ((N.type === "Identifier" || n2(N) && u(a(p(N))) && String(N.value) === a(p(N)) && !(F.parser === "typescript" || F.parser === "babel-ts")) && (F.parser === "json" || F.quoteProps === "consistent" && h3.get(E))) {
              let x2 = s(JSON.stringify(N.type === "Identifier" ? N.name : N.value.toString()), F);
              return f.call((I) => t(I, x2, F), "key");
            }
            return l(w, F) && (F.quoteProps === "as-needed" || F.quoteProps === "consistent" && !h3.get(E)) ? f.call((x2) => t(x2, /^\d/.test(N.value) ? a(N.value) : N.value, F), "key") : _("key");
          }
          function c(f, F, _) {
            return f.getValue().shorthand ? _("value") : y(f, F, _, g(f, F, _), ":", "value");
          }
          r.exports = { printProperty: c, printPropertyKey: g };
        } }), qr = te({ "src/language-js/print/function.js"(e2, r) {
          "use strict";
          ne();
          var t = Zt(), { printDanglingComments: s, printCommentsSeparately: a } = et(), n2 = lt(), { getNextNonSpaceNonCommentCharacterIndex: u } = Ue(), { builders: { line: i, softline: l, group: p, indent: y, ifBreak: h3, hardline: g, join: c, indentIfBreak: f }, utils: { removeLines: F, willBreak: _ } } = qe(), { ArgExpansionBailout: w } = Qt(), { getFunctionParameters: E, hasLeadingOwnLineComment: N, isFlowAnnotationComment: x2, isJsxNode: I, isTemplateOnItsOwnLine: P, shouldPrintComma: $, startsWithNoLookaheadToken: D, isBinaryish: T, isLineComment: m, hasComment: C, getComments: o, CommentCheckFlags: d, isCallLikeExpression: v, isCallExpression: S, getCallArguments: b, hasNakedLeftSide: B, getLeftSide: k } = Ke(), { locEnd: M } = ut(), { printFunctionParameters: R, shouldGroupFunctionParameters: q } = Lr(), { printPropertyKey: J } = rr(), { printFunctionTypeParameters: L } = ct();
          function Q(U, Z, se, fe) {
            let ge = U.getValue(), he = false;
            if ((ge.type === "FunctionDeclaration" || ge.type === "FunctionExpression") && fe && fe.expandLastArg) {
              let Pe = U.getParentNode();
              S(Pe) && b(Pe).length > 1 && (he = true);
            }
            let we = [];
            ge.type === "TSDeclareFunction" && ge.declare && we.push("declare "), ge.async && we.push("async "), ge.generator ? we.push("function* ") : we.push("function "), ge.id && we.push(Z("id"));
            let ke = R(U, Z, se, he), Re = K(U, Z, se), Ne = q(ge, Re);
            return we.push(L(U, se, Z), p([Ne ? p(ke) : ke, Re]), ge.body ? " " : "", Z("body")), se.semi && (ge.declare || !ge.body) && we.push(";"), we;
          }
          function V(U, Z, se) {
            let fe = U.getNode(), { kind: ge } = fe, he = fe.value || fe, we = [];
            return !ge || ge === "init" || ge === "method" || ge === "constructor" ? he.async && we.push("async ") : (t.ok(ge === "get" || ge === "set"), we.push(ge, " ")), he.generator && we.push("*"), we.push(J(U, Z, se), fe.optional || fe.key.optional ? "?" : ""), fe === he ? we.push(j(U, Z, se)) : he.type === "FunctionExpression" ? we.push(U.call((ke) => j(ke, Z, se), "value")) : we.push(se("value")), we;
          }
          function j(U, Z, se) {
            let fe = U.getNode(), ge = R(U, se, Z), he = K(U, se, Z), we = q(fe, he), ke = [L(U, Z, se), p([we ? p(ge) : ge, he])];
            return fe.body ? ke.push(" ", se("body")) : ke.push(Z.semi ? ";" : ""), ke;
          }
          function Y(U, Z, se, fe) {
            let ge = U.getValue(), he = [];
            if (ge.async && he.push("async "), W(U, Z)) he.push(se(["params", 0]));
            else {
              let ke = fe && (fe.expandLastArg || fe.expandFirstArg), Re = K(U, se, Z);
              if (ke) {
                if (_(Re)) throw new w();
                Re = p(F(Re));
              }
              he.push(p([R(U, se, Z, ke, true), Re]));
            }
            let we = s(U, Z, true, (ke) => {
              let Re = u(Z.originalText, ke, M);
              return Re !== false && Z.originalText.slice(Re, Re + 2) === "=>";
            });
            return we && he.push(" ", we), he;
          }
          function ie(U, Z, se, fe, ge, he) {
            let we = U.getName(), ke = U.getParentNode(), Re = v(ke) && we === "callee", Ne = Boolean(Z && Z.assignmentLayout), Pe = he.body.type !== "BlockStatement" && he.body.type !== "ObjectExpression" && he.body.type !== "SequenceExpression", oe = Re && Pe || Z && Z.assignmentLayout === "chain-tail-arrow-chain", H = Symbol("arrow-chain");
            return he.body.type === "SequenceExpression" && (ge = p(["(", y([l, ge]), l, ")"])), p([p(y([Re || Ne ? l : "", p(c([" =>", i], se), { shouldBreak: fe })]), { id: H, shouldBreak: oe }), " =>", f(Pe ? y([i, ge]) : [" ", ge], { groupId: H }), Re ? h3(l, "", { groupId: H }) : ""]);
          }
          function ee(U, Z, se, fe) {
            let ge = U.getValue(), he = [], we = [], ke = false;
            if (function H() {
              let pe = Y(U, Z, se, fe);
              if (he.length === 0) he.push(pe);
              else {
                let { leading: X, trailing: le } = a(U, Z);
                he.push([X, pe]), we.unshift(le);
              }
              ke = ke || ge.returnType && E(ge).length > 0 || ge.typeParameters || E(ge).some((X) => X.type !== "Identifier"), ge.body.type !== "ArrowFunctionExpression" || fe && fe.expandLastArg ? we.unshift(se("body", fe)) : (ge = ge.body, U.call(H, "body"));
            }(), he.length > 1) return ie(U, fe, he, ke, we, ge);
            let Re = he;
            if (Re.push(" =>"), !N(Z.originalText, ge.body) && (ge.body.type === "ArrayExpression" || ge.body.type === "ObjectExpression" || ge.body.type === "BlockStatement" || I(ge.body) || P(ge.body, Z.originalText) || ge.body.type === "ArrowFunctionExpression" || ge.body.type === "DoExpression")) return p([...Re, " ", we]);
            if (ge.body.type === "SequenceExpression") return p([...Re, p([" (", y([l, we]), l, ")"])]);
            let Ne = (fe && fe.expandLastArg || U.getParentNode().type === "JSXExpressionContainer") && !C(ge), Pe = fe && fe.expandLastArg && $(Z, "all"), oe = ge.body.type === "ConditionalExpression" && !D(ge.body, (H) => H.type === "ObjectExpression");
            return p([...Re, p([y([i, oe ? h3("", "(") : "", we, oe ? h3("", ")") : ""]), Ne ? [h3(Pe ? "," : ""), l] : ""])]);
          }
          function ce(U) {
            let Z = E(U);
            return Z.length === 1 && !U.typeParameters && !C(U, d.Dangling) && Z[0].type === "Identifier" && !Z[0].typeAnnotation && !C(Z[0]) && !Z[0].optional && !U.predicate && !U.returnType;
          }
          function W(U, Z) {
            if (Z.arrowParens === "always") return false;
            if (Z.arrowParens === "avoid") {
              let se = U.getValue();
              return ce(se);
            }
            return false;
          }
          function K(U, Z, se) {
            let fe = U.getValue(), ge = Z("returnType");
            if (fe.returnType && x2(se.originalText, fe.returnType)) return [" /*: ", ge, " */"];
            let he = [ge];
            return fe.returnType && fe.returnType.typeAnnotation && he.unshift(": "), fe.predicate && he.push(fe.returnType ? " " : ": ", Z("predicate")), he;
          }
          function de(U, Z, se) {
            let fe = U.getValue(), ge = Z.semi ? ";" : "", he = [];
            fe.argument && (z(Z, fe.argument) ? he.push([" (", y([g, se("argument")]), g, ")"]) : T(fe.argument) || fe.argument.type === "SequenceExpression" ? he.push(p([h3(" (", " "), y([l, se("argument")]), l, h3(")")])) : he.push(" ", se("argument")));
            let we = o(fe), ke = n2(we), Re = ke && m(ke);
            return Re && he.push(ge), C(fe, d.Dangling) && he.push(" ", s(U, Z, true)), Re || he.push(ge), he;
          }
          function ue(U, Z, se) {
            return ["return", de(U, Z, se)];
          }
          function Fe(U, Z, se) {
            return ["throw", de(U, Z, se)];
          }
          function z(U, Z) {
            if (N(U.originalText, Z)) return true;
            if (B(Z)) {
              let se = Z, fe;
              for (; fe = k(se); ) if (se = fe, N(U.originalText, se)) return true;
            }
            return false;
          }
          r.exports = { printFunction: Q, printArrowFunction: ee, printMethod: V, printReturnStatement: ue, printThrowStatement: Fe, printMethodInternal: j, shouldPrintParamsWithoutParens: W };
        } }), nu = te({ "src/language-js/print/decorators.js"(e2, r) {
          "use strict";
          ne();
          var { isNonEmptyArray: t, hasNewline: s } = Ue(), { builders: { line: a, hardline: n2, join: u, breakParent: i, group: l } } = qe(), { locStart: p, locEnd: y } = ut(), { getParentExportDeclaration: h3 } = Ke();
          function g(w, E, N) {
            let x2 = w.getValue();
            return l([u(a, w.map(N, "decorators")), F(x2, E) ? n2 : a]);
          }
          function c(w, E, N) {
            return [u(n2, w.map(N, "declaration", "decorators")), n2];
          }
          function f(w, E, N) {
            let x2 = w.getValue(), { decorators: I } = x2;
            if (!t(I) || _(w.getParentNode())) return;
            let P = x2.type === "ClassExpression" || x2.type === "ClassDeclaration" || F(x2, E);
            return [h3(w) ? n2 : P ? i : "", u(a, w.map(N, "decorators")), a];
          }
          function F(w, E) {
            return w.decorators.some((N) => s(E.originalText, y(N)));
          }
          function _(w) {
            if (w.type !== "ExportDefaultDeclaration" && w.type !== "ExportNamedDeclaration" && w.type !== "DeclareExportDeclaration") return false;
            let E = w.declaration && w.declaration.decorators;
            return t(E) && p(w) === p(E[0]);
          }
          r.exports = { printDecorators: f, printClassMemberDecorators: g, printDecoratorsBeforeExport: c, hasDecoratorsBeforeExport: _ };
        } }), nr = te({ "src/language-js/print/class.js"(e2, r) {
          "use strict";
          ne();
          var { isNonEmptyArray: t, createGroupIdMapper: s } = Ue(), { printComments: a, printDanglingComments: n2 } = et(), { builders: { join: u, line: i, hardline: l, softline: p, group: y, indent: h3, ifBreak: g } } = qe(), { hasComment: c, CommentCheckFlags: f } = Ke(), { getTypeParametersGroupId: F } = jr(), { printMethod: _ } = qr(), { printOptionalToken: w, printTypeAnnotation: E, printDefiniteToken: N } = ct(), { printPropertyKey: x2 } = rr(), { printAssignment: I } = tr(), { printClassMemberDecorators: P } = nu();
          function $(b, B, k) {
            let M = b.getValue(), R = [];
            M.declare && R.push("declare "), M.abstract && R.push("abstract "), R.push("class");
            let q = M.id && c(M.id, f.Trailing) || M.typeParameters && c(M.typeParameters, f.Trailing) || M.superClass && c(M.superClass) || t(M.extends) || t(M.mixins) || t(M.implements), J = [], L = [];
            if (M.id && J.push(" ", k("id")), J.push(k("typeParameters")), M.superClass) {
              let Q = [d(b, B, k), k("superTypeParameters")], V = b.call((j) => ["extends ", a(j, Q, B)], "superClass");
              q ? L.push(i, y(V)) : L.push(" ", V);
            } else L.push(o(b, B, k, "extends"));
            if (L.push(o(b, B, k, "mixins"), o(b, B, k, "implements")), q) {
              let Q;
              C(M) ? Q = [...J, h3(L)] : Q = h3([...J, L]), R.push(y(Q, { id: D(M) }));
            } else R.push(...J, ...L);
            return R.push(" ", k("body")), R;
          }
          var D = s("heritageGroup");
          function T(b) {
            return g(l, "", { groupId: D(b) });
          }
          function m(b) {
            return ["superClass", "extends", "mixins", "implements"].filter((B) => Boolean(b[B])).length > 1;
          }
          function C(b) {
            return b.typeParameters && !c(b.typeParameters, f.Trailing | f.Line) && !m(b);
          }
          function o(b, B, k, M) {
            let R = b.getValue();
            if (!t(R[M])) return "";
            let q = n2(b, B, true, (J) => {
              let { marker: L } = J;
              return L === M;
            });
            return [C(R) ? g(" ", i, { groupId: F(R.typeParameters) }) : i, q, q && l, M, y(h3([i, u([",", i], b.map(k, M))]))];
          }
          function d(b, B, k) {
            let M = k("superClass");
            return b.getParentNode().type === "AssignmentExpression" ? y(g(["(", h3([p, M]), p, ")"], M)) : M;
          }
          function v(b, B, k) {
            let M = b.getValue(), R = [];
            return t(M.decorators) && R.push(P(b, B, k)), M.accessibility && R.push(M.accessibility + " "), M.readonly && R.push("readonly "), M.declare && R.push("declare "), M.static && R.push("static "), (M.type === "TSAbstractMethodDefinition" || M.abstract) && R.push("abstract "), M.override && R.push("override "), R.push(_(b, B, k)), R;
          }
          function S(b, B, k) {
            let M = b.getValue(), R = [], q = B.semi ? ";" : "";
            return t(M.decorators) && R.push(P(b, B, k)), M.accessibility && R.push(M.accessibility + " "), M.declare && R.push("declare "), M.static && R.push("static "), (M.type === "TSAbstractPropertyDefinition" || M.type === "TSAbstractAccessorProperty" || M.abstract) && R.push("abstract "), M.override && R.push("override "), M.readonly && R.push("readonly "), M.variance && R.push(k("variance")), (M.type === "ClassAccessorProperty" || M.type === "AccessorProperty" || M.type === "TSAbstractAccessorProperty") && R.push("accessor "), R.push(x2(b, B, k), w(b), N(b), E(b, B, k)), [I(b, B, k, R, " =", "value"), q];
          }
          r.exports = { printClass: $, printClassMethod: v, printClassProperty: S, printHardlineAfterHeritage: T };
        } }), bo = te({ "src/language-js/print/interface.js"(e2, r) {
          "use strict";
          ne();
          var { isNonEmptyArray: t } = Ue(), { builders: { join: s, line: a, group: n2, indent: u, ifBreak: i } } = qe(), { hasComment: l, identity: p, CommentCheckFlags: y } = Ke(), { getTypeParametersGroupId: h3 } = jr(), { printTypeScriptModifiers: g } = ct();
          function c(f, F, _) {
            let w = f.getValue(), E = [];
            w.declare && E.push("declare "), w.type === "TSInterfaceDeclaration" && E.push(w.abstract ? "abstract " : "", g(f, F, _)), E.push("interface");
            let N = [], x2 = [];
            w.type !== "InterfaceTypeAnnotation" && N.push(" ", _("id"), _("typeParameters"));
            let I = w.typeParameters && !l(w.typeParameters, y.Trailing | y.Line);
            return t(w.extends) && x2.push(I ? i(" ", a, { groupId: h3(w.typeParameters) }) : a, "extends ", (w.extends.length === 1 ? p : u)(s([",", a], f.map(_, "extends")))), w.id && l(w.id, y.Trailing) || t(w.extends) ? I ? E.push(n2([...N, u(x2)])) : E.push(n2(u([...N, ...x2]))) : E.push(...N, ...x2), E.push(" ", _("body")), n2(E);
          }
          r.exports = { printInterface: c };
        } }), To = te({ "src/language-js/print/module.js"(e2, r) {
          "use strict";
          ne();
          var { isNonEmptyArray: t } = Ue(), { builders: { softline: s, group: a, indent: n2, join: u, line: i, ifBreak: l, hardline: p } } = qe(), { printDanglingComments: y } = et(), { hasComment: h3, CommentCheckFlags: g, shouldPrintComma: c, needsHardlineAfterDanglingComment: f, isStringLiteral: F, rawText: _ } = Ke(), { locStart: w, hasSameLoc: E } = ut(), { hasDecoratorsBeforeExport: N, printDecoratorsBeforeExport: x2 } = nu();
          function I(S, b, B) {
            let k = S.getValue(), M = b.semi ? ";" : "", R = [], { importKind: q } = k;
            return R.push("import"), q && q !== "value" && R.push(" ", q), R.push(m(S, b, B), T(S, b, B), o(S, b, B), M), R;
          }
          function P(S, b, B) {
            let k = S.getValue(), M = [];
            N(k) && M.push(x2(S, b, B));
            let { type: R, exportKind: q, declaration: J } = k;
            return M.push("export"), (k.default || R === "ExportDefaultDeclaration") && M.push(" default"), h3(k, g.Dangling) && (M.push(" ", y(S, b, true)), f(k) && M.push(p)), J ? M.push(" ", B("declaration")) : M.push(q === "type" ? " type" : "", m(S, b, B), T(S, b, B), o(S, b, B)), D(k, b) && M.push(";"), M;
          }
          function $(S, b, B) {
            let k = S.getValue(), M = b.semi ? ";" : "", R = [], { exportKind: q, exported: J } = k;
            return R.push("export"), q === "type" && R.push(" type"), R.push(" *"), J && R.push(" as ", B("exported")), R.push(T(S, b, B), o(S, b, B), M), R;
          }
          function D(S, b) {
            if (!b.semi) return false;
            let { type: B, declaration: k } = S, M = S.default || B === "ExportDefaultDeclaration";
            if (!k) return true;
            let { type: R } = k;
            return !!(M && R !== "ClassDeclaration" && R !== "FunctionDeclaration" && R !== "TSInterfaceDeclaration" && R !== "DeclareClass" && R !== "DeclareFunction" && R !== "TSDeclareFunction" && R !== "EnumDeclaration");
          }
          function T(S, b, B) {
            let k = S.getValue();
            if (!k.source) return "";
            let M = [];
            return C(k, b) || M.push(" from"), M.push(" ", B("source")), M;
          }
          function m(S, b, B) {
            let k = S.getValue();
            if (C(k, b)) return "";
            let M = [" "];
            if (t(k.specifiers)) {
              let R = [], q = [];
              S.each(() => {
                let J = S.getValue().type;
                if (J === "ExportNamespaceSpecifier" || J === "ExportDefaultSpecifier" || J === "ImportNamespaceSpecifier" || J === "ImportDefaultSpecifier") R.push(B());
                else if (J === "ExportSpecifier" || J === "ImportSpecifier") q.push(B());
                else throw new Error(`Unknown specifier type ${JSON.stringify(J)}`);
              }, "specifiers"), M.push(u(", ", R)), q.length > 0 && (R.length > 0 && M.push(", "), q.length > 1 || R.length > 0 || k.specifiers.some((L) => h3(L)) ? M.push(a(["{", n2([b.bracketSpacing ? i : s, u([",", i], q)]), l(c(b) ? "," : ""), b.bracketSpacing ? i : s, "}"])) : M.push(["{", b.bracketSpacing ? " " : "", ...q, b.bracketSpacing ? " " : "", "}"]));
            } else M.push("{}");
            return M;
          }
          function C(S, b) {
            let { type: B, importKind: k, source: M, specifiers: R } = S;
            return B !== "ImportDeclaration" || t(R) || k === "type" ? false : !/{\s*}/.test(b.originalText.slice(w(S), w(M)));
          }
          function o(S, b, B) {
            let k = S.getNode();
            return t(k.assertions) ? [" assert {", b.bracketSpacing ? " " : "", u(", ", S.map(B, "assertions")), b.bracketSpacing ? " " : "", "}"] : "";
          }
          function d(S, b, B) {
            let k = S.getNode(), { type: M } = k, R = [], q = M === "ImportSpecifier" ? k.importKind : k.exportKind;
            q && q !== "value" && R.push(q, " ");
            let J = M.startsWith("Import"), L = J ? "imported" : "local", Q = J ? "local" : "exported", V = k[L], j = k[Q], Y = "", ie = "";
            return M === "ExportNamespaceSpecifier" || M === "ImportNamespaceSpecifier" ? Y = "*" : V && (Y = B(L)), j && !v(k) && (ie = B(Q)), R.push(Y, Y && ie ? " as " : "", ie), R;
          }
          function v(S) {
            if (S.type !== "ImportSpecifier" && S.type !== "ExportSpecifier") return false;
            let { local: b, [S.type === "ImportSpecifier" ? "imported" : "exported"]: B } = S;
            if (b.type !== B.type || !E(b, B)) return false;
            if (F(b)) return b.value === B.value && _(b) === _(B);
            switch (b.type) {
              case "Identifier":
                return b.name === B.name;
              default:
                return false;
            }
          }
          r.exports = { printImportDeclaration: I, printExportDeclaration: P, printExportAllDeclaration: $, printModuleSpecifier: d };
        } }), uu = te({ "src/language-js/print/object.js"(e2, r) {
          "use strict";
          ne();
          var { printDanglingComments: t } = et(), { builders: { line: s, softline: a, group: n2, indent: u, ifBreak: i, hardline: l } } = qe(), { getLast: p, hasNewlineInRange: y, hasNewline: h3, isNonEmptyArray: g } = Ue(), { shouldPrintComma: c, hasComment: f, getComments: F, CommentCheckFlags: _, isNextLineEmpty: w } = Ke(), { locStart: E, locEnd: N } = ut(), { printOptionalToken: x2, printTypeAnnotation: I } = ct(), { shouldHugFunctionParameters: P } = Lr(), { shouldHugType: $ } = Or(), { printHardlineAfterHeritage: D } = nr();
          function T(m, C, o) {
            let d = C.semi ? ";" : "", v = m.getValue(), S;
            v.type === "TSTypeLiteral" ? S = "members" : v.type === "TSInterfaceBody" ? S = "body" : S = "properties";
            let b = v.type === "ObjectTypeAnnotation", B = [S];
            b && B.push("indexers", "callProperties", "internalSlots");
            let k = B.map((W) => v[W][0]).sort((W, K) => E(W) - E(K))[0], M = m.getParentNode(0), R = b && M && (M.type === "InterfaceDeclaration" || M.type === "DeclareInterface" || M.type === "DeclareClass") && m.getName() === "body", q = v.type === "TSInterfaceBody" || R || v.type === "ObjectPattern" && M.type !== "FunctionDeclaration" && M.type !== "FunctionExpression" && M.type !== "ArrowFunctionExpression" && M.type !== "ObjectMethod" && M.type !== "ClassMethod" && M.type !== "ClassPrivateMethod" && M.type !== "AssignmentPattern" && M.type !== "CatchClause" && v.properties.some((W) => W.value && (W.value.type === "ObjectPattern" || W.value.type === "ArrayPattern")) || v.type !== "ObjectPattern" && k && y(C.originalText, E(v), E(k)), J = R ? ";" : v.type === "TSInterfaceBody" || v.type === "TSTypeLiteral" ? i(d, ";") : ",", L = v.type === "RecordExpression" ? "#{" : v.exact ? "{|" : "{", Q = v.exact ? "|}" : "}", V = [];
            for (let W of B) m.each((K) => {
              let de = K.getValue();
              V.push({ node: de, printed: o(), loc: E(de) });
            }, W);
            B.length > 1 && V.sort((W, K) => W.loc - K.loc);
            let j = [], Y = V.map((W) => {
              let K = [...j, n2(W.printed)];
              return j = [J, s], (W.node.type === "TSPropertySignature" || W.node.type === "TSMethodSignature" || W.node.type === "TSConstructSignatureDeclaration") && f(W.node, _.PrettierIgnore) && j.shift(), w(W.node, C) && j.push(l), K;
            });
            if (v.inexact) {
              let W;
              if (f(v, _.Dangling)) {
                let K = f(v, _.Line);
                W = [t(m, C, true), K || h3(C.originalText, N(p(F(v)))) ? l : s, "..."];
              } else W = ["..."];
              Y.push([...j, ...W]);
            }
            let ie = p(v[S]), ee = !(v.inexact || ie && ie.type === "RestElement" || ie && (ie.type === "TSPropertySignature" || ie.type === "TSCallSignatureDeclaration" || ie.type === "TSMethodSignature" || ie.type === "TSConstructSignatureDeclaration") && f(ie, _.PrettierIgnore)), ce;
            if (Y.length === 0) {
              if (!f(v, _.Dangling)) return [L, Q, I(m, C, o)];
              ce = n2([L, t(m, C), a, Q, x2(m), I(m, C, o)]);
            } else ce = [R && g(v.properties) ? D(M) : "", L, u([C.bracketSpacing ? s : a, ...Y]), i(ee && (J !== "," || c(C)) ? J : ""), C.bracketSpacing ? s : a, Q, x2(m), I(m, C, o)];
            return m.match((W) => W.type === "ObjectPattern" && !W.decorators, (W, K, de) => P(W) && (K === "params" || K === "parameters" || K === "this" || K === "rest") && de === 0) || m.match($, (W, K) => K === "typeAnnotation", (W, K) => K === "typeAnnotation", (W, K, de) => P(W) && (K === "params" || K === "parameters" || K === "this" || K === "rest") && de === 0) || !q && m.match((W) => W.type === "ObjectPattern", (W) => W.type === "AssignmentExpression" || W.type === "VariableDeclarator") ? ce : n2(ce, { shouldBreak: q });
          }
          r.exports = { printObject: T };
        } }), dd = te({ "src/language-js/print/flow.js"(e2, r) {
          "use strict";
          ne();
          var t = Zt(), { printDanglingComments: s } = et(), { printString: a, printNumber: n2 } = Ue(), { builders: { hardline: u, softline: i, group: l, indent: p } } = qe(), { getParentExportDeclaration: y, isFunctionNotation: h3, isGetterOrSetter: g, rawText: c, shouldPrintComma: f } = Ke(), { locStart: F, locEnd: _ } = ut(), { replaceTextEndOfLine: w } = Yt(), { printClass: E } = nr(), { printOpaqueType: N, printTypeAlias: x2, printIntersectionType: I, printUnionType: P, printFunctionType: $, printTupleType: D, printIndexedAccessType: T } = Or(), { printInterface: m } = bo(), { printTypeParameter: C, printTypeParameters: o } = jr(), { printExportDeclaration: d, printExportAllDeclaration: v } = To(), { printArrayItems: S } = er(), { printObject: b } = uu(), { printPropertyKey: B } = rr(), { printOptionalToken: k, printTypeAnnotation: M, printRestSpread: R } = ct();
          function q(L, Q, V) {
            let j = L.getValue(), Y = Q.semi ? ";" : "", ie = [];
            switch (j.type) {
              case "DeclareClass":
                return J(L, E(L, Q, V));
              case "DeclareFunction":
                return J(L, ["function ", V("id"), j.predicate ? " " : "", V("predicate"), Y]);
              case "DeclareModule":
                return J(L, ["module ", V("id"), " ", V("body")]);
              case "DeclareModuleExports":
                return J(L, ["module.exports", ": ", V("typeAnnotation"), Y]);
              case "DeclareVariable":
                return J(L, ["var ", V("id"), Y]);
              case "DeclareOpaqueType":
                return J(L, N(L, Q, V));
              case "DeclareInterface":
                return J(L, m(L, Q, V));
              case "DeclareTypeAlias":
                return J(L, x2(L, Q, V));
              case "DeclareExportDeclaration":
                return J(L, d(L, Q, V));
              case "DeclareExportAllDeclaration":
                return J(L, v(L, Q, V));
              case "OpaqueType":
                return N(L, Q, V);
              case "TypeAlias":
                return x2(L, Q, V);
              case "IntersectionTypeAnnotation":
                return I(L, Q, V);
              case "UnionTypeAnnotation":
                return P(L, Q, V);
              case "FunctionTypeAnnotation":
                return $(L, Q, V);
              case "TupleTypeAnnotation":
                return D(L, Q, V);
              case "GenericTypeAnnotation":
                return [V("id"), o(L, Q, V, "typeParameters")];
              case "IndexedAccessType":
              case "OptionalIndexedAccessType":
                return T(L, Q, V);
              case "TypeAnnotation":
                return V("typeAnnotation");
              case "TypeParameter":
                return C(L, Q, V);
              case "TypeofTypeAnnotation":
                return ["typeof ", V("argument")];
              case "ExistsTypeAnnotation":
                return "*";
              case "EmptyTypeAnnotation":
                return "empty";
              case "MixedTypeAnnotation":
                return "mixed";
              case "ArrayTypeAnnotation":
                return [V("elementType"), "[]"];
              case "BooleanLiteralTypeAnnotation":
                return String(j.value);
              case "EnumDeclaration":
                return ["enum ", V("id"), " ", V("body")];
              case "EnumBooleanBody":
              case "EnumNumberBody":
              case "EnumStringBody":
              case "EnumSymbolBody": {
                if (j.type === "EnumSymbolBody" || j.explicitType) {
                  let ee = null;
                  switch (j.type) {
                    case "EnumBooleanBody":
                      ee = "boolean";
                      break;
                    case "EnumNumberBody":
                      ee = "number";
                      break;
                    case "EnumStringBody":
                      ee = "string";
                      break;
                    case "EnumSymbolBody":
                      ee = "symbol";
                      break;
                  }
                  ie.push("of ", ee, " ");
                }
                if (j.members.length === 0 && !j.hasUnknownMembers) ie.push(l(["{", s(L, Q), i, "}"]));
                else {
                  let ee = j.members.length > 0 ? [u, S(L, Q, "members", V), j.hasUnknownMembers || f(Q) ? "," : ""] : [];
                  ie.push(l(["{", p([...ee, ...j.hasUnknownMembers ? [u, "..."] : []]), s(L, Q, true), u, "}"]));
                }
                return ie;
              }
              case "EnumBooleanMember":
              case "EnumNumberMember":
              case "EnumStringMember":
                return [V("id"), " = ", typeof j.init == "object" ? V("init") : String(j.init)];
              case "EnumDefaultedMember":
                return V("id");
              case "FunctionTypeParam": {
                let ee = j.name ? V("name") : L.getParentNode().this === j ? "this" : "";
                return [ee, k(L), ee ? ": " : "", V("typeAnnotation")];
              }
              case "InterfaceDeclaration":
              case "InterfaceTypeAnnotation":
                return m(L, Q, V);
              case "ClassImplements":
              case "InterfaceExtends":
                return [V("id"), V("typeParameters")];
              case "NullableTypeAnnotation":
                return ["?", V("typeAnnotation")];
              case "Variance": {
                let { kind: ee } = j;
                return t.ok(ee === "plus" || ee === "minus"), ee === "plus" ? "+" : "-";
              }
              case "ObjectTypeCallProperty":
                return j.static && ie.push("static "), ie.push(V("value")), ie;
              case "ObjectTypeIndexer":
                return [j.static ? "static " : "", j.variance ? V("variance") : "", "[", V("id"), j.id ? ": " : "", V("key"), "]: ", V("value")];
              case "ObjectTypeProperty": {
                let ee = "";
                return j.proto ? ee = "proto " : j.static && (ee = "static "), [ee, g(j) ? j.kind + " " : "", j.variance ? V("variance") : "", B(L, Q, V), k(L), h3(j) ? "" : ": ", V("value")];
              }
              case "ObjectTypeAnnotation":
                return b(L, Q, V);
              case "ObjectTypeInternalSlot":
                return [j.static ? "static " : "", "[[", V("id"), "]]", k(L), j.method ? "" : ": ", V("value")];
              case "ObjectTypeSpreadProperty":
                return R(L, Q, V);
              case "QualifiedTypeofIdentifier":
              case "QualifiedTypeIdentifier":
                return [V("qualification"), ".", V("id")];
              case "StringLiteralTypeAnnotation":
                return w(a(c(j), Q));
              case "NumberLiteralTypeAnnotation":
                t.strictEqual(typeof j.value, "number");
              case "BigIntLiteralTypeAnnotation":
                return j.extra ? n2(j.extra.raw) : n2(j.raw);
              case "TypeCastExpression":
                return ["(", V("expression"), M(L, Q, V), ")"];
              case "TypeParameterDeclaration":
              case "TypeParameterInstantiation": {
                let ee = o(L, Q, V, "params");
                if (Q.parser === "flow") {
                  let ce = F(j), W = _(j), K = Q.originalText.lastIndexOf("/*", ce), de = Q.originalText.indexOf("*/", W);
                  if (K !== -1 && de !== -1) {
                    let ue = Q.originalText.slice(K + 2, de).trim();
                    if (ue.startsWith("::") && !ue.includes("/*") && !ue.includes("*/")) return ["/*:: ", ee, " */"];
                  }
                }
                return ee;
              }
              case "InferredPredicate":
                return "%checks";
              case "DeclaredPredicate":
                return ["%checks(", V("value"), ")"];
              case "AnyTypeAnnotation":
                return "any";
              case "BooleanTypeAnnotation":
                return "boolean";
              case "BigIntTypeAnnotation":
                return "bigint";
              case "NullLiteralTypeAnnotation":
                return "null";
              case "NumberTypeAnnotation":
                return "number";
              case "SymbolTypeAnnotation":
                return "symbol";
              case "StringTypeAnnotation":
                return "string";
              case "VoidTypeAnnotation":
                return "void";
              case "ThisTypeAnnotation":
                return "this";
              case "Node":
              case "Printable":
              case "SourceLocation":
              case "Position":
              case "Statement":
              case "Function":
              case "Pattern":
              case "Expression":
              case "Declaration":
              case "Specifier":
              case "NamedSpecifier":
              case "Comment":
              case "MemberTypeAnnotation":
              case "Type":
                throw new Error("unprintable type: " + JSON.stringify(j.type));
            }
          }
          function J(L, Q) {
            let V = y(L);
            return V ? (t.strictEqual(V.type, "DeclareExportDeclaration"), Q) : ["declare ", Q];
          }
          r.exports = { printFlow: q };
        } }), gd = te({ "src/language-js/utils/is-ts-keyword-type.js"(e2, r) {
          "use strict";
          ne();
          function t(s) {
            let { type: a } = s;
            return a.startsWith("TS") && a.endsWith("Keyword");
          }
          r.exports = t;
        } }), Bo = te({ "src/language-js/print/ternary.js"(e2, r) {
          "use strict";
          ne();
          var { hasNewlineInRange: t } = Ue(), { isJsxNode: s, getComments: a, isCallExpression: n2, isMemberExpression: u, isTSTypeExpression: i } = Ke(), { locStart: l, locEnd: p } = ut(), y = Pt(), { builders: { line: h3, softline: g, group: c, indent: f, align: F, ifBreak: _, dedent: w, breakParent: E } } = qe();
          function N(D) {
            let T = [D];
            for (let m = 0; m < T.length; m++) {
              let C = T[m];
              for (let o of ["test", "consequent", "alternate"]) {
                let d = C[o];
                if (s(d)) return true;
                d.type === "ConditionalExpression" && T.push(d);
              }
            }
            return false;
          }
          function x2(D, T, m) {
            let C = D.getValue(), o = C.type === "ConditionalExpression", d = o ? "alternate" : "falseType", v = D.getParentNode(), S = o ? m("test") : [m("checkType"), " ", "extends", " ", m("extendsType")];
            return v.type === C.type && v[d] === C ? F(2, S) : S;
          }
          var I = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
          function P(D) {
            let T = D.getValue();
            if (T.type !== "ConditionalExpression") return false;
            let m, C = T;
            for (let o = 0; !m; o++) {
              let d = D.getParentNode(o);
              if (n2(d) && d.callee === C || u(d) && d.object === C || d.type === "TSNonNullExpression" && d.expression === C) {
                C = d;
                continue;
              }
              d.type === "NewExpression" && d.callee === C || i(d) && d.expression === C ? (m = D.getParentNode(o + 1), C = d) : m = d;
            }
            return C === T ? false : m[I.get(m.type)] === C;
          }
          function $(D, T, m) {
            let C = D.getValue(), o = C.type === "ConditionalExpression", d = o ? "consequent" : "trueType", v = o ? "alternate" : "falseType", S = o ? ["test"] : ["checkType", "extendsType"], b = C[d], B = C[v], k = [], M = false, R = D.getParentNode(), q = R.type === C.type && S.some((ue) => R[ue] === C), J = R.type === C.type && !q, L, Q, V = 0;
            do
              Q = L || C, L = D.getParentNode(V), V++;
            while (L && L.type === C.type && S.every((ue) => L[ue] !== Q));
            let j = L || R, Y = Q;
            if (o && (s(C[S[0]]) || s(b) || s(B) || N(Y))) {
              M = true, J = true;
              let ue = (z) => [_("("), f([g, z]), g, _(")")], Fe = (z) => z.type === "NullLiteral" || z.type === "Literal" && z.value === null || z.type === "Identifier" && z.name === "undefined";
              k.push(" ? ", Fe(b) ? m(d) : ue(m(d)), " : ", B.type === C.type || Fe(B) ? m(v) : ue(m(v)));
            } else {
              let ue = [h3, "? ", b.type === C.type ? _("", "(") : "", F(2, m(d)), b.type === C.type ? _("", ")") : "", h3, ": ", B.type === C.type ? m(v) : F(2, m(v))];
              k.push(R.type !== C.type || R[v] === C || q ? ue : T.useTabs ? w(f(ue)) : F(Math.max(0, T.tabWidth - 2), ue));
            }
            let ee = [...S.map((ue) => a(C[ue])), a(b), a(B)].flat().some((ue) => y(ue) && t(T.originalText, l(ue), p(ue))), ce = (ue) => R === j ? c(ue, { shouldBreak: ee }) : ee ? [ue, E] : ue, W = !M && (u(R) || R.type === "NGPipeExpression" && R.left === C) && !R.computed, K = P(D), de = ce([x2(D, T, m), J ? k : f(k), o && W && !K ? g : ""]);
            return q || K ? c([f([g, de]), g]) : de;
          }
          r.exports = { printTernary: $ };
        } }), No = te({ "src/language-js/print/statement.js"(e2, r) {
          "use strict";
          ne();
          var { builders: { hardline: t } } = qe(), s = qt(), { getLeftSidePathName: a, hasNakedLeftSide: n2, isJsxNode: u, isTheOnlyJsxElementInMarkdown: i, hasComment: l, CommentCheckFlags: p, isNextLineEmpty: y } = Ke(), { shouldPrintParamsWithoutParens: h3 } = qr();
          function g(x2, I, P, $) {
            let D = x2.getValue(), T = [], m = D.type === "ClassBody", C = c(D[$]);
            return x2.each((o, d, v) => {
              let S = o.getValue();
              if (S.type === "EmptyStatement") return;
              let b = P();
              !I.semi && !m && !i(I, o) && f(o, I) ? l(S, p.Leading) ? T.push(P([], { needsSemi: true })) : T.push(";", b) : T.push(b), !I.semi && m && E(S) && N(S, v[d + 1]) && T.push(";"), S !== C && (T.push(t), y(S, I) && T.push(t));
            }, $), T;
          }
          function c(x2) {
            for (let I = x2.length - 1; I >= 0; I--) {
              let P = x2[I];
              if (P.type !== "EmptyStatement") return P;
            }
          }
          function f(x2, I) {
            return x2.getNode().type !== "ExpressionStatement" ? false : x2.call(($) => F($, I), "expression");
          }
          function F(x2, I) {
            let P = x2.getValue();
            switch (P.type) {
              case "ParenthesizedExpression":
              case "TypeCastExpression":
              case "ArrayExpression":
              case "ArrayPattern":
              case "TemplateLiteral":
              case "TemplateElement":
              case "RegExpLiteral":
                return true;
              case "ArrowFunctionExpression": {
                if (!h3(x2, I)) return true;
                break;
              }
              case "UnaryExpression": {
                let { prefix: $, operator: D } = P;
                if ($ && (D === "+" || D === "-")) return true;
                break;
              }
              case "BindExpression": {
                if (!P.object) return true;
                break;
              }
              case "Literal": {
                if (P.regex) return true;
                break;
              }
              default:
                if (u(P)) return true;
            }
            return s(x2, I) ? true : n2(P) ? x2.call(($) => F($, I), ...a(x2, P)) : false;
          }
          function _(x2, I, P) {
            return g(x2, I, P, "body");
          }
          function w(x2, I, P) {
            return g(x2, I, P, "consequent");
          }
          var E = (x2) => {
            let { type: I } = x2;
            return I === "ClassProperty" || I === "PropertyDefinition" || I === "ClassPrivateProperty" || I === "ClassAccessorProperty" || I === "AccessorProperty" || I === "TSAbstractPropertyDefinition" || I === "TSAbstractAccessorProperty";
          };
          function N(x2, I) {
            let { type: P, name: $ } = x2.key;
            if (!x2.computed && P === "Identifier" && ($ === "static" || $ === "get" || $ === "set" || $ === "accessor") && !x2.value && !x2.typeAnnotation) return true;
            if (!I || I.static || I.accessibility) return false;
            if (!I.computed) {
              let D = I.key && I.key.name;
              if (D === "in" || D === "instanceof") return true;
            }
            if (E(I) && I.variance && !I.static && !I.declare) return true;
            switch (I.type) {
              case "ClassProperty":
              case "PropertyDefinition":
              case "TSAbstractPropertyDefinition":
                return I.computed;
              case "MethodDefinition":
              case "TSAbstractMethodDefinition":
              case "ClassMethod":
              case "ClassPrivateMethod": {
                if ((I.value ? I.value.async : I.async) || I.kind === "get" || I.kind === "set") return false;
                let T = I.value ? I.value.generator : I.generator;
                return !!(I.computed || T);
              }
              case "TSIndexSignature":
                return true;
            }
            return false;
          }
          r.exports = { printBody: _, printSwitchCaseConsequent: w };
        } }), wo = te({ "src/language-js/print/block.js"(e2, r) {
          "use strict";
          ne();
          var { printDanglingComments: t } = et(), { isNonEmptyArray: s } = Ue(), { builders: { hardline: a, indent: n2 } } = qe(), { hasComment: u, CommentCheckFlags: i, isNextLineEmpty: l } = Ke(), { printHardlineAfterHeritage: p } = nr(), { printBody: y } = No();
          function h3(c, f, F) {
            let _ = c.getValue(), w = [];
            if (_.type === "StaticBlock" && w.push("static "), _.type === "ClassBody" && s(_.body)) {
              let N = c.getParentNode();
              w.push(p(N));
            }
            w.push("{");
            let E = g(c, f, F);
            if (E) w.push(n2([a, E]), a);
            else {
              let N = c.getParentNode(), x2 = c.getParentNode(1);
              N.type === "ArrowFunctionExpression" || N.type === "FunctionExpression" || N.type === "FunctionDeclaration" || N.type === "ObjectMethod" || N.type === "ClassMethod" || N.type === "ClassPrivateMethod" || N.type === "ForStatement" || N.type === "WhileStatement" || N.type === "DoWhileStatement" || N.type === "DoExpression" || N.type === "CatchClause" && !x2.finalizer || N.type === "TSModuleDeclaration" || N.type === "TSDeclareFunction" || _.type === "StaticBlock" || _.type === "ClassBody" || w.push(a);
            }
            return w.push("}"), w;
          }
          function g(c, f, F) {
            let _ = c.getValue(), w = s(_.directives), E = _.body.some((I) => I.type !== "EmptyStatement"), N = u(_, i.Dangling);
            if (!w && !E && !N) return "";
            let x2 = [];
            if (w && c.each((I, P, $) => {
              x2.push(F()), (P < $.length - 1 || E || N) && (x2.push(a), l(I.getValue(), f) && x2.push(a));
            }, "directives"), E && x2.push(y(c, f, F)), N && x2.push(t(c, f, true)), _.type === "Program") {
              let I = c.getParentNode();
              (!I || I.type !== "ModuleExpression") && x2.push(a);
            }
            return x2;
          }
          r.exports = { printBlock: h3, printBlockBody: g };
        } }), yd = te({ "src/language-js/print/typescript.js"(e2, r) {
          "use strict";
          ne();
          var { printDanglingComments: t } = et(), { hasNewlineInRange: s } = Ue(), { builders: { join: a, line: n2, hardline: u, softline: i, group: l, indent: p, conditionalGroup: y, ifBreak: h3 } } = qe(), { isStringLiteral: g, getTypeScriptMappedTypeModifier: c, shouldPrintComma: f, isCallExpression: F, isMemberExpression: _ } = Ke(), w = gd(), { locStart: E, locEnd: N } = ut(), { printOptionalToken: x2, printTypeScriptModifiers: I } = ct(), { printTernary: P } = Bo(), { printFunctionParameters: $, shouldGroupFunctionParameters: D } = Lr(), { printTemplateLiteral: T } = jt(), { printArrayItems: m } = er(), { printObject: C } = uu(), { printClassProperty: o, printClassMethod: d } = nr(), { printTypeParameter: v, printTypeParameters: S } = jr(), { printPropertyKey: b } = rr(), { printFunction: B, printMethodInternal: k } = qr(), { printInterface: M } = bo(), { printBlock: R } = wo(), { printTypeAlias: q, printIntersectionType: J, printUnionType: L, printFunctionType: Q, printTupleType: V, printIndexedAccessType: j, printJSDocType: Y } = Or();
          function ie(ee, ce, W) {
            let K = ee.getValue();
            if (!K.type.startsWith("TS")) return;
            if (w(K)) return K.type.slice(2, -7).toLowerCase();
            let de = ce.semi ? ";" : "", ue = [];
            switch (K.type) {
              case "TSThisType":
                return "this";
              case "TSTypeAssertion": {
                let Fe = !(K.expression.type === "ArrayExpression" || K.expression.type === "ObjectExpression"), z = l(["<", p([i, W("typeAnnotation")]), i, ">"]), U = [h3("("), p([i, W("expression")]), i, h3(")")];
                return Fe ? y([[z, W("expression")], [z, l(U, { shouldBreak: true })], [z, W("expression")]]) : l([z, W("expression")]);
              }
              case "TSDeclareFunction":
                return B(ee, W, ce);
              case "TSExportAssignment":
                return ["export = ", W("expression"), de];
              case "TSModuleBlock":
                return R(ee, ce, W);
              case "TSInterfaceBody":
              case "TSTypeLiteral":
                return C(ee, ce, W);
              case "TSTypeAliasDeclaration":
                return q(ee, ce, W);
              case "TSQualifiedName":
                return a(".", [W("left"), W("right")]);
              case "TSAbstractMethodDefinition":
              case "TSDeclareMethod":
                return d(ee, ce, W);
              case "TSAbstractAccessorProperty":
              case "TSAbstractPropertyDefinition":
                return o(ee, ce, W);
              case "TSInterfaceHeritage":
              case "TSExpressionWithTypeArguments":
                return ue.push(W("expression")), K.typeParameters && ue.push(W("typeParameters")), ue;
              case "TSTemplateLiteralType":
                return T(ee, W, ce);
              case "TSNamedTupleMember":
                return [W("label"), K.optional ? "?" : "", ": ", W("elementType")];
              case "TSRestType":
                return ["...", W("typeAnnotation")];
              case "TSOptionalType":
                return [W("typeAnnotation"), "?"];
              case "TSInterfaceDeclaration":
                return M(ee, ce, W);
              case "TSClassImplements":
                return [W("expression"), W("typeParameters")];
              case "TSTypeParameterDeclaration":
              case "TSTypeParameterInstantiation":
                return S(ee, ce, W, "params");
              case "TSTypeParameter":
                return v(ee, ce, W);
              case "TSSatisfiesExpression":
              case "TSAsExpression": {
                let Fe = K.type === "TSAsExpression" ? "as" : "satisfies";
                ue.push(W("expression"), ` ${Fe} `, W("typeAnnotation"));
                let z = ee.getParentNode();
                return F(z) && z.callee === K || _(z) && z.object === K ? l([p([i, ...ue]), i]) : ue;
              }
              case "TSArrayType":
                return [W("elementType"), "[]"];
              case "TSPropertySignature":
                return K.readonly && ue.push("readonly "), ue.push(b(ee, ce, W), x2(ee)), K.typeAnnotation && ue.push(": ", W("typeAnnotation")), K.initializer && ue.push(" = ", W("initializer")), ue;
              case "TSParameterProperty":
                return K.accessibility && ue.push(K.accessibility + " "), K.export && ue.push("export "), K.static && ue.push("static "), K.override && ue.push("override "), K.readonly && ue.push("readonly "), ue.push(W("parameter")), ue;
              case "TSTypeQuery":
                return ["typeof ", W("exprName"), W("typeParameters")];
              case "TSIndexSignature": {
                let Fe = ee.getParentNode(), z = K.parameters.length > 1 ? h3(f(ce) ? "," : "") : "", U = l([p([i, a([", ", i], ee.map(W, "parameters"))]), z, i]);
                return [K.export ? "export " : "", K.accessibility ? [K.accessibility, " "] : "", K.static ? "static " : "", K.readonly ? "readonly " : "", K.declare ? "declare " : "", "[", K.parameters ? U : "", K.typeAnnotation ? "]: " : "]", K.typeAnnotation ? W("typeAnnotation") : "", Fe.type === "ClassBody" ? de : ""];
              }
              case "TSTypePredicate":
                return [K.asserts ? "asserts " : "", W("parameterName"), K.typeAnnotation ? [" is ", W("typeAnnotation")] : ""];
              case "TSNonNullExpression":
                return [W("expression"), "!"];
              case "TSImportType":
                return [K.isTypeOf ? "typeof " : "", "import(", W(K.parameter ? "parameter" : "argument"), ")", K.qualifier ? [".", W("qualifier")] : "", S(ee, ce, W, "typeParameters")];
              case "TSLiteralType":
                return W("literal");
              case "TSIndexedAccessType":
                return j(ee, ce, W);
              case "TSConstructSignatureDeclaration":
              case "TSCallSignatureDeclaration":
              case "TSConstructorType": {
                if (K.type === "TSConstructorType" && K.abstract && ue.push("abstract "), K.type !== "TSCallSignatureDeclaration" && ue.push("new "), ue.push(l($(ee, W, ce, false, true))), K.returnType || K.typeAnnotation) {
                  let Fe = K.type === "TSConstructorType";
                  ue.push(Fe ? " => " : ": ", W("returnType"), W("typeAnnotation"));
                }
                return ue;
              }
              case "TSTypeOperator":
                return [K.operator, " ", W("typeAnnotation")];
              case "TSMappedType": {
                let Fe = s(ce.originalText, E(K), N(K));
                return l(["{", p([ce.bracketSpacing ? n2 : i, W("typeParameter"), K.optional ? c(K.optional, "?") : "", K.typeAnnotation ? ": " : "", W("typeAnnotation"), h3(de)]), t(ee, ce, true), ce.bracketSpacing ? n2 : i, "}"], { shouldBreak: Fe });
              }
              case "TSMethodSignature": {
                let Fe = K.kind && K.kind !== "method" ? `${K.kind} ` : "";
                ue.push(K.accessibility ? [K.accessibility, " "] : "", Fe, K.export ? "export " : "", K.static ? "static " : "", K.readonly ? "readonly " : "", K.abstract ? "abstract " : "", K.declare ? "declare " : "", K.computed ? "[" : "", W("key"), K.computed ? "]" : "", x2(ee));
                let z = $(ee, W, ce, false, true), U = K.returnType ? "returnType" : "typeAnnotation", Z = K[U], se = Z ? W(U) : "", fe = D(K, se);
                return ue.push(fe ? l(z) : z), Z && ue.push(": ", l(se)), l(ue);
              }
              case "TSNamespaceExportDeclaration":
                return ue.push("export as namespace ", W("id")), ce.semi && ue.push(";"), l(ue);
              case "TSEnumDeclaration":
                return K.declare && ue.push("declare "), K.modifiers && ue.push(I(ee, ce, W)), K.const && ue.push("const "), ue.push("enum ", W("id"), " "), K.members.length === 0 ? ue.push(l(["{", t(ee, ce), i, "}"])) : ue.push(l(["{", p([u, m(ee, ce, "members", W), f(ce, "es5") ? "," : ""]), t(ee, ce, true), u, "}"])), ue;
              case "TSEnumMember":
                return K.computed ? ue.push("[", W("id"), "]") : ue.push(W("id")), K.initializer && ue.push(" = ", W("initializer")), ue;
              case "TSImportEqualsDeclaration":
                return K.isExport && ue.push("export "), ue.push("import "), K.importKind && K.importKind !== "value" && ue.push(K.importKind, " "), ue.push(W("id"), " = ", W("moduleReference")), ce.semi && ue.push(";"), l(ue);
              case "TSExternalModuleReference":
                return ["require(", W("expression"), ")"];
              case "TSModuleDeclaration": {
                let Fe = ee.getParentNode(), z = g(K.id), U = Fe.type === "TSModuleDeclaration", Z = K.body && K.body.type === "TSModuleDeclaration";
                if (U) ue.push(".");
                else {
                  K.declare && ue.push("declare "), ue.push(I(ee, ce, W));
                  let se = ce.originalText.slice(E(K), E(K.id));
                  K.id.type === "Identifier" && K.id.name === "global" && !/namespace|module/.test(se) || ue.push(z || /(?:^|\s)module(?:\s|$)/.test(se) ? "module " : "namespace ");
                }
                return ue.push(W("id")), Z ? ue.push(W("body")) : K.body ? ue.push(" ", l(W("body"))) : ue.push(de), ue;
              }
              case "TSConditionalType":
                return P(ee, ce, W);
              case "TSInferType":
                return ["infer", " ", W("typeParameter")];
              case "TSIntersectionType":
                return J(ee, ce, W);
              case "TSUnionType":
                return L(ee, ce, W);
              case "TSFunctionType":
                return Q(ee, ce, W);
              case "TSTupleType":
                return V(ee, ce, W);
              case "TSTypeReference":
                return [W("typeName"), S(ee, ce, W, "typeParameters")];
              case "TSTypeAnnotation":
                return W("typeAnnotation");
              case "TSEmptyBodyFunctionExpression":
                return k(ee, ce, W);
              case "TSJSDocAllType":
                return "*";
              case "TSJSDocUnknownType":
                return "?";
              case "TSJSDocNullableType":
                return Y(ee, W, "?");
              case "TSJSDocNonNullableType":
                return Y(ee, W, "!");
              case "TSInstantiationExpression":
                return [W("expression"), W("typeParameters")];
              default:
                throw new Error(`Unknown TypeScript node type: ${JSON.stringify(K.type)}.`);
            }
          }
          r.exports = { printTypescript: ie };
        } }), hd = te({ "src/language-js/print/comment.js"(e2, r) {
          "use strict";
          ne();
          var { hasNewline: t } = Ue(), { builders: { join: s, hardline: a }, utils: { replaceTextEndOfLine: n2 } } = qe(), { isLineComment: u } = Ke(), { locStart: i, locEnd: l } = ut(), p = Pt();
          function y(c, f) {
            let F = c.getValue();
            if (u(F)) return f.originalText.slice(i(F), l(F)).trimEnd();
            if (p(F)) {
              if (h3(F)) {
                let E = g(F);
                return F.trailing && !t(f.originalText, i(F), { backwards: true }) ? [a, E] : E;
              }
              let _ = l(F), w = f.originalText.slice(_ - 3, _) === "*-/";
              return ["/*", n2(F.value), w ? "*-/" : "*/"];
            }
            throw new Error("Not a comment: " + JSON.stringify(F));
          }
          function h3(c) {
            let f = `*${c.value}*`.split(`
`);
            return f.length > 1 && f.every((F) => F.trim()[0] === "*");
          }
          function g(c) {
            let f = c.value.split(`
`);
            return ["/*", s(a, f.map((F, _) => _ === 0 ? F.trimEnd() : " " + (_ < f.length - 1 ? F.trim() : F.trimStart()))), "*/"];
          }
          r.exports = { printComment: y };
        } }), vd = te({ "src/language-js/print/literal.js"(e2, r) {
          "use strict";
          ne();
          var { printString: t, printNumber: s } = Ue(), { replaceTextEndOfLine: a } = Yt(), { printDirective: n2 } = ct();
          function u(y, h3) {
            let g = y.getNode();
            switch (g.type) {
              case "RegExpLiteral":
                return p(g);
              case "BigIntLiteral":
                return l(g.bigint || g.extra.raw);
              case "NumericLiteral":
                return s(g.extra.raw);
              case "StringLiteral":
                return a(t(g.extra.raw, h3));
              case "NullLiteral":
                return "null";
              case "BooleanLiteral":
                return String(g.value);
              case "DecimalLiteral":
                return s(g.value) + "m";
              case "Literal": {
                if (g.regex) return p(g.regex);
                if (g.bigint) return l(g.raw);
                if (g.decimal) return s(g.decimal) + "m";
                let { value: c } = g;
                return typeof c == "number" ? s(g.raw) : typeof c == "string" ? i(y) ? n2(g.raw, h3) : a(t(g.raw, h3)) : String(c);
              }
            }
          }
          function i(y) {
            if (y.getName() !== "expression") return;
            let h3 = y.getParentNode();
            return h3.type === "ExpressionStatement" && h3.directive;
          }
          function l(y) {
            return y.toLowerCase();
          }
          function p(y) {
            let { pattern: h3, flags: g } = y;
            return g = [...g].sort().join(""), `/${h3}/${g}`;
          }
          r.exports = { printLiteral: u };
        } }), Cd = te({ "src/language-js/printer-estree.js"(e2, r) {
          "use strict";
          ne();
          var { printDanglingComments: t } = et(), { hasNewline: s } = Ue(), { builders: { join: a, line: n2, hardline: u, softline: i, group: l, indent: p }, utils: { replaceTextEndOfLine: y } } = qe(), h3 = td2(), g = rd(), { insertPragma: c } = Co(), f = Eo(), F = qt(), _ = Fo(), { hasFlowShorthandAnnotationComment: w, hasComment: E, CommentCheckFlags: N, isTheOnlyJsxElementInMarkdown: x2, isLineComment: I, isNextLineEmpty: P, needsHardlineAfterDanglingComment: $, hasIgnoreComment: D, isCallExpression: T, isMemberExpression: m, markerForIfWithoutBlockAndSameLineComment: C } = Ke(), { locStart: o, locEnd: d } = ut(), v = Pt(), { printHtmlBinding: S, isVueEventBindingExpression: b } = pd(), { printAngular: B } = fd(), { printJsx: k, hasJsxIgnoreComment: M } = Dd(), { printFlow: R } = dd(), { printTypescript: q } = yd(), { printOptionalToken: J, printBindExpressionCallee: L, printTypeAnnotation: Q, adjustClause: V, printRestSpread: j, printDefiniteToken: Y, printDirective: ie } = ct(), { printImportDeclaration: ee, printExportDeclaration: ce, printExportAllDeclaration: W, printModuleSpecifier: K } = To(), { printTernary: de } = Bo(), { printTemplateLiteral: ue } = jt(), { printArray: Fe } = er(), { printObject: z } = uu(), { printClass: U, printClassMethod: Z, printClassProperty: se } = nr(), { printProperty: fe } = rr(), { printFunction: ge, printArrowFunction: he, printMethod: we, printReturnStatement: ke, printThrowStatement: Re } = qr(), { printCallExpression: Ne } = xo(), { printVariableDeclarator: Pe, printAssignmentExpression: oe } = tr(), { printBinaryishExpression: H } = ru(), { printSwitchCaseConsequent: pe } = No(), { printMemberExpression: X } = So(), { printBlock: le, printBlockBody: Ae } = wo(), { printComment: Ee } = hd(), { printLiteral: De } = vd(), { printDecorators: A } = nu();
          function G(Ce, Be, ve, ze) {
            let be = re(Ce, Be, ve, ze);
            if (!be) return "";
            let Ye = Ce.getValue(), { type: Se } = Ye;
            if (Se === "ClassMethod" || Se === "ClassPrivateMethod" || Se === "ClassProperty" || Se === "ClassAccessorProperty" || Se === "AccessorProperty" || Se === "TSAbstractAccessorProperty" || Se === "PropertyDefinition" || Se === "TSAbstractPropertyDefinition" || Se === "ClassPrivateProperty" || Se === "MethodDefinition" || Se === "TSAbstractMethodDefinition" || Se === "TSDeclareMethod") return be;
            let Ie = [be], Oe = A(Ce, Be, ve), Je = Ye.type === "ClassExpression" && Oe;
            if (Oe && (Ie = [...Oe, be], !Je)) return l(Ie);
            if (!F(Ce, Be)) return ze && ze.needsSemi && Ie.unshift(";"), Ie.length === 1 && Ie[0] === be ? be : Ie;
            if (Je && (Ie = [p([n2, ...Ie])]), Ie.unshift("("), ze && ze.needsSemi && Ie.unshift(";"), w(Ye)) {
              let [je] = Ye.trailingComments;
              Ie.push(" /*", je.value.trimStart(), "*/"), je.printed = true;
            }
            return Je && Ie.push(n2), Ie.push(")"), Ie;
          }
          function re(Ce, Be, ve, ze) {
            let be = Ce.getValue(), Ye = Be.semi ? ";" : "";
            if (!be) return "";
            if (typeof be == "string") return be;
            for (let Ie of [De, S, B, k, R, q]) {
              let Oe = Ie(Ce, Be, ve);
              if (typeof Oe < "u") return Oe;
            }
            let Se = [];
            switch (be.type) {
              case "JsExpressionRoot":
                return ve("node");
              case "JsonRoot":
                return [ve("node"), u];
              case "File":
                return be.program && be.program.interpreter && Se.push(ve(["program", "interpreter"])), Se.push(ve("program")), Se;
              case "Program":
                return Ae(Ce, Be, ve);
              case "EmptyStatement":
                return "";
              case "ExpressionStatement": {
                if (Be.parser === "__vue_event_binding" || Be.parser === "__vue_ts_event_binding") {
                  let Oe = Ce.getParentNode();
                  if (Oe.type === "Program" && Oe.body.length === 1 && Oe.body[0] === be) return [ve("expression"), b(be.expression) ? ";" : ""];
                }
                let Ie = t(Ce, Be, true, (Oe) => {
                  let { marker: Je } = Oe;
                  return Je === C;
                });
                return [ve("expression"), x2(Be, Ce) ? "" : Ye, Ie ? [" ", Ie] : ""];
              }
              case "ParenthesizedExpression":
                return !E(be.expression) && (be.expression.type === "ObjectExpression" || be.expression.type === "ArrayExpression") ? ["(", ve("expression"), ")"] : l(["(", p([i, ve("expression")]), i, ")"]);
              case "AssignmentExpression":
                return oe(Ce, Be, ve);
              case "VariableDeclarator":
                return Pe(Ce, Be, ve);
              case "BinaryExpression":
              case "LogicalExpression":
                return H(Ce, Be, ve);
              case "AssignmentPattern":
                return [ve("left"), " = ", ve("right")];
              case "OptionalMemberExpression":
              case "MemberExpression":
                return X(Ce, Be, ve);
              case "MetaProperty":
                return [ve("meta"), ".", ve("property")];
              case "BindExpression":
                return be.object && Se.push(ve("object")), Se.push(l(p([i, L(Ce, Be, ve)]))), Se;
              case "Identifier":
                return [be.name, J(Ce), Y(Ce), Q(Ce, Be, ve)];
              case "V8IntrinsicIdentifier":
                return ["%", be.name];
              case "SpreadElement":
              case "SpreadElementPattern":
              case "SpreadProperty":
              case "SpreadPropertyPattern":
              case "RestElement":
                return j(Ce, Be, ve);
              case "FunctionDeclaration":
              case "FunctionExpression":
                return ge(Ce, ve, Be, ze);
              case "ArrowFunctionExpression":
                return he(Ce, Be, ve, ze);
              case "YieldExpression":
                return Se.push("yield"), be.delegate && Se.push("*"), be.argument && Se.push(" ", ve("argument")), Se;
              case "AwaitExpression": {
                if (Se.push("await"), be.argument) {
                  Se.push(" ", ve("argument"));
                  let Ie = Ce.getParentNode();
                  if (T(Ie) && Ie.callee === be || m(Ie) && Ie.object === be) {
                    Se = [p([i, ...Se]), i];
                    let Oe = Ce.findAncestor((Je) => Je.type === "AwaitExpression" || Je.type === "BlockStatement");
                    if (!Oe || Oe.type !== "AwaitExpression") return l(Se);
                  }
                }
                return Se;
              }
              case "ExportDefaultDeclaration":
              case "ExportNamedDeclaration":
                return ce(Ce, Be, ve);
              case "ExportAllDeclaration":
                return W(Ce, Be, ve);
              case "ImportDeclaration":
                return ee(Ce, Be, ve);
              case "ImportSpecifier":
              case "ExportSpecifier":
              case "ImportNamespaceSpecifier":
              case "ExportNamespaceSpecifier":
              case "ImportDefaultSpecifier":
              case "ExportDefaultSpecifier":
                return K(Ce, Be, ve);
              case "ImportAttribute":
                return [ve("key"), ": ", ve("value")];
              case "Import":
                return "import";
              case "BlockStatement":
              case "StaticBlock":
              case "ClassBody":
                return le(Ce, Be, ve);
              case "ThrowStatement":
                return Re(Ce, Be, ve);
              case "ReturnStatement":
                return ke(Ce, Be, ve);
              case "NewExpression":
              case "ImportExpression":
              case "OptionalCallExpression":
              case "CallExpression":
                return Ne(Ce, Be, ve);
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                return z(Ce, Be, ve);
              case "ObjectProperty":
              case "Property":
                return be.method || be.kind === "get" || be.kind === "set" ? we(Ce, Be, ve) : fe(Ce, Be, ve);
              case "ObjectMethod":
                return we(Ce, Be, ve);
              case "Decorator":
                return ["@", ve("expression")];
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                return Fe(Ce, Be, ve);
              case "SequenceExpression": {
                let Ie = Ce.getParentNode(0);
                if (Ie.type === "ExpressionStatement" || Ie.type === "ForStatement") {
                  let Oe = [];
                  return Ce.each((Je, Te) => {
                    Te === 0 ? Oe.push(ve()) : Oe.push(",", p([n2, ve()]));
                  }, "expressions"), l(Oe);
                }
                return l(a([",", n2], Ce.map(ve, "expressions")));
              }
              case "ThisExpression":
                return "this";
              case "Super":
                return "super";
              case "Directive":
                return [ve("value"), Ye];
              case "DirectiveLiteral":
                return ie(be.extra.raw, Be);
              case "UnaryExpression":
                return Se.push(be.operator), /[a-z]$/.test(be.operator) && Se.push(" "), E(be.argument) ? Se.push(l(["(", p([i, ve("argument")]), i, ")"])) : Se.push(ve("argument")), Se;
              case "UpdateExpression":
                return Se.push(ve("argument"), be.operator), be.prefix && Se.reverse(), Se;
              case "ConditionalExpression":
                return de(Ce, Be, ve);
              case "VariableDeclaration": {
                let Ie = Ce.map(ve, "declarations"), Oe = Ce.getParentNode(), Je = Oe.type === "ForStatement" || Oe.type === "ForInStatement" || Oe.type === "ForOfStatement", Te = be.declarations.some((Me) => Me.init), je;
                return Ie.length === 1 && !E(be.declarations[0]) ? je = Ie[0] : Ie.length > 0 && (je = p(Ie[0])), Se = [be.declare ? "declare " : "", be.kind, je ? [" ", je] : "", p(Ie.slice(1).map((Me) => [",", Te && !Je ? u : n2, Me]))], Je && Oe.body !== be || Se.push(Ye), l(Se);
              }
              case "WithStatement":
                return l(["with (", ve("object"), ")", V(be.body, ve("body"))]);
              case "IfStatement": {
                let Ie = V(be.consequent, ve("consequent")), Oe = l(["if (", l([p([i, ve("test")]), i]), ")", Ie]);
                if (Se.push(Oe), be.alternate) {
                  let Je = E(be.consequent, N.Trailing | N.Line) || $(be), Te = be.consequent.type === "BlockStatement" && !Je;
                  Se.push(Te ? " " : u), E(be, N.Dangling) && Se.push(t(Ce, Be, true), Je ? u : " "), Se.push("else", l(V(be.alternate, ve("alternate"), be.alternate.type === "IfStatement")));
                }
                return Se;
              }
              case "ForStatement": {
                let Ie = V(be.body, ve("body")), Oe = t(Ce, Be, true), Je = Oe ? [Oe, i] : "";
                return !be.init && !be.test && !be.update ? [Je, l(["for (;;)", Ie])] : [Je, l(["for (", l([p([i, ve("init"), ";", n2, ve("test"), ";", n2, ve("update")]), i]), ")", Ie])];
              }
              case "WhileStatement":
                return l(["while (", l([p([i, ve("test")]), i]), ")", V(be.body, ve("body"))]);
              case "ForInStatement":
                return l(["for (", ve("left"), " in ", ve("right"), ")", V(be.body, ve("body"))]);
              case "ForOfStatement":
                return l(["for", be.await ? " await" : "", " (", ve("left"), " of ", ve("right"), ")", V(be.body, ve("body"))]);
              case "DoWhileStatement": {
                let Ie = V(be.body, ve("body"));
                return Se = [l(["do", Ie])], be.body.type === "BlockStatement" ? Se.push(" ") : Se.push(u), Se.push("while (", l([p([i, ve("test")]), i]), ")", Ye), Se;
              }
              case "DoExpression":
                return [be.async ? "async " : "", "do ", ve("body")];
              case "BreakStatement":
                return Se.push("break"), be.label && Se.push(" ", ve("label")), Se.push(Ye), Se;
              case "ContinueStatement":
                return Se.push("continue"), be.label && Se.push(" ", ve("label")), Se.push(Ye), Se;
              case "LabeledStatement":
                return be.body.type === "EmptyStatement" ? [ve("label"), ":;"] : [ve("label"), ": ", ve("body")];
              case "TryStatement":
                return ["try ", ve("block"), be.handler ? [" ", ve("handler")] : "", be.finalizer ? [" finally ", ve("finalizer")] : ""];
              case "CatchClause":
                if (be.param) {
                  let Ie = E(be.param, (Je) => !v(Je) || Je.leading && s(Be.originalText, d(Je)) || Je.trailing && s(Be.originalText, o(Je), { backwards: true })), Oe = ve("param");
                  return ["catch ", Ie ? ["(", p([i, Oe]), i, ") "] : ["(", Oe, ") "], ve("body")];
                }
                return ["catch ", ve("body")];
              case "SwitchStatement":
                return [l(["switch (", p([i, ve("discriminant")]), i, ")"]), " {", be.cases.length > 0 ? p([u, a(u, Ce.map((Ie, Oe, Je) => {
                  let Te = Ie.getValue();
                  return [ve(), Oe !== Je.length - 1 && P(Te, Be) ? u : ""];
                }, "cases"))]) : "", u, "}"];
              case "SwitchCase": {
                be.test ? Se.push("case ", ve("test"), ":") : Se.push("default:"), E(be, N.Dangling) && Se.push(" ", t(Ce, Be, true));
                let Ie = be.consequent.filter((Oe) => Oe.type !== "EmptyStatement");
                if (Ie.length > 0) {
                  let Oe = pe(Ce, Be, ve);
                  Se.push(Ie.length === 1 && Ie[0].type === "BlockStatement" ? [" ", Oe] : p([u, Oe]));
                }
                return Se;
              }
              case "DebuggerStatement":
                return ["debugger", Ye];
              case "ClassDeclaration":
              case "ClassExpression":
                return U(Ce, Be, ve);
              case "ClassMethod":
              case "ClassPrivateMethod":
              case "MethodDefinition":
                return Z(Ce, Be, ve);
              case "ClassProperty":
              case "PropertyDefinition":
              case "ClassPrivateProperty":
              case "ClassAccessorProperty":
              case "AccessorProperty":
                return se(Ce, Be, ve);
              case "TemplateElement":
                return y(be.value.raw);
              case "TemplateLiteral":
                return ue(Ce, ve, Be);
              case "TaggedTemplateExpression":
                return [ve("tag"), ve("typeParameters"), ve("quasi")];
              case "PrivateIdentifier":
                return ["#", ve("name")];
              case "PrivateName":
                return ["#", ve("id")];
              case "InterpreterDirective":
                return Se.push("#!", be.value, u), P(be, Be) && Se.push(u), Se;
              case "TopicReference":
                return "%";
              case "ArgumentPlaceholder":
                return "?";
              case "ModuleExpression": {
                Se.push("module {");
                let Ie = ve("body");
                return Ie && Se.push(p([u, Ie]), u), Se.push("}"), Se;
              }
              default:
                throw new Error("unknown type: " + JSON.stringify(be.type));
            }
          }
          function ye(Ce) {
            return Ce.type && !v(Ce) && !I(Ce) && Ce.type !== "EmptyStatement" && Ce.type !== "TemplateElement" && Ce.type !== "Import" && Ce.type !== "TSEmptyBodyFunctionExpression";
          }
          r.exports = { preprocess: _, print: G, embed: h3, insertPragma: c, massageAstNode: g, hasPrettierIgnore(Ce) {
            return D(Ce) || M(Ce);
          }, willPrintOwnComments: f.willPrintOwnComments, canAttachComment: ye, printComment: Ee, isBlockComment: v, handleComments: { avoidAstMutation: true, ownLine: f.handleOwnLineComment, endOfLine: f.handleEndOfLineComment, remaining: f.handleRemainingComment }, getCommentChildNodes: f.getCommentChildNodes };
        } }), Ed = te({ "src/language-js/printer-estree-json.js"(e2, r) {
          "use strict";
          ne();
          var { builders: { hardline: t, indent: s, join: a } } = qe(), n2 = Fo();
          function u(y, h3, g) {
            let c = y.getValue();
            switch (c.type) {
              case "JsonRoot":
                return [g("node"), t];
              case "ArrayExpression": {
                if (c.elements.length === 0) return "[]";
                let f = y.map(() => y.getValue() === null ? "null" : g(), "elements");
                return ["[", s([t, a([",", t], f)]), t, "]"];
              }
              case "ObjectExpression":
                return c.properties.length === 0 ? "{}" : ["{", s([t, a([",", t], y.map(g, "properties"))]), t, "}"];
              case "ObjectProperty":
                return [g("key"), ": ", g("value")];
              case "UnaryExpression":
                return [c.operator === "+" ? "" : c.operator, g("argument")];
              case "NullLiteral":
                return "null";
              case "BooleanLiteral":
                return c.value ? "true" : "false";
              case "StringLiteral":
                return JSON.stringify(c.value);
              case "NumericLiteral":
                return i(y) ? JSON.stringify(String(c.value)) : JSON.stringify(c.value);
              case "Identifier":
                return i(y) ? JSON.stringify(c.name) : c.name;
              case "TemplateLiteral":
                return g(["quasis", 0]);
              case "TemplateElement":
                return JSON.stringify(c.value.cooked);
              default:
                throw new Error("unknown type: " + JSON.stringify(c.type));
            }
          }
          function i(y) {
            return y.getName() === "key" && y.getParentNode().type === "ObjectProperty";
          }
          var l = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
          function p(y, h3) {
            let { type: g } = y;
            if (g === "ObjectProperty") {
              let { key: c } = y;
              c.type === "Identifier" ? h3.key = { type: "StringLiteral", value: c.name } : c.type === "NumericLiteral" && (h3.key = { type: "StringLiteral", value: String(c.value) });
              return;
            }
            if (g === "UnaryExpression" && y.operator === "+") return h3.argument;
            if (g === "ArrayExpression") {
              for (let [c, f] of y.elements.entries()) f === null && h3.elements.splice(c, 0, { type: "NullLiteral" });
              return;
            }
            if (g === "TemplateLiteral") return { type: "StringLiteral", value: y.quasis[0].value.cooked };
          }
          p.ignoredProperties = l, r.exports = { preprocess: n2, print: u, massageAstNode: p };
        } }), Mt = te({ "src/common/common-options.js"(e2, r) {
          "use strict";
          ne();
          var t = "Common";
          r.exports = { bracketSpacing: { since: "0.0.0", category: t, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: t, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: t, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: t, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { since: "2.6.0", category: t, type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
        } }), Fd = te({ "src/language-js/options.js"(e2, r) {
          "use strict";
          ne();
          var t = Mt(), s = "JavaScript";
          r.exports = { arrowParens: { since: "1.9.0", category: s, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: t.bracketSameLine, bracketSpacing: t.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: s, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: s, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: t.singleQuote, jsxSingleQuote: { since: "1.15.0", category: s, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: s, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: s, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] }, singleAttributePerLine: t.singleAttributePerLine };
        } }), Ad = te({ "src/language-js/parse/parsers.js"() {
          ne();
        } }), Ln = te({ "node_modules/linguist-languages/data/JavaScript.json"(e2, r) {
          r.exports = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 };
        } }), Sd = te({ "node_modules/linguist-languages/data/TypeScript.json"(e2, r) {
          r.exports = { name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 };
        } }), xd = te({ "node_modules/linguist-languages/data/TSX.json"(e2, r) {
          r.exports = { name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 };
        } }), wa = te({ "node_modules/linguist-languages/data/JSON.json"(e2, r) {
          r.exports = { name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 };
        } }), bd = te({ "node_modules/linguist-languages/data/JSON with Comments.json"(e2, r) {
          r.exports = { name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 };
        } }), Td = te({ "node_modules/linguist-languages/data/JSON5.json"(e2, r) {
          r.exports = { name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
        } }), Bd = te({ "src/language-js/index.js"(e2, r) {
          "use strict";
          ne();
          var t = _t(), s = Cd(), a = Ed(), n2 = Fd(), u = Ad(), i = [t(Ln(), (p) => ({ since: "0.0.0", parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...p.interpreters, "zx"], extensions: [...p.extensions.filter((y) => y !== ".jsx"), ".wxs"] })), t(Ln(), () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), t(Ln(), () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), t(Sd(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] })), t(xd(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), t(wa(), () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"] })), t(wa(), (p) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: p.extensions.filter((y) => y !== ".jsonl") })), t(bd(), (p) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...p.filenames, ".eslintrc", ".swcrc"] })), t(Td(), () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))], l = { estree: s, "estree-json": a };
          r.exports = { languages: i, options: n2, printers: l, parsers: u };
        } }), Nd = te({ "src/language-css/clean.js"(e2, r) {
          "use strict";
          ne();
          var { isFrontMatterNode: t } = Ue(), s = lt(), a = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
          function n2(i, l, p) {
            if (t(i) && i.lang === "yaml" && delete l.value, i.type === "css-comment" && p.type === "css-root" && p.nodes.length > 0 && ((p.nodes[0] === i || t(p.nodes[0]) && p.nodes[1] === i) && (delete l.text, /^\*\s*@(?:format|prettier)\s*$/.test(i.text)) || p.type === "css-root" && s(p.nodes) === i)) return null;
            if (i.type === "value-root" && delete l.text, (i.type === "media-query" || i.type === "media-query-list" || i.type === "media-feature-expression") && delete l.value, i.type === "css-rule" && delete l.params, i.type === "selector-combinator" && (l.value = l.value.replace(/\s+/g, " ")), i.type === "media-feature" && (l.value = l.value.replace(/ /g, "")), (i.type === "value-word" && (i.isColor && i.isHex || ["initial", "inherit", "unset", "revert"].includes(l.value.replace().toLowerCase())) || i.type === "media-feature" || i.type === "selector-root-invalid" || i.type === "selector-pseudo") && (l.value = l.value.toLowerCase()), i.type === "css-decl" && (l.prop = l.prop.toLowerCase()), (i.type === "css-atrule" || i.type === "css-import") && (l.name = l.name.toLowerCase()), i.type === "value-number" && (l.unit = l.unit.toLowerCase()), (i.type === "media-feature" || i.type === "media-keyword" || i.type === "media-type" || i.type === "media-unknown" || i.type === "media-url" || i.type === "media-value" || i.type === "selector-attribute" || i.type === "selector-string" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "value-string") && l.value && (l.value = u(l.value)), i.type === "selector-attribute" && (l.attribute = l.attribute.trim(), l.namespace && typeof l.namespace == "string" && (l.namespace = l.namespace.trim(), l.namespace.length === 0 && (l.namespace = true)), l.value && (l.value = l.value.trim().replace(/^["']|["']$/g, ""), delete l.quoted)), (i.type === "media-value" || i.type === "media-type" || i.type === "value-number" || i.type === "selector-root-invalid" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "selector-tag") && l.value && (l.value = l.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (y, h3, g) => {
              let c = Number(h3);
              return Number.isNaN(c) ? y : c + g.toLowerCase();
            })), i.type === "selector-tag") {
              let y = i.value.toLowerCase();
              ["from", "to"].includes(y) && (l.value = y);
            }
            if (i.type === "css-atrule" && i.name.toLowerCase() === "supports" && delete l.value, i.type === "selector-unknown" && delete l.value, i.type === "value-comma_group") {
              let y = i.groups.findIndex((h3) => h3.type === "value-number" && h3.unit === "...");
              y !== -1 && (l.groups[y].unit = "", l.groups.splice(y + 1, 0, { type: "value-word", value: "...", isColor: false, isHex: false }));
            }
            if (i.type === "value-comma_group" && i.groups.some((y) => y.type === "value-atword" && y.value.endsWith("[") || y.type === "value-word" && y.value.startsWith("]"))) return { type: "value-atword", value: i.groups.map((y) => y.value).join(""), group: { open: null, close: null, groups: [], type: "value-paren_group" } };
          }
          n2.ignoredProperties = a;
          function u(i) {
            return i.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1");
          }
          r.exports = n2;
        } }), su = te({ "src/utils/front-matter/print.js"(e2, r) {
          "use strict";
          ne();
          var { builders: { hardline: t, markAsRoot: s } } = qe();
          function a(n2, u) {
            if (n2.lang === "yaml") {
              let i = n2.value.trim(), l = i ? u(i, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
              return s([n2.startDelimiter, t, l, l ? t : "", n2.endDelimiter]);
            }
          }
          r.exports = a;
        } }), wd = te({ "src/language-css/embed.js"(e2, r) {
          "use strict";
          ne();
          var { builders: { hardline: t } } = qe(), s = su();
          function a(n2, u, i) {
            let l = n2.getValue();
            if (l.type === "front-matter") {
              let p = s(l, i);
              return p ? [p, t] : "";
            }
          }
          r.exports = a;
        } }), _o = te({ "src/utils/front-matter/parse.js"(e2, r) {
          "use strict";
          ne();
          var t = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
          function s(a) {
            let n2 = a.match(t);
            if (!n2) return { content: a };
            let { startDelimiter: u, language: i, value: l = "", endDelimiter: p } = n2.groups, y = i.trim() || "yaml";
            if (u === "+++" && (y = "toml"), y !== "yaml" && u !== p) return { content: a };
            let [h3] = n2;
            return { frontMatter: { type: "front-matter", lang: y, value: l, startDelimiter: u, endDelimiter: p, raw: h3.replace(/\n$/, "") }, content: h3.replace(/[^\n]/g, " ") + a.slice(h3.length) };
          }
          r.exports = s;
        } }), _d = te({ "src/language-css/pragma.js"(e2, r) {
          "use strict";
          ne();
          var t = Co(), s = _o();
          function a(u) {
            return t.hasPragma(s(u).content);
          }
          function n2(u) {
            let { frontMatter: i, content: l } = s(u);
            return (i ? i.raw + `

` : "") + t.insertPragma(l);
          }
          r.exports = { hasPragma: a, insertPragma: n2 };
        } }), Pd = te({ "src/language-css/utils/index.js"(e2, r) {
          "use strict";
          ne();
          var t = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
          function s(z, U) {
            let Z = Array.isArray(U) ? U : [U], se = -1, fe;
            for (; fe = z.getParentNode(++se); ) if (Z.includes(fe.type)) return se;
            return -1;
          }
          function a(z, U) {
            let Z = s(z, U);
            return Z === -1 ? null : z.getParentNode(Z);
          }
          function n2(z) {
            var U;
            let Z = a(z, "css-decl");
            return Z == null || (U = Z.prop) === null || U === void 0 ? void 0 : U.toLowerCase();
          }
          var u = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
          function i(z) {
            return u.has(z.toLowerCase());
          }
          function l(z, U) {
            let Z = a(z, "css-atrule");
            return (Z == null ? void 0 : Z.name) && Z.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(U.toLowerCase());
          }
          function p(z) {
            return z.includes("$") || z.includes("@") || z.includes("#") || z.startsWith("%") || z.startsWith("--") || z.startsWith(":--") || z.includes("(") && z.includes(")") ? z : z.toLowerCase();
          }
          function y(z, U) {
            var Z;
            let se = a(z, "value-func");
            return (se == null || (Z = se.value) === null || Z === void 0 ? void 0 : Z.toLowerCase()) === U;
          }
          function h3(z) {
            var U;
            let Z = a(z, "css-rule"), se = Z == null || (U = Z.raws) === null || U === void 0 ? void 0 : U.selector;
            return se && (se.startsWith(":import") || se.startsWith(":export"));
          }
          function g(z, U) {
            let Z = Array.isArray(U) ? U : [U], se = a(z, "css-atrule");
            return se && Z.includes(se.name.toLowerCase());
          }
          function c(z) {
            let U = z.getValue(), Z = a(z, "css-atrule");
            return (Z == null ? void 0 : Z.name) === "import" && U.groups[0].value === "url" && U.groups.length === 2;
          }
          function f(z) {
            return z.type === "value-func" && z.value.toLowerCase() === "url";
          }
          function F(z, U) {
            var Z;
            let se = (Z = z.getParentNode()) === null || Z === void 0 ? void 0 : Z.nodes;
            return se && se.indexOf(U) === se.length - 1;
          }
          function _(z) {
            let { selector: U } = z;
            return U ? typeof U == "string" && /^@.+:.*$/.test(U) || U.value && /^@.+:.*$/.test(U.value) : false;
          }
          function w(z) {
            return z.type === "value-word" && ["from", "through", "end"].includes(z.value);
          }
          function E(z) {
            return z.type === "value-word" && ["and", "or", "not"].includes(z.value);
          }
          function N(z) {
            return z.type === "value-word" && z.value === "in";
          }
          function x2(z) {
            return z.type === "value-operator" && z.value === "*";
          }
          function I(z) {
            return z.type === "value-operator" && z.value === "/";
          }
          function P(z) {
            return z.type === "value-operator" && z.value === "+";
          }
          function $(z) {
            return z.type === "value-operator" && z.value === "-";
          }
          function D(z) {
            return z.type === "value-operator" && z.value === "%";
          }
          function T(z) {
            return x2(z) || I(z) || P(z) || $(z) || D(z);
          }
          function m(z) {
            return z.type === "value-word" && ["==", "!="].includes(z.value);
          }
          function C(z) {
            return z.type === "value-word" && ["<", ">", "<=", ">="].includes(z.value);
          }
          function o(z) {
            return z.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(z.name);
          }
          function d(z) {
            var U;
            return ((U = z.raws) === null || U === void 0 ? void 0 : U.params) && /^\(\s*\)$/.test(z.raws.params);
          }
          function v(z) {
            return z.name.startsWith("prettier-placeholder");
          }
          function S(z) {
            return z.prop.startsWith("@prettier-placeholder");
          }
          function b(z, U) {
            return z.value === "$$" && z.type === "value-func" && (U == null ? void 0 : U.type) === "value-word" && !U.raws.before;
          }
          function B(z) {
            var U, Z;
            return ((U = z.value) === null || U === void 0 ? void 0 : U.type) === "value-root" && ((Z = z.value.group) === null || Z === void 0 ? void 0 : Z.type) === "value-value" && z.prop.toLowerCase() === "composes";
          }
          function k(z) {
            var U, Z, se;
            return ((U = z.value) === null || U === void 0 || (Z = U.group) === null || Z === void 0 || (se = Z.group) === null || se === void 0 ? void 0 : se.type) === "value-paren_group" && z.value.group.group.open !== null && z.value.group.group.close !== null;
          }
          function M(z) {
            var U;
            return ((U = z.raws) === null || U === void 0 ? void 0 : U.before) === "";
          }
          function R(z) {
            var U, Z;
            return z.type === "value-comma_group" && ((U = z.groups) === null || U === void 0 || (Z = U[1]) === null || Z === void 0 ? void 0 : Z.type) === "value-colon";
          }
          function q(z) {
            var U;
            return z.type === "value-paren_group" && ((U = z.groups) === null || U === void 0 ? void 0 : U[0]) && R(z.groups[0]);
          }
          function J(z) {
            var U;
            let Z = z.getValue();
            if (Z.groups.length === 0) return false;
            let se = z.getParentNode(1);
            if (!q(Z) && !(se && q(se))) return false;
            let fe = a(z, "css-decl");
            return !!(fe != null && (U = fe.prop) !== null && U !== void 0 && U.startsWith("$") || q(se) || se.type === "value-func");
          }
          function L(z) {
            return z.type === "value-comment" && z.inline;
          }
          function Q(z) {
            return z.type === "value-word" && z.value === "#";
          }
          function V(z) {
            return z.type === "value-word" && z.value === "{";
          }
          function j(z) {
            return z.type === "value-word" && z.value === "}";
          }
          function Y(z) {
            return ["value-word", "value-atword"].includes(z.type);
          }
          function ie(z) {
            return (z == null ? void 0 : z.type) === "value-colon";
          }
          function ee(z, U) {
            if (!R(U)) return false;
            let { groups: Z } = U, se = Z.indexOf(z);
            return se === -1 ? false : ie(Z[se + 1]);
          }
          function ce(z) {
            return z.value && ["not", "and", "or"].includes(z.value.toLowerCase());
          }
          function W(z) {
            return z.type !== "value-func" ? false : t.has(z.value.toLowerCase());
          }
          function K(z) {
            return /\/\//.test(z.split(/[\n\r]/).pop());
          }
          function de(z) {
            return (z == null ? void 0 : z.type) === "value-atword" && z.value.startsWith("prettier-placeholder-");
          }
          function ue(z, U) {
            var Z, se;
            if (((Z = z.open) === null || Z === void 0 ? void 0 : Z.value) !== "(" || ((se = z.close) === null || se === void 0 ? void 0 : se.value) !== ")" || z.groups.some((fe) => fe.type !== "value-comma_group")) return false;
            if (U.type === "value-comma_group") {
              let fe = U.groups.indexOf(z) - 1, ge = U.groups[fe];
              if ((ge == null ? void 0 : ge.type) === "value-word" && ge.value === "with") return true;
            }
            return false;
          }
          function Fe(z) {
            var U, Z;
            return z.type === "value-paren_group" && ((U = z.open) === null || U === void 0 ? void 0 : U.value) === "(" && ((Z = z.close) === null || Z === void 0 ? void 0 : Z.value) === ")";
          }
          r.exports = { getAncestorCounter: s, getAncestorNode: a, getPropOfDeclNode: n2, maybeToLowerCase: p, insideValueFunctionNode: y, insideICSSRuleNode: h3, insideAtRuleNode: g, insideURLFunctionInImportAtRuleNode: c, isKeyframeAtRuleKeywords: l, isWideKeywords: i, isLastNode: F, isSCSSControlDirectiveNode: o, isDetachedRulesetDeclarationNode: _, isRelationalOperatorNode: C, isEqualityOperatorNode: m, isMultiplicationNode: x2, isDivisionNode: I, isAdditionNode: P, isSubtractionNode: $, isModuloNode: D, isMathOperatorNode: T, isEachKeywordNode: N, isForKeywordNode: w, isURLFunctionNode: f, isIfElseKeywordNode: E, hasComposesNode: B, hasParensAroundNode: k, hasEmptyRawBefore: M, isDetachedRulesetCallNode: d, isTemplatePlaceholderNode: v, isTemplatePropNode: S, isPostcssSimpleVarNode: b, isKeyValuePairNode: R, isKeyValuePairInParenGroupNode: q, isKeyInValuePairNode: ee, isSCSSMapItemNode: J, isInlineValueCommentNode: L, isHashNode: Q, isLeftCurlyBraceNode: V, isRightCurlyBraceNode: j, isWordNode: Y, isColonNode: ie, isMediaAndSupportsKeywords: ce, isColorAdjusterFuncNode: W, lastLineHasInlineComment: K, isAtWordPlaceholderNode: de, isConfigurationNode: ue, isParenGroupNode: Fe };
        } }), Id = te({ "src/utils/line-column-to-index.js"(e2, r) {
          "use strict";
          ne(), r.exports = function(t, s) {
            let a = 0;
            for (let n2 = 0; n2 < t.line - 1; ++n2) a = s.indexOf(`
`, a) + 1;
            return a + t.column;
          };
        } }), kd = te({ "src/language-css/loc.js"(e2, r) {
          "use strict";
          ne();
          var { skipEverythingButNewLine: t } = Pr(), s = lt(), a = Id();
          function n2(c, f) {
            return typeof c.sourceIndex == "number" ? c.sourceIndex : c.source ? a(c.source.start, f) - 1 : null;
          }
          function u(c, f) {
            if (c.type === "css-comment" && c.inline) return t(f, c.source.startOffset);
            let F = c.nodes && s(c.nodes);
            return F && c.source && !c.source.end && (c = F), c.source && c.source.end ? a(c.source.end, f) : null;
          }
          function i(c, f) {
            c.source && (c.source.startOffset = n2(c, f), c.source.endOffset = u(c, f));
            for (let F in c) {
              let _ = c[F];
              F === "source" || !_ || typeof _ != "object" || (_.type === "value-root" || _.type === "value-unknown" ? l(_, p(c), _.text || _.value) : i(_, f));
            }
          }
          function l(c, f, F) {
            c.source && (c.source.startOffset = n2(c, F) + f, c.source.endOffset = u(c, F) + f);
            for (let _ in c) {
              let w = c[_];
              _ === "source" || !w || typeof w != "object" || l(w, f, F);
            }
          }
          function p(c) {
            let f = c.source.startOffset;
            return typeof c.prop == "string" && (f += c.prop.length), c.type === "css-atrule" && typeof c.name == "string" && (f += 1 + c.name.length + c.raws.afterName.match(/^\s*:?\s*/)[0].length), c.type !== "css-atrule" && c.raws && typeof c.raws.between == "string" && (f += c.raws.between.length), f;
          }
          function y(c) {
            let f = "initial", F = "initial", _, w = false, E = [];
            for (let N = 0; N < c.length; N++) {
              let x2 = c[N];
              switch (f) {
                case "initial":
                  if (x2 === "'") {
                    f = "single-quotes";
                    continue;
                  }
                  if (x2 === '"') {
                    f = "double-quotes";
                    continue;
                  }
                  if ((x2 === "u" || x2 === "U") && c.slice(N, N + 4).toLowerCase() === "url(") {
                    f = "url", N += 3;
                    continue;
                  }
                  if (x2 === "*" && c[N - 1] === "/") {
                    f = "comment-block";
                    continue;
                  }
                  if (x2 === "/" && c[N - 1] === "/") {
                    f = "comment-inline", _ = N - 1;
                    continue;
                  }
                  continue;
                case "single-quotes":
                  if (x2 === "'" && c[N - 1] !== "\\" && (f = F, F = "initial"), x2 === `
` || x2 === "\r") return c;
                  continue;
                case "double-quotes":
                  if (x2 === '"' && c[N - 1] !== "\\" && (f = F, F = "initial"), x2 === `
` || x2 === "\r") return c;
                  continue;
                case "url":
                  if (x2 === ")" && (f = "initial"), x2 === `
` || x2 === "\r") return c;
                  if (x2 === "'") {
                    f = "single-quotes", F = "url";
                    continue;
                  }
                  if (x2 === '"') {
                    f = "double-quotes", F = "url";
                    continue;
                  }
                  continue;
                case "comment-block":
                  x2 === "/" && c[N - 1] === "*" && (f = "initial");
                  continue;
                case "comment-inline":
                  (x2 === '"' || x2 === "'" || x2 === "*") && (w = true), (x2 === `
` || x2 === "\r") && (w && E.push([_, N]), f = "initial", w = false);
                  continue;
              }
            }
            for (let [N, x2] of E) c = c.slice(0, N) + c.slice(N, x2).replace(/["'*]/g, " ") + c.slice(x2);
            return c;
          }
          function h3(c) {
            return c.source.startOffset;
          }
          function g(c) {
            return c.source.endOffset;
          }
          r.exports = { locStart: h3, locEnd: g, calculateLoc: i, replaceQuotesInInlineComments: y };
        } }), Ld = te({ "src/language-css/utils/is-less-parser.js"(e2, r) {
          "use strict";
          ne();
          function t(s) {
            return s.parser === "css" || s.parser === "less";
          }
          r.exports = t;
        } }), Od = te({ "src/language-css/utils/is-scss.js"(e2, r) {
          "use strict";
          ne();
          function t(s, a) {
            return s === "less" || s === "scss" ? s === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(a);
          }
          r.exports = t;
        } }), jd = te({ "src/language-css/utils/css-units.evaluate.js"(e2, r) {
          r.exports = { em: "em", rem: "rem", ex: "ex", rex: "rex", cap: "cap", rcap: "rcap", ch: "ch", rch: "rch", ic: "ic", ric: "ric", lh: "lh", rlh: "rlh", vw: "vw", svw: "svw", lvw: "lvw", dvw: "dvw", vh: "vh", svh: "svh", lvh: "lvh", dvh: "dvh", vi: "vi", svi: "svi", lvi: "lvi", dvi: "dvi", vb: "vb", svb: "svb", lvb: "lvb", dvb: "dvb", vmin: "vmin", svmin: "svmin", lvmin: "lvmin", dvmin: "dvmin", vmax: "vmax", svmax: "svmax", lvmax: "lvmax", dvmax: "dvmax", cm: "cm", mm: "mm", q: "Q", in: "in", pt: "pt", pc: "pc", px: "px", deg: "deg", grad: "grad", rad: "rad", turn: "turn", s: "s", ms: "ms", hz: "Hz", khz: "kHz", dpi: "dpi", dpcm: "dpcm", dppx: "dppx", x: "x" };
        } }), qd = te({ "src/language-css/utils/print-unit.js"(e2, r) {
          "use strict";
          ne();
          var t = jd();
          function s(a) {
            let n2 = a.toLowerCase();
            return Object.prototype.hasOwnProperty.call(t, n2) ? t[n2] : a;
          }
          r.exports = s;
        } }), Md = te({ "src/language-css/printer-postcss.js"(e2, r) {
          "use strict";
          ne();
          var t = lt(), { printNumber: s, printString: a, hasNewline: n2, isFrontMatterNode: u, isNextLineEmpty: i, isNonEmptyArray: l } = Ue(), { builders: { join: p, line: y, hardline: h3, softline: g, group: c, fill: f, indent: F, dedent: _, ifBreak: w, breakParent: E }, utils: { removeLines: N, getDocParts: x2 } } = qe(), I = Nd(), P = wd(), { insertPragma: $ } = _d(), { getAncestorNode: D, getPropOfDeclNode: T, maybeToLowerCase: m, insideValueFunctionNode: C, insideICSSRuleNode: o, insideAtRuleNode: d, insideURLFunctionInImportAtRuleNode: v, isKeyframeAtRuleKeywords: S, isWideKeywords: b, isLastNode: B, isSCSSControlDirectiveNode: k, isDetachedRulesetDeclarationNode: M, isRelationalOperatorNode: R, isEqualityOperatorNode: q, isMultiplicationNode: J, isDivisionNode: L, isAdditionNode: Q, isSubtractionNode: V, isMathOperatorNode: j, isEachKeywordNode: Y, isForKeywordNode: ie, isURLFunctionNode: ee, isIfElseKeywordNode: ce, hasComposesNode: W, hasParensAroundNode: K, hasEmptyRawBefore: de, isKeyValuePairNode: ue, isKeyInValuePairNode: Fe, isDetachedRulesetCallNode: z, isTemplatePlaceholderNode: U, isTemplatePropNode: Z, isPostcssSimpleVarNode: se, isSCSSMapItemNode: fe, isInlineValueCommentNode: ge, isHashNode: he, isLeftCurlyBraceNode: we, isRightCurlyBraceNode: ke, isWordNode: Re, isColonNode: Ne, isMediaAndSupportsKeywords: Pe, isColorAdjusterFuncNode: oe, lastLineHasInlineComment: H, isAtWordPlaceholderNode: pe, isConfigurationNode: X, isParenGroupNode: le } = Pd(), { locStart: Ae, locEnd: Ee } = kd(), De = Ld(), A = Od(), G = qd();
          function re(Te) {
            return Te.trailingComma === "es5" || Te.trailingComma === "all";
          }
          function ye(Te, je, Me) {
            let ae = Te.getValue();
            if (!ae) return "";
            if (typeof ae == "string") return ae;
            switch (ae.type) {
              case "front-matter":
                return [ae.raw, h3];
              case "css-root": {
                let Ve = Ce(Te, je, Me), We = ae.raws.after.trim();
                return We.startsWith(";") && (We = We.slice(1).trim()), [Ve, We ? ` ${We}` : "", x2(Ve).length > 0 ? h3 : ""];
              }
              case "css-comment": {
                let Ve = ae.inline || ae.raws.inline, We = je.originalText.slice(Ae(ae), Ee(ae));
                return Ve ? We.trimEnd() : We;
              }
              case "css-rule":
                return [Me("selector"), ae.important ? " !important" : "", ae.nodes ? [ae.selector && ae.selector.type === "selector-unknown" && H(ae.selector.value) ? y : " ", "{", ae.nodes.length > 0 ? F([h3, Ce(Te, je, Me)]) : "", h3, "}", M(ae) ? ";" : ""] : ";"];
              case "css-decl": {
                let Ve = Te.getParentNode(), { between: We } = ae.raws, Xe = We.trim(), st = Xe === ":", O = W(ae) ? N(Me("value")) : Me("value");
                return !st && H(Xe) && (O = F([h3, _(O)])), [ae.raws.before.replace(/[\s;]/g, ""), Ve.type === "css-atrule" && Ve.variable || o(Te) ? ae.prop : m(ae.prop), Xe.startsWith("//") ? " " : "", Xe, ae.extend ? "" : " ", De(je) && ae.extend && ae.selector ? ["extend(", Me("selector"), ")"] : "", O, ae.raws.important ? ae.raws.important.replace(/\s*!\s*important/i, " !important") : ae.important ? " !important" : "", ae.raws.scssDefault ? ae.raws.scssDefault.replace(/\s*!default/i, " !default") : ae.scssDefault ? " !default" : "", ae.raws.scssGlobal ? ae.raws.scssGlobal.replace(/\s*!global/i, " !global") : ae.scssGlobal ? " !global" : "", ae.nodes ? [" {", F([g, Ce(Te, je, Me)]), g, "}"] : Z(ae) && !Ve.raws.semicolon && je.originalText[Ee(ae) - 1] !== ";" ? "" : je.__isHTMLStyleAttribute && B(Te, ae) ? w(";") : ";"];
              }
              case "css-atrule": {
                let Ve = Te.getParentNode(), We = U(ae) && !Ve.raws.semicolon && je.originalText[Ee(ae) - 1] !== ";";
                if (De(je)) {
                  if (ae.mixin) return [Me("selector"), ae.important ? " !important" : "", We ? "" : ";"];
                  if (ae.function) return [ae.name, Me("params"), We ? "" : ";"];
                  if (ae.variable) return ["@", ae.name, ": ", ae.value ? Me("value") : "", ae.raws.between.trim() ? ae.raws.between.trim() + " " : "", ae.nodes ? ["{", F([ae.nodes.length > 0 ? g : "", Ce(Te, je, Me)]), g, "}"] : "", We ? "" : ";"];
                }
                return ["@", z(ae) || ae.name.endsWith(":") ? ae.name : m(ae.name), ae.params ? [z(ae) ? "" : U(ae) ? ae.raws.afterName === "" ? "" : ae.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(ae.raws.afterName) ? [h3, h3] : /^\s*\n/.test(ae.raws.afterName) ? h3 : " " : " ", Me("params")] : "", ae.selector ? F([" ", Me("selector")]) : "", ae.value ? c([" ", Me("value"), k(ae) ? K(ae) ? " " : y : ""]) : ae.name === "else" ? " " : "", ae.nodes ? [k(ae) ? "" : ae.selector && !ae.selector.nodes && typeof ae.selector.value == "string" && H(ae.selector.value) || !ae.selector && typeof ae.params == "string" && H(ae.params) ? y : " ", "{", F([ae.nodes.length > 0 ? g : "", Ce(Te, je, Me)]), g, "}"] : We ? "" : ";"];
              }
              case "media-query-list": {
                let Ve = [];
                return Te.each((We) => {
                  let Xe = We.getValue();
                  Xe.type === "media-query" && Xe.value === "" || Ve.push(Me());
                }, "nodes"), c(F(p(y, Ve)));
              }
              case "media-query":
                return [p(" ", Te.map(Me, "nodes")), B(Te, ae) ? "" : ","];
              case "media-type":
                return Oe(Se(ae.value, je));
              case "media-feature-expression":
                return ae.nodes ? ["(", ...Te.map(Me, "nodes"), ")"] : ae.value;
              case "media-feature":
                return m(Se(ae.value.replace(/ +/g, " "), je));
              case "media-colon":
                return [ae.value, " "];
              case "media-value":
                return Oe(Se(ae.value, je));
              case "media-keyword":
                return Se(ae.value, je);
              case "media-url":
                return Se(ae.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), je);
              case "media-unknown":
                return ae.value;
              case "selector-root":
                return c([d(Te, "custom-selector") ? [D(Te, "css-atrule").customSelector, y] : "", p([",", d(Te, ["extend", "custom-selector", "nest"]) ? y : h3], Te.map(Me, "nodes"))]);
              case "selector-selector":
                return c(F(Te.map(Me, "nodes")));
              case "selector-comment":
                return ae.value;
              case "selector-string":
                return Se(ae.value, je);
              case "selector-tag": {
                let Ve = Te.getParentNode(), We = Ve && Ve.nodes.indexOf(ae), Xe = We && Ve.nodes[We - 1];
                return [ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", Xe.type === "selector-nesting" ? ae.value : Oe(S(Te, ae.value) ? ae.value.toLowerCase() : ae.value)];
              }
              case "selector-id":
                return ["#", ae.value];
              case "selector-class":
                return [".", Oe(Se(ae.value, je))];
              case "selector-attribute": {
                var nt;
                return ["[", ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", ae.attribute.trim(), (nt = ae.operator) !== null && nt !== void 0 ? nt : "", ae.value ? Ie(Se(ae.value.trim(), je), je) : "", ae.insensitive ? " i" : "", "]"];
              }
              case "selector-combinator": {
                if (ae.value === "+" || ae.value === ">" || ae.value === "~" || ae.value === ">>>") {
                  let Xe = Te.getParentNode();
                  return [Xe.type === "selector-selector" && Xe.nodes[0] === ae ? "" : y, ae.value, B(Te, ae) ? "" : " "];
                }
                let Ve = ae.value.trim().startsWith("(") ? y : "", We = Oe(Se(ae.value.trim(), je)) || y;
                return [Ve, We];
              }
              case "selector-universal":
                return [ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", ae.value];
              case "selector-pseudo":
                return [m(ae.value), l(ae.nodes) ? c(["(", F([g, p([",", y], Te.map(Me, "nodes"))]), g, ")"]) : ""];
              case "selector-nesting":
                return ae.value;
              case "selector-unknown": {
                let Ve = D(Te, "css-rule");
                if (Ve && Ve.isSCSSNesterProperty) return Oe(Se(m(ae.value), je));
                let We = Te.getParentNode();
                if (We.raws && We.raws.selector) {
                  let st = Ae(We), O = st + We.raws.selector.length;
                  return je.originalText.slice(st, O).trim();
                }
                let Xe = Te.getParentNode(1);
                if (We.type === "value-paren_group" && Xe && Xe.type === "value-func" && Xe.value === "selector") {
                  let st = Ee(We.open) + 1, O = Ae(We.close), me = je.originalText.slice(st, O).trim();
                  return H(me) ? [E, me] : me;
                }
                return ae.value;
              }
              case "value-value":
              case "value-root":
                return Me("group");
              case "value-comment":
                return je.originalText.slice(Ae(ae), Ee(ae));
              case "value-comma_group": {
                let Ve = Te.getParentNode(), We = Te.getParentNode(1), Xe = T(Te), st = Xe && Ve.type === "value-value" && (Xe === "grid" || Xe.startsWith("grid-template")), O = D(Te, "css-atrule"), me = O && k(O), _e = ae.groups.some((at) => ge(at)), He = Te.map(Me, "groups"), Ge = [], it = C(Te, "url"), Qe = false, rt = false;
                for (let at = 0; at < ae.groups.length; ++at) {
                  var tt;
                  Ge.push(He[at]);
                  let Ze = ae.groups[at - 1], Le = ae.groups[at], $e = ae.groups[at + 1], sr = ae.groups[at + 2];
                  if (it) {
                    ($e && Q($e) || Q(Le)) && Ge.push(" ");
                    continue;
                  }
                  if (d(Te, "forward") && Le.type === "value-word" && Le.value && Ze !== void 0 && Ze.type === "value-word" && Ze.value === "as" && $e.type === "value-operator" && $e.value === "*" || !$e || Le.type === "value-word" && Le.value.endsWith("-") && pe($e)) continue;
                  if (Le.type === "value-string" && Le.quoted) {
                    let $r = Le.value.lastIndexOf("#{"), Vr = Le.value.lastIndexOf("}");
                    $r !== -1 && Vr !== -1 ? Qe = $r > Vr : $r !== -1 ? Qe = true : Vr !== -1 && (Qe = false);
                  }
                  if (Qe || Ne(Le) || Ne($e) || Le.type === "value-atword" && (Le.value === "" || Le.value.endsWith("[")) || $e.type === "value-word" && $e.value.startsWith("]") || Le.value === "~" || Le.value && Le.value.includes("\\") && $e && $e.type !== "value-comment" || Ze && Ze.value && Ze.value.indexOf("\\") === Ze.value.length - 1 && Le.type === "value-operator" && Le.value === "/" || Le.value === "\\" || se(Le, $e) || he(Le) || we(Le) || ke($e) || we($e) && de($e) || ke(Le) && de($e) || Le.value === "--" && he($e)) continue;
                  let Rr = j(Le), ou = j($e);
                  if ((Rr && he($e) || ou && ke(Le)) && de($e) || !Ze && L(Le) || C(Te, "calc") && (Q(Le) || Q($e) || V(Le) || V($e)) && de($e)) continue;
                  let qo = (Q(Le) || V(Le)) && at === 0 && ($e.type === "value-number" || $e.isHex) && We && oe(We) && !de($e), lu = sr && sr.type === "value-func" || sr && Re(sr) || Le.type === "value-func" || Re(Le), cu = $e.type === "value-func" || Re($e) || Ze && Ze.type === "value-func" || Ze && Re(Ze);
                  if (!(!(J($e) || J(Le)) && !C(Te, "calc") && !qo && (L($e) && !lu || L(Le) && !cu || Q($e) && !lu || Q(Le) && !cu || V($e) || V(Le)) && (de($e) || Rr && (!Ze || Ze && j(Ze)))) && !((je.parser === "scss" || je.parser === "less") && Rr && Le.value === "-" && le($e) && Ee(Le) === Ae($e.open) && $e.open.value === "(")) {
                    if (ge(Le)) {
                      if (Ve.type === "value-paren_group") {
                        Ge.push(_(h3));
                        continue;
                      }
                      Ge.push(h3);
                      continue;
                    }
                    if (me && (q($e) || R($e) || ce($e) || Y(Le) || ie(Le))) {
                      Ge.push(" ");
                      continue;
                    }
                    if (O && O.name.toLowerCase() === "namespace") {
                      Ge.push(" ");
                      continue;
                    }
                    if (st) {
                      Le.source && $e.source && Le.source.start.line !== $e.source.start.line ? (Ge.push(h3), rt = true) : Ge.push(" ");
                      continue;
                    }
                    if (ou) {
                      Ge.push(" ");
                      continue;
                    }
                    if (!($e && $e.value === "...") && !(pe(Le) && pe($e) && Ee(Le) === Ae($e))) {
                      if (pe(Le) && le($e) && Ee(Le) === Ae($e.open)) {
                        Ge.push(g);
                        continue;
                      }
                      if (Le.value === "with" && le($e)) {
                        Ge.push(" ");
                        continue;
                      }
                      (tt = Le.value) !== null && tt !== void 0 && tt.endsWith("#") && $e.value === "{" && le($e.group) || Ge.push(y);
                    }
                  }
                }
                return _e && Ge.push(E), rt && Ge.unshift(h3), me ? c(F(Ge)) : v(Te) ? c(f(Ge)) : c(F(f(Ge)));
              }
              case "value-paren_group": {
                let Ve = Te.getParentNode();
                if (Ve && ee(Ve) && (ae.groups.length === 1 || ae.groups.length > 0 && ae.groups[0].type === "value-comma_group" && ae.groups[0].groups.length > 0 && ae.groups[0].groups[0].type === "value-word" && ae.groups[0].groups[0].value.startsWith("data:"))) return [ae.open ? Me("open") : "", p(",", Te.map(Me, "groups")), ae.close ? Me("close") : ""];
                if (!ae.open) {
                  let it = Te.map(Me, "groups"), Qe = [];
                  for (let rt = 0; rt < it.length; rt++) rt !== 0 && Qe.push([",", y]), Qe.push(it[rt]);
                  return c(F(f(Qe)));
                }
                let We = fe(Te), Xe = t(ae.groups), st = Xe && Xe.type === "value-comment", O = Fe(ae, Ve), me = X(ae, Ve), _e = me || We && !O, He = me || O, Ge = c([ae.open ? Me("open") : "", F([g, p([y], Te.map((it, Qe) => {
                  let rt = it.getValue(), at = Qe === ae.groups.length - 1, Ze = [Me(), at ? "" : ","];
                  if (ue(rt) && rt.type === "value-comma_group" && rt.groups && rt.groups[0].type !== "value-paren_group" && rt.groups[2] && rt.groups[2].type === "value-paren_group") {
                    let Le = x2(Ze[0].contents.contents);
                    Le[1] = c(Le[1]), Ze = [c(_(Ze))];
                  }
                  if (!at && rt.type === "value-comma_group" && l(rt.groups)) {
                    let Le = t(rt.groups);
                    !Le.source && Le.close && (Le = Le.close), Le.source && i(je.originalText, Le, Ee) && Ze.push(h3);
                  }
                  return Ze;
                }, "groups"))]), w(!st && A(je.parser, je.originalText) && We && re(je) ? "," : ""), g, ae.close ? Me("close") : ""], { shouldBreak: _e });
                return He ? _(Ge) : Ge;
              }
              case "value-func":
                return [ae.value, d(Te, "supports") && Pe(ae) ? " " : "", Me("group")];
              case "value-paren":
                return ae.value;
              case "value-number":
                return [Je(ae.value), G(ae.unit)];
              case "value-operator":
                return ae.value;
              case "value-word":
                return ae.isColor && ae.isHex || b(ae.value) ? ae.value.toLowerCase() : ae.value;
              case "value-colon": {
                let Ve = Te.getParentNode(), We = Ve && Ve.groups.indexOf(ae), Xe = We && Ve.groups[We - 1];
                return [ae.value, Xe && typeof Xe.value == "string" && t(Xe.value) === "\\" || C(Te, "url") ? "" : y];
              }
              case "value-comma":
                return [ae.value, " "];
              case "value-string":
                return a(ae.raws.quote + ae.value + ae.raws.quote, je);
              case "value-atword":
                return ["@", ae.value];
              case "value-unicode-range":
                return ae.value;
              case "value-unknown":
                return ae.value;
              default:
                throw new Error(`Unknown postcss type ${JSON.stringify(ae.type)}`);
            }
          }
          function Ce(Te, je, Me) {
            let ae = [];
            return Te.each((nt, tt, Ve) => {
              let We = Ve[tt - 1];
              if (We && We.type === "css-comment" && We.text.trim() === "prettier-ignore") {
                let Xe = nt.getValue();
                ae.push(je.originalText.slice(Ae(Xe), Ee(Xe)));
              } else ae.push(Me());
              tt !== Ve.length - 1 && (Ve[tt + 1].type === "css-comment" && !n2(je.originalText, Ae(Ve[tt + 1]), { backwards: true }) && !u(Ve[tt]) || Ve[tt + 1].type === "css-atrule" && Ve[tt + 1].name === "else" && Ve[tt].type !== "css-comment" ? ae.push(" ") : (ae.push(je.__isHTMLStyleAttribute ? y : h3), i(je.originalText, nt.getValue(), Ee) && !u(Ve[tt]) && ae.push(h3)));
            }, "nodes"), ae;
          }
          var Be = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, ve = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g, ze = /[A-Za-z]+/g, be = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g, Ye = new RegExp(Be.source + `|(${be.source})?(${ve.source})(${ze.source})?`, "g");
          function Se(Te, je) {
            return Te.replace(Be, (Me) => a(Me, je));
          }
          function Ie(Te, je) {
            let Me = je.singleQuote ? "'" : '"';
            return Te.includes('"') || Te.includes("'") ? Te : Me + Te + Me;
          }
          function Oe(Te) {
            return Te.replace(Ye, (je, Me, ae, nt, tt) => !ae && nt ? Je(nt) + m(tt || "") : je);
          }
          function Je(Te) {
            return s(Te).replace(/\.0(?=$|e)/, "");
          }
          r.exports = { print: ye, embed: P, insertPragma: $, massageAstNode: I };
        } }), Rd = te({ "src/language-css/options.js"(e2, r) {
          "use strict";
          ne();
          var t = Mt();
          r.exports = { singleQuote: t.singleQuote };
        } }), $d = te({ "src/language-css/parsers.js"() {
          ne();
        } }), Vd = te({ "node_modules/linguist-languages/data/CSS.json"(e2, r) {
          r.exports = { name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 };
        } }), Wd = te({ "node_modules/linguist-languages/data/PostCSS.json"(e2, r) {
          r.exports = { name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 };
        } }), Hd = te({ "node_modules/linguist-languages/data/Less.json"(e2, r) {
          r.exports = { name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 };
        } }), Gd = te({ "node_modules/linguist-languages/data/SCSS.json"(e2, r) {
          r.exports = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
        } }), Ud = te({ "src/language-css/index.js"(e2, r) {
          "use strict";
          ne();
          var t = _t(), s = Md(), a = Rd(), n2 = $d(), u = [t(Vd(), (l) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...l.extensions, ".wxss"] })), t(Wd(), () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), t(Hd(), () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), t(Gd(), () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))], i = { postcss: s };
          r.exports = { languages: u, options: a, printers: i, parsers: n2 };
        } }), Jd = te({ "src/language-handlebars/loc.js"(e2, r) {
          "use strict";
          ne();
          function t(a) {
            return a.loc.start.offset;
          }
          function s(a) {
            return a.loc.end.offset;
          }
          r.exports = { locStart: t, locEnd: s };
        } }), zd = te({ "src/language-handlebars/clean.js"(e2, r) {
          "use strict";
          ne();
          function t(s, a) {
            if (s.type === "TextNode") {
              let n2 = s.chars.trim();
              if (!n2) return null;
              a.chars = n2.replace(/[\t\n\f\r ]+/g, " ");
            }
            s.type === "AttrNode" && s.name.toLowerCase() === "class" && delete a.value;
          }
          t.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]), r.exports = t;
        } }), Xd = te({ "src/language-handlebars/html-void-elements.evaluate.js"(e2, r) {
          r.exports = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
        } }), Kd = te({ "src/language-handlebars/utils.js"(e2, r) {
          "use strict";
          ne();
          var t = lt(), s = Xd();
          function a(x2) {
            let I = x2.getValue(), P = x2.getParentNode(0);
            return !!(g(x2, ["ElementNode"]) && t(P.children) === I || g(x2, ["Block"]) && t(P.body) === I);
          }
          function n2(x2) {
            return x2.toUpperCase() === x2;
          }
          function u(x2) {
            return h3(x2, ["ElementNode"]) && typeof x2.tag == "string" && !x2.tag.startsWith(":") && (n2(x2.tag[0]) || x2.tag.includes("."));
          }
          var i = new Set(s);
          function l(x2) {
            return i.has(x2.toLowerCase()) && !n2(x2[0]);
          }
          function p(x2) {
            return x2.selfClosing === true || l(x2.tag) || u(x2) && x2.children.every((I) => y(I));
          }
          function y(x2) {
            return h3(x2, ["TextNode"]) && !/\S/.test(x2.chars);
          }
          function h3(x2, I) {
            return x2 && I.includes(x2.type);
          }
          function g(x2, I) {
            let P = x2.getParentNode(0);
            return h3(P, I);
          }
          function c(x2, I) {
            let P = _(x2);
            return h3(P, I);
          }
          function f(x2, I) {
            let P = w(x2);
            return h3(P, I);
          }
          function F(x2, I) {
            var P, $, D, T;
            let m = x2.getValue(), C = (P = x2.getParentNode(0)) !== null && P !== void 0 ? P : {}, o = ($ = (D = (T = C.children) !== null && T !== void 0 ? T : C.body) !== null && D !== void 0 ? D : C.parts) !== null && $ !== void 0 ? $ : [], d = o.indexOf(m);
            return d !== -1 && o[d + I];
          }
          function _(x2) {
            let I = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
            return F(x2, -I);
          }
          function w(x2) {
            return F(x2, 1);
          }
          function E(x2) {
            return h3(x2, ["MustacheCommentStatement"]) && typeof x2.value == "string" && x2.value.trim() === "prettier-ignore";
          }
          function N(x2) {
            let I = x2.getValue(), P = _(x2, 2);
            return E(I) || E(P);
          }
          r.exports = { getNextNode: w, getPreviousNode: _, hasPrettierIgnore: N, isLastNodeOfSiblings: a, isNextNodeOfSomeType: f, isNodeOfSomeType: h3, isParentOfSomeType: g, isPreviousNodeOfSomeType: c, isVoid: p, isWhitespaceNode: y };
        } }), Yd = te({ "src/language-handlebars/printer-glimmer.js"(e2, r) {
          "use strict";
          ne();
          var { builders: { dedent: t, fill: s, group: a, hardline: n2, ifBreak: u, indent: i, join: l, line: p, softline: y }, utils: { getDocParts: h3, replaceTextEndOfLine: g } } = qe(), { getPreferredQuote: c, isNonEmptyArray: f } = Ue(), { locStart: F, locEnd: _ } = Jd(), w = zd(), { getNextNode: E, getPreviousNode: N, hasPrettierIgnore: x2, isLastNodeOfSiblings: I, isNextNodeOfSomeType: P, isNodeOfSomeType: $, isParentOfSomeType: D, isPreviousNodeOfSomeType: T, isVoid: m, isWhitespaceNode: C } = Kd(), o = 2;
          function d(H, pe, X) {
            let le = H.getValue();
            if (!le) return "";
            if (x2(H)) return pe.originalText.slice(F(le), _(le));
            let Ae = pe.singleQuote ? "'" : '"';
            switch (le.type) {
              case "Block":
              case "Program":
              case "Template":
                return a(H.map(X, "body"));
              case "ElementNode": {
                let Ee = a(S(H, X)), De = pe.htmlWhitespaceSensitivity === "ignore" && P(H, ["ElementNode"]) ? y : "";
                if (m(le)) return [Ee, De];
                let A = ["</", le.tag, ">"];
                return le.children.length === 0 ? [Ee, i(A), De] : pe.htmlWhitespaceSensitivity === "ignore" ? [Ee, i(b(H, pe, X)), n2, i(A), De] : [Ee, i(a(b(H, pe, X))), i(A), De];
              }
              case "BlockStatement": {
                let Ee = H.getParentNode(1);
                return Ee && Ee.inverse && Ee.inverse.body.length === 1 && Ee.inverse.body[0] === le && Ee.inverse.body[0].path.parts[0] === Ee.path.parts[0] ? [ie(H, X, Ee.inverse.body[0].path.parts[0]), de(H, X, pe), ue(H, X, pe)] : [j(H, X), a([de(H, X, pe), ue(H, X, pe), ee(H, X, pe)])];
              }
              case "ElementModifierStatement":
                return a(["{{", Re(H, X), "}}"]);
              case "MustacheStatement":
                return a([k(le), Re(H, X), M(le)]);
              case "SubExpression":
                return a(["(", ke(H, X), y, ")"]);
              case "AttrNode": {
                let Ee = le.value.type === "TextNode";
                if (Ee && le.value.chars === "" && F(le.value) === _(le.value)) return le.name;
                let A = Ee ? c(le.value.chars, Ae).quote : le.value.type === "ConcatStatement" ? c(le.value.parts.filter((re) => re.type === "TextNode").map((re) => re.chars).join(""), Ae).quote : "", G = X("value");
                return [le.name, "=", A, le.name === "class" && A ? a(i(G)) : G, A];
              }
              case "ConcatStatement":
                return H.map(X, "parts");
              case "Hash":
                return l(p, H.map(X, "pairs"));
              case "HashPair":
                return [le.key, "=", X("value")];
              case "TextNode": {
                let Ee = le.chars.replace(/{{/g, "\\{{"), De = U(H);
                if (De) {
                  if (De === "class") {
                    let Ye = Ee.trim().split(/\s+/).join(" "), Se = false, Ie = false;
                    return D(H, ["ConcatStatement"]) && (T(H, ["MustacheStatement"]) && /^\s/.test(Ee) && (Se = true), P(H, ["MustacheStatement"]) && /\s$/.test(Ee) && Ye !== "" && (Ie = true)), [Se ? p : "", Ye, Ie ? p : ""];
                  }
                  return g(Ee);
                }
                let G = /^[\t\n\f\r ]*$/.test(Ee), re = !N(H), ye = !E(H);
                if (pe.htmlWhitespaceSensitivity !== "ignore") {
                  let Ye = /^[\t\n\f\r ]*/, Se = /[\t\n\f\r ]*$/, Ie = ye && D(H, ["Template"]), Oe = re && D(H, ["Template"]);
                  if (G) {
                    if (Oe || Ie) return "";
                    let ae = [p], nt = Z(Ee);
                    return nt && (ae = ge(nt)), I(H) && (ae = ae.map((tt) => t(tt))), ae;
                  }
                  let [Je] = Ee.match(Ye), [Te] = Ee.match(Se), je = [];
                  if (Je) {
                    je = [p];
                    let ae = Z(Je);
                    ae && (je = ge(ae)), Ee = Ee.replace(Ye, "");
                  }
                  let Me = [];
                  if (Te) {
                    if (!Ie) {
                      Me = [p];
                      let ae = Z(Te);
                      ae && (Me = ge(ae)), I(H) && (Me = Me.map((nt) => t(nt)));
                    }
                    Ee = Ee.replace(Se, "");
                  }
                  return [...je, s(Fe(Ee)), ...Me];
                }
                let Ce = Z(Ee), Be = se(Ee), ve = fe(Ee);
                if ((re || ye) && G && D(H, ["Block", "ElementNode", "Template"])) return "";
                G && Ce ? (Be = Math.min(Ce, o), ve = 0) : (P(H, ["BlockStatement", "ElementNode"]) && (ve = Math.max(ve, 1)), T(H, ["BlockStatement", "ElementNode"]) && (Be = Math.max(Be, 1)));
                let ze = "", be = "";
                return ve === 0 && P(H, ["MustacheStatement"]) && (be = " "), Be === 0 && T(H, ["MustacheStatement"]) && (ze = " "), re && (Be = 0, ze = ""), ye && (ve = 0, be = ""), Ee = Ee.replace(/^[\t\n\f\r ]+/g, ze).replace(/[\t\n\f\r ]+$/, be), [...ge(Be), s(Fe(Ee)), ...ge(ve)];
              }
              case "MustacheCommentStatement": {
                let Ee = F(le), De = _(le), A = pe.originalText.charAt(Ee + 2) === "~", G = pe.originalText.charAt(De - 3) === "~", re = le.value.includes("}}") ? "--" : "";
                return ["{{", A ? "~" : "", "!", re, le.value, re, G ? "~" : "", "}}"];
              }
              case "PathExpression":
                return le.original;
              case "BooleanLiteral":
                return String(le.value);
              case "CommentStatement":
                return ["<!--", le.value, "-->"];
              case "StringLiteral": {
                if (we(H)) {
                  let Ee = pe.singleQuote ? '"' : "'";
                  return he(le.value, Ee);
                }
                return he(le.value, Ae);
              }
              case "NumberLiteral":
                return String(le.value);
              case "UndefinedLiteral":
                return "undefined";
              case "NullLiteral":
                return "null";
              default:
                throw new Error("unknown glimmer type: " + JSON.stringify(le.type));
            }
          }
          function v(H, pe) {
            return F(H) - F(pe);
          }
          function S(H, pe) {
            let X = H.getValue(), le = ["attributes", "modifiers", "comments"].filter((Ee) => f(X[Ee])), Ae = le.flatMap((Ee) => X[Ee]).sort(v);
            for (let Ee of le) H.each((De) => {
              let A = Ae.indexOf(De.getValue());
              Ae.splice(A, 1, [p, pe()]);
            }, Ee);
            return f(X.blockParams) && Ae.push(p, oe(X)), ["<", X.tag, i(Ae), B(X)];
          }
          function b(H, pe, X) {
            let Ae = H.getValue().children.every((Ee) => C(Ee));
            return pe.htmlWhitespaceSensitivity === "ignore" && Ae ? "" : H.map((Ee, De) => {
              let A = X();
              return De === 0 && pe.htmlWhitespaceSensitivity === "ignore" ? [y, A] : A;
            }, "children");
          }
          function B(H) {
            return m(H) ? u([y, "/>"], [" />", y]) : u([y, ">"], ">");
          }
          function k(H) {
            let pe = H.escaped === false ? "{{{" : "{{", X = H.strip && H.strip.open ? "~" : "";
            return [pe, X];
          }
          function M(H) {
            let pe = H.escaped === false ? "}}}" : "}}";
            return [H.strip && H.strip.close ? "~" : "", pe];
          }
          function R(H) {
            let pe = k(H), X = H.openStrip.open ? "~" : "";
            return [pe, X, "#"];
          }
          function q(H) {
            let pe = M(H);
            return [H.openStrip.close ? "~" : "", pe];
          }
          function J(H) {
            let pe = k(H), X = H.closeStrip.open ? "~" : "";
            return [pe, X, "/"];
          }
          function L(H) {
            let pe = M(H);
            return [H.closeStrip.close ? "~" : "", pe];
          }
          function Q(H) {
            let pe = k(H), X = H.inverseStrip.open ? "~" : "";
            return [pe, X];
          }
          function V(H) {
            let pe = M(H);
            return [H.inverseStrip.close ? "~" : "", pe];
          }
          function j(H, pe) {
            let X = H.getValue(), le = [], Ae = Pe(H, pe);
            return Ae && le.push(a(Ae)), f(X.program.blockParams) && le.push(oe(X.program)), a([R(X), Ne(H, pe), le.length > 0 ? i([p, l(p, le)]) : "", y, q(X)]);
          }
          function Y(H, pe) {
            return [pe.htmlWhitespaceSensitivity === "ignore" ? n2 : "", Q(H), "else", V(H)];
          }
          function ie(H, pe, X) {
            let le = H.getValue(), Ae = H.getParentNode(1);
            return a([Q(Ae), ["else", " ", X], i([p, a(Pe(H, pe)), ...f(le.program.blockParams) ? [p, oe(le.program)] : []]), y, V(Ae)]);
          }
          function ee(H, pe, X) {
            let le = H.getValue();
            return X.htmlWhitespaceSensitivity === "ignore" ? [ce(le) ? y : n2, J(le), pe("path"), L(le)] : [J(le), pe("path"), L(le)];
          }
          function ce(H) {
            return $(H, ["BlockStatement"]) && H.program.body.every((pe) => C(pe));
          }
          function W(H) {
            return K(H) && H.inverse.body.length === 1 && $(H.inverse.body[0], ["BlockStatement"]) && H.inverse.body[0].path.parts[0] === H.path.parts[0];
          }
          function K(H) {
            return $(H, ["BlockStatement"]) && H.inverse;
          }
          function de(H, pe, X) {
            let le = H.getValue();
            if (ce(le)) return "";
            let Ae = pe("program");
            return X.htmlWhitespaceSensitivity === "ignore" ? i([n2, Ae]) : i(Ae);
          }
          function ue(H, pe, X) {
            let le = H.getValue(), Ae = pe("inverse"), Ee = X.htmlWhitespaceSensitivity === "ignore" ? [n2, Ae] : Ae;
            return W(le) ? Ee : K(le) ? [Y(le, X), i(Ee)] : "";
          }
          function Fe(H) {
            return h3(l(p, z(H)));
          }
          function z(H) {
            return H.split(/[\t\n\f\r ]+/);
          }
          function U(H) {
            for (let pe = 0; pe < 2; pe++) {
              let X = H.getParentNode(pe);
              if (X && X.type === "AttrNode") return X.name.toLowerCase();
            }
          }
          function Z(H) {
            return H = typeof H == "string" ? H : "", H.split(`
`).length - 1;
          }
          function se(H) {
            H = typeof H == "string" ? H : "";
            let pe = (H.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
            return Z(pe);
          }
          function fe(H) {
            H = typeof H == "string" ? H : "";
            let pe = (H.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
            return Z(pe);
          }
          function ge() {
            let H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return Array.from({ length: Math.min(H, o) }).fill(n2);
          }
          function he(H, pe) {
            let { quote: X, regex: le } = c(H, pe);
            return [X, H.replace(le, `\\${X}`), X];
          }
          function we(H) {
            let pe = 0, X = H.getParentNode(pe);
            for (; X && $(X, ["SubExpression"]); ) pe++, X = H.getParentNode(pe);
            return !!(X && $(H.getParentNode(pe + 1), ["ConcatStatement"]) && $(H.getParentNode(pe + 2), ["AttrNode"]));
          }
          function ke(H, pe) {
            let X = Ne(H, pe), le = Pe(H, pe);
            return le ? i([X, p, a(le)]) : X;
          }
          function Re(H, pe) {
            let X = Ne(H, pe), le = Pe(H, pe);
            return le ? [i([X, p, le]), y] : X;
          }
          function Ne(H, pe) {
            return pe("path");
          }
          function Pe(H, pe) {
            let X = H.getValue(), le = [];
            if (X.params.length > 0) {
              let Ae = H.map(pe, "params");
              le.push(...Ae);
            }
            if (X.hash && X.hash.pairs.length > 0) {
              let Ae = pe("hash");
              le.push(Ae);
            }
            return le.length === 0 ? "" : l(p, le);
          }
          function oe(H) {
            return ["as |", H.blockParams.join(" "), "|"];
          }
          r.exports = { print: d, massageAstNode: w };
        } }), Qd = te({ "src/language-handlebars/parsers.js"() {
          ne();
        } }), Zd = te({ "node_modules/linguist-languages/data/Handlebars.json"(e2, r) {
          r.exports = { name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 };
        } }), eg = te({ "src/language-handlebars/index.js"(e2, r) {
          "use strict";
          ne();
          var t = _t(), s = Yd(), a = Qd(), n2 = [t(Zd(), () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], u = { glimmer: s };
          r.exports = { languages: n2, printers: u, parsers: a };
        } }), tg = te({ "src/language-graphql/pragma.js"(e2, r) {
          "use strict";
          ne();
          function t(a) {
            return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(a);
          }
          function s(a) {
            return `# @format

` + a;
          }
          r.exports = { hasPragma: t, insertPragma: s };
        } }), rg = te({ "src/language-graphql/loc.js"(e2, r) {
          "use strict";
          ne();
          function t(a) {
            return typeof a.start == "number" ? a.start : a.loc && a.loc.start;
          }
          function s(a) {
            return typeof a.end == "number" ? a.end : a.loc && a.loc.end;
          }
          r.exports = { locStart: t, locEnd: s };
        } }), ng = te({ "src/language-graphql/printer-graphql.js"(e2, r) {
          "use strict";
          ne();
          var { builders: { join: t, hardline: s, line: a, softline: n2, group: u, indent: i, ifBreak: l } } = qe(), { isNextLineEmpty: p, isNonEmptyArray: y } = Ue(), { insertPragma: h3 } = tg(), { locStart: g, locEnd: c } = rg();
          function f(P, $, D) {
            let T = P.getValue();
            if (!T) return "";
            if (typeof T == "string") return T;
            switch (T.kind) {
              case "Document": {
                let m = [];
                return P.each((C, o, d) => {
                  m.push(D()), o !== d.length - 1 && (m.push(s), p($.originalText, C.getValue(), c) && m.push(s));
                }, "definitions"), [...m, s];
              }
              case "OperationDefinition": {
                let m = $.originalText[g(T)] !== "{", C = Boolean(T.name);
                return [m ? T.operation : "", m && C ? [" ", D("name")] : "", m && !C && y(T.variableDefinitions) ? " " : "", y(T.variableDefinitions) ? u(["(", i([n2, t([l("", ", "), n2], P.map(D, "variableDefinitions"))]), n2, ")"]) : "", F(P, D, T), T.selectionSet ? !m && !C ? "" : " " : "", D("selectionSet")];
              }
              case "FragmentDefinition":
                return ["fragment ", D("name"), y(T.variableDefinitions) ? u(["(", i([n2, t([l("", ", "), n2], P.map(D, "variableDefinitions"))]), n2, ")"]) : "", " on ", D("typeCondition"), F(P, D, T), " ", D("selectionSet")];
              case "SelectionSet":
                return ["{", i([s, t(s, _(P, $, D, "selections"))]), s, "}"];
              case "Field":
                return u([T.alias ? [D("alias"), ": "] : "", D("name"), T.arguments.length > 0 ? u(["(", i([n2, t([l("", ", "), n2], _(P, $, D, "arguments"))]), n2, ")"]) : "", F(P, D, T), T.selectionSet ? " " : "", D("selectionSet")]);
              case "Name":
                return T.value;
              case "StringValue": {
                if (T.block) {
                  let m = T.value.replace(/"""/g, "\\$&").split(`
`);
                  return m.length === 1 && (m[0] = m[0].trim()), m.every((C) => C === "") && (m.length = 0), t(s, ['"""', ...m, '"""']);
                }
                return ['"', T.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
              }
              case "IntValue":
              case "FloatValue":
              case "EnumValue":
                return T.value;
              case "BooleanValue":
                return T.value ? "true" : "false";
              case "NullValue":
                return "null";
              case "Variable":
                return ["$", D("name")];
              case "ListValue":
                return u(["[", i([n2, t([l("", ", "), n2], P.map(D, "values"))]), n2, "]"]);
              case "ObjectValue":
                return u(["{", $.bracketSpacing && T.fields.length > 0 ? " " : "", i([n2, t([l("", ", "), n2], P.map(D, "fields"))]), n2, l("", $.bracketSpacing && T.fields.length > 0 ? " " : ""), "}"]);
              case "ObjectField":
              case "Argument":
                return [D("name"), ": ", D("value")];
              case "Directive":
                return ["@", D("name"), T.arguments.length > 0 ? u(["(", i([n2, t([l("", ", "), n2], _(P, $, D, "arguments"))]), n2, ")"]) : ""];
              case "NamedType":
                return D("name");
              case "VariableDefinition":
                return [D("variable"), ": ", D("type"), T.defaultValue ? [" = ", D("defaultValue")] : "", F(P, D, T)];
              case "ObjectTypeExtension":
              case "ObjectTypeDefinition":
                return [D("description"), T.description ? s : "", T.kind === "ObjectTypeExtension" ? "extend " : "", "type ", D("name"), T.interfaces.length > 0 ? [" implements ", ...N(P, $, D)] : "", F(P, D, T), T.fields.length > 0 ? [" {", i([s, t(s, _(P, $, D, "fields"))]), s, "}"] : ""];
              case "FieldDefinition":
                return [D("description"), T.description ? s : "", D("name"), T.arguments.length > 0 ? u(["(", i([n2, t([l("", ", "), n2], _(P, $, D, "arguments"))]), n2, ")"]) : "", ": ", D("type"), F(P, D, T)];
              case "DirectiveDefinition":
                return [D("description"), T.description ? s : "", "directive ", "@", D("name"), T.arguments.length > 0 ? u(["(", i([n2, t([l("", ", "), n2], _(P, $, D, "arguments"))]), n2, ")"]) : "", T.repeatable ? " repeatable" : "", " on ", t(" | ", P.map(D, "locations"))];
              case "EnumTypeExtension":
              case "EnumTypeDefinition":
                return [D("description"), T.description ? s : "", T.kind === "EnumTypeExtension" ? "extend " : "", "enum ", D("name"), F(P, D, T), T.values.length > 0 ? [" {", i([s, t(s, _(P, $, D, "values"))]), s, "}"] : ""];
              case "EnumValueDefinition":
                return [D("description"), T.description ? s : "", D("name"), F(P, D, T)];
              case "InputValueDefinition":
                return [D("description"), T.description ? T.description.block ? s : a : "", D("name"), ": ", D("type"), T.defaultValue ? [" = ", D("defaultValue")] : "", F(P, D, T)];
              case "InputObjectTypeExtension":
              case "InputObjectTypeDefinition":
                return [D("description"), T.description ? s : "", T.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", D("name"), F(P, D, T), T.fields.length > 0 ? [" {", i([s, t(s, _(P, $, D, "fields"))]), s, "}"] : ""];
              case "SchemaExtension":
                return ["extend schema", F(P, D, T), ...T.operationTypes.length > 0 ? [" {", i([s, t(s, _(P, $, D, "operationTypes"))]), s, "}"] : []];
              case "SchemaDefinition":
                return [D("description"), T.description ? s : "", "schema", F(P, D, T), " {", T.operationTypes.length > 0 ? i([s, t(s, _(P, $, D, "operationTypes"))]) : "", s, "}"];
              case "OperationTypeDefinition":
                return [D("operation"), ": ", D("type")];
              case "InterfaceTypeExtension":
              case "InterfaceTypeDefinition":
                return [D("description"), T.description ? s : "", T.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", D("name"), T.interfaces.length > 0 ? [" implements ", ...N(P, $, D)] : "", F(P, D, T), T.fields.length > 0 ? [" {", i([s, t(s, _(P, $, D, "fields"))]), s, "}"] : ""];
              case "FragmentSpread":
                return ["...", D("name"), F(P, D, T)];
              case "InlineFragment":
                return ["...", T.typeCondition ? [" on ", D("typeCondition")] : "", F(P, D, T), " ", D("selectionSet")];
              case "UnionTypeExtension":
              case "UnionTypeDefinition":
                return u([D("description"), T.description ? s : "", u([T.kind === "UnionTypeExtension" ? "extend " : "", "union ", D("name"), F(P, D, T), T.types.length > 0 ? [" =", l("", " "), i([l([a, "  "]), t([a, "| "], P.map(D, "types"))])] : ""])]);
              case "ScalarTypeExtension":
              case "ScalarTypeDefinition":
                return [D("description"), T.description ? s : "", T.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", D("name"), F(P, D, T)];
              case "NonNullType":
                return [D("type"), "!"];
              case "ListType":
                return ["[", D("type"), "]"];
              default:
                throw new Error("unknown graphql type: " + JSON.stringify(T.kind));
            }
          }
          function F(P, $, D) {
            if (D.directives.length === 0) return "";
            let T = t(a, P.map($, "directives"));
            return D.kind === "FragmentDefinition" || D.kind === "OperationDefinition" ? u([a, T]) : [" ", u(i([n2, T]))];
          }
          function _(P, $, D, T) {
            return P.map((m, C, o) => {
              let d = D();
              return C < o.length - 1 && p($.originalText, m.getValue(), c) ? [d, s] : d;
            }, T);
          }
          function w(P) {
            return P.kind && P.kind !== "Comment";
          }
          function E(P) {
            let $ = P.getValue();
            if ($.kind === "Comment") return "#" + $.value.trimEnd();
            throw new Error("Not a comment: " + JSON.stringify($));
          }
          function N(P, $, D) {
            let T = P.getNode(), m = [], { interfaces: C } = T, o = P.map((d) => D(d), "interfaces");
            for (let d = 0; d < C.length; d++) {
              let v = C[d];
              m.push(o[d]);
              let S = C[d + 1];
              if (S) {
                let b = $.originalText.slice(v.loc.end, S.loc.start), B = b.includes("#"), k = b.replace(/#.*/g, "").trim();
                m.push(k === "," ? "," : " &", B ? a : " ");
              }
            }
            return m;
          }
          function x2(P, $) {
            P.kind === "StringValue" && P.block && !P.value.includes(`
`) && ($.value = $.value.trim());
          }
          x2.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
          function I(P) {
            var $;
            let D = P.getValue();
            return D == null || ($ = D.comments) === null || $ === void 0 ? void 0 : $.some((T) => T.value.trim() === "prettier-ignore");
          }
          r.exports = { print: f, massageAstNode: x2, hasPrettierIgnore: I, insertPragma: h3, printComment: E, canAttachComment: w };
        } }), ug = te({ "src/language-graphql/options.js"(e2, r) {
          "use strict";
          ne();
          var t = Mt();
          r.exports = { bracketSpacing: t.bracketSpacing };
        } }), sg = te({ "src/language-graphql/parsers.js"() {
          ne();
        } }), ig = te({ "node_modules/linguist-languages/data/GraphQL.json"(e2, r) {
          r.exports = { name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 };
        } }), ag = te({ "src/language-graphql/index.js"(e2, r) {
          "use strict";
          ne();
          var t = _t(), s = ng(), a = ug(), n2 = sg(), u = [t(ig(), () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], i = { graphql: s };
          r.exports = { languages: u, options: a, printers: i, parsers: n2 };
        } }), Po = te({ "node_modules/collapse-white-space/index.js"(e2, r) {
          "use strict";
          ne(), r.exports = t;
          function t(s) {
            return String(s).replace(/\s+/g, " ");
          }
        } }), Io = te({ "src/language-markdown/loc.js"(e2, r) {
          "use strict";
          ne();
          function t(a) {
            return a.position.start.offset;
          }
          function s(a) {
            return a.position.end.offset;
          }
          r.exports = { locStart: t, locEnd: s };
        } }), og = te({ "src/language-markdown/constants.evaluate.js"(e2, r) {
          r.exports = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" };
        } }), iu = te({ "src/language-markdown/utils.js"(e2, r) {
          "use strict";
          ne();
          var { getLast: t } = Ue(), { locStart: s, locEnd: a } = Io(), { cjkPattern: n2, kPattern: u, punctuationPattern: i } = og(), l = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], p = [...l, "tableCell", "paragraph", "heading"], y = new RegExp(u), h3 = new RegExp(i);
          function g(E, N) {
            let x2 = "non-cjk", I = "cj-letter", P = "k-letter", $ = "cjk-punctuation", D = [], T = (N.proseWrap === "preserve" ? E : E.replace(new RegExp(`(${n2})
(${n2})`, "g"), "$1$2")).split(/([\t\n ]+)/);
            for (let [C, o] of T.entries()) {
              if (C % 2 === 1) {
                D.push({ type: "whitespace", value: /\n/.test(o) ? `
` : " " });
                continue;
              }
              if ((C === 0 || C === T.length - 1) && o === "") continue;
              let d = o.split(new RegExp(`(${n2})`));
              for (let [v, S] of d.entries()) if (!((v === 0 || v === d.length - 1) && S === "")) {
                if (v % 2 === 0) {
                  S !== "" && m({ type: "word", value: S, kind: x2, hasLeadingPunctuation: h3.test(S[0]), hasTrailingPunctuation: h3.test(t(S)) });
                  continue;
                }
                m(h3.test(S) ? { type: "word", value: S, kind: $, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: S, kind: y.test(S) ? P : I, hasLeadingPunctuation: false, hasTrailingPunctuation: false });
              }
            }
            return D;
            function m(C) {
              let o = t(D);
              o && o.type === "word" && (o.kind === x2 && C.kind === I && !o.hasTrailingPunctuation || o.kind === I && C.kind === x2 && !C.hasLeadingPunctuation ? D.push({ type: "whitespace", value: " " }) : !d(x2, $) && ![o.value, C.value].some((v) => /\u3000/.test(v)) && D.push({ type: "whitespace", value: "" })), D.push(C);
              function d(v, S) {
                return o.kind === v && C.kind === S || o.kind === S && C.kind === v;
              }
            }
          }
          function c(E, N) {
            let [, x2, I, P] = N.slice(E.position.start.offset, E.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
            return { numberText: x2, marker: I, leadingSpaces: P };
          }
          function f(E, N) {
            if (!E.ordered || E.children.length < 2) return false;
            let x2 = Number(c(E.children[0], N.originalText).numberText), I = Number(c(E.children[1], N.originalText).numberText);
            if (x2 === 0 && E.children.length > 2) {
              let P = Number(c(E.children[2], N.originalText).numberText);
              return I === 1 && P === 1;
            }
            return I === 1;
          }
          function F(E, N) {
            let { value: x2 } = E;
            return E.position.end.offset === N.length && x2.endsWith(`
`) && N.endsWith(`
`) ? x2.slice(0, -1) : x2;
          }
          function _(E, N) {
            return function x2(I, P, $) {
              let D = Object.assign({}, N(I, P, $));
              return D.children && (D.children = D.children.map((T, m) => x2(T, m, [D, ...$]))), D;
            }(E, null, []);
          }
          function w(E) {
            if ((E == null ? void 0 : E.type) !== "link" || E.children.length !== 1) return false;
            let [N] = E.children;
            return s(E) === s(N) && a(E) === a(N);
          }
          r.exports = { mapAst: _, splitText: g, punctuationPattern: i, getFencedCodeBlockValue: F, getOrderedListItemInfo: c, hasGitDiffFriendlyOrderedList: f, INLINE_NODE_TYPES: l, INLINE_NODE_WRAPPER_TYPES: p, isAutolink: w };
        } }), lg = te({ "src/language-markdown/embed.js"(e2, r) {
          "use strict";
          ne();
          var { inferParserByLanguage: t, getMaxContinuousCount: s } = Ue(), { builders: { hardline: a, markAsRoot: n2 }, utils: { replaceEndOfLine: u } } = qe(), i = su(), { getFencedCodeBlockValue: l } = iu();
          function p(y, h3, g, c) {
            let f = y.getValue();
            if (f.type === "code" && f.lang !== null) {
              let F = t(f.lang, c);
              if (F) {
                let _ = c.__inJsTemplate ? "~" : "`", w = _.repeat(Math.max(3, s(f.value, _) + 1)), E = { parser: F };
                f.lang === "tsx" && (E.filepath = "dummy.tsx");
                let N = g(l(f, c.originalText), E, { stripTrailingHardline: true });
                return n2([w, f.lang, f.meta ? " " + f.meta : "", a, u(N), a, w]);
              }
            }
            switch (f.type) {
              case "front-matter":
                return i(f, g);
              case "importExport":
                return [g(f.value, { parser: "babel" }, { stripTrailingHardline: true }), a];
              case "jsx":
                return g(`<$>${f.value}</$>`, { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
            }
            return null;
          }
          r.exports = p;
        } }), ko = te({ "src/language-markdown/pragma.js"(e2, r) {
          "use strict";
          ne();
          var t = _o(), s = ["format", "prettier"];
          function a(n2) {
            let u = `@(${s.join("|")})`, i = new RegExp([`<!--\\s*${u}\\s*-->`, `{\\s*\\/\\*\\s*${u}\\s*\\*\\/\\s*}`, `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${u}[^\\S
]*($|
)[\\s\\S]*
.*-->`].join("|"), "m"), l = n2.match(i);
            return (l == null ? void 0 : l.index) === 0;
          }
          r.exports = { startWithPragma: a, hasPragma: (n2) => a(t(n2).content.trimStart()), insertPragma: (n2) => {
            let u = t(n2), i = `<!-- @${s[0]} -->`;
            return u.frontMatter ? `${u.frontMatter.raw}

${i}

${u.content}` : `${i}

${u.content}`;
          } };
        } }), cg = te({ "src/language-markdown/print-preprocess.js"(e2, r) {
          "use strict";
          ne();
          var t = lt(), { getOrderedListItemInfo: s, mapAst: a, splitText: n2 } = iu(), u = /^.$/su;
          function i(w, E) {
            return w = y(w, E), w = c(w), w = p(w, E), w = F(w, E), w = _(w, E), w = f(w, E), w = l(w), w = h3(w), w;
          }
          function l(w) {
            return a(w, (E) => E.type !== "import" && E.type !== "export" ? E : Object.assign(Object.assign({}, E), {}, { type: "importExport" }));
          }
          function p(w, E) {
            return a(w, (N) => N.type !== "inlineCode" || E.proseWrap === "preserve" ? N : Object.assign(Object.assign({}, N), {}, { value: N.value.replace(/\s+/g, " ") }));
          }
          function y(w, E) {
            return a(w, (N) => N.type !== "text" || N.value === "*" || N.value === "_" || !u.test(N.value) || N.position.end.offset - N.position.start.offset === N.value.length ? N : Object.assign(Object.assign({}, N), {}, { value: E.originalText.slice(N.position.start.offset, N.position.end.offset) }));
          }
          function h3(w) {
            return g(w, (E, N) => E.type === "importExport" && N.type === "importExport", (E, N) => ({ type: "importExport", value: E.value + `

` + N.value, position: { start: E.position.start, end: N.position.end } }));
          }
          function g(w, E, N) {
            return a(w, (x2) => {
              if (!x2.children) return x2;
              let I = x2.children.reduce((P, $) => {
                let D = t(P);
                return D && E(D, $) ? P.splice(-1, 1, N(D, $)) : P.push($), P;
              }, []);
              return Object.assign(Object.assign({}, x2), {}, { children: I });
            });
          }
          function c(w) {
            return g(w, (E, N) => E.type === "text" && N.type === "text", (E, N) => ({ type: "text", value: E.value + N.value, position: { start: E.position.start, end: N.position.end } }));
          }
          function f(w, E) {
            return a(w, (N, x2, I) => {
              let [P] = I;
              if (N.type !== "text") return N;
              let { value: $ } = N;
              return P.type === "paragraph" && (x2 === 0 && ($ = $.trimStart()), x2 === P.children.length - 1 && ($ = $.trimEnd())), { type: "sentence", position: N.position, children: n2($, E) };
            });
          }
          function F(w, E) {
            return a(w, (N, x2, I) => {
              if (N.type === "code") {
                let P = /^\n?(?: {4,}|\t)/.test(E.originalText.slice(N.position.start.offset, N.position.end.offset));
                if (N.isIndented = P, P) for (let $ = 0; $ < I.length; $++) {
                  let D = I[$];
                  if (D.hasIndentedCodeblock) break;
                  D.type === "list" && (D.hasIndentedCodeblock = true);
                }
              }
              return N;
            });
          }
          function _(w, E) {
            return a(w, (I, P, $) => {
              if (I.type === "list" && I.children.length > 0) {
                for (let D = 0; D < $.length; D++) {
                  let T = $[D];
                  if (T.type === "list" && !T.isAligned) return I.isAligned = false, I;
                }
                I.isAligned = x2(I);
              }
              return I;
            });
            function N(I) {
              return I.children.length === 0 ? -1 : I.children[0].position.start.column - 1;
            }
            function x2(I) {
              if (!I.ordered) return true;
              let [P, $] = I.children;
              if (s(P, E.originalText).leadingSpaces.length > 1) return true;
              let T = N(P);
              if (T === -1) return false;
              if (I.children.length === 1) return T % E.tabWidth === 0;
              let m = N($);
              return T !== m ? false : T % E.tabWidth === 0 ? true : s($, E.originalText).leadingSpaces.length > 1;
            }
          }
          r.exports = i;
        } }), pg = te({ "src/language-markdown/clean.js"(e2, r) {
          "use strict";
          ne();
          var t = Po(), { isFrontMatterNode: s } = Ue(), { startWithPragma: a } = ko(), n2 = /* @__PURE__ */ new Set(["position", "raw"]);
          function u(i, l, p) {
            if ((i.type === "front-matter" || i.type === "code" || i.type === "yaml" || i.type === "import" || i.type === "export" || i.type === "jsx") && delete l.value, i.type === "list" && delete l.isAligned, (i.type === "list" || i.type === "listItem") && (delete l.spread, delete l.loose), i.type === "text" || (i.type === "inlineCode" && (l.value = i.value.replace(/[\t\n ]+/g, " ")), i.type === "wikiLink" && (l.value = i.value.trim().replace(/[\t\n]+/g, " ")), (i.type === "definition" || i.type === "linkReference" || i.type === "imageReference") && (l.label = t(i.label)), (i.type === "definition" || i.type === "link" || i.type === "image") && i.title && (l.title = i.title.replace(/\\(["')])/g, "$1")), p && p.type === "root" && p.children.length > 0 && (p.children[0] === i || s(p.children[0]) && p.children[1] === i) && i.type === "html" && a(i.value))) return null;
          }
          u.ignoredProperties = n2, r.exports = u;
        } }), fg = te({ "src/language-markdown/printer-markdown.js"(e2, r) {
          "use strict";
          ne();
          var t = Po(), { getLast: s, getMinNotPresentContinuousCount: a, getMaxContinuousCount: n2, getStringWidth: u, isNonEmptyArray: i } = Ue(), { builders: { breakParent: l, join: p, line: y, literalline: h3, markAsRoot: g, hardline: c, softline: f, ifBreak: F, fill: _, align: w, indent: E, group: N, hardlineWithoutBreakParent: x2 }, utils: { normalizeDoc: I, replaceTextEndOfLine: P }, printer: { printDocToString: $ } } = qe(), D = lg(), { insertPragma: T } = ko(), { locStart: m, locEnd: C } = Io(), o = cg(), d = pg(), { getFencedCodeBlockValue: v, hasGitDiffFriendlyOrderedList: S, splitText: b, punctuationPattern: B, INLINE_NODE_TYPES: k, INLINE_NODE_WRAPPER_TYPES: M, isAutolink: R } = iu(), q = /* @__PURE__ */ new Set(["importExport"]), J = ["heading", "tableCell", "link", "wikiLink"], L = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
          function Q(oe, H, pe) {
            let X = oe.getValue();
            if (ge(oe)) return b(H.originalText.slice(X.position.start.offset, X.position.end.offset), H).map((le) => le.type === "word" ? le.value : le.value === "" ? "" : W(oe, le.value, H));
            switch (X.type) {
              case "front-matter":
                return H.originalText.slice(X.position.start.offset, X.position.end.offset);
              case "root":
                return X.children.length === 0 ? "" : [I(de(oe, H, pe)), q.has(z(X).type) ? "" : c];
              case "paragraph":
                return ue(oe, H, pe, { postprocessor: _ });
              case "sentence":
                return ue(oe, H, pe);
              case "word": {
                let le = X.value.replace(/\*/g, "\\$&").replace(new RegExp([`(^|${B})(_+)`, `(_+)(${B}|$)`].join("|"), "g"), (De, A, G, re, ye) => (G ? `${A}${G}` : `${re}${ye}`).replace(/_/g, "\\_")), Ae = (De, A, G) => De.type === "sentence" && G === 0, Ee = (De, A, G) => R(De.children[G - 1]);
                return le !== X.value && (oe.match(void 0, Ae, Ee) || oe.match(void 0, Ae, (De, A, G) => De.type === "emphasis" && G === 0, Ee)) && (le = le.replace(/^(\\?[*_])+/, (De) => De.replace(/\\/g, ""))), le;
              }
              case "whitespace": {
                let le = oe.getParentNode(), Ae = le.children.indexOf(X), Ee = le.children[Ae + 1], De = Ee && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(Ee.value) ? "never" : H.proseWrap;
                return W(oe, X.value, { proseWrap: De });
              }
              case "emphasis": {
                let le;
                if (R(X.children[0])) le = H.originalText[X.position.start.offset];
                else {
                  let Ae = oe.getParentNode(), Ee = Ae.children.indexOf(X), De = Ae.children[Ee - 1], A = Ae.children[Ee + 1];
                  le = De && De.type === "sentence" && De.children.length > 0 && s(De.children).type === "word" && !s(De.children).hasTrailingPunctuation || A && A.type === "sentence" && A.children.length > 0 && A.children[0].type === "word" && !A.children[0].hasLeadingPunctuation || ce(oe, "emphasis") ? "*" : "_";
                }
                return [le, ue(oe, H, pe), le];
              }
              case "strong":
                return ["**", ue(oe, H, pe), "**"];
              case "delete":
                return ["~~", ue(oe, H, pe), "~~"];
              case "inlineCode": {
                let le = a(X.value, "`"), Ae = "`".repeat(le || 1), Ee = le && !/^\s/.test(X.value) ? " " : "";
                return [Ae, Ee, X.value, Ee, Ae];
              }
              case "wikiLink": {
                let le = "";
                return H.proseWrap === "preserve" ? le = X.value : le = X.value.replace(/[\t\n]+/g, " "), ["[[", le, "]]"];
              }
              case "link":
                switch (H.originalText[X.position.start.offset]) {
                  case "<": {
                    let le = "mailto:";
                    return ["<", X.url.startsWith(le) && H.originalText.slice(X.position.start.offset + 1, X.position.start.offset + 1 + le.length) !== le ? X.url.slice(le.length) : X.url, ">"];
                  }
                  case "[":
                    return ["[", ue(oe, H, pe), "](", he(X.url, ")"), we(X.title, H), ")"];
                  default:
                    return H.originalText.slice(X.position.start.offset, X.position.end.offset);
                }
              case "image":
                return ["![", X.alt || "", "](", he(X.url, ")"), we(X.title, H), ")"];
              case "blockquote":
                return ["> ", w("> ", ue(oe, H, pe))];
              case "heading":
                return ["#".repeat(X.depth) + " ", ue(oe, H, pe)];
              case "code": {
                if (X.isIndented) {
                  let Ee = " ".repeat(4);
                  return w(Ee, [Ee, ...P(X.value, c)]);
                }
                let le = H.__inJsTemplate ? "~" : "`", Ae = le.repeat(Math.max(3, n2(X.value, le) + 1));
                return [Ae, X.lang || "", X.meta ? " " + X.meta : "", c, ...P(v(X, H.originalText), c), c, Ae];
              }
              case "html": {
                let le = oe.getParentNode(), Ae = le.type === "root" && s(le.children) === X ? X.value.trimEnd() : X.value, Ee = /^<!--.*-->$/s.test(Ae);
                return P(Ae, Ee ? c : g(h3));
              }
              case "list": {
                let le = Y(X, oe.getParentNode()), Ae = S(X, H);
                return ue(oe, H, pe, { processor: (Ee, De) => {
                  let A = re(), G = Ee.getValue();
                  if (G.children.length === 2 && G.children[1].type === "html" && G.children[0].position.start.column !== G.children[1].position.start.column) return [A, V(Ee, H, pe, A)];
                  return [A, w(" ".repeat(A.length), V(Ee, H, pe, A))];
                  function re() {
                    let ye = X.ordered ? (De === 0 ? X.start : Ae ? 1 : X.start + De) + (le % 2 === 0 ? ". " : ") ") : le % 2 === 0 ? "- " : "* ";
                    return X.isAligned || X.hasIndentedCodeblock ? j(ye, H) : ye;
                  }
                } });
              }
              case "thematicBreak": {
                let le = ee(oe, "list");
                return le === -1 ? "---" : Y(oe.getParentNode(le), oe.getParentNode(le + 1)) % 2 === 0 ? "***" : "---";
              }
              case "linkReference":
                return ["[", ue(oe, H, pe), "]", X.referenceType === "full" ? Ne(X) : X.referenceType === "collapsed" ? "[]" : ""];
              case "imageReference":
                switch (X.referenceType) {
                  case "full":
                    return ["![", X.alt || "", "]", Ne(X)];
                  default:
                    return ["![", X.alt, "]", X.referenceType === "collapsed" ? "[]" : ""];
                }
              case "definition": {
                let le = H.proseWrap === "always" ? y : " ";
                return N([Ne(X), ":", E([le, he(X.url), X.title === null ? "" : [le, we(X.title, H, false)]])]);
              }
              case "footnote":
                return ["[^", ue(oe, H, pe), "]"];
              case "footnoteReference":
                return Pe(X);
              case "footnoteDefinition": {
                let le = oe.getParentNode().children[oe.getName() + 1], Ae = X.children.length === 1 && X.children[0].type === "paragraph" && (H.proseWrap === "never" || H.proseWrap === "preserve" && X.children[0].position.start.line === X.children[0].position.end.line);
                return [Pe(X), ": ", Ae ? ue(oe, H, pe) : N([w(" ".repeat(4), ue(oe, H, pe, { processor: (Ee, De) => De === 0 ? N([f, pe()]) : pe() })), le && le.type === "footnoteDefinition" ? f : ""])];
              }
              case "table":
                return K(oe, H, pe);
              case "tableCell":
                return ue(oe, H, pe);
              case "break":
                return /\s/.test(H.originalText[X.position.start.offset]) ? ["  ", g(h3)] : ["\\", c];
              case "liquidNode":
                return P(X.value, c);
              case "importExport":
                return [X.value, c];
              case "esComment":
                return ["{/* ", X.value, " */}"];
              case "jsx":
                return X.value;
              case "math":
                return ["$$", c, X.value ? [...P(X.value, c), c] : "", "$$"];
              case "inlineMath":
                return H.originalText.slice(m(X), C(X));
              case "tableRow":
              case "listItem":
              default:
                throw new Error(`Unknown markdown type ${JSON.stringify(X.type)}`);
            }
          }
          function V(oe, H, pe, X) {
            let le = oe.getValue(), Ae = le.checked === null ? "" : le.checked ? "[x] " : "[ ] ";
            return [Ae, ue(oe, H, pe, { processor: (Ee, De) => {
              if (De === 0 && Ee.getValue().type !== "list") return w(" ".repeat(Ae.length), pe());
              let A = " ".repeat(ke(H.tabWidth - X.length, 0, 3));
              return [A, w(A, pe())];
            } })];
          }
          function j(oe, H) {
            let pe = X();
            return oe + " ".repeat(pe >= 4 ? 0 : pe);
            function X() {
              let le = oe.length % H.tabWidth;
              return le === 0 ? 0 : H.tabWidth - le;
            }
          }
          function Y(oe, H) {
            return ie(oe, H, (pe) => pe.ordered === oe.ordered);
          }
          function ie(oe, H, pe) {
            let X = -1;
            for (let le of H.children) if (le.type === oe.type && pe(le) ? X++ : X = -1, le === oe) return X;
          }
          function ee(oe, H) {
            let pe = Array.isArray(H) ? H : [H], X = -1, le;
            for (; le = oe.getParentNode(++X); ) if (pe.includes(le.type)) return X;
            return -1;
          }
          function ce(oe, H) {
            let pe = ee(oe, H);
            return pe === -1 ? null : oe.getParentNode(pe);
          }
          function W(oe, H, pe) {
            if (pe.proseWrap === "preserve" && H === `
`) return c;
            let X = pe.proseWrap === "always" && !ce(oe, J);
            return H !== "" ? X ? y : " " : X ? f : "";
          }
          function K(oe, H, pe) {
            let X = oe.getValue(), le = [], Ae = oe.map((ye) => ye.map((Ce, Be) => {
              let ve = $(pe(), H).formatted, ze = u(ve);
              return le[Be] = Math.max(le[Be] || 3, ze), { text: ve, width: ze };
            }, "children"), "children"), Ee = A(false);
            if (H.proseWrap !== "never") return [l, Ee];
            let De = A(true);
            return [l, N(F(De, Ee))];
            function A(ye) {
              let Ce = [re(Ae[0], ye), G(ye)];
              return Ae.length > 1 && Ce.push(p(x2, Ae.slice(1).map((Be) => re(Be, ye)))), p(x2, Ce);
            }
            function G(ye) {
              return `| ${le.map((Be, ve) => {
                let ze = X.align[ve], be = ze === "center" || ze === "left" ? ":" : "-", Ye = ze === "center" || ze === "right" ? ":" : "-", Se = ye ? "-" : "-".repeat(Be - 2);
                return `${be}${Se}${Ye}`;
              }).join(" | ")} |`;
            }
            function re(ye, Ce) {
              return `| ${ye.map((ve, ze) => {
                let { text: be, width: Ye } = ve;
                if (Ce) return be;
                let Se = le[ze] - Ye, Ie = X.align[ze], Oe = 0;
                Ie === "right" ? Oe = Se : Ie === "center" && (Oe = Math.floor(Se / 2));
                let Je = Se - Oe;
                return `${" ".repeat(Oe)}${be}${" ".repeat(Je)}`;
              }).join(" | ")} |`;
            }
          }
          function de(oe, H, pe) {
            let X = [], le = null, { children: Ae } = oe.getValue();
            for (let [Ee, De] of Ae.entries()) switch (U(De)) {
              case "start":
                le === null && (le = { index: Ee, offset: De.position.end.offset });
                break;
              case "end":
                le !== null && (X.push({ start: le, end: { index: Ee, offset: De.position.start.offset } }), le = null);
                break;
              default:
                break;
            }
            return ue(oe, H, pe, { processor: (Ee, De) => {
              if (X.length > 0) {
                let A = X[0];
                if (De === A.start.index) return [Fe(Ae[A.start.index]), H.originalText.slice(A.start.offset, A.end.offset), Fe(Ae[A.end.index])];
                if (A.start.index < De && De < A.end.index) return false;
                if (De === A.end.index) return X.shift(), false;
              }
              return pe();
            } });
          }
          function ue(oe, H, pe) {
            let X = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, { postprocessor: le } = X, Ae = X.processor || (() => pe()), Ee = oe.getValue(), De = [], A;
            return oe.each((G, re) => {
              let ye = G.getValue(), Ce = Ae(G, re);
              if (Ce !== false) {
                let Be = { parts: De, prevNode: A, parentNode: Ee, options: H };
                Z(ye, Be) && (De.push(c), A && q.has(A.type) || (se(ye, Be) || fe(ye, Be)) && De.push(c), fe(ye, Be) && De.push(c)), De.push(Ce), A = ye;
              }
            }, "children"), le ? le(De) : De;
          }
          function Fe(oe) {
            if (oe.type === "html") return oe.value;
            if (oe.type === "paragraph" && Array.isArray(oe.children) && oe.children.length === 1 && oe.children[0].type === "esComment") return ["{/* ", oe.children[0].value, " */}"];
          }
          function z(oe) {
            let H = oe;
            for (; i(H.children); ) H = s(H.children);
            return H;
          }
          function U(oe) {
            let H;
            if (oe.type === "html") H = oe.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
            else {
              let pe;
              oe.type === "esComment" ? pe = oe : oe.type === "paragraph" && oe.children.length === 1 && oe.children[0].type === "esComment" && (pe = oe.children[0]), pe && (H = pe.value.match(/^prettier-ignore(?:-(start|end))?$/));
            }
            return H ? H[1] || "next" : false;
          }
          function Z(oe, H) {
            let pe = H.parts.length === 0, X = k.includes(oe.type), le = oe.type === "html" && M.includes(H.parentNode.type);
            return !pe && !X && !le;
          }
          function se(oe, H) {
            var pe, X, le;
            let Ee = (H.prevNode && H.prevNode.type) === oe.type && L.has(oe.type), De = H.parentNode.type === "listItem" && !H.parentNode.loose, A = ((pe = H.prevNode) === null || pe === void 0 ? void 0 : pe.type) === "listItem" && H.prevNode.loose, G = U(H.prevNode) === "next", re = oe.type === "html" && ((X = H.prevNode) === null || X === void 0 ? void 0 : X.type) === "html" && H.prevNode.position.end.line + 1 === oe.position.start.line, ye = oe.type === "html" && H.parentNode.type === "listItem" && ((le = H.prevNode) === null || le === void 0 ? void 0 : le.type) === "paragraph" && H.prevNode.position.end.line + 1 === oe.position.start.line;
            return A || !(Ee || De || G || re || ye);
          }
          function fe(oe, H) {
            let pe = H.prevNode && H.prevNode.type === "list", X = oe.type === "code" && oe.isIndented;
            return pe && X;
          }
          function ge(oe) {
            let H = ce(oe, ["linkReference", "imageReference"]);
            return H && (H.type !== "linkReference" || H.referenceType !== "full");
          }
          function he(oe) {
            let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], pe = [" ", ...Array.isArray(H) ? H : [H]];
            return new RegExp(pe.map((X) => `\\${X}`).join("|")).test(oe) ? `<${oe}>` : oe;
          }
          function we(oe, H) {
            let pe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
            if (!oe) return "";
            if (pe) return " " + we(oe, H, false);
            if (oe = oe.replace(/\\(["')])/g, "$1"), oe.includes('"') && oe.includes("'") && !oe.includes(")")) return `(${oe})`;
            let X = oe.split("'").length - 1, le = oe.split('"').length - 1, Ae = X > le ? '"' : le > X || H.singleQuote ? "'" : '"';
            return oe = oe.replace(/\\/, "\\\\"), oe = oe.replace(new RegExp(`(${Ae})`, "g"), "\\$1"), `${Ae}${oe}${Ae}`;
          }
          function ke(oe, H, pe) {
            return oe < H ? H : oe > pe ? pe : oe;
          }
          function Re(oe) {
            let H = Number(oe.getName());
            if (H === 0) return false;
            let pe = oe.getParentNode().children[H - 1];
            return U(pe) === "next";
          }
          function Ne(oe) {
            return `[${t(oe.label)}]`;
          }
          function Pe(oe) {
            return `[^${oe.label}]`;
          }
          r.exports = { preprocess: o, print: Q, embed: D, massageAstNode: d, hasPrettierIgnore: Re, insertPragma: T };
        } }), Dg = te({ "src/language-markdown/options.js"(e2, r) {
          "use strict";
          ne();
          var t = Mt();
          r.exports = { proseWrap: t.proseWrap, singleQuote: t.singleQuote };
        } }), mg = te({ "src/language-markdown/parsers.js"() {
          ne();
        } }), _a3 = te({ "node_modules/linguist-languages/data/Markdown.json"(e2, r) {
          r.exports = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".livemd", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
        } }), dg = te({ "src/language-markdown/index.js"(e2, r) {
          "use strict";
          ne();
          var t = _t(), s = fg(), a = Dg(), n2 = mg(), u = [t(_a3(), (l) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...l.filenames, "README"], extensions: l.extensions.filter((p) => p !== ".mdx") })), t(_a3(), () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))], i = { mdast: s };
          r.exports = { languages: u, options: a, printers: i, parsers: n2 };
        } }), gg = te({ "src/language-html/clean.js"(e2, r) {
          "use strict";
          ne();
          var { isFrontMatterNode: t } = Ue(), s = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
          function a(n2, u) {
            if (n2.type === "text" || n2.type === "comment" || t(n2) || n2.type === "yaml" || n2.type === "toml") return null;
            n2.type === "attribute" && delete u.value, n2.type === "docType" && delete u.value;
          }
          a.ignoredProperties = s, r.exports = a;
        } }), yg = te({ "src/language-html/constants.evaluate.js"(e2, r) {
          r.exports = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" };
        } }), hg = te({ "src/language-html/utils/is-unknown-namespace.js"(e2, r) {
          "use strict";
          ne();
          function t(s) {
            return s.type === "element" && !s.hasExplicitNamespace && !["html", "svg"].includes(s.namespace);
          }
          r.exports = t;
        } }), Rt = te({ "src/language-html/utils/index.js"(e2, r) {
          "use strict";
          ne();
          var { inferParserByLanguage: t, isFrontMatterNode: s } = Ue(), { builders: { line: a, hardline: n2, join: u }, utils: { getDocParts: i, replaceTextEndOfLine: l } } = qe(), { CSS_DISPLAY_TAGS: p, CSS_DISPLAY_DEFAULT: y, CSS_WHITE_SPACE_TAGS: h3, CSS_WHITE_SPACE_DEFAULT: g } = yg(), c = hg(), f = /* @__PURE__ */ new Set(["	", `
`, "\f", "\r", " "]), F = (A) => A.replace(/^[\t\n\f\r ]+/, ""), _ = (A) => A.replace(/[\t\n\f\r ]+$/, ""), w = (A) => F(_(A)), E = (A) => A.replace(/^[\t\f\r ]*\n/g, ""), N = (A) => E(_(A)), x2 = (A) => A.split(/[\t\n\f\r ]+/), I = (A) => A.match(/^[\t\n\f\r ]*/)[0], P = (A) => {
            let [, G, re, ye] = A.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
            return { leadingWhitespace: G, trailingWhitespace: ye, text: re };
          }, $ = (A) => /[\t\n\f\r ]/.test(A);
          function D(A, G) {
            return !!(A.type === "ieConditionalComment" && A.lastChild && !A.lastChild.isSelfClosing && !A.lastChild.endSourceSpan || A.type === "ieConditionalComment" && !A.complete || se(A) && A.children.some((re) => re.type !== "text" && re.type !== "interpolation") || X(A, G) && !o(A) && A.type !== "interpolation");
          }
          function T(A) {
            return A.type === "attribute" || !A.parent || !A.prev ? false : m(A.prev);
          }
          function m(A) {
            return A.type === "comment" && A.value.trim() === "prettier-ignore";
          }
          function C(A) {
            return A.type === "text" || A.type === "comment";
          }
          function o(A) {
            return A.type === "element" && (A.fullName === "script" || A.fullName === "style" || A.fullName === "svg:style" || c(A) && (A.name === "script" || A.name === "style"));
          }
          function d(A) {
            return A.children && !o(A);
          }
          function v(A) {
            return o(A) || A.type === "interpolation" || S(A);
          }
          function S(A) {
            return we(A).startsWith("pre");
          }
          function b(A, G) {
            let re = ye();
            if (re && !A.prev && A.parent && A.parent.tagDefinition && A.parent.tagDefinition.ignoreFirstLf) return A.type === "interpolation";
            return re;
            function ye() {
              return s(A) ? false : (A.type === "text" || A.type === "interpolation") && A.prev && (A.prev.type === "text" || A.prev.type === "interpolation") ? true : !A.parent || A.parent.cssDisplay === "none" ? false : se(A.parent) ? true : !(!A.prev && (A.parent.type === "root" || se(A) && A.parent || o(A.parent) || H(A.parent, G) || !ue(A.parent.cssDisplay)) || A.prev && !U(A.prev.cssDisplay));
            }
          }
          function B(A, G) {
            return s(A) ? false : (A.type === "text" || A.type === "interpolation") && A.next && (A.next.type === "text" || A.next.type === "interpolation") ? true : !A.parent || A.parent.cssDisplay === "none" ? false : se(A.parent) ? true : !(!A.next && (A.parent.type === "root" || se(A) && A.parent || o(A.parent) || H(A.parent, G) || !Fe(A.parent.cssDisplay)) || A.next && !z(A.next.cssDisplay));
          }
          function k(A) {
            return Z(A.cssDisplay) && !o(A);
          }
          function M(A) {
            return s(A) || A.next && A.sourceSpan.end && A.sourceSpan.end.line + 1 < A.next.sourceSpan.start.line;
          }
          function R(A) {
            return q(A) || A.type === "element" && A.children.length > 0 && (["body", "script", "style"].includes(A.name) || A.children.some((G) => ee(G))) || A.firstChild && A.firstChild === A.lastChild && A.firstChild.type !== "text" && V(A.firstChild) && (!A.lastChild.isTrailingSpaceSensitive || j(A.lastChild));
          }
          function q(A) {
            return A.type === "element" && A.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(A.name) || A.cssDisplay.startsWith("table") && A.cssDisplay !== "table-cell");
          }
          function J(A) {
            return Y(A) || A.prev && L(A.prev) || Q(A);
          }
          function L(A) {
            return Y(A) || A.type === "element" && A.fullName === "br" || Q(A);
          }
          function Q(A) {
            return V(A) && j(A);
          }
          function V(A) {
            return A.hasLeadingSpaces && (A.prev ? A.prev.sourceSpan.end.line < A.sourceSpan.start.line : A.parent.type === "root" || A.parent.startSourceSpan.end.line < A.sourceSpan.start.line);
          }
          function j(A) {
            return A.hasTrailingSpaces && (A.next ? A.next.sourceSpan.start.line > A.sourceSpan.end.line : A.parent.type === "root" || A.parent.endSourceSpan && A.parent.endSourceSpan.start.line > A.sourceSpan.end.line);
          }
          function Y(A) {
            switch (A.type) {
              case "ieConditionalComment":
              case "comment":
              case "directive":
                return true;
              case "element":
                return ["script", "select"].includes(A.name);
            }
            return false;
          }
          function ie(A) {
            return A.lastChild ? ie(A.lastChild) : A;
          }
          function ee(A) {
            return A.children && A.children.some((G) => G.type !== "text");
          }
          function ce(A) {
            let { type: G, lang: re } = A.attrMap;
            if (G === "module" || G === "text/javascript" || G === "text/babel" || G === "application/javascript" || re === "jsx") return "babel";
            if (G === "application/x-typescript" || re === "ts" || re === "tsx") return "typescript";
            if (G === "text/markdown") return "markdown";
            if (G === "text/html") return "html";
            if (G && (G.endsWith("json") || G.endsWith("importmap")) || G === "speculationrules") return "json";
            if (G === "text/x-handlebars-template") return "glimmer";
          }
          function W(A, G) {
            let { lang: re } = A.attrMap;
            if (!re || re === "postcss" || re === "css") return "css";
            if (re === "scss") return "scss";
            if (re === "less") return "less";
            if (re === "stylus") return t("stylus", G);
          }
          function K(A, G) {
            if (A.name === "script" && !A.attrMap.src) return !A.attrMap.lang && !A.attrMap.type ? "babel" : ce(A);
            if (A.name === "style") return W(A, G);
            if (G && X(A, G)) return ce(A) || !("src" in A.attrMap) && t(A.attrMap.lang, G);
          }
          function de(A) {
            return A === "block" || A === "list-item" || A.startsWith("table");
          }
          function ue(A) {
            return !de(A) && A !== "inline-block";
          }
          function Fe(A) {
            return !de(A) && A !== "inline-block";
          }
          function z(A) {
            return !de(A);
          }
          function U(A) {
            return !de(A);
          }
          function Z(A) {
            return !de(A) && A !== "inline-block";
          }
          function se(A) {
            return we(A).startsWith("pre");
          }
          function fe(A, G) {
            let re = 0;
            for (let ye = A.stack.length - 1; ye >= 0; ye--) {
              let Ce = A.stack[ye];
              Ce && typeof Ce == "object" && !Array.isArray(Ce) && G(Ce) && re++;
            }
            return re;
          }
          function ge(A, G) {
            let re = A;
            for (; re; ) {
              if (G(re)) return true;
              re = re.parent;
            }
            return false;
          }
          function he(A, G) {
            if (A.prev && A.prev.type === "comment") {
              let ye = A.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
              if (ye) return ye[1];
            }
            let re = false;
            if (A.type === "element" && A.namespace === "svg") if (ge(A, (ye) => ye.fullName === "svg:foreignObject")) re = true;
            else return A.name === "svg" ? "inline-block" : "block";
            switch (G.htmlWhitespaceSensitivity) {
              case "strict":
                return "inline";
              case "ignore":
                return "block";
              default:
                return G.parser === "vue" && A.parent && A.parent.type === "root" ? "block" : A.type === "element" && (!A.namespace || re || c(A)) && p[A.name] || y;
            }
          }
          function we(A) {
            return A.type === "element" && (!A.namespace || c(A)) && h3[A.name] || g;
          }
          function ke(A) {
            let G = Number.POSITIVE_INFINITY;
            for (let re of A.split(`
`)) {
              if (re.length === 0) continue;
              if (!f.has(re[0])) return 0;
              let ye = I(re).length;
              re.length !== ye && ye < G && (G = ye);
            }
            return G === Number.POSITIVE_INFINITY ? 0 : G;
          }
          function Re(A) {
            let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ke(A);
            return G === 0 ? A : A.split(`
`).map((re) => re.slice(G)).join(`
`);
          }
          function Ne(A, G) {
            let re = 0;
            for (let ye = 0; ye < A.length; ye++) A[ye] === G && re++;
            return re;
          }
          function Pe(A) {
            return A.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
          }
          var oe = /* @__PURE__ */ new Set(["template", "style", "script"]);
          function H(A, G) {
            return pe(A, G) && !oe.has(A.fullName);
          }
          function pe(A, G) {
            return G.parser === "vue" && A.type === "element" && A.parent.type === "root" && A.fullName.toLowerCase() !== "html";
          }
          function X(A, G) {
            return pe(A, G) && (H(A, G) || A.attrMap.lang && A.attrMap.lang !== "html");
          }
          function le(A) {
            let G = A.fullName;
            return G.charAt(0) === "#" || G === "slot-scope" || G === "v-slot" || G.startsWith("v-slot:");
          }
          function Ae(A, G) {
            let re = A.parent;
            if (!pe(re, G)) return false;
            let ye = re.fullName, Ce = A.fullName;
            return ye === "script" && Ce === "setup" || ye === "style" && Ce === "vars";
          }
          function Ee(A) {
            let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : A.value;
            return A.parent.isWhitespaceSensitive ? A.parent.isIndentationSensitive ? l(G) : l(Re(N(G)), n2) : i(u(a, x2(G)));
          }
          function De(A, G) {
            return pe(A, G) && A.name === "script";
          }
          r.exports = { htmlTrim: w, htmlTrimPreserveIndentation: N, hasHtmlWhitespace: $, getLeadingAndTrailingHtmlWhitespace: P, canHaveInterpolation: d, countChars: Ne, countParents: fe, dedentString: Re, forceBreakChildren: q, forceBreakContent: R, forceNextEmptyLine: M, getLastDescendant: ie, getNodeCssStyleDisplay: he, getNodeCssStyleWhiteSpace: we, hasPrettierIgnore: T, inferScriptParser: K, isVueCustomBlock: H, isVueNonHtmlBlock: X, isVueScriptTag: De, isVueSlotAttribute: le, isVueSfcBindingsAttribute: Ae, isVueSfcBlock: pe, isDanglingSpaceSensitiveNode: k, isIndentationSensitiveNode: S, isLeadingSpaceSensitiveNode: b, isPreLikeNode: se, isScriptLikeTag: o, isTextLikeNode: C, isTrailingSpaceSensitiveNode: B, isWhitespaceSensitiveNode: v, isUnknownNamespace: c, preferHardlineAsLeadingSpaces: J, preferHardlineAsTrailingSpaces: L, shouldPreserveContent: D, unescapeQuoteEntities: Pe, getTextValueParts: Ee };
        } }), vg = te({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true }), e2.$EOF = 0, e2.$BSPACE = 8, e2.$TAB = 9, e2.$LF = 10, e2.$VTAB = 11, e2.$FF = 12, e2.$CR = 13, e2.$SPACE = 32, e2.$BANG = 33, e2.$DQ = 34, e2.$HASH = 35, e2.$$ = 36, e2.$PERCENT = 37, e2.$AMPERSAND = 38, e2.$SQ = 39, e2.$LPAREN = 40, e2.$RPAREN = 41, e2.$STAR = 42, e2.$PLUS = 43, e2.$COMMA = 44, e2.$MINUS = 45, e2.$PERIOD = 46, e2.$SLASH = 47, e2.$COLON = 58, e2.$SEMICOLON = 59, e2.$LT = 60, e2.$EQ = 61, e2.$GT = 62, e2.$QUESTION = 63, e2.$0 = 48, e2.$7 = 55, e2.$9 = 57, e2.$A = 65, e2.$E = 69, e2.$F = 70, e2.$X = 88, e2.$Z = 90, e2.$LBRACKET = 91, e2.$BACKSLASH = 92, e2.$RBRACKET = 93, e2.$CARET = 94, e2.$_ = 95, e2.$a = 97, e2.$b = 98, e2.$e = 101, e2.$f = 102, e2.$n = 110, e2.$r = 114, e2.$t = 116, e2.$u = 117, e2.$v = 118, e2.$x = 120, e2.$z = 122, e2.$LBRACE = 123, e2.$BAR = 124, e2.$RBRACE = 125, e2.$NBSP = 160, e2.$PIPE = 124, e2.$TILDA = 126, e2.$AT = 64, e2.$BT = 96;
          function r(i) {
            return i >= e2.$TAB && i <= e2.$SPACE || i == e2.$NBSP;
          }
          e2.isWhitespace = r;
          function t(i) {
            return e2.$0 <= i && i <= e2.$9;
          }
          e2.isDigit = t;
          function s(i) {
            return i >= e2.$a && i <= e2.$z || i >= e2.$A && i <= e2.$Z;
          }
          e2.isAsciiLetter = s;
          function a(i) {
            return i >= e2.$a && i <= e2.$f || i >= e2.$A && i <= e2.$F || t(i);
          }
          e2.isAsciiHexDigit = a;
          function n2(i) {
            return i === e2.$LF || i === e2.$CR;
          }
          e2.isNewLine = n2;
          function u(i) {
            return e2.$0 <= i && i <= e2.$7;
          }
          e2.isOctalDigit = u;
        } }), Cg = te({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = class {
            constructor(s, a, n2) {
              this.filePath = s, this.name = a, this.members = n2;
            }
            assertNoMembers() {
              if (this.members.length) throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
            }
          };
          e2.StaticSymbol = r;
          var t = class {
            constructor() {
              this.cache = /* @__PURE__ */ new Map();
            }
            get(s, a, n2) {
              n2 = n2 || [];
              let u = n2.length ? `.${n2.join(".")}` : "", i = `"${s}".${a}${u}`, l = this.cache.get(i);
              return l || (l = new r(s, a, n2), this.cache.set(i, l)), l;
            }
          };
          e2.StaticSymbolCache = t;
        } }), Eg = te({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = /-+([a-z0-9])/g;
          function t(o) {
            return o.replace(r, function() {
              for (var d = arguments.length, v = new Array(d), S = 0; S < d; S++) v[S] = arguments[S];
              return v[1].toUpperCase();
            });
          }
          e2.dashCaseToCamelCase = t;
          function s(o, d) {
            return n2(o, ":", d);
          }
          e2.splitAtColon = s;
          function a(o, d) {
            return n2(o, ".", d);
          }
          e2.splitAtPeriod = a;
          function n2(o, d, v) {
            let S = o.indexOf(d);
            return S == -1 ? v : [o.slice(0, S).trim(), o.slice(S + 1).trim()];
          }
          function u(o, d, v) {
            return Array.isArray(o) ? d.visitArray(o, v) : E(o) ? d.visitStringMap(o, v) : o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean" ? d.visitPrimitive(o, v) : d.visitOther(o, v);
          }
          e2.visitValue = u;
          function i(o) {
            return o != null;
          }
          e2.isDefined = i;
          function l(o) {
            return o === void 0 ? null : o;
          }
          e2.noUndefined = l;
          var p = class {
            visitArray(o, d) {
              return o.map((v) => u(v, this, d));
            }
            visitStringMap(o, d) {
              let v = {};
              return Object.keys(o).forEach((S) => {
                v[S] = u(o[S], this, d);
              }), v;
            }
            visitPrimitive(o, d) {
              return o;
            }
            visitOther(o, d) {
              return o;
            }
          };
          e2.ValueTransformer = p, e2.SyncAsync = { assertSync: (o) => {
            if (P(o)) throw new Error("Illegal state: value cannot be a promise");
            return o;
          }, then: (o, d) => P(o) ? o.then(d) : d(o), all: (o) => o.some(P) ? Promise.all(o) : o };
          function y(o) {
            throw new Error(`Internal Error: ${o}`);
          }
          e2.error = y;
          function h3(o, d) {
            let v = Error(o);
            return v[g] = true, d && (v[c] = d), v;
          }
          e2.syntaxError = h3;
          var g = "ngSyntaxError", c = "ngParseErrors";
          function f(o) {
            return o[g];
          }
          e2.isSyntaxError = f;
          function F(o) {
            return o[c] || [];
          }
          e2.getParseErrors = F;
          function _(o) {
            return o.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
          }
          e2.escapeRegExp = _;
          var w = Object.getPrototypeOf({});
          function E(o) {
            return typeof o == "object" && o !== null && Object.getPrototypeOf(o) === w;
          }
          function N(o) {
            let d = "";
            for (let v = 0; v < o.length; v++) {
              let S = o.charCodeAt(v);
              if (S >= 55296 && S <= 56319 && o.length > v + 1) {
                let b = o.charCodeAt(v + 1);
                b >= 56320 && b <= 57343 && (v++, S = (S - 55296 << 10) + b - 56320 + 65536);
              }
              S <= 127 ? d += String.fromCharCode(S) : S <= 2047 ? d += String.fromCharCode(S >> 6 & 31 | 192, S & 63 | 128) : S <= 65535 ? d += String.fromCharCode(S >> 12 | 224, S >> 6 & 63 | 128, S & 63 | 128) : S <= 2097151 && (d += String.fromCharCode(S >> 18 & 7 | 240, S >> 12 & 63 | 128, S >> 6 & 63 | 128, S & 63 | 128));
            }
            return d;
          }
          e2.utf8Encode = N;
          function x2(o) {
            if (typeof o == "string") return o;
            if (o instanceof Array) return "[" + o.map(x2).join(", ") + "]";
            if (o == null) return "" + o;
            if (o.overriddenName) return `${o.overriddenName}`;
            if (o.name) return `${o.name}`;
            if (!o.toString) return "object";
            let d = o.toString();
            if (d == null) return "" + d;
            let v = d.indexOf(`
`);
            return v === -1 ? d : d.substring(0, v);
          }
          e2.stringify = x2;
          function I(o) {
            return typeof o == "function" && o.hasOwnProperty("__forward_ref__") ? o() : o;
          }
          e2.resolveForwardRef = I;
          function P(o) {
            return !!o && typeof o.then == "function";
          }
          e2.isPromise = P;
          var $ = class {
            constructor(o) {
              this.full = o;
              let d = o.split(".");
              this.major = d[0], this.minor = d[1], this.patch = d.slice(2).join(".");
            }
          };
          e2.Version = $;
          var D = typeof window < "u" && window, T = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, m = typeof globalThis < "u" && globalThis, C = m || D || T;
          e2.global = C;
        } }), Fg = te({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = Cg(), t = Eg(), s = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
          function a(v) {
            return v.replace(/\W/g, "_");
          }
          e2.sanitizeIdentifier = a;
          var n2 = 0;
          function u(v) {
            if (!v || !v.reference) return null;
            let S = v.reference;
            if (S instanceof r.StaticSymbol) return S.name;
            if (S.__anonymousType) return S.__anonymousType;
            let b = t.stringify(S);
            return b.indexOf("(") >= 0 ? (b = `anonymous_${n2++}`, S.__anonymousType = b) : b = a(b), b;
          }
          e2.identifierName = u;
          function i(v) {
            let S = v.reference;
            return S instanceof r.StaticSymbol ? S.filePath : `./${t.stringify(S)}`;
          }
          e2.identifierModuleUrl = i;
          function l(v, S) {
            return `View_${u({ reference: v })}_${S}`;
          }
          e2.viewClassName = l;
          function p(v) {
            return `RenderType_${u({ reference: v })}`;
          }
          e2.rendererTypeName = p;
          function y(v) {
            return `HostView_${u({ reference: v })}`;
          }
          e2.hostViewClassName = y;
          function h3(v) {
            return `${u({ reference: v })}NgFactory`;
          }
          e2.componentFactoryName = h3;
          var g;
          (function(v) {
            v[v.Pipe = 0] = "Pipe", v[v.Directive = 1] = "Directive", v[v.NgModule = 2] = "NgModule", v[v.Injectable = 3] = "Injectable";
          })(g = e2.CompileSummaryKind || (e2.CompileSummaryKind = {}));
          function c(v) {
            return v.value != null ? a(v.value) : u(v.identifier);
          }
          e2.tokenName = c;
          function f(v) {
            return v.identifier != null ? v.identifier.reference : v.value;
          }
          e2.tokenReference = f;
          var F = class {
            constructor() {
              let { moduleUrl: v, styles: S, styleUrls: b } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              this.moduleUrl = v || null, this.styles = P(S), this.styleUrls = P(b);
            }
          };
          e2.CompileStylesheetMetadata = F;
          var _ = class {
            constructor(v) {
              let { encapsulation: S, template: b, templateUrl: B, htmlAst: k, styles: M, styleUrls: R, externalStylesheets: q, animations: J, ngContentSelectors: L, interpolation: Q, isInline: V, preserveWhitespaces: j } = v;
              if (this.encapsulation = S, this.template = b, this.templateUrl = B, this.htmlAst = k, this.styles = P(M), this.styleUrls = P(R), this.externalStylesheets = P(q), this.animations = J ? D(J) : [], this.ngContentSelectors = L || [], Q && Q.length != 2) throw new Error("'interpolation' should have a start and an end symbol.");
              this.interpolation = Q, this.isInline = V, this.preserveWhitespaces = j;
            }
            toSummary() {
              return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
            }
          };
          e2.CompileTemplateMetadata = _;
          var w = class {
            static create(v) {
              let { isHost: S, type: b, isComponent: B, selector: k, exportAs: M, changeDetection: R, inputs: q, outputs: J, host: L, providers: Q, viewProviders: V, queries: j, guards: Y, viewQueries: ie, entryComponents: ee, template: ce, componentViewType: W, rendererType: K, componentFactory: de } = v, ue = {}, Fe = {}, z = {};
              L != null && Object.keys(L).forEach((se) => {
                let fe = L[se], ge = se.match(s);
                ge === null ? z[se] = fe : ge[1] != null ? Fe[ge[1]] = fe : ge[2] != null && (ue[ge[2]] = fe);
              });
              let U = {};
              q != null && q.forEach((se) => {
                let fe = t.splitAtColon(se, [se, se]);
                U[fe[0]] = fe[1];
              });
              let Z = {};
              return J != null && J.forEach((se) => {
                let fe = t.splitAtColon(se, [se, se]);
                Z[fe[0]] = fe[1];
              }), new w({ isHost: S, type: b, isComponent: !!B, selector: k, exportAs: M, changeDetection: R, inputs: U, outputs: Z, hostListeners: ue, hostProperties: Fe, hostAttributes: z, providers: Q, viewProviders: V, queries: j, guards: Y, viewQueries: ie, entryComponents: ee, template: ce, componentViewType: W, rendererType: K, componentFactory: de });
            }
            constructor(v) {
              let { isHost: S, type: b, isComponent: B, selector: k, exportAs: M, changeDetection: R, inputs: q, outputs: J, hostListeners: L, hostProperties: Q, hostAttributes: V, providers: j, viewProviders: Y, queries: ie, guards: ee, viewQueries: ce, entryComponents: W, template: K, componentViewType: de, rendererType: ue, componentFactory: Fe } = v;
              this.isHost = !!S, this.type = b, this.isComponent = B, this.selector = k, this.exportAs = M, this.changeDetection = R, this.inputs = q, this.outputs = J, this.hostListeners = L, this.hostProperties = Q, this.hostAttributes = V, this.providers = P(j), this.viewProviders = P(Y), this.queries = P(ie), this.guards = ee, this.viewQueries = P(ce), this.entryComponents = P(W), this.template = K, this.componentViewType = de, this.rendererType = ue, this.componentFactory = Fe;
            }
            toSummary() {
              return { summaryKind: g.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
            }
          };
          e2.CompileDirectiveMetadata = w;
          var E = class {
            constructor(v) {
              let { type: S, name: b, pure: B } = v;
              this.type = S, this.name = b, this.pure = !!B;
            }
            toSummary() {
              return { summaryKind: g.Pipe, type: this.type, name: this.name, pure: this.pure };
            }
          };
          e2.CompilePipeMetadata = E;
          var N = class {
          };
          e2.CompileShallowModuleMetadata = N;
          var x2 = class {
            constructor(v) {
              let { type: S, providers: b, declaredDirectives: B, exportedDirectives: k, declaredPipes: M, exportedPipes: R, entryComponents: q, bootstrapComponents: J, importedModules: L, exportedModules: Q, schemas: V, transitiveModule: j, id: Y } = v;
              this.type = S || null, this.declaredDirectives = P(B), this.exportedDirectives = P(k), this.declaredPipes = P(M), this.exportedPipes = P(R), this.providers = P(b), this.entryComponents = P(q), this.bootstrapComponents = P(J), this.importedModules = P(L), this.exportedModules = P(Q), this.schemas = P(V), this.id = Y || null, this.transitiveModule = j || null;
            }
            toSummary() {
              let v = this.transitiveModule;
              return { summaryKind: g.NgModule, type: this.type, entryComponents: v.entryComponents, providers: v.providers, modules: v.modules, exportedDirectives: v.exportedDirectives, exportedPipes: v.exportedPipes };
            }
          };
          e2.CompileNgModuleMetadata = x2;
          var I = class {
            constructor() {
              this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
            }
            addProvider(v, S) {
              this.providers.push({ provider: v, module: S });
            }
            addDirective(v) {
              this.directivesSet.has(v.reference) || (this.directivesSet.add(v.reference), this.directives.push(v));
            }
            addExportedDirective(v) {
              this.exportedDirectivesSet.has(v.reference) || (this.exportedDirectivesSet.add(v.reference), this.exportedDirectives.push(v));
            }
            addPipe(v) {
              this.pipesSet.has(v.reference) || (this.pipesSet.add(v.reference), this.pipes.push(v));
            }
            addExportedPipe(v) {
              this.exportedPipesSet.has(v.reference) || (this.exportedPipesSet.add(v.reference), this.exportedPipes.push(v));
            }
            addModule(v) {
              this.modulesSet.has(v.reference) || (this.modulesSet.add(v.reference), this.modules.push(v));
            }
            addEntryComponent(v) {
              this.entryComponentsSet.has(v.componentType) || (this.entryComponentsSet.add(v.componentType), this.entryComponents.push(v));
            }
          };
          e2.TransitiveCompileNgModuleMetadata = I;
          function P(v) {
            return v || [];
          }
          var $ = class {
            constructor(v, S) {
              let { useClass: b, useValue: B, useExisting: k, useFactory: M, deps: R, multi: q } = S;
              this.token = v, this.useClass = b || null, this.useValue = B, this.useExisting = k, this.useFactory = M || null, this.dependencies = R || null, this.multi = !!q;
            }
          };
          e2.ProviderMeta = $;
          function D(v) {
            return v.reduce((S, b) => {
              let B = Array.isArray(b) ? D(b) : b;
              return S.concat(B);
            }, []);
          }
          e2.flatten = D;
          function T(v) {
            return v.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
          }
          function m(v, S, b) {
            let B;
            return b.isInline ? S.type.reference instanceof r.StaticSymbol ? B = `${S.type.reference.filePath}.${S.type.reference.name}.html` : B = `${u(v)}/${u(S.type)}.html` : B = b.templateUrl, S.type.reference instanceof r.StaticSymbol ? B : T(B);
          }
          e2.templateSourceUrl = m;
          function C(v, S) {
            let b = v.moduleUrl.split(/\/\\/g), B = b[b.length - 1];
            return T(`css/${S}${B}.ngstyle.js`);
          }
          e2.sharedStylesheetJitUrl = C;
          function o(v) {
            return T(`${u(v.type)}/module.ngfactory.js`);
          }
          e2.ngModuleJitUrl = o;
          function d(v, S) {
            return T(`${u(v)}/${u(S.type)}.ngfactory.js`);
          }
          e2.templateJitUrl = d;
        } }), Ag = te({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e2) {
          "use strict";
          ne(), Object.defineProperty(e2, "__esModule", { value: true });
          var r = vg(), t = Fg(), s = class {
            constructor(y, h3, g, c) {
              this.file = y, this.offset = h3, this.line = g, this.col = c;
            }
            toString() {
              return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
            }
            moveBy(y) {
              let h3 = this.file.content, g = h3.length, c = this.offset, f = this.line, F = this.col;
              for (; c > 0 && y < 0; ) if (c--, y++, h3.charCodeAt(c) == r.$LF) {
                f--;
                let w = h3.substr(0, c - 1).lastIndexOf(String.fromCharCode(r.$LF));
                F = w > 0 ? c - w : c;
              } else F--;
              for (; c < g && y > 0; ) {
                let _ = h3.charCodeAt(c);
                c++, y--, _ == r.$LF ? (f++, F = 0) : F++;
              }
              return new s(this.file, c, f, F);
            }
            getContext(y, h3) {
              let g = this.file.content, c = this.offset;
              if (c != null) {
                c > g.length - 1 && (c = g.length - 1);
                let f = c, F = 0, _ = 0;
                for (; F < y && c > 0 && (c--, F++, !(g[c] == `
` && ++_ == h3)); ) ;
                for (F = 0, _ = 0; F < y && f < g.length - 1 && (f++, F++, !(g[f] == `
` && ++_ == h3)); ) ;
                return { before: g.substring(c, this.offset), after: g.substring(this.offset, f + 1) };
              }
              return null;
            }
          };
          e2.ParseLocation = s;
          var a = class {
            constructor(y, h3) {
              this.content = y, this.url = h3;
            }
          };
          e2.ParseSourceFile = a;
          var n2 = class {
            constructor(y, h3) {
              let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
              this.start = y, this.end = h3, this.details = g;
            }
            toString() {
              return this.start.file.content.substring(this.start.offset, this.end.offset);
            }
          };
          e2.ParseSourceSpan = n2, e2.EMPTY_PARSE_LOCATION = new s(new a("", ""), 0, 0, 0), e2.EMPTY_SOURCE_SPAN = new n2(e2.EMPTY_PARSE_LOCATION, e2.EMPTY_PARSE_LOCATION);
          var u;
          (function(y) {
            y[y.WARNING = 0] = "WARNING", y[y.ERROR = 1] = "ERROR";
          })(u = e2.ParseErrorLevel || (e2.ParseErrorLevel = {}));
          var i = class {
            constructor(y, h3) {
              let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u.ERROR;
              this.span = y, this.msg = h3, this.level = g;
            }
            contextualMessage() {
              let y = this.span.start.getContext(100, 3);
              return y ? `${this.msg} ("${y.before}[${u[this.level]} ->]${y.after}")` : this.msg;
            }
            toString() {
              let y = this.span.details ? `, ${this.span.details}` : "";
              return `${this.contextualMessage()}: ${this.span.start}${y}`;
            }
          };
          e2.ParseError = i;
          function l(y, h3) {
            let g = t.identifierModuleUrl(h3), c = g != null ? `in ${y} ${t.identifierName(h3)} in ${g}` : `in ${y} ${t.identifierName(h3)}`, f = new a("", c);
            return new n2(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
          }
          e2.typeSourceSpan = l;
          function p(y, h3, g) {
            let c = `in ${y} ${h3} in ${g}`, f = new a("", c);
            return new n2(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
          }
          e2.r3JitTypeSourceSpan = p;
        } }), Sg = te({ "src/language-html/print-preprocess.js"(e2, r) {
          "use strict";
          ne();
          var { ParseSourceSpan: t } = Ag(), { htmlTrim: s, getLeadingAndTrailingHtmlWhitespace: a, hasHtmlWhitespace: n2, canHaveInterpolation: u, getNodeCssStyleDisplay: i, isDanglingSpaceSensitiveNode: l, isIndentationSensitiveNode: p, isLeadingSpaceSensitiveNode: y, isTrailingSpaceSensitiveNode: h3, isWhitespaceSensitiveNode: g, isVueScriptTag: c } = Rt(), f = [_, w, N, I, P, T, $, D, m, x2, C];
          function F(o, d) {
            for (let v of f) v(o, d);
            return o;
          }
          function _(o) {
            o.walk((d) => {
              if (d.type === "element" && d.tagDefinition.ignoreFirstLf && d.children.length > 0 && d.children[0].type === "text" && d.children[0].value[0] === `
`) {
                let v = d.children[0];
                v.value.length === 1 ? d.removeChild(v) : v.value = v.value.slice(1);
              }
            });
          }
          function w(o) {
            let d = (v) => v.type === "element" && v.prev && v.prev.type === "ieConditionalStartComment" && v.prev.sourceSpan.end.offset === v.startSourceSpan.start.offset && v.firstChild && v.firstChild.type === "ieConditionalEndComment" && v.firstChild.sourceSpan.start.offset === v.startSourceSpan.end.offset;
            o.walk((v) => {
              if (v.children) for (let S = 0; S < v.children.length; S++) {
                let b = v.children[S];
                if (!d(b)) continue;
                let B = b.prev, k = b.firstChild;
                v.removeChild(B), S--;
                let M = new t(B.sourceSpan.start, k.sourceSpan.end), R = new t(M.start, b.sourceSpan.end);
                b.condition = B.condition, b.sourceSpan = R, b.startSourceSpan = M, b.removeChild(k);
              }
            });
          }
          function E(o, d, v) {
            o.walk((S) => {
              if (S.children) for (let b = 0; b < S.children.length; b++) {
                let B = S.children[b];
                if (B.type !== "text" && !d(B)) continue;
                B.type !== "text" && (B.type = "text", B.value = v(B));
                let k = B.prev;
                !k || k.type !== "text" || (k.value += B.value, k.sourceSpan = new t(k.sourceSpan.start, B.sourceSpan.end), S.removeChild(B), b--);
              }
            });
          }
          function N(o) {
            return E(o, (d) => d.type === "cdata", (d) => `<![CDATA[${d.value}]]>`);
          }
          function x2(o) {
            let d = (v) => v.type === "element" && v.attrs.length === 0 && v.children.length === 1 && v.firstChild.type === "text" && !n2(v.children[0].value) && !v.firstChild.hasLeadingSpaces && !v.firstChild.hasTrailingSpaces && v.isLeadingSpaceSensitive && !v.hasLeadingSpaces && v.isTrailingSpaceSensitive && !v.hasTrailingSpaces && v.prev && v.prev.type === "text" && v.next && v.next.type === "text";
            o.walk((v) => {
              if (v.children) for (let S = 0; S < v.children.length; S++) {
                let b = v.children[S];
                if (!d(b)) continue;
                let B = b.prev, k = b.next;
                B.value += `<${b.rawName}>` + b.firstChild.value + `</${b.rawName}>` + k.value, B.sourceSpan = new t(B.sourceSpan.start, k.sourceSpan.end), B.isTrailingSpaceSensitive = k.isTrailingSpaceSensitive, B.hasTrailingSpaces = k.hasTrailingSpaces, v.removeChild(b), S--, v.removeChild(k);
              }
            });
          }
          function I(o, d) {
            if (d.parser === "html") return;
            let v = /{{(.+?)}}/s;
            o.walk((S) => {
              if (u(S)) for (let b of S.children) {
                if (b.type !== "text") continue;
                let B = b.sourceSpan.start, k = null, M = b.value.split(v);
                for (let R = 0; R < M.length; R++, B = k) {
                  let q = M[R];
                  if (R % 2 === 0) {
                    k = B.moveBy(q.length), q.length > 0 && S.insertChildBefore(b, { type: "text", value: q, sourceSpan: new t(B, k) });
                    continue;
                  }
                  k = B.moveBy(q.length + 4), S.insertChildBefore(b, { type: "interpolation", sourceSpan: new t(B, k), children: q.length === 0 ? [] : [{ type: "text", value: q, sourceSpan: new t(B.moveBy(2), k.moveBy(-2)) }] });
                }
                S.removeChild(b);
              }
            });
          }
          function P(o) {
            o.walk((d) => {
              if (!d.children) return;
              if (d.children.length === 0 || d.children.length === 1 && d.children[0].type === "text" && s(d.children[0].value).length === 0) {
                d.hasDanglingSpaces = d.children.length > 0, d.children = [];
                return;
              }
              let v = g(d), S = p(d);
              if (!v) for (let b = 0; b < d.children.length; b++) {
                let B = d.children[b];
                if (B.type !== "text") continue;
                let { leadingWhitespace: k, text: M, trailingWhitespace: R } = a(B.value), q = B.prev, J = B.next;
                M ? (B.value = M, B.sourceSpan = new t(B.sourceSpan.start.moveBy(k.length), B.sourceSpan.end.moveBy(-R.length)), k && (q && (q.hasTrailingSpaces = true), B.hasLeadingSpaces = true), R && (B.hasTrailingSpaces = true, J && (J.hasLeadingSpaces = true))) : (d.removeChild(B), b--, (k || R) && (q && (q.hasTrailingSpaces = true), J && (J.hasLeadingSpaces = true)));
              }
              d.isWhitespaceSensitive = v, d.isIndentationSensitive = S;
            });
          }
          function $(o) {
            o.walk((d) => {
              d.isSelfClosing = !d.children || d.type === "element" && (d.tagDefinition.isVoid || d.startSourceSpan === d.endSourceSpan);
            });
          }
          function D(o, d) {
            o.walk((v) => {
              v.type === "element" && (v.hasHtmComponentClosingTag = v.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(d.originalText.slice(v.endSourceSpan.start.offset, v.endSourceSpan.end.offset)));
            });
          }
          function T(o, d) {
            o.walk((v) => {
              v.cssDisplay = i(v, d);
            });
          }
          function m(o, d) {
            o.walk((v) => {
              let { children: S } = v;
              if (S) {
                if (S.length === 0) {
                  v.isDanglingSpaceSensitive = l(v);
                  return;
                }
                for (let b of S) b.isLeadingSpaceSensitive = y(b, d), b.isTrailingSpaceSensitive = h3(b, d);
                for (let b = 0; b < S.length; b++) {
                  let B = S[b];
                  B.isLeadingSpaceSensitive = (b === 0 || B.prev.isTrailingSpaceSensitive) && B.isLeadingSpaceSensitive, B.isTrailingSpaceSensitive = (b === S.length - 1 || B.next.isLeadingSpaceSensitive) && B.isTrailingSpaceSensitive;
                }
              }
            });
          }
          function C(o, d) {
            if (d.parser === "vue") {
              let v = o.children.find((b) => c(b, d));
              if (!v) return;
              let { lang: S } = v.attrMap;
              (S === "ts" || S === "typescript") && (d.__should_parse_vue_template_with_ts = true);
            }
          }
          r.exports = F;
        } }), xg = te({ "src/language-html/pragma.js"(e2, r) {
          "use strict";
          ne();
          function t(a) {
            return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(a);
          }
          function s(a) {
            return `<!-- @format -->

` + a.replace(/^\s*\n/, "");
          }
          r.exports = { hasPragma: t, insertPragma: s };
        } }), au = te({ "src/language-html/loc.js"(e2, r) {
          "use strict";
          ne();
          function t(a) {
            return a.sourceSpan.start.offset;
          }
          function s(a) {
            return a.sourceSpan.end.offset;
          }
          r.exports = { locStart: t, locEnd: s };
        } }), ur = te({ "src/language-html/print/tag.js"(e2, r) {
          "use strict";
          ne();
          var t = Zt(), { isNonEmptyArray: s } = Ue(), { builders: { indent: a, join: n2, line: u, softline: i, hardline: l }, utils: { replaceTextEndOfLine: p } } = qe(), { locStart: y, locEnd: h3 } = au(), { isTextLikeNode: g, getLastDescendant: c, isPreLikeNode: f, hasPrettierIgnore: F, shouldPreserveContent: _, isVueSfcBlock: w } = Rt();
          function E(L, Q) {
            return [L.isSelfClosing ? "" : N(L, Q), x2(L, Q)];
          }
          function N(L, Q) {
            return L.lastChild && o(L.lastChild) ? "" : [I(L, Q), $(L, Q)];
          }
          function x2(L, Q) {
            return (L.next ? m(L.next) : C(L.parent)) ? "" : [D(L, Q), P(L, Q)];
          }
          function I(L, Q) {
            return C(L) ? D(L.lastChild, Q) : "";
          }
          function P(L, Q) {
            return o(L) ? $(L.parent, Q) : d(L) ? q(L.next) : "";
          }
          function $(L, Q) {
            if (t(!L.isSelfClosing), T(L, Q)) return "";
            switch (L.type) {
              case "ieConditionalComment":
                return "<!";
              case "element":
                if (L.hasHtmComponentClosingTag) return "<//";
              default:
                return `</${L.rawName}`;
            }
          }
          function D(L, Q) {
            if (T(L, Q)) return "";
            switch (L.type) {
              case "ieConditionalComment":
              case "ieConditionalEndComment":
                return "[endif]-->";
              case "ieConditionalStartComment":
                return "]><!-->";
              case "interpolation":
                return "}}";
              case "element":
                if (L.isSelfClosing) return "/>";
              default:
                return ">";
            }
          }
          function T(L, Q) {
            return !L.isSelfClosing && !L.endSourceSpan && (F(L) || _(L.parent, Q));
          }
          function m(L) {
            return L.prev && L.prev.type !== "docType" && !g(L.prev) && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
          }
          function C(L) {
            return L.lastChild && L.lastChild.isTrailingSpaceSensitive && !L.lastChild.hasTrailingSpaces && !g(c(L.lastChild)) && !f(L);
          }
          function o(L) {
            return !L.next && !L.hasTrailingSpaces && L.isTrailingSpaceSensitive && g(c(L));
          }
          function d(L) {
            return L.next && !g(L.next) && g(L) && L.isTrailingSpaceSensitive && !L.hasTrailingSpaces;
          }
          function v(L) {
            let Q = L.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
            return Q ? Q[1] ? Q[1].split(/\s+/) : true : false;
          }
          function S(L) {
            return !L.prev && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
          }
          function b(L, Q, V) {
            let j = L.getValue();
            if (!s(j.attrs)) return j.isSelfClosing ? " " : "";
            let Y = j.prev && j.prev.type === "comment" && v(j.prev.value), ie = typeof Y == "boolean" ? () => Y : Array.isArray(Y) ? (ue) => Y.includes(ue.rawName) : () => false, ee = L.map((ue) => {
              let Fe = ue.getValue();
              return ie(Fe) ? p(Q.originalText.slice(y(Fe), h3(Fe))) : V();
            }, "attrs"), ce = j.type === "element" && j.fullName === "script" && j.attrs.length === 1 && j.attrs[0].fullName === "src" && j.children.length === 0, K = Q.singleAttributePerLine && j.attrs.length > 1 && !w(j, Q) ? l : u, de = [a([ce ? " " : u, n2(K, ee)])];
            return j.firstChild && S(j.firstChild) || j.isSelfClosing && C(j.parent) || ce ? de.push(j.isSelfClosing ? " " : "") : de.push(Q.bracketSameLine ? j.isSelfClosing ? " " : "" : j.isSelfClosing ? u : i), de;
          }
          function B(L) {
            return L.firstChild && S(L.firstChild) ? "" : J(L);
          }
          function k(L, Q, V) {
            let j = L.getValue();
            return [M(j, Q), b(L, Q, V), j.isSelfClosing ? "" : B(j)];
          }
          function M(L, Q) {
            return L.prev && d(L.prev) ? "" : [R(L, Q), q(L)];
          }
          function R(L, Q) {
            return S(L) ? J(L.parent) : m(L) ? D(L.prev, Q) : "";
          }
          function q(L) {
            switch (L.type) {
              case "ieConditionalComment":
              case "ieConditionalStartComment":
                return `<!--[if ${L.condition}`;
              case "ieConditionalEndComment":
                return "<!--<!";
              case "interpolation":
                return "{{";
              case "docType":
                return "<!DOCTYPE";
              case "element":
                if (L.condition) return `<!--[if ${L.condition}]><!--><${L.rawName}`;
              default:
                return `<${L.rawName}`;
            }
          }
          function J(L) {
            switch (t(!L.isSelfClosing), L.type) {
              case "ieConditionalComment":
                return "]>";
              case "element":
                if (L.condition) return "><!--<![endif]-->";
              default:
                return ">";
            }
          }
          r.exports = { printClosingTag: E, printClosingTagStart: N, printClosingTagStartMarker: $, printClosingTagEndMarker: D, printClosingTagSuffix: P, printClosingTagEnd: x2, needsToBorrowLastChildClosingTagEndMarker: C, needsToBorrowParentClosingTagStartMarker: o, needsToBorrowPrevClosingTagEndMarker: m, printOpeningTag: k, printOpeningTagStart: M, printOpeningTagPrefix: R, printOpeningTagStartMarker: q, printOpeningTagEndMarker: J, needsToBorrowNextOpeningTagStartMarker: d, needsToBorrowParentOpeningTagEndMarker: S };
        } }), bg = te({ "node_modules/parse-srcset/src/parse-srcset.js"(e2, r) {
          ne(), function(t, s) {
            typeof define == "function" && define.amd ? define([], s) : typeof r == "object" && r.exports ? r.exports = s() : t.parseSrcset = s();
          }(e2, function() {
            return function(t, s) {
              var a = s && s.logger || console;
              function n2($) {
                return $ === " " || $ === "	" || $ === `
` || $ === "\f" || $ === "\r";
              }
              function u($) {
                var D, T = $.exec(t.substring(N));
                if (T) return D = T[0], N += D.length, D;
              }
              for (var i = t.length, l = /^[ \t\n\r\u000c]+/, p = /^[, \t\n\r\u000c]+/, y = /^[^ \t\n\r\u000c]+/, h3 = /[,]+$/, g = /^\d+$/, c = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, f, F, _, w, E, N = 0, x2 = []; ; ) {
                if (u(p), N >= i) return x2;
                f = u(y), F = [], f.slice(-1) === "," ? (f = f.replace(h3, ""), P()) : I();
              }
              function I() {
                for (u(l), _ = "", w = "in descriptor"; ; ) {
                  if (E = t.charAt(N), w === "in descriptor") if (n2(E)) _ && (F.push(_), _ = "", w = "after descriptor");
                  else if (E === ",") {
                    N += 1, _ && F.push(_), P();
                    return;
                  } else if (E === "(") _ = _ + E, w = "in parens";
                  else if (E === "") {
                    _ && F.push(_), P();
                    return;
                  } else _ = _ + E;
                  else if (w === "in parens") if (E === ")") _ = _ + E, w = "in descriptor";
                  else if (E === "") {
                    F.push(_), P();
                    return;
                  } else _ = _ + E;
                  else if (w === "after descriptor" && !n2(E)) if (E === "") {
                    P();
                    return;
                  } else w = "in descriptor", N -= 1;
                  N += 1;
                }
              }
              function P() {
                var $ = false, D, T, m, C, o = {}, d, v, S, b, B;
                for (C = 0; C < F.length; C++) d = F[C], v = d[d.length - 1], S = d.substring(0, d.length - 1), b = parseInt(S, 10), B = parseFloat(S), g.test(S) && v === "w" ? ((D || T) && ($ = true), b === 0 ? $ = true : D = b) : c.test(S) && v === "x" ? ((D || T || m) && ($ = true), B < 0 ? $ = true : T = B) : g.test(S) && v === "h" ? ((m || T) && ($ = true), b === 0 ? $ = true : m = b) : $ = true;
                $ ? a && a.error && a.error("Invalid srcset descriptor found in '" + t + "' at '" + d + "'.") : (o.url = f, D && (o.w = D), T && (o.d = T), m && (o.h = m), x2.push(o));
              }
            };
          });
        } }), Tg = te({ "src/language-html/syntax-attribute.js"(e2, r) {
          "use strict";
          ne();
          var t = bg(), { builders: { ifBreak: s, join: a, line: n2 } } = qe();
          function u(l) {
            let p = t(l, { logger: { error(I) {
              throw new Error(I);
            } } }), y = p.some((I) => {
              let { w: P } = I;
              return P;
            }), h3 = p.some((I) => {
              let { h: P } = I;
              return P;
            }), g = p.some((I) => {
              let { d: P } = I;
              return P;
            });
            if (y + h3 + g > 1) throw new Error("Mixed descriptor in srcset is not supported");
            let c = y ? "w" : h3 ? "h" : "d", f = y ? "w" : h3 ? "h" : "x", F = (I) => Math.max(...I), _ = p.map((I) => I.url), w = F(_.map((I) => I.length)), E = p.map((I) => I[c]).map((I) => I ? I.toString() : ""), N = E.map((I) => {
              let P = I.indexOf(".");
              return P === -1 ? I.length : P;
            }), x2 = F(N);
            return a([",", n2], _.map((I, P) => {
              let $ = [I], D = E[P];
              if (D) {
                let T = w - I.length + 1, m = x2 - N[P], C = " ".repeat(T + m);
                $.push(s(C, " "), D + f);
              }
              return $;
            }));
          }
          function i(l) {
            return l.trim().split(/\s+/).join(" ");
          }
          r.exports = { printImgSrcset: u, printClassNames: i };
        } }), Bg = te({ "src/language-html/syntax-vue.js"(e2, r) {
          "use strict";
          ne();
          var { builders: { group: t } } = qe();
          function s(i, l) {
            let { left: p, operator: y, right: h3 } = a(i);
            return [t(l(`function _(${p}) {}`, { parser: "babel", __isVueForBindingLeft: true })), " ", y, " ", l(h3, { parser: "__js_expression" }, { stripTrailingHardline: true })];
          }
          function a(i) {
            let l = /(.*?)\s+(in|of)\s+(.*)/s, p = /,([^,\]}]*)(?:,([^,\]}]*))?$/, y = /^\(|\)$/g, h3 = i.match(l);
            if (!h3) return;
            let g = {};
            if (g.for = h3[3].trim(), !g.for) return;
            let c = h3[1].trim().replace(y, ""), f = c.match(p);
            f ? (g.alias = c.replace(p, ""), g.iterator1 = f[1].trim(), f[2] && (g.iterator2 = f[2].trim())) : g.alias = c;
            let F = [g.alias, g.iterator1, g.iterator2];
            if (!F.some((_, w) => !_ && (w === 0 || F.slice(w + 1).some(Boolean)))) return { left: F.filter(Boolean).join(","), operator: h3[2], right: g.for };
          }
          function n2(i, l) {
            return l(`function _(${i}) {}`, { parser: "babel", __isVueBindings: true });
          }
          function u(i) {
            let l = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, p = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/, y = i.trim();
            return l.test(y) || p.test(y);
          }
          r.exports = { isVueEventBindingExpression: u, printVueFor: s, printVueBindings: n2 };
        } }), Lo = te({ "src/language-html/get-node-content.js"(e2, r) {
          "use strict";
          ne();
          var { needsToBorrowParentClosingTagStartMarker: t, printClosingTagStartMarker: s, needsToBorrowLastChildClosingTagEndMarker: a, printClosingTagEndMarker: n2, needsToBorrowParentOpeningTagEndMarker: u, printOpeningTagEndMarker: i } = ur();
          function l(p, y) {
            let h3 = p.startSourceSpan.end.offset;
            p.firstChild && u(p.firstChild) && (h3 -= i(p).length);
            let g = p.endSourceSpan.start.offset;
            return p.lastChild && t(p.lastChild) ? g += s(p, y).length : a(p) && (g -= n2(p.lastChild, y).length), y.originalText.slice(h3, g);
          }
          r.exports = l;
        } }), Ng = te({ "src/language-html/embed.js"(e2, r) {
          "use strict";
          ne();
          var { builders: { breakParent: t, group: s, hardline: a, indent: n2, line: u, fill: i, softline: l }, utils: { mapDoc: p, replaceTextEndOfLine: y } } = qe(), h3 = su(), { printClosingTag: g, printClosingTagSuffix: c, needsToBorrowPrevClosingTagEndMarker: f, printOpeningTagPrefix: F, printOpeningTag: _ } = ur(), { printImgSrcset: w, printClassNames: E } = Tg(), { printVueFor: N, printVueBindings: x2, isVueEventBindingExpression: I } = Bg(), { isScriptLikeTag: P, isVueNonHtmlBlock: $, inferScriptParser: D, htmlTrimPreserveIndentation: T, dedentString: m, unescapeQuoteEntities: C, isVueSlotAttribute: o, isVueSfcBindingsAttribute: d, getTextValueParts: v } = Rt(), S = Lo();
          function b(k, M, R) {
            let q = (ee) => new RegExp(ee.join("|")).test(k.fullName), J = () => C(k.value), L = false, Q = (ee, ce) => {
              let W = ee.type === "NGRoot" ? ee.node.type === "NGMicrosyntax" && ee.node.body.length === 1 && ee.node.body[0].type === "NGMicrosyntaxExpression" ? ee.node.body[0].expression : ee.node : ee.type === "JsExpressionRoot" ? ee.node : ee;
              W && (W.type === "ObjectExpression" || W.type === "ArrayExpression" || ce.parser === "__vue_expression" && (W.type === "TemplateLiteral" || W.type === "StringLiteral")) && (L = true);
            }, V = (ee) => s(ee), j = function(ee) {
              let ce = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              return s([n2([l, ee]), ce ? l : ""]);
            }, Y = (ee) => L ? V(ee) : j(ee), ie = (ee, ce) => M(ee, Object.assign({ __onHtmlBindingRoot: Q, __embeddedInHtml: true }, ce));
            if (k.fullName === "srcset" && (k.parent.fullName === "img" || k.parent.fullName === "source")) return j(w(J()));
            if (k.fullName === "class" && !R.parentParser) {
              let ee = J();
              if (!ee.includes("{{")) return E(ee);
            }
            if (k.fullName === "style" && !R.parentParser) {
              let ee = J();
              if (!ee.includes("{{")) return j(ie(ee, { parser: "css", __isHTMLStyleAttribute: true }));
            }
            if (R.parser === "vue") {
              if (k.fullName === "v-for") return N(J(), ie);
              if (o(k) || d(k, R)) return x2(J(), ie);
              let ee = ["^@", "^v-on:"], ce = ["^:", "^v-bind:"], W = ["^v-"];
              if (q(ee)) {
                let K = J(), de = I(K) ? "__js_expression" : R.__should_parse_vue_template_with_ts ? "__vue_ts_event_binding" : "__vue_event_binding";
                return Y(ie(K, { parser: de }));
              }
              if (q(ce)) return Y(ie(J(), { parser: "__vue_expression" }));
              if (q(W)) return Y(ie(J(), { parser: "__js_expression" }));
            }
            if (R.parser === "angular") {
              let ee = (z, U) => ie(z, Object.assign(Object.assign({}, U), {}, { trailingComma: "none" })), ce = ["^\\*"], W = ["^\\(.+\\)$", "^on-"], K = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], de = ["^i18n(-.+)?$"];
              if (q(W)) return Y(ee(J(), { parser: "__ng_action" }));
              if (q(K)) return Y(ee(J(), { parser: "__ng_binding" }));
              if (q(de)) {
                let z = J().trim();
                return j(i(v(k, z)), !z.includes("@@"));
              }
              if (q(ce)) return Y(ee(J(), { parser: "__ng_directive" }));
              let ue = /{{(.+?)}}/s, Fe = J();
              if (ue.test(Fe)) {
                let z = [];
                for (let [U, Z] of Fe.split(ue).entries()) if (U % 2 === 0) z.push(y(Z));
                else try {
                  z.push(s(["{{", n2([u, ee(Z, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), u, "}}"]));
                } catch (e3) {
                  z.push("{{", y(Z), "}}");
                }
                return s(z);
              }
            }
            return null;
          }
          function B(k, M, R, q) {
            let J = k.getValue();
            switch (J.type) {
              case "element": {
                if (P(J) || J.type === "interpolation") return;
                if (!J.isSelfClosing && $(J, q)) {
                  let L = D(J, q);
                  if (!L) return;
                  let Q = S(J, q), V = /^\s*$/.test(Q), j = "";
                  return V || (j = R(T(Q), { parser: L, __embeddedInHtml: true }, { stripTrailingHardline: true }), V = j === ""), [F(J, q), s(_(k, q, M)), V ? "" : a, j, V ? "" : a, g(J, q), c(J, q)];
                }
                break;
              }
              case "text": {
                if (P(J.parent)) {
                  let L = D(J.parent, q);
                  if (L) {
                    let Q = L === "markdown" ? m(J.value.replace(/^[^\S\n]*\n/, "")) : J.value, V = { parser: L, __embeddedInHtml: true };
                    if (q.parser === "html" && L === "babel") {
                      let j = "script", { attrMap: Y } = J.parent;
                      Y && (Y.type === "module" || Y.type === "text/babel" && Y["data-type"] === "module") && (j = "module"), V.__babelSourceType = j;
                    }
                    return [t, F(J, q), R(Q, V, { stripTrailingHardline: true }), c(J, q)];
                  }
                } else if (J.parent.type === "interpolation") {
                  let L = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
                  return q.parser === "angular" ? (L.parser = "__ng_interpolation", L.trailingComma = "none") : q.parser === "vue" ? L.parser = q.__should_parse_vue_template_with_ts ? "__vue_ts_expression" : "__vue_expression" : L.parser = "__js_expression", [n2([u, R(J.value, L, { stripTrailingHardline: true })]), J.parent.next && f(J.parent.next) ? " " : u];
                }
                break;
              }
              case "attribute": {
                if (!J.value) break;
                if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(q.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset))) return [J.rawName, "=", J.value];
                if (q.parser === "lwc" && /^{.*}$/s.test(q.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset))) return [J.rawName, "=", J.value];
                let L = b(J, (Q, V) => R(Q, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, V), { stripTrailingHardline: true }), q);
                if (L) return [J.rawName, '="', s(p(L, (Q) => typeof Q == "string" ? Q.replace(/"/g, "&quot;") : Q)), '"'];
                break;
              }
              case "front-matter":
                return h3(J, R);
            }
          }
          r.exports = B;
        } }), Oo = te({ "src/language-html/print/children.js"(e2, r) {
          "use strict";
          ne();
          var { builders: { breakParent: t, group: s, ifBreak: a, line: n2, softline: u, hardline: i }, utils: { replaceTextEndOfLine: l } } = qe(), { locStart: p, locEnd: y } = au(), { forceBreakChildren: h3, forceNextEmptyLine: g, isTextLikeNode: c, hasPrettierIgnore: f, preferHardlineAsLeadingSpaces: F } = Rt(), { printOpeningTagPrefix: _, needsToBorrowNextOpeningTagStartMarker: w, printOpeningTagStartMarker: E, needsToBorrowPrevClosingTagEndMarker: N, printClosingTagEndMarker: x2, printClosingTagSuffix: I, needsToBorrowParentClosingTagStartMarker: P } = ur();
          function $(m, C, o) {
            let d = m.getValue();
            return f(d) ? [_(d, C), ...l(C.originalText.slice(p(d) + (d.prev && w(d.prev) ? E(d).length : 0), y(d) - (d.next && N(d.next) ? x2(d, C).length : 0))), I(d, C)] : o();
          }
          function D(m, C) {
            return c(m) && c(C) ? m.isTrailingSpaceSensitive ? m.hasTrailingSpaces ? F(C) ? i : n2 : "" : F(C) ? i : u : w(m) && (f(C) || C.firstChild || C.isSelfClosing || C.type === "element" && C.attrs.length > 0) || m.type === "element" && m.isSelfClosing && N(C) ? "" : !C.isLeadingSpaceSensitive || F(C) || N(C) && m.lastChild && P(m.lastChild) && m.lastChild.lastChild && P(m.lastChild.lastChild) ? i : C.hasLeadingSpaces ? n2 : u;
          }
          function T(m, C, o) {
            let d = m.getValue();
            if (h3(d)) return [t, ...m.map((S) => {
              let b = S.getValue(), B = b.prev ? D(b.prev, b) : "";
              return [B ? [B, g(b.prev) ? i : ""] : "", $(S, C, o)];
            }, "children")];
            let v = d.children.map(() => Symbol(""));
            return m.map((S, b) => {
              let B = S.getValue();
              if (c(B)) {
                if (B.prev && c(B.prev)) {
                  let Q = D(B.prev, B);
                  if (Q) return g(B.prev) ? [i, i, $(S, C, o)] : [Q, $(S, C, o)];
                }
                return $(S, C, o);
              }
              let k = [], M = [], R = [], q = [], J = B.prev ? D(B.prev, B) : "", L = B.next ? D(B, B.next) : "";
              return J && (g(B.prev) ? k.push(i, i) : J === i ? k.push(i) : c(B.prev) ? M.push(J) : M.push(a("", u, { groupId: v[b - 1] }))), L && (g(B) ? c(B.next) && q.push(i, i) : L === i ? c(B.next) && q.push(i) : R.push(L)), [...k, s([...M, s([$(S, C, o), ...R], { id: v[b] })]), ...q];
            }, "children");
          }
          r.exports = { printChildren: T };
        } }), wg = te({ "src/language-html/print/element.js"(e2, r) {
          "use strict";
          ne();
          var { builders: { breakParent: t, dedentToRoot: s, group: a, ifBreak: n2, indentIfBreak: u, indent: i, line: l, softline: p }, utils: { replaceTextEndOfLine: y } } = qe(), h3 = Lo(), { shouldPreserveContent: g, isScriptLikeTag: c, isVueCustomBlock: f, countParents: F, forceBreakContent: _ } = Rt(), { printOpeningTagPrefix: w, printOpeningTag: E, printClosingTagSuffix: N, printClosingTag: x2, needsToBorrowPrevClosingTagEndMarker: I, needsToBorrowLastChildClosingTagEndMarker: P } = ur(), { printChildren: $ } = Oo();
          function D(T, m, C) {
            let o = T.getValue();
            if (g(o, m)) return [w(o, m), a(E(T, m, C)), ...y(h3(o, m)), ...x2(o, m), N(o, m)];
            let d = o.children.length === 1 && o.firstChild.type === "interpolation" && o.firstChild.isLeadingSpaceSensitive && !o.firstChild.hasLeadingSpaces && o.lastChild.isTrailingSpaceSensitive && !o.lastChild.hasTrailingSpaces, v = Symbol("element-attr-group-id"), S = (M) => a([a(E(T, m, C), { id: v }), M, x2(o, m)]), b = (M) => d ? u(M, { groupId: v }) : (c(o) || f(o, m)) && o.parent.type === "root" && m.parser === "vue" && !m.vueIndentScriptAndStyle ? M : i(M), B = () => d ? n2(p, "", { groupId: v }) : o.firstChild.hasLeadingSpaces && o.firstChild.isLeadingSpaceSensitive ? l : o.firstChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive ? s(p) : p, k = () => (o.next ? I(o.next) : P(o.parent)) ? o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? " " : "" : d ? n2(p, "", { groupId: v }) : o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? l : (o.lastChild.type === "comment" || o.lastChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${m.tabWidth * F(T, (R) => R.parent && R.parent.type !== "root")}}$`).test(o.lastChild.value) ? "" : p;
            return o.children.length === 0 ? S(o.hasDanglingSpaces && o.isDanglingSpaceSensitive ? l : "") : S([_(o) ? t : "", b([B(), $(T, m, C)]), k()]);
          }
          r.exports = { printElement: D };
        } }), _g = te({ "src/language-html/printer-html.js"(e2, r) {
          "use strict";
          ne();
          var { builders: { fill: t, group: s, hardline: a, literalline: n2 }, utils: { cleanDoc: u, getDocParts: i, isConcat: l, replaceTextEndOfLine: p } } = qe(), y = gg(), { countChars: h3, unescapeQuoteEntities: g, getTextValueParts: c } = Rt(), f = Sg(), { insertPragma: F } = xg(), { locStart: _, locEnd: w } = au(), E = Ng(), { printClosingTagSuffix: N, printClosingTagEnd: x2, printOpeningTagPrefix: I, printOpeningTagStart: P } = ur(), { printElement: $ } = wg(), { printChildren: D } = Oo();
          function T(m, C, o) {
            let d = m.getValue();
            switch (d.type) {
              case "front-matter":
                return p(d.raw);
              case "root":
                return C.__onHtmlRoot && C.__onHtmlRoot(d), [s(D(m, C, o)), a];
              case "element":
              case "ieConditionalComment":
                return $(m, C, o);
              case "ieConditionalStartComment":
              case "ieConditionalEndComment":
                return [P(d), x2(d)];
              case "interpolation":
                return [P(d, C), ...m.map(o, "children"), x2(d, C)];
              case "text": {
                if (d.parent.type === "interpolation") {
                  let S = /\n[^\S\n]*$/, b = S.test(d.value), B = b ? d.value.replace(S, "") : d.value;
                  return [...p(B), b ? a : ""];
                }
                let v = u([I(d, C), ...c(d), N(d, C)]);
                return l(v) || v.type === "fill" ? t(i(v)) : v;
              }
              case "docType":
                return [s([P(d, C), " ", d.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), x2(d, C)];
              case "comment":
                return [I(d, C), ...p(C.originalText.slice(_(d), w(d)), n2), N(d, C)];
              case "attribute": {
                if (d.value === null) return d.rawName;
                let v = g(d.value), S = h3(v, "'"), b = h3(v, '"'), B = S < b ? "'" : '"';
                return [d.rawName, "=", B, ...p(B === '"' ? v.replace(/"/g, "&quot;") : v.replace(/'/g, "&apos;")), B];
              }
              default:
                throw new Error(`Unexpected node type ${d.type}`);
            }
          }
          r.exports = { preprocess: f, print: T, insertPragma: F, massageAstNode: y, embed: E };
        } }), Pg = te({ "src/language-html/options.js"(e2, r) {
          "use strict";
          ne();
          var t = Mt(), s = "HTML";
          r.exports = { bracketSameLine: t.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: s, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: t.singleAttributePerLine, vueIndentScriptAndStyle: { since: "1.19.0", category: s, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
        } }), Ig = te({ "src/language-html/parsers.js"() {
          ne();
        } }), On = te({ "node_modules/linguist-languages/data/HTML.json"(e2, r) {
          r.exports = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 };
        } }), kg = te({ "node_modules/linguist-languages/data/Vue.json"(e2, r) {
          r.exports = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
        } }), Lg = te({ "src/language-html/index.js"(e2, r) {
          "use strict";
          ne();
          var t = _t(), s = _g(), a = Pg(), n2 = Ig(), u = [t(On(), () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), t(On(), (l) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...l.extensions, ".mjml"] })), t(On(), () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), t(kg(), () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))], i = { html: s };
          r.exports = { languages: u, printers: i, options: a, parsers: n2 };
        } }), Og = te({ "src/language-yaml/pragma.js"(e2, r) {
          "use strict";
          ne();
          function t(n2) {
            return /^\s*@(?:prettier|format)\s*$/.test(n2);
          }
          function s(n2) {
            return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(n2);
          }
          function a(n2) {
            return `# @format

${n2}`;
          }
          r.exports = { isPragma: t, hasPragma: s, insertPragma: a };
        } }), jg = te({ "src/language-yaml/loc.js"(e2, r) {
          "use strict";
          ne();
          function t(a) {
            return a.position.start.offset;
          }
          function s(a) {
            return a.position.end.offset;
          }
          r.exports = { locStart: t, locEnd: s };
        } }), qg = te({ "src/language-yaml/embed.js"(e2, r) {
          "use strict";
          ne();
          function t(s, a, n2, u) {
            if (s.getValue().type === "root" && u.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint|lintstaged)rc$/.test(u.filepath)) return n2(u.originalText, Object.assign(Object.assign({}, u), {}, { parser: "json" }));
          }
          r.exports = t;
        } }), $t = te({ "src/language-yaml/utils.js"(e2, r) {
          "use strict";
          ne();
          var { getLast: t, isNonEmptyArray: s } = Ue();
          function a(D, T) {
            let m = 0, C = D.stack.length - 1;
            for (let o = 0; o < C; o++) {
              let d = D.stack[o];
              n2(d) && T(d) && m++;
            }
            return m;
          }
          function n2(D, T) {
            return D && typeof D.type == "string" && (!T || T.includes(D.type));
          }
          function u(D, T, m) {
            return T("children" in D ? Object.assign(Object.assign({}, D), {}, { children: D.children.map((C) => u(C, T, D)) }) : D, m);
          }
          function i(D, T, m) {
            Object.defineProperty(D, T, { get: m, enumerable: false });
          }
          function l(D, T) {
            let m = 0, C = T.length;
            for (let o = D.position.end.offset - 1; o < C; o++) {
              let d = T[o];
              if (d === `
` && m++, m === 1 && /\S/.test(d)) return false;
              if (m === 2) return true;
            }
            return false;
          }
          function p(D) {
            switch (D.getValue().type) {
              case "tag":
              case "anchor":
              case "comment":
                return false;
            }
            let m = D.stack.length;
            for (let C = 1; C < m; C++) {
              let o = D.stack[C], d = D.stack[C - 1];
              if (Array.isArray(d) && typeof o == "number" && o !== d.length - 1) return false;
            }
            return true;
          }
          function y(D) {
            return s(D.children) ? y(t(D.children)) : D;
          }
          function h3(D) {
            return D.value.trim() === "prettier-ignore";
          }
          function g(D) {
            let T = D.getValue();
            if (T.type === "documentBody") {
              let m = D.getParentNode();
              return N(m.head) && h3(t(m.head.endComments));
            }
            return F(T) && h3(t(T.leadingComments));
          }
          function c(D) {
            return !s(D.children) && !f(D);
          }
          function f(D) {
            return F(D) || _(D) || w(D) || E(D) || N(D);
          }
          function F(D) {
            return s(D == null ? void 0 : D.leadingComments);
          }
          function _(D) {
            return s(D == null ? void 0 : D.middleComments);
          }
          function w(D) {
            return D == null ? void 0 : D.indicatorComment;
          }
          function E(D) {
            return D == null ? void 0 : D.trailingComment;
          }
          function N(D) {
            return s(D == null ? void 0 : D.endComments);
          }
          function x2(D) {
            let T = [], m;
            for (let C of D.split(/( +)/)) C !== " " ? m === " " ? T.push(C) : T.push((T.pop() || "") + C) : m === void 0 && T.unshift(""), m = C;
            return m === " " && T.push((T.pop() || "") + " "), T[0] === "" && (T.shift(), T.unshift(" " + (T.shift() || ""))), T;
          }
          function I(D, T, m) {
            let C = T.split(`
`).map((o, d, v) => d === 0 && d === v.length - 1 ? o : d !== 0 && d !== v.length - 1 ? o.trim() : d === 0 ? o.trimEnd() : o.trimStart());
            return m.proseWrap === "preserve" ? C.map((o) => o.length === 0 ? [] : [o]) : C.map((o) => o.length === 0 ? [] : x2(o)).reduce((o, d, v) => v !== 0 && C[v - 1].length > 0 && d.length > 0 && !(D === "quoteDouble" && t(t(o)).endsWith("\\")) ? [...o.slice(0, -1), [...t(o), ...d]] : [...o, d], []).map((o) => m.proseWrap === "never" ? [o.join(" ")] : o);
          }
          function P(D, T) {
            let { parentIndent: m, isLastDescendant: C, options: o } = T, d = D.position.start.line === D.position.end.line ? "" : o.originalText.slice(D.position.start.offset, D.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1], v;
            if (D.indent === null) {
              let B = d.match(/^(?<leadingSpace> *)[^\n\r ]/m);
              v = B ? B.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
            } else v = D.indent - 1 + m;
            let S = d.split(`
`).map((B) => B.slice(v));
            if (o.proseWrap === "preserve" || D.type === "blockLiteral") return b(S.map((B) => B.length === 0 ? [] : [B]));
            return b(S.map((B) => B.length === 0 ? [] : x2(B)).reduce((B, k, M) => M !== 0 && S[M - 1].length > 0 && k.length > 0 && !/^\s/.test(k[0]) && !/^\s|\s$/.test(t(B)) ? [...B.slice(0, -1), [...t(B), ...k]] : [...B, k], []).map((B) => B.reduce((k, M) => k.length > 0 && /\s$/.test(t(k)) ? [...k.slice(0, -1), t(k) + " " + M] : [...k, M], [])).map((B) => o.proseWrap === "never" ? [B.join(" ")] : B));
            function b(B) {
              if (D.chomping === "keep") return t(B).length === 0 ? B.slice(0, -1) : B;
              let k = 0;
              for (let M = B.length - 1; M >= 0 && B[M].length === 0; M--) k++;
              return k === 0 ? B : k >= 2 && !C ? B.slice(0, -(k - 1)) : B.slice(0, -k);
            }
          }
          function $(D) {
            if (!D) return true;
            switch (D.type) {
              case "plain":
              case "quoteDouble":
              case "quoteSingle":
              case "alias":
              case "flowMapping":
              case "flowSequence":
                return true;
              default:
                return false;
            }
          }
          r.exports = { getLast: t, getAncestorCount: a, isNode: n2, isEmptyNode: c, isInlineNode: $, mapNode: u, defineShortcut: i, isNextLineEmpty: l, isLastDescendantNode: p, getBlockValueLineContents: P, getFlowScalarLineContents: I, getLastDescendantNode: y, hasPrettierIgnore: g, hasLeadingComments: F, hasMiddleComments: _, hasIndicatorComment: w, hasTrailingComment: E, hasEndComments: N };
        } }), Mg = te({ "src/language-yaml/print-preprocess.js"(e2, r) {
          "use strict";
          ne();
          var { defineShortcut: t, mapNode: s } = $t();
          function a(u) {
            return s(u, n2);
          }
          function n2(u) {
            switch (u.type) {
              case "document":
                t(u, "head", () => u.children[0]), t(u, "body", () => u.children[1]);
                break;
              case "documentBody":
              case "sequenceItem":
              case "flowSequenceItem":
              case "mappingKey":
              case "mappingValue":
                t(u, "content", () => u.children[0]);
                break;
              case "mappingItem":
              case "flowMappingItem":
                t(u, "key", () => u.children[0]), t(u, "value", () => u.children[1]);
                break;
            }
            return u;
          }
          r.exports = a;
        } }), Mr = te({ "src/language-yaml/print/misc.js"(e2, r) {
          "use strict";
          ne();
          var { builders: { softline: t, align: s } } = qe(), { hasEndComments: a, isNextLineEmpty: n2, isNode: u } = $t(), i = /* @__PURE__ */ new WeakMap();
          function l(h3, g) {
            let c = h3.getValue(), f = h3.stack[0], F;
            return i.has(f) ? F = i.get(f) : (F = /* @__PURE__ */ new Set(), i.set(f, F)), !F.has(c.position.end.line) && (F.add(c.position.end.line), n2(c, g) && !p(h3.getParentNode())) ? t : "";
          }
          function p(h3) {
            return a(h3) && !u(h3, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
          }
          function y(h3, g) {
            return s(" ".repeat(h3), g);
          }
          r.exports = { alignWithSpaces: y, shouldPrintEndComments: p, printNextEmptyLine: l };
        } }), Rg = te({ "src/language-yaml/print/flow-mapping-sequence.js"(e2, r) {
          "use strict";
          ne();
          var { builders: { ifBreak: t, line: s, softline: a, hardline: n2, join: u } } = qe(), { isEmptyNode: i, getLast: l, hasEndComments: p } = $t(), { printNextEmptyLine: y, alignWithSpaces: h3 } = Mr();
          function g(f, F, _) {
            let w = f.getValue(), E = w.type === "flowMapping", N = E ? "{" : "[", x2 = E ? "}" : "]", I = a;
            E && w.children.length > 0 && _.bracketSpacing && (I = s);
            let P = l(w.children), $ = P && P.type === "flowMappingItem" && i(P.key) && i(P.value);
            return [N, h3(_.tabWidth, [I, c(f, F, _), _.trailingComma === "none" ? "" : t(","), p(w) ? [n2, u(n2, f.map(F, "endComments"))] : ""]), $ ? "" : I, x2];
          }
          function c(f, F, _) {
            let w = f.getValue();
            return f.map((N, x2) => [F(), x2 === w.children.length - 1 ? "" : [",", s, w.children[x2].position.start.line !== w.children[x2 + 1].position.start.line ? y(N, _.originalText) : ""]], "children");
          }
          r.exports = { printFlowMapping: g, printFlowSequence: g };
        } }), $g = te({ "src/language-yaml/print/mapping-item.js"(e2, r) {
          "use strict";
          ne();
          var { builders: { conditionalGroup: t, group: s, hardline: a, ifBreak: n2, join: u, line: i } } = qe(), { hasLeadingComments: l, hasMiddleComments: p, hasTrailingComment: y, hasEndComments: h3, isNode: g, isEmptyNode: c, isInlineNode: f } = $t(), { alignWithSpaces: F } = Mr();
          function _(x2, I, P, $, D) {
            let { key: T, value: m } = x2, C = c(T), o = c(m);
            if (C && o) return ": ";
            let d = $("key"), v = E(x2) ? " " : "";
            if (o) return x2.type === "flowMappingItem" && I.type === "flowMapping" ? d : x2.type === "mappingItem" && w(T.content, D) && !y(T.content) && (!I.tag || I.tag.value !== "tag:yaml.org,2002:set") ? [d, v, ":"] : ["? ", F(2, d)];
            let S = $("value");
            if (C) return [": ", F(2, S)];
            if (l(m) || !f(T.content)) return ["? ", F(2, d), a, u("", P.map($, "value", "leadingComments").map((q) => [q, a])), ": ", F(2, S)];
            if (N(T.content) && !l(T.content) && !p(T.content) && !y(T.content) && !h3(T) && !l(m.content) && !p(m.content) && !h3(m) && w(m.content, D)) return [d, v, ": ", S];
            let b = Symbol("mappingKey"), B = s([n2("? "), s(F(2, d), { id: b })]), k = [a, ": ", F(2, S)], M = [v, ":"];
            l(m.content) || h3(m) && m.content && !g(m.content, ["mapping", "sequence"]) || I.type === "mapping" && y(T.content) && f(m.content) || g(m.content, ["mapping", "sequence"]) && m.content.tag === null && m.content.anchor === null ? M.push(a) : m.content && M.push(i), M.push(S);
            let R = F(D.tabWidth, M);
            return w(T.content, D) && !l(T.content) && !p(T.content) && !h3(T) ? t([[d, R]]) : t([[B, n2(k, R, { groupId: b })]]);
          }
          function w(x2, I) {
            if (!x2) return true;
            switch (x2.type) {
              case "plain":
              case "quoteSingle":
              case "quoteDouble":
                break;
              case "alias":
                return true;
              default:
                return false;
            }
            if (I.proseWrap === "preserve") return x2.position.start.line === x2.position.end.line;
            if (/\\$/m.test(I.originalText.slice(x2.position.start.offset, x2.position.end.offset))) return false;
            switch (I.proseWrap) {
              case "never":
                return !x2.value.includes(`
`);
              case "always":
                return !/[\n ]/.test(x2.value);
              default:
                return false;
            }
          }
          function E(x2) {
            return x2.key.content && x2.key.content.type === "alias";
          }
          function N(x2) {
            if (!x2) return true;
            switch (x2.type) {
              case "plain":
              case "quoteDouble":
              case "quoteSingle":
                return x2.position.start.line === x2.position.end.line;
              case "alias":
                return true;
              default:
                return false;
            }
          }
          r.exports = _;
        } }), Vg = te({ "src/language-yaml/print/block.js"(e2, r) {
          "use strict";
          ne();
          var { builders: { dedent: t, dedentToRoot: s, fill: a, hardline: n2, join: u, line: i, literalline: l, markAsRoot: p }, utils: { getDocParts: y } } = qe(), { getAncestorCount: h3, getBlockValueLineContents: g, hasIndicatorComment: c, isLastDescendantNode: f, isNode: F } = $t(), { alignWithSpaces: _ } = Mr();
          function w(E, N, x2) {
            let I = E.getValue(), P = h3(E, (C) => F(C, ["sequence", "mapping"])), $ = f(E), D = [I.type === "blockFolded" ? ">" : "|"];
            I.indent !== null && D.push(I.indent.toString()), I.chomping !== "clip" && D.push(I.chomping === "keep" ? "+" : "-"), c(I) && D.push(" ", N("indicatorComment"));
            let T = g(I, { parentIndent: P, isLastDescendant: $, options: x2 }), m = [];
            for (let [C, o] of T.entries()) C === 0 && m.push(n2), m.push(a(y(u(i, o)))), C !== T.length - 1 ? m.push(o.length === 0 ? n2 : p(l)) : I.chomping === "keep" && $ && m.push(s(o.length === 0 ? n2 : l));
            return I.indent === null ? D.push(t(_(x2.tabWidth, m))) : D.push(s(_(I.indent - 1 + P, m))), D;
          }
          r.exports = w;
        } }), Wg = te({ "src/language-yaml/printer-yaml.js"(e2, r) {
          "use strict";
          ne();
          var { builders: { breakParent: t, fill: s, group: a, hardline: n2, join: u, line: i, lineSuffix: l, literalline: p }, utils: { getDocParts: y, replaceTextEndOfLine: h3 } } = qe(), { isPreviousLineEmpty: g } = Ue(), { insertPragma: c, isPragma: f } = Og(), { locStart: F } = jg(), _ = qg(), { getFlowScalarLineContents: w, getLastDescendantNode: E, hasLeadingComments: N, hasMiddleComments: x2, hasTrailingComment: I, hasEndComments: P, hasPrettierIgnore: $, isLastDescendantNode: D, isNode: T, isInlineNode: m } = $t(), C = Mg(), { alignWithSpaces: o, printNextEmptyLine: d, shouldPrintEndComments: v } = Mr(), { printFlowMapping: S, printFlowSequence: b } = Rg(), B = $g(), k = Vg();
          function M(j, Y, ie) {
            let ee = j.getValue(), ce = [];
            ee.type !== "mappingValue" && N(ee) && ce.push([u(n2, j.map(ie, "leadingComments")), n2]);
            let { tag: W, anchor: K } = ee;
            W && ce.push(ie("tag")), W && K && ce.push(" "), K && ce.push(ie("anchor"));
            let de = "";
            T(ee, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !D(j) && (de = d(j, Y.originalText)), (W || K) && (T(ee, ["sequence", "mapping"]) && !x2(ee) ? ce.push(n2) : ce.push(" ")), x2(ee) && ce.push([ee.middleComments.length === 1 ? "" : n2, u(n2, j.map(ie, "middleComments")), n2]);
            let ue = j.getParentNode();
            return $(j) ? ce.push(h3(Y.originalText.slice(ee.position.start.offset, ee.position.end.offset).trimEnd(), p)) : ce.push(a(R(ee, ue, j, Y, ie))), I(ee) && !T(ee, ["document", "documentHead"]) && ce.push(l([ee.type === "mappingValue" && !ee.content ? "" : " ", ue.type === "mappingKey" && j.getParentNode(2).type === "mapping" && m(ee) ? "" : t, ie("trailingComment")])), v(ee) && ce.push(o(ee.type === "sequenceItem" ? 2 : 0, [n2, u(n2, j.map((Fe) => [g(Y.originalText, Fe.getValue(), F) ? n2 : "", ie()], "endComments"))])), ce.push(de), ce;
          }
          function R(j, Y, ie, ee, ce) {
            switch (j.type) {
              case "root": {
                let { children: W } = j, K = [];
                ie.each((ue, Fe) => {
                  let z = W[Fe], U = W[Fe + 1];
                  Fe !== 0 && K.push(n2), K.push(ce()), J(z, U) ? (K.push(n2, "..."), I(z) && K.push(" ", ce("trailingComment"))) : U && !I(U.head) && K.push(n2, "---");
                }, "children");
                let de = E(j);
                return (!T(de, ["blockLiteral", "blockFolded"]) || de.chomping !== "keep") && K.push(n2), K;
              }
              case "document": {
                let W = Y.children[ie.getName() + 1], K = [];
                return L(j, W, Y, ee) === "head" && ((j.head.children.length > 0 || j.head.endComments.length > 0) && K.push(ce("head")), I(j.head) ? K.push(["---", " ", ce(["head", "trailingComment"])]) : K.push("---")), q(j) && K.push(ce("body")), u(n2, K);
              }
              case "documentHead":
                return u(n2, [...ie.map(ce, "children"), ...ie.map(ce, "endComments")]);
              case "documentBody": {
                let { children: W, endComments: K } = j, de = "";
                if (W.length > 0 && K.length > 0) {
                  let ue = E(j);
                  T(ue, ["blockFolded", "blockLiteral"]) ? ue.chomping !== "keep" && (de = [n2, n2]) : de = n2;
                }
                return [u(n2, ie.map(ce, "children")), de, u(n2, ie.map(ce, "endComments"))];
              }
              case "directive":
                return ["%", u(" ", [j.name, ...j.parameters])];
              case "comment":
                return ["#", j.value];
              case "alias":
                return ["*", j.value];
              case "tag":
                return ee.originalText.slice(j.position.start.offset, j.position.end.offset);
              case "anchor":
                return ["&", j.value];
              case "plain":
                return Q(j.type, ee.originalText.slice(j.position.start.offset, j.position.end.offset), ee);
              case "quoteDouble":
              case "quoteSingle": {
                let W = "'", K = '"', de = ee.originalText.slice(j.position.start.offset + 1, j.position.end.offset - 1);
                if (j.type === "quoteSingle" && de.includes("\\") || j.type === "quoteDouble" && /\\[^"]/.test(de)) {
                  let Fe = j.type === "quoteDouble" ? K : W;
                  return [Fe, Q(j.type, de, ee), Fe];
                }
                if (de.includes(K)) return [W, Q(j.type, j.type === "quoteDouble" ? de.replace(/\\"/g, K).replace(/'/g, W.repeat(2)) : de, ee), W];
                if (de.includes(W)) return [K, Q(j.type, j.type === "quoteSingle" ? de.replace(/''/g, W) : de, ee), K];
                let ue = ee.singleQuote ? W : K;
                return [ue, Q(j.type, de, ee), ue];
              }
              case "blockFolded":
              case "blockLiteral":
                return k(ie, ce, ee);
              case "mapping":
              case "sequence":
                return u(n2, ie.map(ce, "children"));
              case "sequenceItem":
                return ["- ", o(2, j.content ? ce("content") : "")];
              case "mappingKey":
              case "mappingValue":
                return j.content ? ce("content") : "";
              case "mappingItem":
              case "flowMappingItem":
                return B(j, Y, ie, ce, ee);
              case "flowMapping":
                return S(ie, ce, ee);
              case "flowSequence":
                return b(ie, ce, ee);
              case "flowSequenceItem":
                return ce("content");
              default:
                throw new Error(`Unexpected node type ${j.type}`);
            }
          }
          function q(j) {
            return j.body.children.length > 0 || P(j.body);
          }
          function J(j, Y) {
            return I(j) || Y && (Y.head.children.length > 0 || P(Y.head));
          }
          function L(j, Y, ie, ee) {
            return ie.children[0] === j && /---(?:\s|$)/.test(ee.originalText.slice(F(j), F(j) + 4)) || j.head.children.length > 0 || P(j.head) || I(j.head) ? "head" : J(j, Y) ? false : Y ? "root" : false;
          }
          function Q(j, Y, ie) {
            let ee = w(j, Y, ie);
            return u(n2, ee.map((ce) => s(y(u(i, ce)))));
          }
          function V(j, Y) {
            if (T(Y)) switch (delete Y.position, Y.type) {
              case "comment":
                if (f(Y.value)) return null;
                break;
              case "quoteDouble":
              case "quoteSingle":
                Y.type = "quote";
                break;
            }
          }
          r.exports = { preprocess: C, embed: _, print: M, massageAstNode: V, insertPragma: c };
        } }), Hg = te({ "src/language-yaml/options.js"(e2, r) {
          "use strict";
          ne();
          var t = Mt();
          r.exports = { bracketSpacing: t.bracketSpacing, singleQuote: t.singleQuote, proseWrap: t.proseWrap };
        } }), Gg = te({ "src/language-yaml/parsers.js"() {
          ne();
        } }), Ug = te({ "node_modules/linguist-languages/data/YAML.json"(e2, r) {
          r.exports = { name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 };
        } }), Jg = te({ "src/language-yaml/index.js"(e2, r) {
          "use strict";
          ne();
          var t = _t(), s = Wg(), a = Hg(), n2 = Gg(), u = [t(Ug(), (i) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...i.filenames.filter((l) => l !== "yarn.lock"), ".prettierrc", ".stylelintrc", ".lintstagedrc"] }))];
          r.exports = { languages: u, printers: { yaml: s }, options: a, parsers: n2 };
        } }), zg = te({ "src/languages.js"(e2, r) {
          "use strict";
          ne(), r.exports = [Bd(), Ud(), eg(), ag(), dg(), Lg(), Jg()];
        } });
        ne();
        var { version: Xg } = Ia(), Ot = Gm(), { getSupportInfo: Kg } = Xn(), Yg = Um(), Qg = zg(), Zg = qe();
        function Nt(e2) {
          let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return function() {
            for (var t = arguments.length, s = new Array(t), a = 0; a < t; a++) s[a] = arguments[a];
            let n2 = s[r] || {}, u = n2.plugins || [];
            return s[r] = Object.assign(Object.assign({}, n2), {}, { plugins: [...Qg, ...Array.isArray(u) ? u : Object.values(u)] }), e2(...s);
          };
        }
        var jn = Nt(Ot.formatWithCursor);
        jo.exports = { formatWithCursor: jn, format(e2, r) {
          return jn(e2, r).formatted;
        }, check(e2, r) {
          let { formatted: t } = jn(e2, r);
          return t === e2;
        }, doc: Zg, getSupportInfo: Nt(Kg, 0), version: Xg, util: Yg, __debug: { parse: Nt(Ot.parse), formatAST: Nt(Ot.formatAST), formatDoc: Nt(Ot.formatDoc), printToDoc: Nt(Ot.printToDoc), printDocToString: Nt(Ot.printDocToString) } };
      });
      return e0();
    });
  }
});

// src/index.ts
var _path2 = require('path'); var _path3 = _interopRequireDefault(_path2);
var _process2 = require('process'); var _process3 = _interopRequireDefault(_process2);

// ../../packages-engine/core/src/constants.ts
var LAYER_DEFAULT = "default";
var LAYER_PREFLIGHTS = "preflights";
var LAYER_SHORTCUTS = "shortcuts";
var LAYER_IMPORTS = "imports";
var DEFAULT_LAYERS = {
  [LAYER_IMPORTS]: -200,
  [LAYER_PREFLIGHTS]: -100,
  [LAYER_SHORTCUTS]: -10,
  [LAYER_DEFAULT]: 0
};

// ../../packages-engine/core/src/extractors/split.ts
var defaultSplitRE = /[\\:]?[\s'"`;{}]+/g;
var splitWithVariantGroupRE = /([\\:]?[\s"'`;<>]|:\(|\)"|\)\s)/g;
function splitCode(code) {
  return code.split(defaultSplitRE);
}
var extractorSplit = {
  name: "@unocss/core/extractor-split",
  order: 0,
  extract({ code }) {
    return splitCode(code);
  }
};

// ../../packages-engine/core/src/utils/basic.ts
function toArray2(value = []) {
  return Array.isArray(value) ? value : [value];
}
function uniq(value) {
  return Array.from(new Set(value));
}
function uniqueBy(array, equalFn) {
  return array.reduce((acc, cur) => {
    const index = acc.findIndex((item) => equalFn(cur, item));
    if (index === -1)
      acc.push(cur);
    return acc;
  }, []);
}
function isString(s) {
  return typeof s === "string";
}

// ../../packages-engine/core/src/utils/countable-set.ts
var CountableSet = class extends Set {
  constructor(values) {
    var _a3;
    super(values);
    (_a3 = this._map) != null ? _a3 : this._map = /* @__PURE__ */ new Map();
  }
  add(key) {
    var _a3, _b2;
    (_a3 = this._map) != null ? _a3 : this._map = /* @__PURE__ */ new Map();
    this._map.set(key, ((_b2 = this._map.get(key)) != null ? _b2 : 0) + 1);
    return super.add(key);
  }
  delete(key) {
    this._map.delete(key);
    return super.delete(key);
  }
  clear() {
    this._map.clear();
    super.clear();
  }
  getCount(key) {
    var _a3;
    return (_a3 = this._map.get(key)) != null ? _a3 : 0;
  }
  setCount(key, count) {
    this._map.set(key, count);
    return super.add(key);
  }
};
function isCountableSet(value) {
  return value instanceof CountableSet;
}

// ../../packages-engine/core/src/utils/escape.ts
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function escapeSelector(str) {
  const length = str.length;
  let index = -1;
  let codeUnit;
  let result = "";
  const firstCodeUnit = str.charCodeAt(0);
  while (++index < length) {
    codeUnit = str.charCodeAt(index);
    if (codeUnit === 0) {
      result += "\uFFFD";
      continue;
    }
    if (codeUnit === 37) {
      result += "\\%";
      continue;
    }
    if (codeUnit === 44) {
      result += "\\,";
      continue;
    }
    if (
      // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
      // U+007F, []
      codeUnit >= 1 && codeUnit <= 31 || codeUnit === 127 || index === 0 && codeUnit >= 48 && codeUnit <= 57 || index === 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit === 45
    ) {
      result += `\\${codeUnit.toString(16)} `;
      continue;
    }
    if (
      // If the character is the first character and is a `-` (U+002D), and
      // there is no second character, []
      index === 0 && length === 1 && codeUnit === 45
    ) {
      result += `\\${str.charAt(index)}`;
      continue;
    }
    if (codeUnit >= 128 || codeUnit === 45 || codeUnit === 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
      result += str.charAt(index);
      continue;
    }
    result += `\\${str.charAt(index)}`;
  }
  return result;
}
var e = escapeSelector;

// ../../packages-engine/core/src/utils/events.ts
function createNanoEvents() {
  return {
    events: {},
    emit(event, ...args) {
      (this.events[event] || []).forEach((i) => i(...args));
    },
    on(event, cb) {
      (this.events[event] = this.events[event] || []).push(cb);
      return () => this.events[event] = (this.events[event] || []).filter((i) => i !== cb);
    }
  };
}

// ../../packages-engine/core/src/utils/helpers.ts
var attributifyRE = /^\[(.+?)~?="(.*)"\]$/;
var cssIdRE = /\.(css|postcss|sass|scss|less|stylus|styl)($|\?)/;
var validateFilterRE = /[\w\u00A0-\uFFFF%-?]/;
function isAttributifySelector(selector) {
  return selector.match(attributifyRE);
}
function isValidSelector(selector = "") {
  return validateFilterRE.test(selector);
}
function normalizeVariant(variant) {
  return typeof variant === "function" ? { match: variant } : variant;
}
function isRawUtil(util) {
  return util.length === 3;
}
function notNull(value) {
  return value != null;
}
function noop() {
}

// ../../packages-engine/core/src/utils/map.ts
var TwoKeyMap = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  get(key1, key2) {
    const m2 = this._map.get(key1);
    if (m2)
      return m2.get(key2);
  }
  getFallback(key1, key2, fallback) {
    let m2 = this._map.get(key1);
    if (!m2) {
      m2 = /* @__PURE__ */ new Map();
      this._map.set(key1, m2);
    }
    if (!m2.has(key2))
      m2.set(key2, fallback);
    return m2.get(key2);
  }
  set(key1, key2, value) {
    let m2 = this._map.get(key1);
    if (!m2) {
      m2 = /* @__PURE__ */ new Map();
      this._map.set(key1, m2);
    }
    m2.set(key2, value);
    return this;
  }
  has(key1, key2) {
    var _a3;
    return (_a3 = this._map.get(key1)) == null ? void 0 : _a3.has(key2);
  }
  delete(key1, key2) {
    var _a3;
    return ((_a3 = this._map.get(key1)) == null ? void 0 : _a3.delete(key2)) || false;
  }
  deleteTop(key1) {
    return this._map.delete(key1);
  }
  map(fn) {
    return Array.from(this._map.entries()).flatMap(([k1, m2]) => Array.from(m2.entries()).map(([k2, v]) => {
      return fn(v, k1, k2);
    }));
  }
};
var BetterMap = class extends Map {
  getFallback(key, fallback) {
    const v = this.get(key);
    if (v === void 0) {
      this.set(key, fallback);
      return fallback;
    }
    return v;
  }
  map(mapFn) {
    const result = [];
    this.forEach((v, k) => {
      result.push(mapFn(v, k));
    });
    return result;
  }
  flatMap(mapFn) {
    const result = [];
    this.forEach((v, k) => {
      result.push(...mapFn(v, k));
    });
    return result;
  }
};

// ../../packages-engine/core/src/utils/object.ts
function normalizeCSSEntries(obj) {
  if (isString(obj))
    return obj;
  return (!Array.isArray(obj) ? Object.entries(obj) : obj).filter((i) => i[1] != null);
}
function normalizeCSSValues(obj) {
  if (Array.isArray(obj)) {
    if (obj.find((i) => !Array.isArray(i) || Array.isArray(i[0])))
      return obj.map((i) => normalizeCSSEntries(i));
    else
      return [obj];
  } else {
    return [normalizeCSSEntries(obj)];
  }
}
function clearIdenticalEntries(entry) {
  return entry.filter(([k, v], idx) => {
    if (k.startsWith("$$"))
      return false;
    for (let i = idx - 1; i >= 0; i--) {
      if (entry[i][0] === k && entry[i][1] === v)
        return false;
    }
    return true;
  });
}
function entriesToCss(arr) {
  if (arr == null)
    return "";
  return clearIdenticalEntries(arr).map(([key, value]) => value != null && typeof value !== "function" ? `${key}:${value};` : void 0).filter(Boolean).join("");
}
function isObject(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}
function mergeDeep(original, patch, mergeArray = false) {
  const o = original;
  const p = patch;
  if (Array.isArray(p)) {
    if (mergeArray && Array.isArray(p))
      return [...o, ...p];
    else
      return [...p];
  }
  const output = { ...o };
  if (isObject(o) && isObject(p)) {
    Object.keys(p).forEach((key) => {
      if (isObject(o[key]) && isObject(p[key]) || Array.isArray(o[key]) && Array.isArray(p[key]))
        output[key] = mergeDeep(o[key], p[key], mergeArray);
      else
        Object.assign(output, { [key]: p[key] });
    });
  }
  return output;
}
function clone(val) {
  let k, out, tmp;
  if (Array.isArray(val)) {
    out = Array.from({ length: k = val.length });
    while (k--) out[k] = (tmp = val[k]) && typeof tmp === "object" ? clone(tmp) : tmp;
    return out;
  }
  if (Object.prototype.toString.call(val) === "[object Object]") {
    out = {};
    for (k in val) {
      if (k === "__proto__") {
        Object.defineProperty(out, k, {
          value: clone(val[k]),
          configurable: true,
          enumerable: true,
          writable: true
        });
      } else {
        out[k] = (tmp = val[k]) && typeof tmp === "object" ? clone(tmp) : tmp;
      }
    }
    return out;
  }
  return val;
}
function isStaticRule(rule) {
  return isString(rule[0]);
}
function isStaticShortcut(sc) {
  return isString(sc[0]);
}

// ../../packages-engine/core/src/utils/variant-group.ts
var regexCache = {};
function makeRegexClassGroup(separators = ["-", ":"]) {
  const key = separators.join("|");
  if (!regexCache[key])
    regexCache[key] = new RegExp(`((?:[!@<~\\w+:_-]|\\[&?>?:?\\S*\\])+?)(${key})\\(((?:[~!<>\\w\\s:/\\\\,%#.$?-]|\\[.*?\\])+?)\\)(?!\\s*?=>)`, "gm");
  regexCache[key].lastIndex = 0;
  return regexCache[key];
}
function parseVariantGroup(str, separators = ["-", ":"], depth = 5) {
  const regexClassGroup = makeRegexClassGroup(separators);
  let hasChanged;
  let content = str.toString();
  const prefixes = /* @__PURE__ */ new Set();
  const groupsByOffset = /* @__PURE__ */ new Map();
  do {
    hasChanged = false;
    content = content.replace(
      regexClassGroup,
      (from, pre, sep, body, groupOffset) => {
        var _a3;
        if (!separators.includes(sep))
          return from;
        hasChanged = true;
        prefixes.add(pre + sep);
        const bodyOffset = groupOffset + pre.length + sep.length + 1;
        const group = { length: from.length, items: [] };
        groupsByOffset.set(groupOffset, group);
        for (const itemMatch of [...body.matchAll(/\S+/g)]) {
          const itemOffset = bodyOffset + itemMatch.index;
          let innerItems = (_a3 = groupsByOffset.get(itemOffset)) == null ? void 0 : _a3.items;
          if (innerItems) {
            groupsByOffset.delete(itemOffset);
          } else {
            innerItems = [{
              offset: itemOffset,
              length: itemMatch[0].length,
              className: itemMatch[0]
            }];
          }
          for (const item of innerItems) {
            item.className = item.className === "~" ? pre : item.className.replace(/^(!?)(.*)/, `$1${pre}${sep}$2`);
            group.items.push(item);
          }
        }
        return "$".repeat(from.length);
      }
    );
    depth -= 1;
  } while (hasChanged && depth);
  let expanded;
  if (typeof str === "string") {
    expanded = "";
    let prevOffset = 0;
    for (const [offset, group] of groupsByOffset) {
      expanded += str.slice(prevOffset, offset);
      expanded += group.items.map((item) => item.className).join(" ");
      prevOffset = offset + group.length;
    }
    expanded += str.slice(prevOffset);
  } else {
    expanded = str;
    for (const [offset, group] of groupsByOffset) {
      expanded.overwrite(
        offset,
        offset + group.length,
        group.items.map((item) => item.className).join(" ")
      );
    }
  }
  return {
    prefixes: Array.from(prefixes),
    hasChanged,
    groupsByOffset,
    // Computed lazily because MagicString's toString does a lot of work
    get expanded() {
      return expanded.toString();
    }
  };
}
function expandVariantGroup(str, separators = ["-", ":"], depth = 5) {
  const res = parseVariantGroup(str, separators, depth);
  return typeof str === "string" ? res.expanded : str;
}

// ../../packages-engine/core/src/utils/warn.ts
var warned = /* @__PURE__ */ new Set();
function warnOnce(msg) {
  if (warned.has(msg))
    return;
  console.warn("[unocss]", msg);
  warned.add(msg);
}

// ../../packages-engine/core/src/config.ts
function resolveShortcuts(shortcuts2) {
  return toArray2(shortcuts2).flatMap((s) => {
    if (Array.isArray(s))
      return [s];
    return Object.entries(s);
  });
}
var __RESOLVED = "_uno_resolved";
async function resolvePreset(presetInput) {
  var _a3;
  let preset = typeof presetInput === "function" ? await presetInput() : await presetInput;
  if (__RESOLVED in preset)
    return preset;
  preset = { ...preset };
  Object.defineProperty(preset, __RESOLVED, {
    value: true,
    enumerable: false
  });
  const shortcuts2 = preset.shortcuts ? resolveShortcuts(preset.shortcuts) : void 0;
  preset.shortcuts = shortcuts2;
  if (preset.prefix || preset.layer) {
    const apply = (i) => {
      if (!i[2])
        i[2] = {};
      const meta = i[2];
      if (meta.prefix == null && preset.prefix)
        meta.prefix = toArray2(preset.prefix);
      if (meta.layer == null && preset.layer)
        meta.layer = preset.layer;
    };
    shortcuts2 == null ? void 0 : shortcuts2.forEach(apply);
    (_a3 = preset.rules) == null ? void 0 : _a3.forEach(apply);
  }
  return preset;
}
async function resolvePresets(preset) {
  const root = await resolvePreset(preset);
  if (!root.presets)
    return [root];
  const nested = (await Promise.all((root.presets || []).flatMap(toArray2).flatMap(resolvePresets))).flat();
  return [root, ...nested];
}
function mergeContentOptions(optionsArray) {
  var _a3, _b2;
  if (optionsArray.length === 0) {
    return {};
  }
  const pipelineIncludes = [];
  const pipelineExcludes = [];
  let pipelineDisabled = false;
  const filesystem = [];
  const inline = [];
  const plain = [];
  for (const options of optionsArray) {
    if (options.pipeline === false) {
      pipelineDisabled = true;
      break;
    } else {
      if ((_a3 = options.pipeline) == null ? void 0 : _a3.include) {
        pipelineIncludes.push(options.pipeline.include);
      }
      if ((_b2 = options.pipeline) == null ? void 0 : _b2.exclude) {
        pipelineExcludes.push(options.pipeline.exclude);
      }
    }
    if (options.filesystem) {
      filesystem.push(options.filesystem);
    }
    if (options.inline) {
      inline.push(options.inline);
    }
    if (options.plain) {
      plain.push(options.plain);
    }
  }
  const mergedContent = {
    pipeline: pipelineDisabled ? false : {
      include: uniq(mergeFilterPatterns(...pipelineIncludes)),
      exclude: uniq(mergeFilterPatterns(...pipelineExcludes))
    }
  };
  if (filesystem.length) {
    mergedContent.filesystem = uniq(filesystem.flat());
  }
  if (inline.length) {
    mergedContent.inline = uniq(inline.flat());
  }
  if (plain.length) {
    mergedContent.plain = uniq(plain.flat());
  }
  return mergedContent;
}
async function resolveConfig(userConfig = {}, defaults = {}) {
  var _a3, _b2, _c;
  const config = Object.assign({}, defaults, userConfig);
  const rawPresets = uniqueBy(
    (await Promise.all((config.presets || []).flatMap(toArray2).flatMap(resolvePresets))).flat(),
    (a, b) => a.name === b.name
  );
  const sortedPresets = [
    ...rawPresets.filter((p) => p.enforce === "pre"),
    ...rawPresets.filter((p) => !p.enforce),
    ...rawPresets.filter((p) => p.enforce === "post")
  ];
  const sources = [
    ...sortedPresets,
    config
  ];
  const sourcesReversed = [...sources].reverse();
  const layers = Object.assign({}, DEFAULT_LAYERS, ...sources.map((i) => i.layers));
  function getMerged(key) {
    return uniq(sources.flatMap((p) => toArray2(p[key] || [])));
  }
  const extractors = getMerged("extractors");
  let extractorDefault = (_a3 = sourcesReversed.find((i) => i.extractorDefault !== void 0)) == null ? void 0 : _a3.extractorDefault;
  if (extractorDefault === void 0)
    extractorDefault = extractorSplit;
  if (extractorDefault && !extractors.includes(extractorDefault))
    extractors.unshift(extractorDefault);
  extractors.sort((a, b) => (a.order || 0) - (b.order || 0));
  const rules4 = getMerged("rules");
  const rulesStaticMap = {};
  const rulesSize = rules4.length;
  const rulesDynamic = rules4.filter((rule) => {
    var _a4;
    if (!isStaticRule(rule))
      return true;
    const prefixes = toArray2(((_a4 = rule[2]) == null ? void 0 : _a4.prefix) || "");
    prefixes.forEach((prefix) => {
      rulesStaticMap[prefix + rule[0]] = rule;
    });
    return false;
  }).reverse();
  let theme4 = mergeThemes(sources.map((p) => p.theme));
  const extendThemes = getMerged("extendTheme");
  for (const extendTheme of extendThemes)
    theme4 = extendTheme(theme4) || theme4;
  const autocomplete = {
    templates: uniq(sources.flatMap((p) => {
      var _a4;
      return toArray2((_a4 = p.autocomplete) == null ? void 0 : _a4.templates);
    })),
    extractors: sources.flatMap((p) => {
      var _a4;
      return toArray2((_a4 = p.autocomplete) == null ? void 0 : _a4.extractors);
    }).sort((a, b) => (a.order || 0) - (b.order || 0)),
    shorthands: mergeAutocompleteShorthands(sources.map((p) => {
      var _a4;
      return ((_a4 = p.autocomplete) == null ? void 0 : _a4.shorthands) || {};
    }))
  };
  let separators = getMerged("separators");
  if (!separators.length)
    separators = [":", "-"];
  const contents3 = getMerged("content");
  const content = mergeContentOptions(contents3);
  const resolved = {
    mergeSelectors: true,
    warn: true,
    sortLayers: (layers2) => layers2,
    ...config,
    blocklist: getMerged("blocklist"),
    presets: sortedPresets,
    envMode: config.envMode || "build",
    shortcutsLayer: config.shortcutsLayer || "shortcuts",
    layers,
    theme: theme4,
    rules: rules4,
    rulesSize,
    rulesDynamic,
    rulesStaticMap,
    preprocess: getMerged("preprocess"),
    postprocess: getMerged("postprocess"),
    preflights: getMerged("preflights"),
    autocomplete,
    variants: getMerged("variants").map(normalizeVariant).sort((a, b) => (a.order || 0) - (b.order || 0)),
    shortcuts: resolveShortcuts(getMerged("shortcuts")).reverse(),
    extractors,
    safelist: getMerged("safelist"),
    separators,
    details: (_b2 = config.details) != null ? _b2 : config.envMode === "dev",
    content,
    transformers: uniqueBy(getMerged("transformers"), (a, b) => a.name === b.name)
  };
  for (const p of sources)
    (_c = p == null ? void 0 : p.configResolved) == null ? void 0 : _c.call(p, resolved);
  return resolved;
}
function mergeThemes(themes) {
  return themes.map((theme4) => theme4 ? clone(theme4) : {}).reduce((a, b) => mergeDeep(a, b), {});
}
function mergeAutocompleteShorthands(shorthands3) {
  return shorthands3.reduce((a, b) => {
    const rs = {};
    for (const key in b) {
      const value = b[key];
      if (Array.isArray(value))
        rs[key] = `(${value.join("|")})`;
      else
        rs[key] = value;
    }
    return {
      ...a,
      ...rs
    };
  }, {});
}
function mergeFilterPatterns(...filterPatterns) {
  return filterPatterns.flatMap(flatternFilterPattern);
}
function flatternFilterPattern(pattern) {
  return Array.isArray(pattern) ? pattern : pattern ? [pattern] : [];
}
function definePreset(preset) {
  return preset;
}

// ../../packages-engine/core/package.json
var version = "66.0.0";

// ../../packages-engine/core/src/generator.ts
var symbols = {
  shortcutsNoMerge: "$$symbol-shortcut-no-merge",
  variants: "$$symbol-variants",
  parent: "$$symbol-parent",
  selector: "$$symbol-selector",
  layer: "$$symbol-layer",
  sort: "$$symbol-sort"
};
var UnoGeneratorInternal = class _UnoGeneratorInternal {
  constructor(userConfig = {}, defaults = {}) {
    this.userConfig = userConfig;
    this.defaults = defaults;
    this.version = version;
    this.events = createNanoEvents();
    this.config = void 0;
    this.cache = /* @__PURE__ */ new Map();
    this.blocked = /* @__PURE__ */ new Set();
    this.parentOrders = /* @__PURE__ */ new Map();
    this.activatedRules = /* @__PURE__ */ new Set();
  }
  static async create(userConfig = {}, defaults = {}) {
    const uno = new _UnoGeneratorInternal(userConfig, defaults);
    uno.config = await resolveConfig(uno.userConfig, uno.defaults);
    uno.events.emit("config", uno.config);
    return uno;
  }
  async setConfig(userConfig, defaults) {
    if (!userConfig)
      return;
    if (defaults)
      this.defaults = defaults;
    this.userConfig = userConfig;
    this.blocked.clear();
    this.parentOrders.clear();
    this.activatedRules.clear();
    this.cache.clear();
    this.config = await resolveConfig(userConfig, this.defaults);
    this.events.emit("config", this.config);
  }
  async applyExtractors(code, id, extracted = /* @__PURE__ */ new Set()) {
    var _a3;
    const context = {
      original: code,
      code,
      id,
      extracted,
      envMode: this.config.envMode
    };
    for (const extractor of this.config.extractors) {
      const result = await ((_a3 = extractor.extract) == null ? void 0 : _a3.call(extractor, context));
      if (!result)
        continue;
      if (isCountableSet(result) && isCountableSet(extracted)) {
        for (const token of result)
          extracted.setCount(token, extracted.getCount(token) + result.getCount(token));
      } else {
        for (const token of result)
          extracted.add(token);
      }
    }
    return extracted;
  }
  makeContext(raw, applied) {
    const context = {
      rawSelector: raw,
      currentSelector: applied[1],
      theme: this.config.theme,
      generator: this,
      symbols,
      variantHandlers: applied[2],
      constructCSS: (...args) => this.constructCustomCSS(context, ...args),
      variantMatch: applied
    };
    return context;
  }
  async parseToken(raw, alias) {
    if (this.blocked.has(raw))
      return;
    const cacheKey = `${raw}${alias ? ` ${alias}` : ""}`;
    if (this.cache.has(cacheKey))
      return this.cache.get(cacheKey);
    let current = raw;
    for (const p of this.config.preprocess)
      current = p(raw);
    if (this.isBlocked(current)) {
      this.blocked.add(raw);
      this.cache.set(cacheKey, null);
      return;
    }
    const variantResults = await this.matchVariants(raw, current);
    if (variantResults.every((i) => !i || this.isBlocked(i[1]))) {
      this.blocked.add(raw);
      this.cache.set(cacheKey, null);
      return;
    }
    const handleVariantResult = async (matched) => {
      var _a3;
      const context = this.makeContext(raw, [alias || matched[0], matched[1], matched[2], matched[3]]);
      if (this.config.details)
        context.variants = [...matched[3]];
      const expanded = await this.expandShortcut(context.currentSelector, context);
      const utils = expanded ? await this.stringifyShortcuts(context.variantMatch, context, expanded[0], expanded[1]) : (_a3 = await this.parseUtil(context.variantMatch, context)) == null ? void 0 : _a3.map((i) => this.stringifyUtil(i, context)).filter(notNull);
      return utils;
    };
    const result = (await Promise.all(variantResults.map((i) => handleVariantResult(i)))).flat().filter((x2) => !!x2);
    if (result == null ? void 0 : result.length) {
      this.cache.set(cacheKey, result);
      return result;
    }
    this.cache.set(cacheKey, null);
  }
  async generate(input, options = {}) {
    const {
      id,
      scope,
      preflights: preflights2 = true,
      safelist = true,
      minify = false,
      extendedInfo = false
    } = options;
    const tokens = isString(input) ? await this.applyExtractors(
      input,
      id,
      extendedInfo ? new CountableSet() : /* @__PURE__ */ new Set()
    ) : Array.isArray(input) ? new Set(input) : input;
    if (safelist) {
      const safelistContext = {
        generator: this,
        theme: this.config.theme
      };
      this.config.safelist.flatMap((s) => typeof s === "function" ? s(safelistContext) : s).forEach((s) => {
        if (!tokens.has(s))
          tokens.add(s);
      });
    }
    const nl = minify ? "" : "\n";
    const layerSet = /* @__PURE__ */ new Set([LAYER_DEFAULT]);
    const matched = extendedInfo ? /* @__PURE__ */ new Map() : /* @__PURE__ */ new Set();
    const sheet = /* @__PURE__ */ new Map();
    let preflightsMap = {};
    const tokenPromises = Array.from(tokens).map(async (raw) => {
      var _a3;
      if (matched.has(raw))
        return;
      const payload = await this.parseToken(raw);
      if (payload == null)
        return;
      if (matched instanceof Map) {
        matched.set(raw, {
          data: payload,
          count: isCountableSet(tokens) ? tokens.getCount(raw) : -1
        });
      } else {
        matched.add(raw);
      }
      for (const item of payload) {
        const parent = item[3] || "";
        const layer = (_a3 = item[4]) == null ? void 0 : _a3.layer;
        if (!sheet.has(parent))
          sheet.set(parent, []);
        sheet.get(parent).push(item);
        if (layer)
          layerSet.add(layer);
      }
    });
    await Promise.all(tokenPromises);
    await (async () => {
      if (!preflights2)
        return;
      const preflightContext = {
        generator: this,
        theme: this.config.theme
      };
      const preflightLayerSet = /* @__PURE__ */ new Set([]);
      this.config.preflights.forEach(({ layer = LAYER_PREFLIGHTS }) => {
        layerSet.add(layer);
        preflightLayerSet.add(layer);
      });
      preflightsMap = Object.fromEntries(
        await Promise.all(Array.from(preflightLayerSet).map(
          async (layer) => {
            const preflights3 = await Promise.all(
              this.config.preflights.filter((i) => (i.layer || LAYER_PREFLIGHTS) === layer).map(async (i) => await i.getCSS(preflightContext))
            );
            const css = preflights3.filter(Boolean).join(nl);
            return [layer, css];
          }
        ))
      );
    })();
    const layers = this.config.sortLayers(Array.from(layerSet).sort((a, b) => {
      var _a3, _b2;
      return ((_a3 = this.config.layers[a]) != null ? _a3 : 0) - ((_b2 = this.config.layers[b]) != null ? _b2 : 0) || a.localeCompare(b);
    }));
    const layerCache = {};
    const outputCssLayers = this.config.outputToCssLayers;
    const getLayerAlias = (layer) => {
      var _a3;
      let alias = layer;
      if (typeof outputCssLayers === "object") {
        alias = (_a3 = outputCssLayers.cssLayerName) == null ? void 0 : _a3.call(outputCssLayers, layer);
      }
      return alias === null ? null : alias != null ? alias : layer;
    };
    const getLayer = (layer = LAYER_DEFAULT) => {
      if (layerCache[layer])
        return layerCache[layer];
      let css = Array.from(sheet).sort((a, b) => {
        var _a3, _b2, _c;
        return ((_a3 = this.parentOrders.get(a[0])) != null ? _a3 : 0) - ((_b2 = this.parentOrders.get(b[0])) != null ? _b2 : 0) || ((_c = a[0]) == null ? void 0 : _c.localeCompare(b[0] || "")) || 0;
      }).map(([parent, items]) => {
        const size = items.length;
        const sorted = items.filter((i) => {
          var _a3;
          return (((_a3 = i[4]) == null ? void 0 : _a3.layer) || LAYER_DEFAULT) === layer;
        }).sort((a, b) => {
          var _a3, _b2, _c, _d, _e, _f, _g, _h;
          return a[0] - b[0] || (((_a3 = a[4]) == null ? void 0 : _a3.sort) || 0) - (((_b2 = b[4]) == null ? void 0 : _b2.sort) || 0) || ((_f = (_c = a[5]) == null ? void 0 : _c.currentSelector) == null ? void 0 : _f.localeCompare((_e = (_d = b[5]) == null ? void 0 : _d.currentSelector) != null ? _e : "")) || ((_g = a[1]) == null ? void 0 : _g.localeCompare(b[1] || "")) || ((_h = a[2]) == null ? void 0 : _h.localeCompare(b[2] || "")) || 0;
        }).map(([, selector, body, , meta, , variantNoMerge]) => {
          var _a3;
          const scopedSelector = selector ? applyScope(selector, scope) : selector;
          return [
            [[scopedSelector != null ? scopedSelector : "", (_a3 = meta == null ? void 0 : meta.sort) != null ? _a3 : 0]],
            body,
            !!(variantNoMerge != null ? variantNoMerge : meta == null ? void 0 : meta.noMerge)
          ];
        });
        if (!sorted.length)
          return void 0;
        const rules4 = sorted.reverse().map(([selectorSortPair, body, noMerge], idx) => {
          if (!noMerge && this.config.mergeSelectors) {
            for (let i = idx + 1; i < size; i++) {
              const current = sorted[i];
              if (current && !current[2] && (selectorSortPair && current[0] || selectorSortPair == null && current[0] == null) && current[1] === body) {
                if (selectorSortPair && current[0])
                  current[0].push(...selectorSortPair);
                return null;
              }
            }
          }
          const selectors = selectorSortPair ? uniq(selectorSortPair.sort((a, b) => {
            var _a3;
            return a[1] - b[1] || ((_a3 = a[0]) == null ? void 0 : _a3.localeCompare(b[0] || "")) || 0;
          }).map((pair) => pair[0]).filter(Boolean)) : [];
          return selectors.length ? `${selectors.join(`,${nl}`)}{${body}}` : body;
        }).filter(Boolean).reverse().join(nl);
        if (!parent)
          return rules4;
        const parents = parent.split(" $$ ");
        return `${parents.join("{")}{${nl}${rules4}${nl}${"}".repeat(parents.length)}`;
      }).filter(Boolean).join(nl);
      if (preflights2) {
        css = [preflightsMap[layer], css].filter(Boolean).join(nl);
      }
      let alias;
      if (outputCssLayers && css) {
        alias = getLayerAlias(layer);
        if (alias !== null) {
          css = `@layer ${alias}{${nl}${css}${nl}}`;
        }
      }
      const layerMark = minify ? "" : `/* layer: ${layer}${alias && alias !== layer ? `, alias: ${alias}` : ""} */${nl}`;
      return layerCache[layer] = css ? layerMark + css : "";
    };
    const getLayers = (includes = layers, excludes) => {
      const layers2 = includes.filter((i) => !(excludes == null ? void 0 : excludes.includes(i)));
      return [
        outputCssLayers && layers2.length > 0 ? `@layer ${layers2.map(getLayerAlias).filter(notNull).join(", ")};` : void 0,
        ...layers2.map((i) => getLayer(i) || "")
      ].filter(Boolean).join(nl);
    };
    const setLayer = async (layer, callback) => {
      const content = await callback(getLayer(layer));
      layerCache[layer] = content;
      return content;
    };
    return {
      get css() {
        return getLayers();
      },
      layers,
      matched,
      getLayers,
      getLayer,
      setLayer
    };
  }
  async matchVariants(raw, current) {
    const context = {
      rawSelector: raw,
      theme: this.config.theme,
      generator: this
    };
    const match = async (result) => {
      var _a3;
      let applied = true;
      const [, , handlers, variants4] = result;
      while (applied) {
        applied = false;
        const processed = result[1];
        for (const v of this.config.variants) {
          if (!v.multiPass && variants4.has(v))
            continue;
          let handler3 = await v.match(processed, context);
          if (!handler3)
            continue;
          if (isString(handler3)) {
            if (handler3 === processed)
              continue;
            handler3 = { matcher: handler3 };
          }
          if (Array.isArray(handler3)) {
            if (!handler3.length)
              continue;
            if (handler3.length === 1) {
              handler3 = handler3[0];
            } else {
              if (v.multiPass)
                throw new Error("multiPass can not be used together with array return variants");
              const clones = handler3.map((h3) => {
                var _a4;
                const _processed = (_a4 = h3.matcher) != null ? _a4 : processed;
                const _handlers = [h3, ...handlers];
                const _variants = new Set(variants4);
                _variants.add(v);
                return [result[0], _processed, _handlers, _variants];
              });
              return (await Promise.all(clones.map((c) => match(c)))).flat();
            }
          }
          result[1] = (_a3 = handler3.matcher) != null ? _a3 : processed;
          handlers.unshift(handler3);
          variants4.add(v);
          applied = true;
          break;
        }
        if (!applied)
          break;
        if (handlers.length > 500)
          throw new Error(`Too many variants applied to "${raw}"`);
      }
      return [result];
    };
    return await match([
      raw,
      current || raw,
      [],
      /* @__PURE__ */ new Set()
    ]);
  }
  applyVariants(parsed, variantHandlers = parsed[4], raw = parsed[1]) {
    const handler3 = variantHandlers.slice().sort((a, b) => (a.order || 0) - (b.order || 0)).reduceRight(
      (previous, v) => (input) => {
        var _a3, _b2, _c;
        const entries = ((_a3 = v.body) == null ? void 0 : _a3.call(v, input.entries)) || input.entries;
        const parents = Array.isArray(v.parent) ? v.parent : [v.parent, void 0];
        return ((_b2 = v.handle) != null ? _b2 : defaultVariantHandler)({
          ...input,
          entries,
          selector: ((_c = v.selector) == null ? void 0 : _c.call(v, input.selector, entries)) || input.selector,
          parent: parents[0] || input.parent,
          parentOrder: parents[1] || input.parentOrder,
          layer: v.layer || input.layer,
          sort: v.sort || input.sort
        }, previous);
      },
      (input) => input
    );
    const variantContextResult = handler3({
      prefix: "",
      selector: toEscapedSelector(raw),
      pseudo: "",
      entries: parsed[2]
    });
    const { parent, parentOrder } = variantContextResult;
    if (parent != null && parentOrder != null)
      this.parentOrders.set(parent, parentOrder);
    const obj = {
      selector: [
        variantContextResult.prefix,
        variantContextResult.selector,
        variantContextResult.pseudo
      ].join(""),
      entries: variantContextResult.entries,
      parent,
      layer: variantContextResult.layer,
      sort: variantContextResult.sort,
      noMerge: variantContextResult.noMerge
    };
    for (const p of this.config.postprocess)
      p(obj);
    return obj;
  }
  constructCustomCSS(context, body, overrideSelector) {
    const normalizedBody = normalizeCSSEntries(body);
    if (isString(normalizedBody))
      return normalizedBody;
    const { selector, entries, parent } = this.applyVariants([0, overrideSelector || context.rawSelector, normalizedBody, void 0, context.variantHandlers]);
    const cssBody = `${selector}{${entriesToCss(entries)}}`;
    if (parent)
      return `${parent}{${cssBody}}`;
    return cssBody;
  }
  async parseUtil(input, context, internal = false, shortcutPrefix) {
    const variantResults = isString(input) ? await this.matchVariants(input) : [input];
    const parse2 = async ([raw, processed, variantHandlers]) => {
      var _a3, _b2;
      if (this.config.details)
        context.rules = (_a3 = context.rules) != null ? _a3 : [];
      const staticMatch = this.config.rulesStaticMap[processed];
      if (staticMatch) {
        if (staticMatch[1] && (internal || !((_b2 = staticMatch[2]) == null ? void 0 : _b2.internal))) {
          context.generator.activatedRules.add(staticMatch);
          if (this.config.details)
            context.rules.push(staticMatch);
          const index = this.config.rules.indexOf(staticMatch);
          const entry = normalizeCSSEntries(staticMatch[1]);
          const meta = staticMatch[2];
          if (isString(entry))
            return [[index, entry, meta]];
          else
            return [[index, raw, entry, meta, variantHandlers]];
        }
      }
      context.variantHandlers = variantHandlers;
      const { rulesDynamic } = this.config;
      for (const rule of rulesDynamic) {
        const [matcher, handler3, meta] = rule;
        if ((meta == null ? void 0 : meta.internal) && !internal)
          continue;
        let unprefixed = processed;
        if (meta == null ? void 0 : meta.prefix) {
          const prefixes = toArray2(meta.prefix);
          if (shortcutPrefix) {
            const shortcutPrefixes = toArray2(shortcutPrefix);
            if (!prefixes.some((i) => shortcutPrefixes.includes(i)))
              continue;
          } else {
            const prefix = prefixes.find((i) => processed.startsWith(i));
            if (prefix == null)
              continue;
            unprefixed = processed.slice(prefix.length);
          }
        }
        const match = unprefixed.match(matcher);
        if (!match)
          continue;
        let result = await handler3(match, context);
        if (!result)
          continue;
        context.generator.activatedRules.add(rule);
        if (this.config.details)
          context.rules.push(rule);
        if (typeof result !== "string") {
          if (Symbol.asyncIterator in result) {
            const entries2 = [];
            for await (const r of result) {
              if (r)
                entries2.push(r);
            }
            result = entries2;
          } else if (Symbol.iterator in result && !Array.isArray(result)) {
            result = Array.from(result).filter(notNull);
          }
        }
        const entries = normalizeCSSValues(result).filter((i) => i.length);
        if (entries.length) {
          const index = this.config.rules.indexOf(rule);
          return entries.map((css) => {
            if (isString(css))
              return [index, css, meta];
            let variants4 = variantHandlers;
            let entryMeta = meta;
            for (const entry of css) {
              if (entry[0] === symbols.variants) {
                variants4 = [
                  ...toArray2(entry[1]),
                  ...variants4
                ];
              } else if (entry[0] === symbols.parent) {
                variants4 = [
                  { parent: entry[1] },
                  ...variants4
                ];
              } else if (entry[0] === symbols.selector) {
                variants4 = [
                  { selector: entry[1] },
                  ...variants4
                ];
              } else if (entry[0] === symbols.layer) {
                variants4 = [
                  { layer: entry[1] },
                  ...variants4
                ];
              } else if (entry[0] === symbols.sort) {
                entryMeta = {
                  ...entryMeta,
                  sort: entry[1]
                };
              }
            }
            return [index, raw, css, entryMeta, variants4];
          });
        }
      }
    };
    const parsed = (await Promise.all(variantResults.map((i) => parse2(i)))).flat().filter((x2) => !!x2);
    if (!parsed.length)
      return void 0;
    return parsed;
  }
  stringifyUtil(parsed, context) {
    var _a3;
    if (!parsed)
      return;
    if (isRawUtil(parsed))
      return [parsed[0], void 0, parsed[1], void 0, parsed[2], this.config.details ? context : void 0, void 0];
    const {
      selector,
      entries,
      parent,
      layer: variantLayer,
      sort: variantSort,
      noMerge
    } = this.applyVariants(parsed);
    const body = entriesToCss(entries);
    if (!body)
      return;
    const { layer: metaLayer, sort: metaSort, ...meta } = (_a3 = parsed[3]) != null ? _a3 : {};
    const ruleMeta = {
      ...meta,
      layer: variantLayer != null ? variantLayer : metaLayer,
      sort: variantSort != null ? variantSort : metaSort
    };
    return [parsed[0], selector, body, parent, ruleMeta, this.config.details ? context : void 0, noMerge];
  }
  async expandShortcut(input, context, depth = 5) {
    var _a3;
    if (depth === 0)
      return;
    const recordShortcut = this.config.details ? (s) => {
      var _a4;
      context.shortcuts = (_a4 = context.shortcuts) != null ? _a4 : [];
      context.shortcuts.push(s);
    } : noop;
    let meta;
    let result;
    let stringResult;
    let inlineResult;
    for (const s of this.config.shortcuts) {
      let unprefixed = input;
      if ((_a3 = s[2]) == null ? void 0 : _a3.prefix) {
        const prefixes = toArray2(s[2].prefix);
        const prefix = prefixes.find((i) => input.startsWith(i));
        if (prefix == null)
          continue;
        unprefixed = input.slice(prefix.length);
      }
      if (isStaticShortcut(s)) {
        if (s[0] === unprefixed) {
          meta = meta || s[2];
          result = s[1];
          recordShortcut(s);
          break;
        }
      } else {
        const match = unprefixed.match(s[0]);
        if (match)
          result = s[1](match, context);
        if (result) {
          meta = meta || s[2];
          recordShortcut(s);
          break;
        }
      }
    }
    if (result) {
      stringResult = uniq(toArray2(result).filter(isString).map((s) => expandVariantGroup(s.trim()).split(/\s+/g)).flat());
      inlineResult = toArray2(result).filter((i) => !isString(i)).map((i) => ({ handles: [], value: i }));
    }
    if (!result) {
      const matched = isString(input) ? await this.matchVariants(input) : [input];
      for (const match of matched) {
        const [raw, inputWithoutVariant, handles] = match;
        if (raw !== inputWithoutVariant) {
          const expanded = await this.expandShortcut(inputWithoutVariant, context, depth - 1);
          if (expanded) {
            stringResult = expanded[0].filter(isString).map((item) => raw.replace(inputWithoutVariant, item));
            inlineResult = expanded[0].filter((i) => !isString(i)).map((item) => {
              return { handles: [...item.handles, ...handles], value: item.value };
            });
          }
        }
      }
    }
    if (!(stringResult == null ? void 0 : stringResult.length) && !(inlineResult == null ? void 0 : inlineResult.length))
      return;
    return [
      [
        await Promise.all(toArray2(stringResult).map(async (s) => {
          var _a4;
          return ((_a4 = await this.expandShortcut(s, context, depth - 1)) == null ? void 0 : _a4[0]) || [s];
        })),
        inlineResult
      ].flat(2).filter((x2) => !!x2),
      meta
    ];
  }
  async stringifyShortcuts(parent, context, expanded, meta = { layer: this.config.shortcutsLayer }) {
    var _a3;
    const layerMap = new BetterMap();
    const parsed = (await Promise.all(uniq(expanded).map(async (i) => {
      const result = isString(i) ? await this.parseUtil(i, context, true, meta.prefix) : [[Number.POSITIVE_INFINITY, "{inline}", normalizeCSSEntries(i.value), void 0, i.handles]];
      if (!result && this.config.warn)
        warnOnce(`unmatched utility "${i}" in shortcut "${parent[1]}"`);
      return result || [];
    }))).flat(1).filter(Boolean).sort((a, b) => a[0] - b[0]);
    const [raw, , parentVariants] = parent;
    const rawStringifiedUtil = [];
    for (const item of parsed) {
      if (isRawUtil(item)) {
        rawStringifiedUtil.push([item[0], void 0, item[1], void 0, item[2], context, void 0]);
        continue;
      }
      const { selector, entries, parent: parent2, sort, noMerge, layer } = this.applyVariants(item, [...item[4], ...parentVariants], raw);
      const selectorMap = layerMap.getFallback(layer != null ? layer : meta.layer, new TwoKeyMap());
      const mapItem = selectorMap.getFallback(selector, parent2, [[], item[0]]);
      mapItem[0].push([entries, !!(noMerge != null ? noMerge : (_a3 = item[3]) == null ? void 0 : _a3.noMerge), sort != null ? sort : 0]);
    }
    return rawStringifiedUtil.concat(layerMap.flatMap(
      (selectorMap, layer) => selectorMap.map(([e2, index], selector, joinedParents) => {
        const stringify = (flatten, noMerge, entrySortPair) => {
          const maxSort = Math.max(...entrySortPair.map((e3) => e3[1]));
          const entriesList = entrySortPair.map((e3) => e3[0]);
          return (flatten ? [entriesList.flat(1)] : entriesList).map((entries) => {
            const body = entriesToCss(entries);
            if (body)
              return [index, selector, body, joinedParents, { ...meta, noMerge, sort: maxSort, layer }, context, void 0];
            return void 0;
          });
        };
        const merges = [
          [e2.filter(([, noMerge]) => noMerge).map(([entries, , sort]) => [entries, sort]), true],
          [e2.filter(([, noMerge]) => !noMerge).map(([entries, , sort]) => [entries, sort]), false]
        ];
        return merges.map(([e3, noMerge]) => [
          ...stringify(false, noMerge, e3.filter(([entries]) => entries.some((entry) => entry[0] === symbols.shortcutsNoMerge))),
          ...stringify(true, noMerge, e3.filter(([entries]) => entries.every((entry) => entry[0] !== symbols.shortcutsNoMerge)))
        ]);
      }).flat(2).filter(Boolean)
    ));
  }
  isBlocked(raw) {
    return !raw || this.config.blocklist.map((e2) => Array.isArray(e2) ? e2[0] : e2).some((e2) => typeof e2 === "function" ? e2(raw) : isString(e2) ? e2 === raw : e2.test(raw));
  }
  getBlocked(raw) {
    const rule = this.config.blocklist.find((e2) => {
      const v = Array.isArray(e2) ? e2[0] : e2;
      return typeof v === "function" ? v(raw) : isString(v) ? v === raw : v.test(raw);
    });
    return rule ? Array.isArray(rule) ? rule : [rule, void 0] : void 0;
  }
};
async function createGenerator(config, defaults) {
  return await UnoGeneratorInternal.create(config, defaults);
}
var regexScopePlaceholder = /\s\$\$\s+/g;
function hasScopePlaceholder(css) {
  return regexScopePlaceholder.test(css);
}
function applyScope(css, scope) {
  if (hasScopePlaceholder(css))
    return css.replace(regexScopePlaceholder, scope ? ` ${scope} ` : " ");
  else
    return scope ? `${scope} ${css}` : css;
}
var attributifyRe = /^\[(.+?)(~?=)"(.*)"\]$/;
function toEscapedSelector(raw) {
  if (attributifyRe.test(raw))
    return raw.replace(attributifyRe, (_, n2, s, i) => `[${e(n2)}${s}"${e(i)}"]`);
  return `.${e(raw)}`;
}
function defaultVariantHandler(input, next) {
  return next(input);
}

// ../../virtual-shared/integration/src/constants.ts
var INCLUDE_COMMENT = "@unocss-include";
var IGNORE_COMMENT = "@unocss-ignore";
var INCLUDE_COMMENT_IDE = "@unocss-ide-include";
var CSS_PLACEHOLDER = "@unocss-placeholder";
var SKIP_START_COMMENT = "@unocss-skip-start";
var SKIP_END_COMMENT = "@unocss-skip-end";
var SKIP_COMMENT_RE = new RegExp(`(//\\s*?${SKIP_START_COMMENT}\\s*?|\\/\\*\\s*?${SKIP_START_COMMENT}\\s*?\\*\\/|<!--\\s*?${SKIP_START_COMMENT}\\s*?-->)[\\s\\S]*?(//\\s*?${SKIP_END_COMMENT}\\s*?|\\/\\*\\s*?${SKIP_END_COMMENT}\\s*?\\*\\/|<!--\\s*?${SKIP_END_COMMENT}\\s*?-->)`, "g");

// ../../virtual-shared/integration/src/defaults.ts
var defaultPipelineExclude = [cssIdRE];
var defaultPipelineInclude = [/\.(vue|svelte|[jt]sx|mdx?|astro|elm|php|phtml|html)($|\?)/];
var defaultIdeMatchInclude = [
  // String literals
  // eslint-disable-next-line no-control-regex
  /(['"`])[^\x01]*?\1/g,
  // HTML tags
  /<[^/?<>0-9$_!"'](?:"[^"]*"|'[^']*'|[^>])+>/g,
  // CSS directives
  /(@apply|--uno|--at-apply)[^;]*;/g
];
var defaultIdeMatchExclude = [
  SKIP_COMMENT_RE
];

// ../../node_modules/.pnpm/find-up@6.3.0/node_modules/find-up/index.js

var _url = require('url');

// ../../node_modules/.pnpm/locate-path@7.2.0/node_modules/locate-path/index.js


var _fs2 = require('fs'); var _fs3 = _interopRequireDefault(_fs2);


// ../../node_modules/.pnpm/yocto-queue@1.1.1/node_modules/yocto-queue/index.js
var Node = class {
  constructor(value) {
    _chunk42PBKAQTcjs.__publicField.call(void 0, this, "value");
    _chunk42PBKAQTcjs.__publicField.call(void 0, this, "next");
    this.value = value;
  }
};
var _head, _tail, _size;
var Queue = class {
  constructor() {
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _head);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _tail);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _size);
    this.clear();
  }
  enqueue(value) {
    const node = new Node(value);
    if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _head)) {
      _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _tail).next = node;
      _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _tail, node);
    } else {
      _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _head, node);
      _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _tail, node);
    }
    _chunk42PBKAQTcjs.__privateWrapper.call(void 0, this, _size)._++;
  }
  dequeue() {
    const current = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _head);
    if (!current) {
      return;
    }
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _head, _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _head).next);
    _chunk42PBKAQTcjs.__privateWrapper.call(void 0, this, _size)._--;
    return current.value;
  }
  peek() {
    if (!_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _head)) {
      return;
    }
    return _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _head).value;
  }
  clear() {
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _head, void 0);
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _tail, void 0);
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _size, 0);
  }
  get size() {
    return _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _size);
  }
  *[Symbol.iterator]() {
    let current = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _head);
    while (current) {
      yield current.value;
      current = current.next;
    }
  }
};
_head = new WeakMap();
_tail = new WeakMap();
_size = new WeakMap();

// ../../node_modules/.pnpm/p-limit@4.0.0/node_modules/p-limit/index.js
function pLimit(concurrency) {
  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
  }
  const queue = new Queue();
  let activeCount = 0;
  const next = () => {
    activeCount--;
    if (queue.size > 0) {
      queue.dequeue()();
    }
  };
  const run = async (fn, resolve4, args) => {
    activeCount++;
    const result = (async () => fn(...args))();
    resolve4(result);
    try {
      await result;
    } catch (e2) {
    }
    next();
  };
  const enqueue = (fn, resolve4, args) => {
    queue.enqueue(run.bind(void 0, fn, resolve4, args));
    (async () => {
      await Promise.resolve();
      if (activeCount < concurrency && queue.size > 0) {
        queue.dequeue()();
      }
    })();
  };
  const generator = (fn, ...args) => new Promise((resolve4) => {
    enqueue(fn, resolve4, args);
  });
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.size
    },
    clearQueue: {
      value: () => {
        queue.clear();
      }
    }
  });
  return generator;
}

// ../../node_modules/.pnpm/p-locate@6.0.0/node_modules/p-locate/index.js
var EndError = class extends Error {
  constructor(value) {
    super();
    this.value = value;
  }
};
var testElement = async (element, tester) => tester(await element);
var finder = async (element) => {
  const values = await Promise.all(element);
  if (values[1] === true) {
    throw new EndError(values[0]);
  }
  return false;
};
async function pLocate(iterable, tester, {
  concurrency = Number.POSITIVE_INFINITY,
  preserveOrder = true
} = {}) {
  const limit = pLimit(concurrency);
  const items = [...iterable].map((element) => [element, limit(testElement, element, tester)]);
  const checkLimit = pLimit(preserveOrder ? 1 : Number.POSITIVE_INFINITY);
  try {
    await Promise.all(items.map((element) => checkLimit(finder, element)));
  } catch (error) {
    if (error instanceof EndError) {
      return error.value;
    }
    throw error;
  }
}

// ../../node_modules/.pnpm/locate-path@7.2.0/node_modules/locate-path/index.js
var typeMappings = {
  directory: "isDirectory",
  file: "isFile"
};
function checkType(type) {
  if (Object.hasOwnProperty.call(typeMappings, type)) {
    return;
  }
  throw new Error(`Invalid type specified: ${type}`);
}
var matchType = (type, stat) => stat[typeMappings[type]]();
var toPath = (urlOrPath) => urlOrPath instanceof URL ? _url.fileURLToPath.call(void 0, urlOrPath) : urlOrPath;
async function locatePath(paths, {
  cwd = _process3.default.cwd(),
  type = "file",
  allowSymlinks = true,
  concurrency,
  preserveOrder
} = {}) {
  checkType(type);
  cwd = toPath(cwd);
  const statFunction = allowSymlinks ? _fs2.promises.stat : _fs2.promises.lstat;
  return pLocate(paths, async (path_) => {
    try {
      const stat = await statFunction(_path3.default.resolve(cwd, path_));
      return matchType(type, stat);
    } catch (e2) {
      return false;
    }
  }, { concurrency, preserveOrder });
}

// ../../node_modules/.pnpm/path-exists@5.0.0/node_modules/path-exists/index.js


// ../../node_modules/.pnpm/find-up@6.3.0/node_modules/find-up/index.js
var toPath2 = (urlOrPath) => urlOrPath instanceof URL ? _url.fileURLToPath.call(void 0, urlOrPath) : urlOrPath;
var findUpStop = Symbol("findUpStop");
async function findUpMultiple(name2, options = {}) {
  let directory = _path3.default.resolve(toPath2(options.cwd) || "");
  const { root } = _path3.default.parse(directory);
  const stopAt = _path3.default.resolve(directory, options.stopAt || root);
  const limit = options.limit || Number.POSITIVE_INFINITY;
  const paths = [name2].flat();
  const runMatcher = async (locateOptions) => {
    if (typeof name2 !== "function") {
      return locatePath(paths, locateOptions);
    }
    const foundPath = await name2(locateOptions.cwd);
    if (typeof foundPath === "string") {
      return locatePath([foundPath], locateOptions);
    }
    return foundPath;
  };
  const matches = [];
  while (true) {
    const foundPath = await runMatcher({ ...options, cwd: directory });
    if (foundPath === findUpStop) {
      break;
    }
    if (foundPath) {
      matches.push(_path3.default.resolve(directory, foundPath));
    }
    if (directory === stopAt || matches.length >= limit) {
      break;
    }
    directory = _path3.default.dirname(directory);
  }
  return matches;
}
async function findUp(name2, options = {}) {
  const matches = await findUpMultiple(name2, { ...options, limit: 1 });
  return matches[0];
}

// ../../node_modules/.pnpm/unplugin-utils@0.2.4/node_modules/unplugin-utils/dist/index.js
var import_picomatch = _chunk42PBKAQTcjs.__toESM.call(void 0, require_picomatch2(), 1);
function normalizePath(filename) {
  return filename.replaceAll("\\", "/");
}
var isArray = Array.isArray;
function toArray3(thing) {
  if (isArray(thing)) return thing;
  if (thing == null) return [];
  return [thing];
}
var escapeMark = "[_#EsCaPe#_]";
function getMatcherString(id, resolutionBase) {
  if (resolutionBase === false || _chunkTR37ZOITcjs.isAbsolute.call(void 0, id) || id.startsWith("**")) return normalizePath(id);
  const basePath = normalizePath(_chunkTR37ZOITcjs.resolve.call(void 0, resolutionBase || "")).replaceAll(/[-^$*+?.()|[\]{}]/g, `${escapeMark}$&`);
  return _chunkTR37ZOITcjs.join.call(void 0, basePath, normalizePath(id)).replaceAll(escapeMark, "\\");
}
function createFilter(include, exclude, options) {
  const resolutionBase = options && options.resolve;
  const getMatcher = (id) => id instanceof RegExp ? id : { test: (what) => {
    const pattern = getMatcherString(id, resolutionBase);
    const fn = (0, import_picomatch.default)(pattern, { dot: true });
    const result = fn(what);
    return result;
  } };
  const includeMatchers = toArray3(include).map(getMatcher);
  const excludeMatchers = toArray3(exclude).map(getMatcher);
  if (!includeMatchers.length && !excludeMatchers.length) return (id) => typeof id === "string" && !id.includes("\0");
  return function result(id) {
    if (typeof id !== "string") return false;
    if (id.includes("\0")) return false;
    const pathId = normalizePath(id);
    for (const matcher of excludeMatchers) {
      if (matcher instanceof RegExp) matcher.lastIndex = 0;
      if (matcher.test(pathId)) return false;
    }
    for (const matcher of includeMatchers) {
      if (matcher instanceof RegExp) matcher.lastIndex = 0;
      if (matcher.test(pathId)) return true;
    }
    return !includeMatchers.length;
  };
}

// src/index.ts
var _vscode = require('vscode');

// src/configs.ts


// src/constants.ts
var defaultLanguageIds = [
  "erb",
  "haml",
  "hbs",
  "html",
  "css",
  "postcss",
  "javascript",
  "javascriptreact",
  "markdown",
  "ejs",
  "php",
  "svelte",
  "typescript",
  "typescriptreact",
  "vue-html",
  "vue",
  "sass",
  "scss",
  "less",
  "stylus",
  "astro",
  "rust"
];
var delimiters = ["-", ":", " ", '"', "'"];

// src/generated/meta.ts
var publisher = "antfu";
var name = "@unocss/vscode";
var version2 = "66.0.0";
var displayName = "UnoCSS";
var extensionId = `${publisher}.${name}`;
var commands = {
  /**
   * Reload UnoCSS
   * @value `unocss.reload`
   */
  reload: "unocss.reload",
  /**
   * Insert `@unocss-skip` for the selection
   * @value `unocss.insert-skip-annotation`
   */
  insertSkipAnnotation: "unocss.insert-skip-annotation"
};
var configs = {
  /**
   * Disable the UnoCSS extension
   * @key `unocss.disable`
   * @default `false`
   * @type `boolean`
   */
  disable: {
    key: "unocss.disable",
    default: false
  },
  /**
   * 
   * @key `unocss.languageIds`
   * @default `undefined`
   * @type `array`
   */
  languageIds: {
    key: "unocss.languageIds",
    default: void 0
  },
  /**
   * Project root that contains the UnoCSS configuration file
   * @key `unocss.root`
   * @default `undefined`
   * @type `array,string`
   */
  root: {
    key: "unocss.root",
    default: void 0
  },
  /**
   * Directory of files to be detected
   * @key `unocss.include`
   * @default `undefined`
   * @type `array,string`
   */
  include: {
    key: "unocss.include",
    default: void 0
  },
  /**
   * Directory of files not to be detected
   * @key `unocss.exclude`
   * @default `undefined`
   * @type `array,string`
   */
  exclude: {
    key: "unocss.exclude",
    default: void 0
  },
  /**
   * Enable/disable underline decoration for class names
   * @key `unocss.underline`
   * @default `true`
   * @type `boolean`
   */
  underline: {
    key: "unocss.underline",
    default: true
  },
  /**
   * Enable/disable color preview decorations
   * @key `unocss.colorPreview`
   * @default `true`
   * @type `boolean`
   */
  colorPreview: {
    key: "unocss.colorPreview",
    default: true
  },
  /**
   * Radius for color preview
   * @key `unocss.colorPreviewRadius`
   * @default `"50%"`
   * @type `string`
   */
  colorPreviewRadius: {
    key: "unocss.colorPreviewRadius",
    default: "50%"
  },
  /**
   * Enable/disable rem to px preview in hover
   * @key `unocss.remToPxPreview`
   * @default `true`
   * @type `boolean`
   */
  remToPxPreview: {
    key: "unocss.remToPxPreview",
    default: true
  },
  /**
   * Ratio of rem to px
   * @key `unocss.remToPxRatio`
   * @default `16`
   * @type `number`
   */
  remToPxRatio: {
    key: "unocss.remToPxRatio",
    default: 16
  },
  /**
   * Enable/disable selection style decorations
   * @key `unocss.selectionStyle`
   * @default `true`
   * @type `boolean`
   */
  selectionStyle: {
    key: "unocss.selectionStyle",
    default: true
  },
  /**
   * Be strict about where to show annotations
   * @key `unocss.strictAnnotationMatch`
   * @default `false`
   * @type `boolean`
   */
  strictAnnotationMatch: {
    key: "unocss.strictAnnotationMatch",
    default: false
  },
  /**
   * The matching type for autocomplete
   * @key `unocss.autocomplete.matchType`
   * @default `"prefix"`
   * @type `string`
   */
  autocompleteMatchType: {
    key: "unocss.autocomplete.matchType",
    default: "prefix"
  },
  /**
   * Be strict about where to show autocomplete
   * @key `unocss.autocomplete.strict`
   * @default `false`
   * @type `boolean`
   */
  autocompleteStrict: {
    key: "unocss.autocomplete.strict",
    default: false
  },
  /**
   * The maximum number of items to show in autocomplete
   * @key `unocss.autocomplete.maxItems`
   * @default `1000`
   * @type `number`
   */
  autocompleteMaxItems: {
    key: "unocss.autocomplete.maxItems",
    default: 1e3
  }
};

// src/configs.ts
function getConfig() {
  function watchChanged(keys, callback) {
    const fullKeys = keys.map((key) => configs[key].key);
    return _vscode.workspace.onDidChangeConfiguration((e2) => {
      if (fullKeys.some((key) => e2.affectsConfiguration(key))) {
        callback();
      }
    });
  }
  const object = {
    watchChanged
  };
  const config = _vscode.workspace.getConfiguration();
  for (const [key, value] of Object.entries(configs)) {
    Object.defineProperty(object, key, {
      get() {
        return config.get(value.key, value.default);
      }
    });
  }
  return object;
}
async function validateLanguages(targets, allLanguages) {
  const invalidLanguages = [];
  const validLanguages = targets.filter((language) => {
    if (!allLanguages.includes(language)) {
      invalidLanguages.push(language);
      return false;
    }
    return true;
  });
  if (invalidLanguages.length)
    _vscode.window.showWarningMessage(`These language configurations are illegal: ${invalidLanguages.join(",")}`);
  return validLanguages;
}
async function getLanguageIds() {
  const allLanguages = await _vscode.languages.getLanguages();
  const languagesIds = getConfig().languageIds || [];
  return Array.from(
    new Set(
      [
        ...defaultLanguageIds,
        ...await validateLanguages(languagesIds, allLanguages)
      ].filter((i) => allLanguages.includes(i))
    )
  );
}

// src/contextLoader.ts
var _promises = require('fs/promises');


// ../../virtual-shared/integration/src/context.ts


// ../../packages-engine/config/src/index.ts




// ../../node_modules/.pnpm/unconfig@7.0.0/node_modules/unconfig/dist/index.mjs




// ../../node_modules/.pnpm/defu@6.1.4/node_modules/defu/dist/defu.mjs
function isPlainObject(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
}
function _defu(baseObject, defaults, namespace = ".", merger) {
  if (!isPlainObject(defaults)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isPlainObject(value) && isPlainObject(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? `${namespace}.` : "") + key.toString(),
        merger
      );
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p, c) => _defu(p, c, "", merger), {})
  );
}
var defu = createDefu();
var defuFn = createDefu((object, key, currentValue) => {
  if (object[key] !== void 0 && typeof currentValue === "function") {
    object[key] = currentValue(object[key]);
    return true;
  }
});
var defuArrayFn = createDefu((object, key, currentValue) => {
  if (Array.isArray(object[key]) && typeof currentValue === "function") {
    object[key] = currentValue(object[key]);
    return true;
  }
});

// ../../node_modules/.pnpm/unconfig@7.0.0/node_modules/unconfig/dist/index.mjs
var import_meta2 = {};
function existsSync(fp) {
  try {
    _fs3.default.accessSync(fp, _fs2.constants.R_OK);
    return true;
  } catch (e2) {
    return false;
  }
}
async function findUp2(paths, options = {}) {
  const {
    cwd = _process3.default.cwd(),
    stopAt = _path2.parse.call(void 0, cwd).root,
    multiple = false,
    allowSymlinks = true
  } = options;
  let current = cwd;
  const files = [];
  const stat = allowSymlinks ? _fs2.promises.stat : _fs2.promises.lstat;
  while (current && current !== stopAt) {
    for (const path7 of paths) {
      const filepath = _path2.resolve.call(void 0, current, path7);
      if (existsSync(filepath) && (await stat(filepath)).isFile()) {
        files.push(filepath);
        if (!multiple)
          return files;
      }
    }
    const parent = _path2.dirname.call(void 0, current);
    if (parent === current)
      break;
    current = parent;
  }
  return files;
}
function interopDefault(mod) {
  if (mod == null || typeof mod !== "object" || !("default" in mod) || mod.default == null)
    return mod;
  const defaultValue = mod.default;
  if (typeof defaultValue !== "object")
    return defaultValue;
  for (const key in mod) {
    try {
      if (!(key in defaultValue)) {
        Object.defineProperty(defaultValue, key, {
          enumerable: key !== "default",
          configurable: key !== "default",
          get() {
            return mod[key];
          }
        });
      }
    } catch (e2) {
    }
  }
  return defaultValue;
}
var defaultExtensions = ["mts", "cts", "ts", "mjs", "cjs", "js", "json", ""];
function createConfigLoader(options) {
  const sources = _chunkTR37ZOITcjs.toArray.call(void 0, options.sources || []);
  const {
    cwd = _process3.default.cwd(),
    merge,
    defaults
  } = options;
  const results = [];
  let matchedFiles;
  async function findConfigs() {
    if (matchedFiles == null)
      matchedFiles = [];
    matchedFiles.length = 0;
    for (const source of sources) {
      const { extensions = defaultExtensions } = source;
      const flatTargets = _chunkTR37ZOITcjs.toArray.call(void 0, (source == null ? void 0 : source.files) || []).flatMap(
        (file) => !extensions.length ? [file] : extensions.map((i) => i ? `${file}.${i}` : file)
      );
      const files = await findUp2(flatTargets, { cwd, stopAt: options.stopAt, multiple: merge });
      matchedFiles.push([source, files]);
    }
    return matchedFiles.flatMap((i) => i[1]);
  }
  async function load(force = false) {
    if (matchedFiles == null || force)
      await findConfigs();
    for (const [source, files] of matchedFiles) {
      if (!files.length)
        continue;
      if (!merge) {
        const result = await loadConfigFile(files[0], source);
        if (result) {
          return {
            config: applyDefaults(result.config, defaults),
            sources: result.sources,
            dependencies: result.dependencies
          };
        }
      } else {
        results.push(
          ...(await Promise.all(
            files.map((file) => loadConfigFile(file, source))
          )).filter(_chunkTR37ZOITcjs.notNullish)
        );
      }
    }
    if (!results.length) {
      return {
        config: defaults,
        sources: []
      };
    }
    return {
      config: applyDefaults(...results.map((i) => i.config), defaults),
      sources: results.map((i) => i.sources).flat(),
      dependencies: results.flatMap((i) => i.dependencies || [])
    };
  }
  return {
    load,
    findConfigs
  };
}
function applyDefaults(...args) {
  return defu(...args.map((i) => ({ config: i }))).config;
}
async function loadConfigFile(filepath, source) {
  let config;
  let parser = source.parser || "auto";
  let bundleFilepath = filepath;
  let code;
  async function read() {
    if (code == null)
      code = await _fs2.promises.readFile(filepath, "utf-8");
    return code;
  }
  if (source.transform) {
    const transformed = await source.transform(await read(), filepath);
    if (transformed) {
      bundleFilepath = _path2.join.call(void 0, _path2.dirname.call(void 0, filepath), `__unconfig_${_path2.basename.call(void 0, filepath)}`);
      await _fs2.promises.writeFile(bundleFilepath, transformed, "utf-8");
      code = transformed;
    }
  }
  if (parser === "auto") {
    try {
      config = JSON.parse(await read());
      parser = "json";
    } catch (e2) {
      parser = "import";
    }
  }
  let dependencies;
  try {
    if (!config) {
      if (typeof parser === "function") {
        config = await parser(filepath);
      } else if (parser === "import") {
        if (_process3.default.features.typescript || _process3.default.versions.bun || _process3.default.versions.deno) {
          const defaultImport = await Promise.resolve().then(() => _interopRequireWildcard(require(bundleFilepath)));
          config = interopDefault(defaultImport);
        } else {
          const { createJiti } = await Promise.resolve().then(() => _interopRequireWildcard(require("./jiti-4B2NCL53.cjs")));
          const jiti = createJiti(import_meta2.url, {
            fsCache: false,
            moduleCache: false,
            interopDefault: true
          });
          config = interopDefault(await jiti.import(bundleFilepath, { default: true }));
          dependencies = Object.values(jiti.cache).map((i) => i.filename).filter(Boolean);
        }
      } else if (parser === "json") {
        config = JSON.parse(await read());
      }
    }
    if (!config)
      return;
    const rewritten = source.rewrite ? await source.rewrite(config, filepath) : config;
    if (!rewritten)
      return void 0;
    return {
      config: rewritten,
      sources: [filepath],
      dependencies
    };
  } catch (e2) {
    if (source.skipOnError)
      return;
    throw e2;
  } finally {
    if (bundleFilepath !== filepath)
      await _fs2.promises.unlink(bundleFilepath).catch();
  }
}

// ../../packages-engine/config/src/index.ts
async function loadConfig(cwd = _process3.default.cwd(), configOrPath = cwd, extraConfigSources = [], defaults = {}) {
  let inlineConfig = {};
  if (typeof configOrPath !== "string") {
    inlineConfig = configOrPath;
    if (inlineConfig.configFile === false) {
      return {
        config: inlineConfig,
        sources: []
      };
    } else {
      configOrPath = inlineConfig.configFile || _process3.default.cwd();
    }
  }
  const resolved = _path2.resolve.call(void 0, configOrPath);
  let isFile = false;
  if (_fs3.default.existsSync(resolved) && _fs3.default.statSync(resolved).isFile()) {
    isFile = true;
    cwd = _path2.dirname.call(void 0, resolved);
  }
  const loader = createConfigLoader({
    sources: isFile ? [
      {
        files: resolved,
        extensions: []
      }
    ] : [
      {
        files: [
          "unocss.config",
          "uno.config"
        ]
      },
      ...extraConfigSources
    ],
    cwd,
    defaults: inlineConfig
  });
  const result = await loader.load();
  result.config = Object.assign(defaults, result.config || inlineConfig);
  if (result.config.configDeps) {
    result.sources = [
      ...result.sources,
      ...result.config.configDeps.map((i) => _path2.resolve.call(void 0, cwd, i))
    ];
  }
  return result;
}
function createRecoveryConfigLoader() {
  let lastResolved;
  return async (cwd = _process3.default.cwd(), configOrPath = cwd, extraConfigSources = [], defaults = {}) => {
    try {
      const config = await loadConfig(cwd, configOrPath, extraConfigSources, defaults);
      lastResolved = config;
      return config;
    } catch (e2) {
      if (lastResolved) {
        console.error(e2);
        return lastResolved;
      }
      throw e2;
    }
  };
}

// ../../virtual-shared/integration/src/deprecation.ts
function deprecationCheck(config) {
  var _a3;
  let warned4 = false;
  function warn(msg) {
    warned4 = true;
    console.warn(`[unocss] ${msg}`);
  }
  if (config.include)
    warn("`include` option is deprecated, use `content.pipeline.include` instead.");
  if (config.exclude)
    warn("`exclude` option is deprecated, use `content.pipeline.exclude` instead.");
  if (config.extraContent)
    warn("`extraContent` option is deprecated, use `content` instead.");
  if ((_a3 = config.content) == null ? void 0 : _a3.plain)
    warn("`content.plain` option is renamed to `content.inline`.");
  if (warned4 && typeof process !== "undefined" && process.env.CI)
    throw new Error("deprecation warning");
}

// ../../virtual-shared/integration/src/context.ts
function createContext(configOrPath, defaults = {}, extraConfigSources = [], resolveConfigResult = () => {
}) {
  let root = _process3.default.cwd();
  let rawConfig = {};
  let configFileList = [];
  let uno;
  const _uno = createGenerator(rawConfig, defaults).then((r) => {
    uno = r;
    return r;
  });
  let rollupFilter = createFilter(
    defaultPipelineInclude,
    defaultPipelineExclude,
    { resolve: typeof configOrPath === "string" ? configOrPath : root }
  );
  const invalidations = [];
  const reloadListeners = [];
  const modules = new BetterMap();
  const tokens = /* @__PURE__ */ new Set();
  const tasks = [];
  const affectedModules = /* @__PURE__ */ new Set();
  const loadConfig2 = createRecoveryConfigLoader();
  let ready = reloadConfig();
  async function reloadConfig() {
    var _a3, _b2, _c, _d, _e;
    await _uno;
    const result = await loadConfig2(root, configOrPath, extraConfigSources, defaults);
    resolveConfigResult(result);
    deprecationCheck(result.config);
    rawConfig = result.config;
    configFileList = result.sources;
    await uno.setConfig(rawConfig);
    uno.config.envMode = "dev";
    rollupFilter = ((_a3 = rawConfig.content) == null ? void 0 : _a3.pipeline) === false ? () => false : createFilter(
      ((_c = (_b2 = rawConfig.content) == null ? void 0 : _b2.pipeline) == null ? void 0 : _c.include) || rawConfig.include || defaultPipelineInclude,
      ((_e = (_d = rawConfig.content) == null ? void 0 : _d.pipeline) == null ? void 0 : _e.exclude) || rawConfig.exclude || defaultPipelineExclude,
      { resolve: typeof configOrPath === "string" ? configOrPath : root }
    );
    tokens.clear();
    await Promise.all(modules.map((code, id) => uno.applyExtractors(code.replace(SKIP_COMMENT_RE, ""), id, tokens)));
    invalidate();
    dispatchReload();
    return result;
  }
  async function updateRoot(newRoot) {
    if (newRoot !== root) {
      root = newRoot;
      ready = reloadConfig();
    }
    return await ready;
  }
  function invalidate() {
    invalidations.forEach((cb) => cb());
  }
  function dispatchReload() {
    reloadListeners.forEach((cb) => cb());
  }
  async function extract(code, id) {
    const uno2 = await _uno;
    if (id)
      modules.set(id, code);
    const len = tokens.size;
    await uno2.applyExtractors(code.replace(SKIP_COMMENT_RE, ""), id, tokens);
    if (tokens.size > len)
      invalidate();
  }
  function filter(code, id) {
    if (code.includes(IGNORE_COMMENT))
      return false;
    return code.includes(INCLUDE_COMMENT) || code.includes(CSS_PLACEHOLDER) || rollupFilter(id.replace(/\?v=\w+$/, ""));
  }
  async function getConfig2() {
    await ready;
    return rawConfig;
  }
  async function flushTasks() {
    const _tasks = [...tasks];
    await Promise.all(_tasks);
    if (tasks[0] === _tasks[0])
      tasks.splice(0, _tasks.length);
  }
  return {
    get ready() {
      return ready;
    },
    tokens,
    modules,
    affectedModules,
    tasks,
    flushTasks,
    invalidate,
    onInvalidate(fn) {
      invalidations.push(fn);
    },
    filter,
    reloadConfig,
    onReload(fn) {
      reloadListeners.push(fn);
    },
    get uno() {
      if (!uno)
        throw new Error("Run `await context.ready` before accessing `context.uno`");
      return uno;
    },
    extract,
    getConfig: getConfig2,
    get root() {
      return root;
    },
    updateRoot,
    getConfigFileList: () => configFileList
  };
}

// ../../virtual-shared/integration/src/utils.ts
function isCssId(id) {
  return cssIdRE.test(id);
}
function hash(str) {
  let i;
  let l;
  let hval = 2166136261;
  for (i = 0, l = str.length; i < l; i++) {
    hval ^= str.charCodeAt(i);
    hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
  }
  return `00000${(hval >>> 0).toString(36)}`.slice(-6);
}
function transformSkipCode(code, map, SKIP_RULES_RE, keyFlag) {
  for (const item of Array.from(code.matchAll(SKIP_RULES_RE))) {
    if (item != null) {
      const matched = item[0];
      const withHashKey = `${keyFlag}${hash(matched)}`;
      map.set(withHashKey, matched);
      code = code.replace(matched, withHashKey);
    }
  }
  return code;
}
function restoreSkipCode(code, map) {
  for (const [withHashKey, matched] of map.entries())
    code = code.replaceAll(withHashKey, matched);
  return code;
}

// ../../packages-presets/extractor-arbitrary-variants/src/source-map.ts
var sourceMapRE = /\/\/#\s*sourceMappingURL=.*\n?/g;
function removeSourceMap(code) {
  if (code.includes("sourceMappingURL="))
    return code.replace(sourceMapRE, "");
  return code;
}

// ../../packages-presets/extractor-arbitrary-variants/src/index.ts
var quotedArbitraryValuesRE = /(?:[\w&:[\]-]|\[\S{1,64}=\S{1,64}\]){1,64}\[\\?['"]?\S{1,64}?['"]\]\]?[\w:-]{0,64}/g;
var arbitraryPropertyRE = /\[(\\\W|[\w-]){1,64}:[^\s:]{0,64}?("\S{1,64}?"|'\S{1,64}?'|`\S{1,64}?`|[^\s:]{1,64}?)[^\s:]{0,64}?\)?\]/g;
var arbitraryPropertyCandidateRE = /^\[(?:\\\W|[\w-]){1,64}:['"]?\S{1,64}?['"]?\]$/;
function splitCodeWithArbitraryVariants(code) {
  var _a3;
  const result = [];
  for (const match of code.matchAll(arbitraryPropertyRE)) {
    if (match.index !== 0 && !/^[\s'"`]/.test((_a3 = code[match.index - 1]) != null ? _a3 : ""))
      continue;
    result.push(match[0]);
  }
  for (const match of code.matchAll(quotedArbitraryValuesRE))
    result.push(match[0]);
  const skipMap2 = /* @__PURE__ */ new Map();
  const skipFlag = "@unocss-skip-arbitrary-brackets";
  code = transformSkipCode(code, skipMap2, /-\[(?!&.+?;)[^\]]*\]/g, skipFlag);
  if (!code)
    return result;
  code.split(defaultSplitRE).forEach((match) => {
    if (match.includes(skipFlag))
      match = restoreSkipCode(match, skipMap2);
    if (isValidSelector(match) && !arbitraryPropertyCandidateRE.test(match))
      result.push(match);
  });
  return result;
}
function extractorArbitraryVariants() {
  return {
    name: "@unocss/extractor-arbitrary-variants",
    order: 0,
    extract({ code }) {
      return splitCodeWithArbitraryVariants(removeSourceMap(code));
    }
  };
}

// ../../packages-presets/preset-mini/src/preflights.ts
function preflights(options) {
  if (options.preflight) {
    return [
      {
        layer: "preflights",
        getCSS({ theme: theme4, generator }) {
          var _a3;
          if (theme4.preflightBase) {
            let entries = Object.entries(theme4.preflightBase);
            if (options.preflight === "on-demand") {
              const keys = new Set(Array.from(generator.activatedRules).map((r) => {
                var _a4, _b2;
                return (_b2 = (_a4 = r[2]) == null ? void 0 : _a4.custom) == null ? void 0 : _b2.preflightKeys;
              }).filter(Boolean).flat());
              entries = entries.filter(([k]) => keys.has(k));
            }
            if (entries.length > 0) {
              let css = entriesToCss(entries);
              if (options.variablePrefix !== "un-") {
                css = css.replace(/--un-/g, `--${options.variablePrefix}`);
              }
              const roots = toArray2((_a3 = theme4.preflightRoot) != null ? _a3 : ["*,::before,::after", "::backdrop"]);
              return roots.map((root) => `${root}{${css}}`).join("");
            }
          }
        }
      }
    ];
  }
}

// ../../packages-presets/rule-utils/src/utilities.ts
function getBracket(str, open, close) {
  if (str === "")
    return;
  const l = str.length;
  let parenthesis = 0;
  let opened = false;
  let openAt = 0;
  for (let i = 0; i < l; i++) {
    switch (str[i]) {
      case open:
        if (!opened) {
          opened = true;
          openAt = i;
        }
        parenthesis++;
        break;
      case close:
        --parenthesis;
        if (parenthesis < 0)
          return;
        if (parenthesis === 0) {
          return [
            str.slice(openAt, i + 1),
            str.slice(i + 1),
            str.slice(0, openAt)
          ];
        }
        break;
    }
  }
}
function getStringComponent(str, open, close, separators) {
  if (str === "")
    return;
  if (isString(separators))
    separators = [separators];
  if (separators.length === 0)
    return;
  const l = str.length;
  let parenthesis = 0;
  for (let i = 0; i < l; i++) {
    switch (str[i]) {
      case open:
        parenthesis++;
        break;
      case close:
        if (--parenthesis < 0)
          return;
        break;
      default:
        for (const separator of separators) {
          const separatorLength = separator.length;
          if (separatorLength && separator === str.slice(i, i + separatorLength) && parenthesis === 0) {
            if (i === 0 || i === l - separatorLength)
              return;
            return [
              str.slice(0, i),
              str.slice(i + separatorLength)
            ];
          }
        }
    }
  }
  return [
    str,
    ""
  ];
}
function getStringComponents(str, separators, limit) {
  limit = limit != null ? limit : 10;
  const components = [];
  let i = 0;
  while (str !== "") {
    if (++i > limit)
      return;
    const componentPair = getStringComponent(str, "(", ")", separators);
    if (!componentPair)
      return;
    const [component, rest] = componentPair;
    components.push(component);
    str = rest;
  }
  if (components.length > 0)
    return components;
}

// ../../packages-presets/rule-utils/src/colors.ts
var cssColorFunctions = ["hsl", "hsla", "hwb", "lab", "lch", "oklab", "oklch", "rgb", "rgba"];
var alphaPlaceholders = ["%alpha", "<alpha-value>"];
var alphaPlaceholdersRE = new RegExp(alphaPlaceholders.map((v) => escapeRegExp(v)).join("|"));
function parseCssColor(str = "") {
  const color = parseColor(str);
  if (color == null || color === false)
    return;
  const { type: casedType, components, alpha } = color;
  const type = casedType.toLowerCase();
  if (components.length === 0)
    return;
  if (cssColorFunctions.includes(type) && ![1, 3].includes(components.length))
    return;
  return {
    type,
    components: components.map((c) => typeof c === "string" ? c.trim() : c),
    alpha: typeof alpha === "string" ? alpha.trim() : alpha
  };
}
function colorOpacityToString(color) {
  var _a3;
  const alpha = (_a3 = color.alpha) != null ? _a3 : 1;
  return typeof alpha === "string" && alphaPlaceholders.includes(alpha) ? 1 : alpha;
}
function colorToString(color, alphaOverride) {
  if (typeof color === "string")
    return color.replace(alphaPlaceholdersRE, `${alphaOverride != null ? alphaOverride : 1}`);
  const { components } = color;
  let { alpha, type } = color;
  alpha = alphaOverride != null ? alphaOverride : alpha;
  type = type.toLowerCase();
  if (["hsla", "rgba"].includes(type))
    return `${type}(${components.join(", ")}${alpha == null ? "" : `, ${alpha}`})`;
  alpha = alpha == null ? "" : ` / ${alpha}`;
  if (cssColorFunctions.includes(type))
    return `${type}(${components.join(" ")}${alpha})`;
  return `color(${type} ${components.join(" ")}${alpha})`;
}
function parseColor(str) {
  if (!str)
    return;
  let color = parseHexColor(str);
  if (color != null)
    return color;
  color = cssColorKeyword(str);
  if (color != null)
    return color;
  color = parseCssCommaColorFunction(str);
  if (color != null)
    return color;
  color = parseCssSpaceColorFunction(str);
  if (color != null)
    return color;
  color = parseCssColorFunction(str);
  if (color != null)
    return color;
}
function parseHexColor(str) {
  const [, body] = str.match(/^#([\da-f]+)$/i) || [];
  if (!body)
    return;
  switch (body.length) {
    case 3:
    case 4:
      const digits = Array.from(body, (s) => Number.parseInt(s, 16)).map((n2) => n2 << 4 | n2);
      return {
        type: "rgb",
        components: digits.slice(0, 3),
        alpha: body.length === 3 ? void 0 : Math.round(digits[3] / 255 * 100) / 100
      };
    case 6:
    case 8:
      const value = Number.parseInt(body, 16);
      return {
        type: "rgb",
        components: body.length === 6 ? [value >> 16 & 255, value >> 8 & 255, value & 255] : [value >> 24 & 255, value >> 16 & 255, value >> 8 & 255],
        alpha: body.length === 6 ? void 0 : Math.round((value & 255) / 255 * 100) / 100
      };
  }
}
function cssColorKeyword(str) {
  const color = {
    rebeccapurple: [102, 51, 153, 1]
  }[str];
  if (color != null) {
    return {
      type: "rgb",
      components: color.slice(0, 3),
      alpha: color[3]
    };
  }
}
function parseCssCommaColorFunction(color) {
  const match = color.match(/^(rgb|rgba|hsl|hsla)\((.+)\)$/i);
  if (!match)
    return;
  const [, type, componentString] = match;
  const components = getStringComponents(componentString, ",", 5);
  if (components) {
    if ([3, 4].includes(components.length)) {
      return {
        type,
        components: components.slice(0, 3),
        alpha: components[3]
      };
    } else if (components.length !== 1) {
      return false;
    }
  }
}
var cssColorFunctionsRe = new RegExp(`^(${cssColorFunctions.join("|")})\\((.+)\\)$`, "i");
function parseCssSpaceColorFunction(color) {
  const match = color.match(cssColorFunctionsRe);
  if (!match)
    return;
  const [, fn, componentString] = match;
  const parsed = parseCssSpaceColorValues(`${fn} ${componentString}`);
  if (parsed) {
    const { alpha, components: [type, ...components] } = parsed;
    return {
      type,
      components,
      alpha
    };
  }
}
function parseCssColorFunction(color) {
  const match = color.match(/^color\((.+)\)$/);
  if (!match)
    return;
  const parsed = parseCssSpaceColorValues(match[1]);
  if (parsed) {
    const { alpha, components: [type, ...components] } = parsed;
    return {
      type,
      components,
      alpha
    };
  }
}
function parseCssSpaceColorValues(componentString) {
  const components = getStringComponents(componentString, " ");
  if (!components)
    return;
  let totalComponents = components.length;
  if (components[totalComponents - 2] === "/") {
    return {
      components: components.slice(0, totalComponents - 2),
      alpha: components[totalComponents - 1]
    };
  }
  if (components[totalComponents - 2] != null && (components[totalComponents - 2].endsWith("/") || components[totalComponents - 1].startsWith("/"))) {
    const removed = components.splice(totalComponents - 2);
    components.push(removed.join(" "));
    --totalComponents;
  }
  const withAlpha = getStringComponents(components[totalComponents - 1], "/", 2);
  if (!withAlpha)
    return;
  if (withAlpha.length === 1 || withAlpha[withAlpha.length - 1] === "")
    return { components };
  const alpha = withAlpha.pop();
  components[totalComponents - 1] = withAlpha.join("/");
  return {
    components,
    alpha
  };
}

// ../../packages-presets/rule-utils/src/handlers.ts
function createValueHandler(handlers) {
  const handler3 = function(str) {
    var _a3;
    const s = ((_a3 = this.__options) == null ? void 0 : _a3.sequence) || [];
    this.__options.sequence = [];
    for (const n2 of s) {
      const res = handlers[n2](str);
      if (res != null)
        return res;
    }
  };
  function addProcessor(that, name2) {
    if (!that.__options) {
      that.__options = {
        sequence: []
      };
    }
    that.__options.sequence.push(name2);
    return that;
  }
  for (const name2 of Object.keys(handlers)) {
    Object.defineProperty(handler3, name2, {
      enumerable: true,
      configurable: true,
      get() {
        return addProcessor(this, name2);
      }
    });
  }
  return handler3;
}

// ../../node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.0/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
var comma = ",".charCodeAt(0);
var semicolon = ";".charCodeAt(0);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for (let i = 0; i < chars.length; i++) {
  const c = chars.charCodeAt(i);
  intToChar[i] = c;
  charToInt[c] = i;
}
function encodeInteger(builder, num, relative) {
  let delta = num - relative;
  delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
  do {
    let clamped = delta & 31;
    delta >>>= 5;
    if (delta > 0)
      clamped |= 32;
    builder.write(intToChar[clamped]);
  } while (delta > 0);
  return num;
}
var bufLength = 1024 * 16;
var td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
  decode(buf) {
    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
    return out.toString();
  }
} : {
  decode(buf) {
    let out = "";
    for (let i = 0; i < buf.length; i++) {
      out += String.fromCharCode(buf[i]);
    }
    return out;
  }
};
var StringWriter = class {
  constructor() {
    this.pos = 0;
    this.out = "";
    this.buffer = new Uint8Array(bufLength);
  }
  write(v) {
    const { buffer } = this;
    buffer[this.pos++] = v;
    if (this.pos === bufLength) {
      this.out += td.decode(buffer);
      this.pos = 0;
    }
  }
  flush() {
    const { buffer, out, pos } = this;
    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
  }
};
function encode(decoded) {
  const writer = new StringWriter();
  let sourcesIndex = 0;
  let sourceLine = 0;
  let sourceColumn = 0;
  let namesIndex = 0;
  for (let i = 0; i < decoded.length; i++) {
    const line = decoded[i];
    if (i > 0)
      writer.write(semicolon);
    if (line.length === 0)
      continue;
    let genColumn = 0;
    for (let j = 0; j < line.length; j++) {
      const segment = line[j];
      if (j > 0)
        writer.write(comma);
      genColumn = encodeInteger(writer, segment[0], genColumn);
      if (segment.length === 1)
        continue;
      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
      sourceLine = encodeInteger(writer, segment[2], sourceLine);
      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
      if (segment.length === 4)
        continue;
      namesIndex = encodeInteger(writer, segment[4], namesIndex);
    }
  }
  return writer.flush();
}

// ../../node_modules/.pnpm/magic-string@0.30.17/node_modules/magic-string/dist/magic-string.es.mjs
var BitSet = class _BitSet {
  constructor(arg) {
    this.bits = arg instanceof _BitSet ? arg.bits.slice() : [];
  }
  add(n2) {
    this.bits[n2 >> 5] |= 1 << (n2 & 31);
  }
  has(n2) {
    return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));
  }
};
var Chunk = class _Chunk {
  constructor(start, end, content) {
    this.start = start;
    this.end = end;
    this.original = content;
    this.intro = "";
    this.outro = "";
    this.content = content;
    this.storeName = false;
    this.edited = false;
    {
      this.previous = null;
      this.next = null;
    }
  }
  appendLeft(content) {
    this.outro += content;
  }
  appendRight(content) {
    this.intro = this.intro + content;
  }
  clone() {
    const chunk = new _Chunk(this.start, this.end, this.original);
    chunk.intro = this.intro;
    chunk.outro = this.outro;
    chunk.content = this.content;
    chunk.storeName = this.storeName;
    chunk.edited = this.edited;
    return chunk;
  }
  contains(index) {
    return this.start < index && index < this.end;
  }
  eachNext(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.next;
    }
  }
  eachPrevious(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.previous;
    }
  }
  edit(content, storeName, contentOnly) {
    this.content = content;
    if (!contentOnly) {
      this.intro = "";
      this.outro = "";
    }
    this.storeName = storeName;
    this.edited = true;
    return this;
  }
  prependLeft(content) {
    this.outro = content + this.outro;
  }
  prependRight(content) {
    this.intro = content + this.intro;
  }
  reset() {
    this.intro = "";
    this.outro = "";
    if (this.edited) {
      this.content = this.original;
      this.storeName = false;
      this.edited = false;
    }
  }
  split(index) {
    const sliceIndex = index - this.start;
    const originalBefore = this.original.slice(0, sliceIndex);
    const originalAfter = this.original.slice(sliceIndex);
    this.original = originalBefore;
    const newChunk = new _Chunk(index, this.end, originalAfter);
    newChunk.outro = this.outro;
    this.outro = "";
    this.end = index;
    if (this.edited) {
      newChunk.edit("", false);
      this.content = "";
    } else {
      this.content = originalBefore;
    }
    newChunk.next = this.next;
    if (newChunk.next) newChunk.next.previous = newChunk;
    newChunk.previous = this;
    this.next = newChunk;
    return newChunk;
  }
  toString() {
    return this.intro + this.content + this.outro;
  }
  trimEnd(rx) {
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length) return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        this.split(this.start + trimmed.length).edit("", void 0, true);
        if (this.edited) {
          this.edit(trimmed, this.storeName, true);
        }
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length) return true;
    }
  }
  trimStart(rx) {
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length) return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        const newChunk = this.split(this.end - trimmed.length);
        if (this.edited) {
          newChunk.edit(trimmed, this.storeName, true);
        }
        this.edit("", void 0, true);
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length) return true;
    }
  }
};
function getBtoa() {
  if (typeof globalThis !== "undefined" && typeof globalThis.btoa === "function") {
    return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));
  } else if (typeof Buffer === "function") {
    return (str) => Buffer.from(str, "utf-8").toString("base64");
  } else {
    return () => {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
  }
}
var btoa = /* @__PURE__ */ getBtoa();
var SourceMap = class {
  constructor(properties3) {
    this.version = 3;
    this.file = properties3.file;
    this.sources = properties3.sources;
    this.sourcesContent = properties3.sourcesContent;
    this.names = properties3.names;
    this.mappings = encode(properties3.mappings);
    if (typeof properties3.x_google_ignoreList !== "undefined") {
      this.x_google_ignoreList = properties3.x_google_ignoreList;
    }
    if (typeof properties3.debugId !== "undefined") {
      this.debugId = properties3.debugId;
    }
  }
  toString() {
    return JSON.stringify(this);
  }
  toUrl() {
    return "data:application/json;charset=utf-8;base64," + btoa(this.toString());
  }
};
function guessIndent(code) {
  const lines = code.split("\n");
  const tabbed = lines.filter((line) => /^\t+/.test(line));
  const spaced = lines.filter((line) => /^ {2,}/.test(line));
  if (tabbed.length === 0 && spaced.length === 0) {
    return null;
  }
  if (tabbed.length >= spaced.length) {
    return "	";
  }
  const min = spaced.reduce((previous, current) => {
    const numSpaces = /^ +/.exec(current)[0].length;
    return Math.min(numSpaces, previous);
  }, Infinity);
  return new Array(min + 1).join(" ");
}
function getRelativePath(from, to) {
  const fromParts = from.split(/[/\\]/);
  const toParts = to.split(/[/\\]/);
  fromParts.pop();
  while (fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  if (fromParts.length) {
    let i = fromParts.length;
    while (i--) fromParts[i] = "..";
  }
  return fromParts.concat(toParts).join("/");
}
var toString = Object.prototype.toString;
function isObject2(thing) {
  return toString.call(thing) === "[object Object]";
}
function getLocator(source) {
  const originalLines = source.split("\n");
  const lineOffsets = [];
  for (let i = 0, pos = 0; i < originalLines.length; i++) {
    lineOffsets.push(pos);
    pos += originalLines[i].length + 1;
  }
  return function locate(index) {
    let i = 0;
    let j = lineOffsets.length;
    while (i < j) {
      const m = i + j >> 1;
      if (index < lineOffsets[m]) {
        j = m;
      } else {
        i = m + 1;
      }
    }
    const line = i - 1;
    const column = index - lineOffsets[line];
    return { line, column };
  };
}
var wordRegex = /\w/;
var Mappings = class {
  constructor(hires) {
    this.hires = hires;
    this.generatedCodeLine = 0;
    this.generatedCodeColumn = 0;
    this.raw = [];
    this.rawSegments = this.raw[this.generatedCodeLine] = [];
    this.pending = null;
  }
  addEdit(sourceIndex, content, loc, nameIndex) {
    if (content.length) {
      const contentLengthMinusOne = content.length - 1;
      let contentLineEnd = content.indexOf("\n", 0);
      let previousContentLineEnd = -1;
      while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
        const segment2 = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (nameIndex >= 0) {
          segment2.push(nameIndex);
        }
        this.rawSegments.push(segment2);
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        previousContentLineEnd = contentLineEnd;
        contentLineEnd = content.indexOf("\n", contentLineEnd + 1);
      }
      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
      if (nameIndex >= 0) {
        segment.push(nameIndex);
      }
      this.rawSegments.push(segment);
      this.advance(content.slice(previousContentLineEnd + 1));
    } else if (this.pending) {
      this.rawSegments.push(this.pending);
      this.advance(content);
    }
    this.pending = null;
  }
  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
    let originalCharIndex = chunk.start;
    let first = true;
    let charInHiresBoundary = false;
    while (originalCharIndex < chunk.end) {
      if (original[originalCharIndex] === "\n") {
        loc.line += 1;
        loc.column = 0;
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        first = true;
        charInHiresBoundary = false;
      } else {
        if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
          const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
          if (this.hires === "boundary") {
            if (wordRegex.test(original[originalCharIndex])) {
              if (!charInHiresBoundary) {
                this.rawSegments.push(segment);
                charInHiresBoundary = true;
              }
            } else {
              this.rawSegments.push(segment);
              charInHiresBoundary = false;
            }
          } else {
            this.rawSegments.push(segment);
          }
        }
        loc.column += 1;
        this.generatedCodeColumn += 1;
        first = false;
      }
      originalCharIndex += 1;
    }
    this.pending = null;
  }
  advance(str) {
    if (!str) return;
    const lines = str.split("\n");
    if (lines.length > 1) {
      for (let i = 0; i < lines.length - 1; i++) {
        this.generatedCodeLine++;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
      }
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += lines[lines.length - 1].length;
  }
};
var n = "\n";
var warned2 = {
  insertLeft: false,
  insertRight: false,
  storeName: false
};
var MagicString = class _MagicString {
  constructor(string, options = {}) {
    const chunk = new Chunk(0, string.length, string);
    Object.defineProperties(this, {
      original: { writable: true, value: string },
      outro: { writable: true, value: "" },
      intro: { writable: true, value: "" },
      firstChunk: { writable: true, value: chunk },
      lastChunk: { writable: true, value: chunk },
      lastSearchedChunk: { writable: true, value: chunk },
      byStart: { writable: true, value: {} },
      byEnd: { writable: true, value: {} },
      filename: { writable: true, value: options.filename },
      indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
      sourcemapLocations: { writable: true, value: new BitSet() },
      storedNames: { writable: true, value: {} },
      indentStr: { writable: true, value: void 0 },
      ignoreList: { writable: true, value: options.ignoreList },
      offset: { writable: true, value: options.offset || 0 }
    });
    this.byStart[0] = chunk;
    this.byEnd[string.length] = chunk;
  }
  addSourcemapLocation(char) {
    this.sourcemapLocations.add(char);
  }
  append(content) {
    if (typeof content !== "string") throw new TypeError("outro content must be a string");
    this.outro += content;
    return this;
  }
  appendLeft(index, content) {
    index = index + this.offset;
    if (typeof content !== "string") throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.appendLeft(content);
    } else {
      this.intro += content;
    }
    return this;
  }
  appendRight(index, content) {
    index = index + this.offset;
    if (typeof content !== "string") throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.appendRight(content);
    } else {
      this.outro += content;
    }
    return this;
  }
  clone() {
    const cloned = new _MagicString(this.original, { filename: this.filename, offset: this.offset });
    let originalChunk = this.firstChunk;
    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
    while (originalChunk) {
      cloned.byStart[clonedChunk.start] = clonedChunk;
      cloned.byEnd[clonedChunk.end] = clonedChunk;
      const nextOriginalChunk = originalChunk.next;
      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
      if (nextClonedChunk) {
        clonedChunk.next = nextClonedChunk;
        nextClonedChunk.previous = clonedChunk;
        clonedChunk = nextClonedChunk;
      }
      originalChunk = nextOriginalChunk;
    }
    cloned.lastChunk = clonedChunk;
    if (this.indentExclusionRanges) {
      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
    }
    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
    cloned.intro = this.intro;
    cloned.outro = this.outro;
    return cloned;
  }
  generateDecodedMap(options) {
    options = options || {};
    const sourceIndex = 0;
    const names = Object.keys(this.storedNames);
    const mappings = new Mappings(options.hires);
    const locate = getLocator(this.original);
    if (this.intro) {
      mappings.advance(this.intro);
    }
    this.firstChunk.eachNext((chunk) => {
      const loc = locate(chunk.start);
      if (chunk.intro.length) mappings.advance(chunk.intro);
      if (chunk.edited) {
        mappings.addEdit(
          sourceIndex,
          chunk.content,
          loc,
          chunk.storeName ? names.indexOf(chunk.original) : -1
        );
      } else {
        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
      }
      if (chunk.outro.length) mappings.advance(chunk.outro);
    });
    return {
      file: options.file ? options.file.split(/[/\\]/).pop() : void 0,
      sources: [
        options.source ? getRelativePath(options.file || "", options.source) : options.file || ""
      ],
      sourcesContent: options.includeContent ? [this.original] : void 0,
      names,
      mappings: mappings.raw,
      x_google_ignoreList: this.ignoreList ? [sourceIndex] : void 0
    };
  }
  generateMap(options) {
    return new SourceMap(this.generateDecodedMap(options));
  }
  _ensureindentStr() {
    if (this.indentStr === void 0) {
      this.indentStr = guessIndent(this.original);
    }
  }
  _getRawIndentString() {
    this._ensureindentStr();
    return this.indentStr;
  }
  getIndentString() {
    this._ensureindentStr();
    return this.indentStr === null ? "	" : this.indentStr;
  }
  indent(indentStr, options) {
    const pattern = /^[^\r\n]/gm;
    if (isObject2(indentStr)) {
      options = indentStr;
      indentStr = void 0;
    }
    if (indentStr === void 0) {
      this._ensureindentStr();
      indentStr = this.indentStr || "	";
    }
    if (indentStr === "") return this;
    options = options || {};
    const isExcluded = {};
    if (options.exclude) {
      const exclusions = typeof options.exclude[0] === "number" ? [options.exclude] : options.exclude;
      exclusions.forEach((exclusion) => {
        for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
          isExcluded[i] = true;
        }
      });
    }
    let shouldIndentNextCharacter = options.indentStart !== false;
    const replacer = (match) => {
      if (shouldIndentNextCharacter) return `${indentStr}${match}`;
      shouldIndentNextCharacter = true;
      return match;
    };
    this.intro = this.intro.replace(pattern, replacer);
    let charIndex = 0;
    let chunk = this.firstChunk;
    while (chunk) {
      const end = chunk.end;
      if (chunk.edited) {
        if (!isExcluded[charIndex]) {
          chunk.content = chunk.content.replace(pattern, replacer);
          if (chunk.content.length) {
            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
          }
        }
      } else {
        charIndex = chunk.start;
        while (charIndex < end) {
          if (!isExcluded[charIndex]) {
            const char = this.original[charIndex];
            if (char === "\n") {
              shouldIndentNextCharacter = true;
            } else if (char !== "\r" && shouldIndentNextCharacter) {
              shouldIndentNextCharacter = false;
              if (charIndex === chunk.start) {
                chunk.prependRight(indentStr);
              } else {
                this._splitChunk(chunk, charIndex);
                chunk = chunk.next;
                chunk.prependRight(indentStr);
              }
            }
          }
          charIndex += 1;
        }
      }
      charIndex = chunk.end;
      chunk = chunk.next;
    }
    this.outro = this.outro.replace(pattern, replacer);
    return this;
  }
  insert() {
    throw new Error(
      "magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)"
    );
  }
  insertLeft(index, content) {
    if (!warned2.insertLeft) {
      console.warn(
        "magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"
      );
      warned2.insertLeft = true;
    }
    return this.appendLeft(index, content);
  }
  insertRight(index, content) {
    if (!warned2.insertRight) {
      console.warn(
        "magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"
      );
      warned2.insertRight = true;
    }
    return this.prependRight(index, content);
  }
  move(start, end, index) {
    start = start + this.offset;
    end = end + this.offset;
    index = index + this.offset;
    if (index >= start && index <= end) throw new Error("Cannot move a selection inside itself");
    this._split(start);
    this._split(end);
    this._split(index);
    const first = this.byStart[start];
    const last = this.byEnd[end];
    const oldLeft = first.previous;
    const oldRight = last.next;
    const newRight = this.byStart[index];
    if (!newRight && last === this.lastChunk) return this;
    const newLeft = newRight ? newRight.previous : this.lastChunk;
    if (oldLeft) oldLeft.next = oldRight;
    if (oldRight) oldRight.previous = oldLeft;
    if (newLeft) newLeft.next = first;
    if (newRight) newRight.previous = last;
    if (!first.previous) this.firstChunk = last.next;
    if (!last.next) {
      this.lastChunk = first.previous;
      this.lastChunk.next = null;
    }
    first.previous = newLeft;
    last.next = newRight || null;
    if (!newLeft) this.firstChunk = first;
    if (!newRight) this.lastChunk = last;
    return this;
  }
  overwrite(start, end, content, options) {
    options = options || {};
    return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });
  }
  update(start, end, content, options) {
    start = start + this.offset;
    end = end + this.offset;
    if (typeof content !== "string") throw new TypeError("replacement content must be a string");
    if (this.original.length !== 0) {
      while (start < 0) start += this.original.length;
      while (end < 0) end += this.original.length;
    }
    if (end > this.original.length) throw new Error("end is out of bounds");
    if (start === end)
      throw new Error(
        "Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead"
      );
    this._split(start);
    this._split(end);
    if (options === true) {
      if (!warned2.storeName) {
        console.warn(
          "The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"
        );
        warned2.storeName = true;
      }
      options = { storeName: true };
    }
    const storeName = options !== void 0 ? options.storeName : false;
    const overwrite = options !== void 0 ? options.overwrite : false;
    if (storeName) {
      const original = this.original.slice(start, end);
      Object.defineProperty(this.storedNames, original, {
        writable: true,
        value: true,
        enumerable: true
      });
    }
    const first = this.byStart[start];
    const last = this.byEnd[end];
    if (first) {
      let chunk = first;
      while (chunk !== last) {
        if (chunk.next !== this.byStart[chunk.end]) {
          throw new Error("Cannot overwrite across a split point");
        }
        chunk = chunk.next;
        chunk.edit("", false);
      }
      first.edit(content, storeName, !overwrite);
    } else {
      const newChunk = new Chunk(start, end, "").edit(content, storeName);
      last.next = newChunk;
      newChunk.previous = last;
    }
    return this;
  }
  prepend(content) {
    if (typeof content !== "string") throw new TypeError("outro content must be a string");
    this.intro = content + this.intro;
    return this;
  }
  prependLeft(index, content) {
    index = index + this.offset;
    if (typeof content !== "string") throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.prependLeft(content);
    } else {
      this.intro = content + this.intro;
    }
    return this;
  }
  prependRight(index, content) {
    index = index + this.offset;
    if (typeof content !== "string") throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.prependRight(content);
    } else {
      this.outro = content + this.outro;
    }
    return this;
  }
  remove(start, end) {
    start = start + this.offset;
    end = end + this.offset;
    if (this.original.length !== 0) {
      while (start < 0) start += this.original.length;
      while (end < 0) end += this.original.length;
    }
    if (start === end) return this;
    if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
    if (start > end) throw new Error("end must be greater than start");
    this._split(start);
    this._split(end);
    let chunk = this.byStart[start];
    while (chunk) {
      chunk.intro = "";
      chunk.outro = "";
      chunk.edit("");
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  reset(start, end) {
    start = start + this.offset;
    end = end + this.offset;
    if (this.original.length !== 0) {
      while (start < 0) start += this.original.length;
      while (end < 0) end += this.original.length;
    }
    if (start === end) return this;
    if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
    if (start > end) throw new Error("end must be greater than start");
    this._split(start);
    this._split(end);
    let chunk = this.byStart[start];
    while (chunk) {
      chunk.reset();
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  lastChar() {
    if (this.outro.length) return this.outro[this.outro.length - 1];
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
      if (chunk.content.length) return chunk.content[chunk.content.length - 1];
      if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
    } while (chunk = chunk.previous);
    if (this.intro.length) return this.intro[this.intro.length - 1];
    return "";
  }
  lastLine() {
    let lineIndex = this.outro.lastIndexOf(n);
    if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
    let lineStr = this.outro;
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length > 0) {
        lineIndex = chunk.outro.lastIndexOf(n);
        if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.outro + lineStr;
      }
      if (chunk.content.length > 0) {
        lineIndex = chunk.content.lastIndexOf(n);
        if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.content + lineStr;
      }
      if (chunk.intro.length > 0) {
        lineIndex = chunk.intro.lastIndexOf(n);
        if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.intro + lineStr;
      }
    } while (chunk = chunk.previous);
    lineIndex = this.intro.lastIndexOf(n);
    if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
    return this.intro + lineStr;
  }
  slice(start = 0, end = this.original.length - this.offset) {
    start = start + this.offset;
    end = end + this.offset;
    if (this.original.length !== 0) {
      while (start < 0) start += this.original.length;
      while (end < 0) end += this.original.length;
    }
    let result = "";
    let chunk = this.firstChunk;
    while (chunk && (chunk.start > start || chunk.end <= start)) {
      if (chunk.start < end && chunk.end >= end) {
        return result;
      }
      chunk = chunk.next;
    }
    if (chunk && chunk.edited && chunk.start !== start)
      throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
    const startChunk = chunk;
    while (chunk) {
      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
        result += chunk.intro;
      }
      const containsEnd = chunk.start < end && chunk.end >= end;
      if (containsEnd && chunk.edited && chunk.end !== end)
        throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
      const sliceStart = startChunk === chunk ? start - chunk.start : 0;
      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
      result += chunk.content.slice(sliceStart, sliceEnd);
      if (chunk.outro && (!containsEnd || chunk.end === end)) {
        result += chunk.outro;
      }
      if (containsEnd) {
        break;
      }
      chunk = chunk.next;
    }
    return result;
  }
  // TODO deprecate this? not really very useful
  snip(start, end) {
    const clone2 = this.clone();
    clone2.remove(0, start);
    clone2.remove(end, clone2.original.length);
    return clone2;
  }
  _split(index) {
    if (this.byStart[index] || this.byEnd[index]) return;
    let chunk = this.lastSearchedChunk;
    const searchForward = index > chunk.end;
    while (chunk) {
      if (chunk.contains(index)) return this._splitChunk(chunk, index);
      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
    }
  }
  _splitChunk(chunk, index) {
    if (chunk.edited && chunk.content.length) {
      const loc = getLocator(this.original)(index);
      throw new Error(
        `Cannot split a chunk that has already been edited (${loc.line}:${loc.column} \u2013 "${chunk.original}")`
      );
    }
    const newChunk = chunk.split(index);
    this.byEnd[index] = chunk;
    this.byStart[index] = newChunk;
    this.byEnd[newChunk.end] = newChunk;
    if (chunk === this.lastChunk) this.lastChunk = newChunk;
    this.lastSearchedChunk = chunk;
    return true;
  }
  toString() {
    let str = this.intro;
    let chunk = this.firstChunk;
    while (chunk) {
      str += chunk.toString();
      chunk = chunk.next;
    }
    return str + this.outro;
  }
  isEmpty() {
    let chunk = this.firstChunk;
    do {
      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim())
        return false;
    } while (chunk = chunk.next);
    return true;
  }
  length() {
    let chunk = this.firstChunk;
    let length = 0;
    do {
      length += chunk.intro.length + chunk.content.length + chunk.outro.length;
    } while (chunk = chunk.next);
    return length;
  }
  trimLines() {
    return this.trim("[\\r\\n]");
  }
  trim(charType) {
    return this.trimStart(charType).trimEnd(charType);
  }
  trimEndAborted(charType) {
    const rx = new RegExp((charType || "\\s") + "+$");
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length) return true;
    let chunk = this.lastChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimEnd(rx);
      if (chunk.end !== end) {
        if (this.lastChunk === chunk) {
          this.lastChunk = chunk.next;
        }
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted) return true;
      chunk = chunk.previous;
    } while (chunk);
    return false;
  }
  trimEnd(charType) {
    this.trimEndAborted(charType);
    return this;
  }
  trimStartAborted(charType) {
    const rx = new RegExp("^" + (charType || "\\s") + "+");
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length) return true;
    let chunk = this.firstChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimStart(rx);
      if (chunk.end !== end) {
        if (chunk === this.lastChunk) this.lastChunk = chunk.next;
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted) return true;
      chunk = chunk.next;
    } while (chunk);
    return false;
  }
  trimStart(charType) {
    this.trimStartAborted(charType);
    return this;
  }
  hasChanged() {
    return this.original !== this.toString();
  }
  _replaceRegexp(searchValue, replacement) {
    function getReplacement(match, str) {
      if (typeof replacement === "string") {
        return replacement.replace(/\$(\$|&|\d+)/g, (_, i) => {
          if (i === "$") return "$";
          if (i === "&") return match[0];
          const num = +i;
          if (num < match.length) return match[+i];
          return `$${i}`;
        });
      } else {
        return replacement(...match, match.index, str, match.groups);
      }
    }
    function matchAll(re, str) {
      let match;
      const matches = [];
      while (match = re.exec(str)) {
        matches.push(match);
      }
      return matches;
    }
    if (searchValue.global) {
      const matches = matchAll(searchValue, this.original);
      matches.forEach((match) => {
        if (match.index != null) {
          const replacement2 = getReplacement(match, this.original);
          if (replacement2 !== match[0]) {
            this.overwrite(match.index, match.index + match[0].length, replacement2);
          }
        }
      });
    } else {
      const match = this.original.match(searchValue);
      if (match && match.index != null) {
        const replacement2 = getReplacement(match, this.original);
        if (replacement2 !== match[0]) {
          this.overwrite(match.index, match.index + match[0].length, replacement2);
        }
      }
    }
    return this;
  }
  _replaceString(string, replacement) {
    const { original } = this;
    const index = original.indexOf(string);
    if (index !== -1) {
      this.overwrite(index, index + string.length, replacement);
    }
    return this;
  }
  replace(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceString(searchValue, replacement);
    }
    return this._replaceRegexp(searchValue, replacement);
  }
  _replaceAllString(string, replacement) {
    const { original } = this;
    const stringLength = string.length;
    for (let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)) {
      const previous = original.slice(index, index + stringLength);
      if (previous !== replacement) this.overwrite(index, index + stringLength, replacement);
    }
    return this;
  }
  replaceAll(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceAllString(searchValue, replacement);
    }
    if (!searchValue.global) {
      throw new TypeError(
        "MagicString.prototype.replaceAll called with a non-global RegExp argument"
      );
    }
    return this._replaceRegexp(searchValue, replacement);
  }
};

// ../../packages-presets/rule-utils/src/themeFn.ts
var themeFnRE = /theme\(\s*(['"])?(.*?)\1?\s*\)/g;
function hasThemeFn(str) {
  return str.includes("theme(") && str.includes(")");
}
function transformThemeFn(code, theme4, throwOnMissing = true) {
  const matches = Array.from(code.toString().matchAll(themeFnRE));
  if (!matches.length)
    return code;
  const s = new MagicString(code);
  for (const match of matches) {
    const rawArg = match[2];
    if (!rawArg)
      throw new Error("theme() expect exact one argument, but got 0");
    const value = transformThemeString(rawArg, theme4, throwOnMissing);
    if (value) {
      s.overwrite(
        match.index,
        match.index + match[0].length,
        value
      );
    }
  }
  return s.toString();
}
function transformThemeString(code, theme4, throwOnMissing = true) {
  const [rawKey, alpha] = code.split("/");
  const keys = rawKey.trim().split(".");
  let value = keys.reduce((t, k) => t == null ? void 0 : t[k], theme4);
  if (typeof value === "object") {
    value = value.DEFAULT;
  }
  if (typeof value === "string") {
    if (alpha) {
      const color = parseCssColor(value);
      if (color)
        value = colorToString(color, alpha);
    }
    return value;
  } else if (throwOnMissing) {
    throw new Error(`theme of "${code}" did not found`);
  }
}

// ../../packages-presets/rule-utils/src/variants.ts
function variantMatcher(name2, handler3) {
  let re;
  return {
    name: name2,
    match(input, ctx) {
      if (!re)
        re = new RegExp(`^${escapeRegExp(name2)}(?:${ctx.generator.config.separators.join("|")})`);
      const match = input.match(re);
      if (match) {
        const matcher = input.slice(match[0].length);
        const handlers = toArray2(handler3).map((handler4) => ({
          matcher,
          handle: (input2, next) => next({
            ...input2,
            ...handler4(input2)
          })
        }));
        return handlers.length === 1 ? handlers[0] : handlers;
      }
    },
    autocomplete: `${name2}:`
  };
}
function variantParentMatcher(name2, parent) {
  let re;
  return {
    name: name2,
    match(input, ctx) {
      if (!re)
        re = new RegExp(`^${escapeRegExp(name2)}(?:${ctx.generator.config.separators.join("|")})`);
      const match = input.match(re);
      if (match) {
        return {
          matcher: input.slice(match[0].length),
          handle: (input2, next) => next({
            ...input2,
            parent: `${input2.parent ? `${input2.parent} $$ ` : ""}${parent}`
          })
        };
      }
    },
    autocomplete: `${name2}:`
  };
}
function variantGetBracket(prefix, matcher, separators) {
  var _a3;
  if (matcher.startsWith(`${prefix}[`)) {
    const [match, rest] = (_a3 = getBracket(matcher.slice(prefix.length), "[", "]")) != null ? _a3 : [];
    if (match && rest) {
      for (const separator of separators) {
        if (rest.startsWith(separator))
          return [match, rest.slice(separator.length), separator];
      }
      return [match, rest, ""];
    }
  }
}
function variantGetParameter(prefix, matcher, separators) {
  var _a3;
  if (matcher.startsWith(prefix)) {
    const body = variantGetBracket(prefix, matcher, separators);
    if (body) {
      const [label = "", rest = body[1]] = (_a3 = variantGetParameter("/", body[1], separators)) != null ? _a3 : [];
      return [body[0], rest, label];
    }
    for (const separator of separators.filter((x2) => x2 !== "/")) {
      const pos = matcher.indexOf(separator, prefix.length);
      if (pos !== -1) {
        const labelPos = matcher.indexOf("/", prefix.length);
        const unlabelled = labelPos === -1 || pos <= labelPos;
        return [
          matcher.slice(prefix.length, unlabelled ? pos : labelPos),
          matcher.slice(pos + separator.length),
          unlabelled ? "" : matcher.slice(labelPos + 1, pos)
        ];
      }
    }
  }
}

// ../../packages-presets/preset-mini/src/_utils/handlers/handlers.ts
var handlers_exports = {};
_chunk42PBKAQTcjs.__export.call(void 0, handlers_exports, {
  auto: () => auto,
  bracket: () => bracket,
  bracketOfColor: () => bracketOfColor,
  bracketOfLength: () => bracketOfLength,
  bracketOfPosition: () => bracketOfPosition,
  cssvar: () => cssvar,
  degree: () => degree,
  fraction: () => fraction,
  global: () => global2,
  number: () => number,
  numberWithUnit: () => numberWithUnit,
  percent: () => percent,
  position: () => position,
  properties: () => properties,
  px: () => px,
  rem: () => rem,
  time: () => time
});

// ../../packages-presets/preset-mini/src/_utils/mappings.ts
var directionMap = {
  "l": ["-left"],
  "r": ["-right"],
  "t": ["-top"],
  "b": ["-bottom"],
  "s": ["-inline-start"],
  "e": ["-inline-end"],
  "x": ["-left", "-right"],
  "y": ["-top", "-bottom"],
  "": [""],
  "bs": ["-block-start"],
  "be": ["-block-end"],
  "is": ["-inline-start"],
  "ie": ["-inline-end"],
  "block": ["-block-start", "-block-end"],
  "inline": ["-inline-start", "-inline-end"]
};
var insetMap = {
  ...directionMap,
  s: ["-inset-inline-start"],
  start: ["-inset-inline-start"],
  e: ["-inset-inline-end"],
  end: ["-inset-inline-end"],
  bs: ["-inset-block-start"],
  be: ["-inset-block-end"],
  is: ["-inset-inline-start"],
  ie: ["-inset-inline-end"],
  block: ["-inset-block-start", "-inset-block-end"],
  inline: ["-inset-inline-start", "-inset-inline-end"]
};
var cornerMap = {
  "l": ["-top-left", "-bottom-left"],
  "r": ["-top-right", "-bottom-right"],
  "t": ["-top-left", "-top-right"],
  "b": ["-bottom-left", "-bottom-right"],
  "tl": ["-top-left"],
  "lt": ["-top-left"],
  "tr": ["-top-right"],
  "rt": ["-top-right"],
  "bl": ["-bottom-left"],
  "lb": ["-bottom-left"],
  "br": ["-bottom-right"],
  "rb": ["-bottom-right"],
  "": [""],
  "bs": ["-start-start", "-start-end"],
  "be": ["-end-start", "-end-end"],
  "s": ["-end-start", "-start-start"],
  "is": ["-end-start", "-start-start"],
  "e": ["-start-end", "-end-end"],
  "ie": ["-start-end", "-end-end"],
  "ss": ["-start-start"],
  "bs-is": ["-start-start"],
  "is-bs": ["-start-start"],
  "se": ["-start-end"],
  "bs-ie": ["-start-end"],
  "ie-bs": ["-start-end"],
  "es": ["-end-start"],
  "be-is": ["-end-start"],
  "is-be": ["-end-start"],
  "ee": ["-end-end"],
  "be-ie": ["-end-end"],
  "ie-be": ["-end-end"]
};
var xyzMap = {
  "x": ["-x"],
  "y": ["-y"],
  "z": ["-z"],
  "": ["-x", "-y"]
};
var xyzArray = ["x", "y", "z"];
var basePositionMap = [
  "top",
  "top center",
  "top left",
  "top right",
  "bottom",
  "bottom center",
  "bottom left",
  "bottom right",
  "left",
  "left center",
  "left top",
  "left bottom",
  "right",
  "right center",
  "right top",
  "right bottom",
  "center",
  "center top",
  "center bottom",
  "center left",
  "center right",
  "center center"
];
var positionMap = Object.assign(
  {},
  ...basePositionMap.map((p) => ({ [p.replace(/ /, "-")]: p })),
  ...basePositionMap.map((p) => ({ [p.replace(/\b(\w)\w+/g, "$1").replace(/ /, "")]: p }))
);
var globalKeywords = [
  "inherit",
  "initial",
  "revert",
  "revert-layer",
  "unset"
];
var cssMathFnRE = /^(calc|clamp|min|max)\s*\((.+)\)(.*)/;
var cssVarFnRE = /^(var)\s*\((.+)\)(.*)/;

// ../../packages-presets/preset-mini/src/_utils/handlers/regex.ts
var numberWithUnitRE = /^(-?\d*(?:\.\d+)?)(px|pt|pc|%|r?(?:em|ex|lh|cap|ch|ic)|(?:[sld]?v|cq)(?:[whib]|min|max)|in|cm|mm|rpx)?$/i;
var numberRE = /^(-?\d*(?:\.\d+)?)$/;
var unitOnlyRE = /^(px|[sld]?v[wh])$/i;
var unitOnlyMap = {
  px: 1,
  vw: 100,
  vh: 100,
  svw: 100,
  svh: 100,
  dvw: 100,
  dvh: 100,
  lvh: 100,
  lvw: 100
};
var bracketTypeRe = /^\[(color|image|length|size|position|quoted|string):/i;
var splitComma = /,(?![^()]*\))/g;

// ../../packages-presets/preset-mini/src/_utils/handlers/handlers.ts
var cssProps = [
  // basic props
  "color",
  "border-color",
  "background-color",
  "outline-color",
  "text-decoration-color",
  "flex-grow",
  "flex",
  "flex-shrink",
  "caret-color",
  "font",
  "gap",
  "opacity",
  "visibility",
  "z-index",
  "font-weight",
  "zoom",
  "text-shadow",
  "transform",
  "box-shadow",
  "border",
  // positions
  "background-position",
  "left",
  "right",
  "top",
  "bottom",
  "object-position",
  // sizes
  "max-height",
  "min-height",
  "max-width",
  "min-width",
  "height",
  "width",
  "border-width",
  "margin",
  "padding",
  "outline-width",
  "outline-offset",
  "font-size",
  "line-height",
  "text-indent",
  "vertical-align",
  "border-spacing",
  "letter-spacing",
  "word-spacing",
  // enhances
  "stroke",
  "filter",
  "backdrop-filter",
  "fill",
  "mask",
  "mask-size",
  "mask-border",
  "clip-path",
  "clip",
  "border-radius"
];
function round(n2) {
  return +n2.toFixed(10);
}
function numberWithUnit(str) {
  const match = str.match(numberWithUnitRE);
  if (!match)
    return;
  const [, n2, unit] = match;
  const num = Number.parseFloat(n2);
  if (unit && !Number.isNaN(num))
    return `${round(num)}${unit}`;
}
function auto(str) {
  if (str === "auto" || str === "a")
    return "auto";
}
function rem(str) {
  if (!str)
    return;
  if (unitOnlyRE.test(str))
    return `${unitOnlyMap[str]}${str}`;
  const match = str.match(numberWithUnitRE);
  if (!match)
    return;
  const [, n2, unit] = match;
  const num = Number.parseFloat(n2);
  if (!Number.isNaN(num)) {
    if (num === 0)
      return "0";
    return unit ? `${round(num)}${unit}` : `${round(num / 4)}rem`;
  }
}
function px(str) {
  if (unitOnlyRE.test(str))
    return `${unitOnlyMap[str]}${str}`;
  const match = str.match(numberWithUnitRE);
  if (!match)
    return;
  const [, n2, unit] = match;
  const num = Number.parseFloat(n2);
  if (!Number.isNaN(num))
    return unit ? `${round(num)}${unit}` : `${round(num)}px`;
}
function number(str) {
  if (!numberRE.test(str))
    return;
  const num = Number.parseFloat(str);
  if (!Number.isNaN(num))
    return round(num);
}
function percent(str) {
  if (str.endsWith("%"))
    str = str.slice(0, -1);
  if (!numberRE.test(str))
    return;
  const num = Number.parseFloat(str);
  if (!Number.isNaN(num))
    return `${round(num / 100)}`;
}
function fraction(str) {
  if (!str)
    return;
  if (str === "full")
    return "100%";
  const [left, right] = str.split("/");
  const num = Number.parseFloat(left) / Number.parseFloat(right);
  if (!Number.isNaN(num)) {
    if (num === 0)
      return "0";
    return `${round(num * 100)}%`;
  }
}
function bracketWithType(str, requiredType) {
  if (str && str.startsWith("[") && str.endsWith("]")) {
    let base;
    let hintedType;
    const match = str.match(bracketTypeRe);
    if (!match) {
      base = str.slice(1, -1);
    } else {
      if (!requiredType)
        hintedType = match[1];
      base = str.slice(match[0].length, -1);
    }
    if (!base)
      return;
    if (base === '=""')
      return;
    if (base.startsWith("--"))
      base = `var(${base})`;
    let curly = 0;
    for (const i of base) {
      if (i === "[") {
        curly += 1;
      } else if (i === "]") {
        curly -= 1;
        if (curly < 0)
          return;
      }
    }
    if (curly)
      return;
    switch (hintedType) {
      case "string":
        return base.replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_");
      case "quoted":
        return base.replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_").replace(/(["\\])/g, "\\$1").replace(/^(.+)$/, '"$1"');
    }
    return base.replace(/(url\(.*?\))/g, (v) => v.replace(/_/g, "\\_")).replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_").replace(/(?:calc|clamp|max|min)\((.*)/g, (match2) => {
      const vars = [];
      return match2.replace(/var\((--.+?)[,)]/g, (match3, g1) => {
        vars.push(g1);
        return match3.replace(g1, "--un-calc");
      }).replace(/(-?\d*\.?\d(?!-\d.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ").replace(/--un-calc/g, () => vars.shift());
    });
  }
}
function bracket(str) {
  return bracketWithType(str);
}
function bracketOfColor(str) {
  return bracketWithType(str, "color");
}
function bracketOfLength(str) {
  return bracketWithType(str, "length");
}
function bracketOfPosition(str) {
  return bracketWithType(str, "position");
}
function cssvar(str) {
  if (/^\$[^\s'"`;{}]/.test(str)) {
    const [name2, defaultValue] = str.slice(1).split(",");
    return `var(--${escapeSelector(name2)}${defaultValue ? `, ${defaultValue}` : ""})`;
  }
}
function time(str) {
  const match = str.match(/^(-?[0-9.]+)(s|ms)?$/i);
  if (!match)
    return;
  const [, n2, unit] = match;
  const num = Number.parseFloat(n2);
  if (!Number.isNaN(num)) {
    if (num === 0 && !unit)
      return "0s";
    return unit ? `${round(num)}${unit}` : `${round(num)}ms`;
  }
}
function degree(str) {
  const match = str.match(/^(-?[0-9.]+)(deg|rad|grad|turn)?$/i);
  if (!match)
    return;
  const [, n2, unit] = match;
  const num = Number.parseFloat(n2);
  if (!Number.isNaN(num)) {
    if (num === 0)
      return "0";
    return unit ? `${round(num)}${unit}` : `${round(num)}deg`;
  }
}
function global2(str) {
  if (globalKeywords.includes(str))
    return str;
}
function properties(str) {
  if (str.split(",").every((prop) => cssProps.includes(prop)))
    return str;
}
function position(str) {
  if (["top", "left", "right", "bottom", "center"].includes(str))
    return str;
}

// ../../packages-presets/preset-mini/src/_utils/handlers/index.ts
var handler = createValueHandler(handlers_exports);
var h = handler;

// ../../packages-presets/preset-mini/src/_rules/align.ts
var verticalAlignAlias = {
  "mid": "middle",
  "base": "baseline",
  "btm": "bottom",
  "baseline": "baseline",
  "top": "top",
  "start": "top",
  "middle": "middle",
  "bottom": "bottom",
  "end": "bottom",
  "text-top": "text-top",
  "text-bottom": "text-bottom",
  "sub": "sub",
  "super": "super",
  ...Object.fromEntries(globalKeywords.map((x2) => [x2, x2]))
};
var verticalAligns = [
  [
    /^(?:vertical|align|v)-([-\w]+%?)$/,
    ([, v]) => {
      var _a3;
      return { "vertical-align": (_a3 = verticalAlignAlias[v]) != null ? _a3 : h.numberWithUnit(v) };
    },
    {
      autocomplete: [
        `(vertical|align|v)-(${Object.keys(verticalAlignAlias).join("|")})`,
        "(vertical|align|v)-<percentage>"
      ]
    }
  ]
];
var textAlignValues = ["center", "left", "right", "justify", "start", "end"];
var textAligns = [
  ...textAlignValues.map((v) => [`text-${v}`, { "text-align": v }]),
  ...[
    ...globalKeywords,
    ...textAlignValues
  ].map((v) => [`text-align-${v}`, { "text-align": v }])
];

// ../../packages-presets/preset-mini/src/_utils/utilities.ts
var CONTROL_MINI_NO_NEGATIVE = "$$mini-no-negative";
function directionSize(propertyPrefix) {
  return ([_, direction, size], { theme: theme4 }) => {
    var _a3, _b2, _c;
    const v = (_b2 = (_a3 = theme4.spacing) == null ? void 0 : _a3[size || "DEFAULT"]) != null ? _b2 : h.bracket.cssvar.global.auto.fraction.rem(size);
    if (v != null) {
      return directionMap[direction].map((i) => [`${propertyPrefix}${i}`, v]);
    } else if (size == null ? void 0 : size.startsWith("-")) {
      const v2 = (_c = theme4.spacing) == null ? void 0 : _c[size.slice(1)];
      if (v2 != null)
        return directionMap[direction].map((i) => [`${propertyPrefix}${i}`, `calc(${v2} * -1)`]);
    }
  };
}
function getThemeColorForKey(theme4, colors3, key = "colors") {
  let obj = theme4[key];
  let index = -1;
  for (const c of colors3) {
    index += 1;
    if (obj && typeof obj !== "string") {
      const camel = colors3.slice(index).join("-").replace(/(-[a-z])/g, (n2) => n2.slice(1).toUpperCase());
      if (obj[camel])
        return obj[camel];
      if (obj[c]) {
        obj = obj[c];
        continue;
      }
    }
    return void 0;
  }
  return obj;
}
function getThemeColor(theme4, colors3, key) {
  return getThemeColorForKey(theme4, colors3, key) || getThemeColorForKey(theme4, colors3, "colors");
}
function splitShorthand(body, type) {
  var _a3, _b2;
  const [front, rest] = (_a3 = getStringComponent(body, "[", "]", ["/", ":"])) != null ? _a3 : [];
  if (front != null) {
    const match = ((_b2 = front.match(bracketTypeRe)) != null ? _b2 : [])[1];
    if (match == null || match === type)
      return [front, rest];
  }
}
function parseColor2(body, theme4, key) {
  const split = splitShorthand(body, "color");
  if (!split)
    return;
  const [main, opacity3] = split;
  const colors3 = main.replace(/([a-z])(\d)/g, "$1-$2").split(/-/g);
  const [name2] = colors3;
  if (!name2)
    return;
  let color;
  const bracket3 = h.bracketOfColor(main);
  const bracketOrMain = bracket3 || main;
  if (h.numberWithUnit(bracketOrMain))
    return;
  if (/^#[\da-f]+$/i.test(bracketOrMain))
    color = bracketOrMain;
  else if (/^hex-[\da-fA-F]+$/.test(bracketOrMain))
    color = `#${bracketOrMain.slice(4)}`;
  else if (main.startsWith("$"))
    color = h.cssvar(main);
  color = color || bracket3;
  if (!color) {
    const colorData = getThemeColor(theme4, [main], key);
    if (typeof colorData === "string")
      color = colorData;
  }
  let no = "DEFAULT";
  if (!color) {
    let keys = colors3;
    let _no;
    const [scale] = colors3.slice(-1);
    if (/^\d+$/.test(scale)) {
      no = _no = scale;
      keys = colors3.slice(0, -1);
    }
    const colorData = getThemeColor(theme4, keys, key);
    if (typeof colorData === "object") {
      color = colorData[_no != null ? _no : no];
    } else if (typeof colorData === "string" && !_no) {
      color = colorData;
    }
  }
  return {
    opacity: opacity3,
    name: name2,
    no,
    color,
    cssColor: parseCssColor(color),
    alpha: h.bracket.cssvar.percent(opacity3 != null ? opacity3 : "")
  };
}
function colorResolver(property, varName, key, shouldPass) {
  return ([, body], { theme: theme4, generator }) => {
    const data = parseColor2(body, theme4, key);
    if (!data)
      return;
    const { alpha, color, cssColor } = data;
    const isDev = generator.config.envMode === "dev";
    const rawColorComment = isDev && color ? ` /* ${color} */` : "";
    const css = {};
    if (cssColor) {
      if (alpha != null) {
        css[property] = colorToString(cssColor, alpha) + rawColorComment;
      } else {
        const opacityVar = `--un-${varName}-opacity`;
        const result = colorToString(cssColor, `var(${opacityVar})`);
        if (result.includes(opacityVar))
          css[opacityVar] = colorOpacityToString(cssColor);
        css[property] = result + rawColorComment;
      }
    } else if (color) {
      if (alpha != null) {
        css[property] = colorToString(color, alpha) + rawColorComment;
      } else {
        const opacityVar = `--un-${varName}-opacity`;
        const result = colorToString(color, `var(${opacityVar})`);
        if (result.includes(opacityVar))
          css[opacityVar] = 1;
        css[property] = result + rawColorComment;
      }
    }
    if ((shouldPass == null ? void 0 : shouldPass(css)) !== false)
      return css;
  };
}
function colorableShadows(shadows, colorVar) {
  const colored = [];
  shadows = toArray2(shadows);
  for (let i = 0; i < shadows.length; i++) {
    const components = getStringComponents(shadows[i], " ", 6);
    if (!components || components.length < 3)
      return shadows;
    let isInset = false;
    const pos = components.indexOf("inset");
    if (pos !== -1) {
      components.splice(pos, 1);
      isInset = true;
    }
    let colorVarValue = "";
    const lastComp = components.at(-1);
    if (parseCssColor(components.at(0))) {
      const color = parseCssColor(components.shift());
      if (color)
        colorVarValue = `, ${colorToString(color)}`;
    } else if (parseCssColor(lastComp)) {
      const color = parseCssColor(components.pop());
      if (color)
        colorVarValue = `, ${colorToString(color)}`;
    } else if (lastComp && cssVarFnRE.test(lastComp)) {
      const color = components.pop();
      colorVarValue = `, ${color}`;
    }
    colored.push(`${isInset ? "inset " : ""}${components.join(" ")} var(${colorVar}${colorVarValue})`);
  }
  return colored;
}
function hasParseableColor(color, theme4, key) {
  var _a3;
  return color != null && !!((_a3 = parseColor2(color, theme4, key)) == null ? void 0 : _a3.color);
}
var reLetters = /[a-z]+/gi;
var resolvedBreakpoints = /* @__PURE__ */ new WeakMap();
function resolveBreakpoints({ theme: theme4, generator }, key = "breakpoints") {
  var _a3, _b2;
  const breakpoints3 = ((_b2 = (_a3 = generator == null ? void 0 : generator.userConfig) == null ? void 0 : _a3.theme) == null ? void 0 : _b2[key]) || theme4[key];
  if (!breakpoints3)
    return void 0;
  if (resolvedBreakpoints.has(theme4))
    return resolvedBreakpoints.get(theme4);
  const resolved = Object.entries(breakpoints3).sort((a, b) => Number.parseInt(a[1].replace(reLetters, "")) - Number.parseInt(b[1].replace(reLetters, ""))).map(([point, size]) => ({ point, size }));
  resolvedBreakpoints.set(theme4, resolved);
  return resolved;
}
function makeGlobalStaticRules(prefix, property) {
  return globalKeywords.map((keyword) => [`${prefix}-${keyword}`, { [property != null ? property : prefix]: keyword }]);
}
function isCSSMathFn(value) {
  return value != null && cssMathFnRE.test(value);
}
function isSize(str) {
  if (str[0] === "[" && str.slice(-1) === "]")
    str = str.slice(1, -1);
  return cssMathFnRE.test(str) || numberWithUnitRE.test(str);
}
function transformXYZ(d, v, name2) {
  const values = v.split(splitComma);
  if (d || !d && values.length === 1)
    return xyzMap[d].map((i) => [`--un-${name2}${i}`, v]);
  return values.map((v2, i) => [`--un-${name2}-${xyzArray[i]}`, v2]);
}

// ../../packages-presets/preset-mini/src/_rules/behaviors.ts
var outline = [
  // size
  [/^outline-(?:width-|size-)?(.+)$/, handleWidth, { autocomplete: "outline-(width|size)-<num>" }],
  // color
  [/^outline-(?:color-)?(.+)$/, handleColorOrWidth, { autocomplete: "outline-$colors" }],
  // offset
  [/^outline-offset-(.+)$/, ([, d], { theme: theme4 }) => {
    var _a3, _b2;
    return { "outline-offset": (_b2 = (_a3 = theme4.lineWidth) == null ? void 0 : _a3[d]) != null ? _b2 : h.bracket.cssvar.global.px(d) };
  }, { autocomplete: "outline-(offset)-<num>" }],
  // style
  ["outline", { "outline-style": "solid" }],
  ...["auto", "dashed", "dotted", "double", "hidden", "solid", "groove", "ridge", "inset", "outset", ...globalKeywords].map((v) => [`outline-${v}`, { "outline-style": v }]),
  ["outline-none", { "outline": "2px solid transparent", "outline-offset": "2px" }]
];
function handleWidth([, b], { theme: theme4 }) {
  var _a3, _b2;
  return { "outline-width": (_b2 = (_a3 = theme4.lineWidth) == null ? void 0 : _a3[b]) != null ? _b2 : h.bracket.cssvar.global.px(b) };
}
function handleColorOrWidth(match, ctx) {
  if (isCSSMathFn(h.bracket(match[1])))
    return handleWidth(match, ctx);
  return colorResolver("outline-color", "outline-color", "borderColor")(match, ctx);
}
var appearance = [
  ["appearance-auto", { "-webkit-appearance": "auto", "appearance": "auto" }],
  ["appearance-none", { "-webkit-appearance": "none", "appearance": "none" }]
];
function willChangeProperty(prop) {
  var _a3;
  return (_a3 = h.properties.auto.global(prop)) != null ? _a3 : {
    contents: "contents",
    scroll: "scroll-position"
  }[prop];
}
var willChange = [
  [/^will-change-(.+)/, ([, p]) => ({ "will-change": willChangeProperty(p) })]
];

// ../../packages-presets/preset-mini/src/_rules/border.ts
var borderStyles = ["solid", "dashed", "dotted", "double", "hidden", "none", "groove", "ridge", "inset", "outset", ...globalKeywords];
var borders = [
  // compound
  [/^(?:border|b)()(?:-(.+))?$/, handlerBorderSize, { autocomplete: "(border|b)-<directions>" }],
  [/^(?:border|b)-([xy])(?:-(.+))?$/, handlerBorderSize],
  [/^(?:border|b)-([rltbse])(?:-(.+))?$/, handlerBorderSize],
  [/^(?:border|b)-(block|inline)(?:-(.+))?$/, handlerBorderSize],
  [/^(?:border|b)-([bi][se])(?:-(.+))?$/, handlerBorderSize],
  // size
  [/^(?:border|b)-()(?:width|size)-(.+)$/, handlerBorderSize, { autocomplete: ["(border|b)-<num>", "(border|b)-<directions>-<num>"] }],
  [/^(?:border|b)-([xy])-(?:width|size)-(.+)$/, handlerBorderSize],
  [/^(?:border|b)-([rltbse])-(?:width|size)-(.+)$/, handlerBorderSize],
  [/^(?:border|b)-(block|inline)-(?:width|size)-(.+)$/, handlerBorderSize],
  [/^(?:border|b)-([bi][se])-(?:width|size)-(.+)$/, handlerBorderSize],
  // colors
  [/^(?:border|b)-()(?:color-)?(.+)$/, handlerBorderColorOrSize, { autocomplete: ["(border|b)-$colors", "(border|b)-<directions>-$colors"] }],
  [/^(?:border|b)-([xy])-(?:color-)?(.+)$/, handlerBorderColorOrSize],
  [/^(?:border|b)-([rltbse])-(?:color-)?(.+)$/, handlerBorderColorOrSize],
  [/^(?:border|b)-(block|inline)-(?:color-)?(.+)$/, handlerBorderColorOrSize],
  [/^(?:border|b)-([bi][se])-(?:color-)?(.+)$/, handlerBorderColorOrSize],
  // opacity
  [/^(?:border|b)-()op(?:acity)?-?(.+)$/, handlerBorderOpacity, { autocomplete: "(border|b)-(op|opacity)-<percent>" }],
  [/^(?:border|b)-([xy])-op(?:acity)?-?(.+)$/, handlerBorderOpacity],
  [/^(?:border|b)-([rltbse])-op(?:acity)?-?(.+)$/, handlerBorderOpacity],
  [/^(?:border|b)-(block|inline)-op(?:acity)?-?(.+)$/, handlerBorderOpacity],
  [/^(?:border|b)-([bi][se])-op(?:acity)?-?(.+)$/, handlerBorderOpacity],
  // radius
  [/^(?:border-|b-)?(?:rounded|rd)()(?:-(.+))?$/, handlerRounded, { autocomplete: ["(border|b)-(rounded|rd)", "(border|b)-(rounded|rd)-$borderRadius", "(rounded|rd)", "(rounded|rd)-$borderRadius"] }],
  [/^(?:border-|b-)?(?:rounded|rd)-([rltbse])(?:-(.+))?$/, handlerRounded],
  [/^(?:border-|b-)?(?:rounded|rd)-([rltb]{2})(?:-(.+))?$/, handlerRounded],
  [/^(?:border-|b-)?(?:rounded|rd)-([bise][se])(?:-(.+))?$/, handlerRounded],
  [/^(?:border-|b-)?(?:rounded|rd)-([bi][se]-[bi][se])(?:-(.+))?$/, handlerRounded],
  // style
  [/^(?:border|b)-(?:style-)?()(.+)$/, handlerBorderStyle, { autocomplete: ["(border|b)-style", `(border|b)-(${borderStyles.join("|")})`, "(border|b)-<directions>-style", `(border|b)-<directions>-(${borderStyles.join("|")})`, `(border|b)-<directions>-style-(${borderStyles.join("|")})`, `(border|b)-style-(${borderStyles.join("|")})`] }],
  [/^(?:border|b)-([xy])-(?:style-)?(.+)$/, handlerBorderStyle],
  [/^(?:border|b)-([rltbse])-(?:style-)?(.+)$/, handlerBorderStyle],
  [/^(?:border|b)-(block|inline)-(?:style-)?(.+)$/, handlerBorderStyle],
  [/^(?:border|b)-([bi][se])-(?:style-)?(.+)$/, handlerBorderStyle]
];
function transformBorderColor(color, alpha, direction) {
  if (alpha != null) {
    return {
      [`border${direction}-color`]: colorToString(color, alpha)
    };
  }
  if (direction === "") {
    const object = {};
    const opacityVar = `--un-border-opacity`;
    const result = colorToString(color, `var(${opacityVar})`);
    if (result.includes(opacityVar))
      object[opacityVar] = typeof color === "string" ? 1 : colorOpacityToString(color);
    object["border-color"] = result;
    return object;
  } else {
    const object = {};
    const opacityVar = "--un-border-opacity";
    const opacityDirectionVar = `--un-border${direction}-opacity`;
    const result = colorToString(color, `var(${opacityDirectionVar})`);
    if (result.includes(opacityDirectionVar)) {
      object[opacityVar] = typeof color === "string" ? 1 : colorOpacityToString(color);
      object[opacityDirectionVar] = `var(${opacityVar})`;
    }
    object[`border${direction}-color`] = result;
    return object;
  }
}
function borderColorResolver(direction) {
  return ([, body], theme4) => {
    const data = parseColor2(body, theme4, "borderColor");
    if (!data)
      return;
    const { alpha, color, cssColor } = data;
    if (cssColor)
      return transformBorderColor(cssColor, alpha, direction);
    else if (color)
      return transformBorderColor(color, alpha, direction);
  };
}
function handlerBorderSize([, a = "", b], { theme: theme4 }) {
  var _a3, _b2;
  const v = (_b2 = (_a3 = theme4.lineWidth) == null ? void 0 : _a3[b || "DEFAULT"]) != null ? _b2 : h.bracket.cssvar.global.px(b || "1");
  if (a in directionMap && v != null)
    return directionMap[a].map((i) => [`border${i}-width`, v]);
}
function handlerBorderColorOrSize([, a = "", b], ctx) {
  if (a in directionMap) {
    if (isCSSMathFn(h.bracket(b)))
      return handlerBorderSize(["", a, b], ctx);
    if (hasParseableColor(b, ctx.theme, "borderColor")) {
      return Object.assign(
        {},
        ...directionMap[a].map((i) => borderColorResolver(i)(["", b], ctx.theme))
      );
    }
  }
}
function handlerBorderOpacity([, a = "", opacity3]) {
  const v = h.bracket.percent.cssvar(opacity3);
  if (a in directionMap && v != null)
    return directionMap[a].map((i) => [`--un-border${i}-opacity`, v]);
}
function handlerRounded([, a = "", s], { theme: theme4 }) {
  var _a3;
  const v = ((_a3 = theme4.borderRadius) == null ? void 0 : _a3[s || "DEFAULT"]) || h.bracket.cssvar.global.fraction.rem(s || "1");
  if (a in cornerMap && v != null)
    return cornerMap[a].map((i) => [`border${i}-radius`, v]);
}
function handlerBorderStyle([, a = "", s]) {
  if (borderStyles.includes(s) && a in directionMap)
    return directionMap[a].map((i) => [`border${i}-style`, s]);
}

// ../../packages-presets/preset-mini/src/_rules/color.ts
var opacity = [
  [/^op(?:acity)?-?(.+)$/, ([, d]) => ({ opacity: h.bracket.percent.cssvar(d) })]
];
var bgUrlRE = /^\[url\(.+\)\]$/;
var bgLengthRE = /^\[(?:length|size):.+\]$/;
var bgPositionRE = /^\[position:.+\]$/;
var bgGradientRE = /^\[(?:linear|conic|radial)-gradient\(.+\)\]$/;
var bgImageRE = /^\[image:.+\]$/;
var bgColors = [
  [/^bg-(.+)$/, (...args) => {
    const d = args[0][1];
    if (bgUrlRE.test(d))
      return { "--un-url": h.bracket(d), "background-image": "var(--un-url)" };
    if (bgLengthRE.test(d) && h.bracketOfLength(d) != null)
      return { "background-size": h.bracketOfLength(d).split(" ").map((e2) => {
        var _a3;
        return (_a3 = h.fraction.auto.px.cssvar(e2)) != null ? _a3 : e2;
      }).join(" ") };
    if ((isSize(d) || bgPositionRE.test(d)) && h.bracketOfPosition(d) != null)
      return { "background-position": h.bracketOfPosition(d).split(" ").map((e2) => {
        var _a3;
        return (_a3 = h.position.fraction.auto.px.cssvar(e2)) != null ? _a3 : e2;
      }).join(" ") };
    if (bgGradientRE.test(d) || bgImageRE.test(d)) {
      const s = h.bracket(d);
      if (s) {
        const url = s.startsWith("http") ? `url(${s})` : h.cssvar(s);
        return { "background-image": url != null ? url : s };
      }
    }
    return colorResolver("background-color", "bg", "backgroundColor")(...args);
  }, { autocomplete: "bg-$colors" }],
  [/^bg-op(?:acity)?-?(.+)$/, ([, opacity3]) => ({ "--un-bg-opacity": h.bracket.percent.cssvar(opacity3) }), { autocomplete: "bg-(op|opacity)-<percent>" }]
];
var colorScheme = [
  [/^color-scheme-(\w+)$/, ([, v]) => ({ "color-scheme": v })]
];

// ../../packages-presets/preset-mini/src/_rules/container.ts
var containerParent = [
  [/^@container(?:\/(\w+))?(?:-(normal|inline-size|size))?$/, ([, l, v]) => {
    return {
      "container-type": v != null ? v : "inline-size",
      "container-name": l
    };
  }]
];

// ../../packages-presets/preset-mini/src/_rules/decoration.ts
var decorationStyles = ["solid", "double", "dotted", "dashed", "wavy", ...globalKeywords];
var textDecorations = [
  [/^(?:decoration-)?(underline|overline|line-through)$/, ([, s]) => ({ "text-decoration-line": s }), { autocomplete: "decoration-(underline|overline|line-through)" }],
  // size
  [/^(?:underline|decoration)-(?:size-)?(.+)$/, handleWidth2, { autocomplete: "(underline|decoration)-<num>" }],
  [/^(?:underline|decoration)-(auto|from-font)$/, ([, s]) => ({ "text-decoration-thickness": s }), { autocomplete: "(underline|decoration)-(auto|from-font)" }],
  // colors
  [/^(?:underline|decoration)-(.+)$/, handleColorOrWidth2, { autocomplete: "(underline|decoration)-$colors" }],
  [/^(?:underline|decoration)-op(?:acity)?-?(.+)$/, ([, opacity3]) => ({ "--un-line-opacity": h.bracket.percent.cssvar(opacity3) }), { autocomplete: "(underline|decoration)-(op|opacity)-<percent>" }],
  // offset
  [/^(?:underline|decoration)-offset-(.+)$/, ([, s], { theme: theme4 }) => {
    var _a3, _b2;
    return { "text-underline-offset": (_b2 = (_a3 = theme4.lineWidth) == null ? void 0 : _a3[s]) != null ? _b2 : h.auto.bracket.cssvar.global.px(s) };
  }, { autocomplete: "(underline|decoration)-(offset)-<num>" }],
  // style
  ...decorationStyles.map((v) => [`underline-${v}`, { "text-decoration-style": v }]),
  ...decorationStyles.map((v) => [`decoration-${v}`, { "text-decoration-style": v }]),
  ["no-underline", { "text-decoration": "none" }],
  ["decoration-none", { "text-decoration": "none" }]
];
function handleWidth2([, b], { theme: theme4 }) {
  var _a3, _b2;
  return { "text-decoration-thickness": (_b2 = (_a3 = theme4.lineWidth) == null ? void 0 : _a3[b]) != null ? _b2 : h.bracket.cssvar.global.px(b) };
}
function handleColorOrWidth2(match, ctx) {
  if (isCSSMathFn(h.bracket(match[1])))
    return handleWidth2(match, ctx);
  const result = colorResolver("text-decoration-color", "line", "borderColor")(match, ctx);
  if (result) {
    return {
      "-webkit-text-decoration-color": result["text-decoration-color"],
      ...result
    };
  }
}

// ../../packages-presets/preset-mini/src/_rules/flex.ts
var flex = [
  // display
  ["flex", { display: "flex" }],
  ["inline-flex", { display: "inline-flex" }],
  ["flex-inline", { display: "inline-flex" }],
  // flex
  [/^flex-(.*)$/, ([, d]) => ({ flex: h.bracket(d) != null ? h.bracket(d).split(" ").map((e2) => {
    var _a3;
    return (_a3 = h.cssvar.fraction(e2)) != null ? _a3 : e2;
  }).join(" ") : h.cssvar.fraction(d) })],
  ["flex-1", { flex: "1 1 0%" }],
  ["flex-auto", { flex: "1 1 auto" }],
  ["flex-initial", { flex: "0 1 auto" }],
  ["flex-none", { flex: "none" }],
  // shrink/grow/basis
  [/^(?:flex-)?shrink(?:-(.*))?$/, ([, d = ""]) => {
    var _a3;
    return { "flex-shrink": (_a3 = h.bracket.cssvar.number(d)) != null ? _a3 : 1 };
  }, { autocomplete: ["flex-shrink-<num>", "shrink-<num>"] }],
  [/^(?:flex-)?grow(?:-(.*))?$/, ([, d = ""]) => {
    var _a3;
    return { "flex-grow": (_a3 = h.bracket.cssvar.number(d)) != null ? _a3 : 1 };
  }, { autocomplete: ["flex-grow-<num>", "grow-<num>"] }],
  [/^(?:flex-)?basis-(.+)$/, ([, d], { theme: theme4 }) => {
    var _a3, _b2;
    return { "flex-basis": (_b2 = (_a3 = theme4.spacing) == null ? void 0 : _a3[d]) != null ? _b2 : h.bracket.cssvar.auto.fraction.rem(d) };
  }, { autocomplete: ["flex-basis-$spacing", "basis-$spacing"] }],
  // directions
  ["flex-row", { "flex-direction": "row" }],
  ["flex-row-reverse", { "flex-direction": "row-reverse" }],
  ["flex-col", { "flex-direction": "column" }],
  ["flex-col-reverse", { "flex-direction": "column-reverse" }],
  // wraps
  ["flex-wrap", { "flex-wrap": "wrap" }],
  ["flex-wrap-reverse", { "flex-wrap": "wrap-reverse" }],
  ["flex-nowrap", { "flex-wrap": "nowrap" }]
];

// ../../packages-presets/preset-mini/src/_rules/gap.ts
var directions = {
  "": "",
  "x": "column-",
  "y": "row-",
  "col": "column-",
  "row": "row-"
};
function handleGap([, d = "", s], { theme: theme4 }) {
  var _a3, _b2;
  const v = (_b2 = (_a3 = theme4.spacing) == null ? void 0 : _a3[s]) != null ? _b2 : h.bracket.cssvar.global.rem(s);
  if (v != null) {
    return {
      [`${directions[d]}gap`]: v
    };
  }
}
var gaps = [
  [/^(?:flex-|grid-)?gap-?()(.+)$/, handleGap, { autocomplete: ["gap-$spacing", "gap-<num>"] }],
  [/^(?:flex-|grid-)?gap-([xy])-?(.+)$/, handleGap, { autocomplete: ["gap-(x|y)-$spacing", "gap-(x|y)-<num>"] }],
  [/^(?:flex-|grid-)?gap-(col|row)-?(.+)$/, handleGap, { autocomplete: ["gap-(col|row)-$spacing", "gap-(col|row)-<num>"] }]
];

// ../../packages-presets/preset-mini/src/_rules/grid.ts
function rowCol(s) {
  return s.replace("col", "column");
}
function rowColTheme(s) {
  return s[0] === "r" ? "Row" : "Column";
}
function autoDirection(c, theme4, prop) {
  var _a3;
  const v = (_a3 = theme4[`gridAuto${rowColTheme(c)}`]) == null ? void 0 : _a3[prop];
  if (v != null)
    return v;
  switch (prop) {
    case "min":
      return "min-content";
    case "max":
      return "max-content";
    case "fr":
      return "minmax(0,1fr)";
  }
  return h.bracket.cssvar.auto.rem(prop);
}
var grids = [
  // displays
  ["grid", { display: "grid" }],
  ["inline-grid", { display: "inline-grid" }],
  // global
  [/^(?:grid-)?(row|col)-(.+)$/, ([, c, v], { theme: theme4 }) => {
    var _a3, _b2;
    return {
      [`grid-${rowCol(c)}`]: (_b2 = (_a3 = theme4[`grid${rowColTheme(c)}`]) == null ? void 0 : _a3[v]) != null ? _b2 : h.bracket.cssvar.auto(v)
    };
  }],
  // span
  [/^(?:grid-)?(row|col)-span-(.+)$/, ([, c, s]) => {
    if (s === "full")
      return { [`grid-${rowCol(c)}`]: "1/-1" };
    const v = h.bracket.number(s);
    if (v != null)
      return { [`grid-${rowCol(c)}`]: `span ${v}/span ${v}` };
  }, { autocomplete: "(grid-row|grid-col|row|col)-span-<num>" }],
  // starts & ends
  [/^(?:grid-)?(row|col)-start-(.+)$/, ([, c, v]) => {
    var _a3;
    return { [`grid-${rowCol(c)}-start`]: (_a3 = h.bracket.cssvar(v)) != null ? _a3 : v };
  }],
  [/^(?:grid-)?(row|col)-end-(.+)$/, ([, c, v]) => {
    var _a3;
    return { [`grid-${rowCol(c)}-end`]: (_a3 = h.bracket.cssvar(v)) != null ? _a3 : v };
  }, { autocomplete: "(grid-row|grid-col|row|col)-(start|end)-<num>" }],
  // auto flows
  [/^(?:grid-)?auto-(rows|cols)-(.+)$/, ([, c, v], { theme: theme4 }) => ({ [`grid-auto-${rowCol(c)}`]: autoDirection(c, theme4, v) }), { autocomplete: "(grid-auto|auto)-(rows|cols)-<num>" }],
  // grid-auto-flow, auto-flow: uno
  // grid-flow: wind
  [/^(?:grid-auto-flow|auto-flow|grid-flow)-(.+)$/, ([, v]) => ({ "grid-auto-flow": h.bracket.cssvar(v) })],
  [/^(?:grid-auto-flow|auto-flow|grid-flow)-(row|col|dense|row-dense|col-dense)$/, ([, v]) => ({ "grid-auto-flow": rowCol(v).replace("-", " ") }), { autocomplete: ["(grid-auto-flow|auto-flow|grid-flow)-(row|col|dense|row-dense|col-dense)"] }],
  // templates
  [/^(?:grid-)?(rows|cols)-(.+)$/, ([, c, v], { theme: theme4 }) => {
    var _a3, _b2;
    return {
      [`grid-template-${rowCol(c)}`]: (_b2 = (_a3 = theme4[`gridTemplate${rowColTheme(c)}`]) == null ? void 0 : _a3[v]) != null ? _b2 : h.bracket.cssvar(v)
    };
  }],
  [/^(?:grid-)?(rows|cols)-minmax-([\w.-]+)$/, ([, c, d]) => ({ [`grid-template-${rowCol(c)}`]: `repeat(auto-fill,minmax(${d},1fr))` })],
  [/^(?:grid-)?(rows|cols)-(\d+)$/, ([, c, d]) => ({ [`grid-template-${rowCol(c)}`]: `repeat(${d},minmax(0,1fr))` }), { autocomplete: "(grid-rows|grid-cols|rows|cols)-<num>" }],
  // areas
  [/^grid-area(s)?-(.+)$/, ([, s, v]) => {
    var _a3;
    if (s != null)
      return { "grid-template-areas": (_a3 = h.cssvar(v)) != null ? _a3 : v.split("-").map((s2) => `"${h.bracket(s2)}"`).join(" ") };
    return { "grid-area": h.bracket.cssvar(v) };
  }],
  // template none
  ["grid-rows-none", { "grid-template-rows": "none" }],
  ["grid-cols-none", { "grid-template-columns": "none" }],
  // template subgrid
  ["grid-rows-subgrid", { "grid-template-rows": "subgrid" }],
  ["grid-cols-subgrid", { "grid-template-columns": "subgrid" }]
];

// ../../packages-presets/preset-mini/src/_rules/layout.ts
var overflowValues = [
  "auto",
  "hidden",
  "clip",
  "visible",
  "scroll",
  "overlay",
  ...globalKeywords
];
var overflows = [
  [/^(?:overflow|of)-(.+)$/, ([, v]) => overflowValues.includes(v) ? { overflow: v } : void 0, { autocomplete: [`(overflow|of)-(${overflowValues.join("|")})`, `(overflow|of)-(x|y)-(${overflowValues.join("|")})`] }],
  [/^(?:overflow|of)-([xy])-(.+)$/, ([, d, v]) => overflowValues.includes(v) ? { [`overflow-${d}`]: v } : void 0]
];

// ../../packages-presets/preset-mini/src/_rules/position.ts
var positions = [
  [/^(?:position-|pos-)?(relative|absolute|fixed|sticky)$/, ([, v]) => ({ position: v }), {
    autocomplete: [
      "(position|pos)-<position>",
      "(position|pos)-<globalKeyword>",
      "<position>"
    ]
  }],
  [/^(?:position-|pos-)([-\w]+)$/, ([, v]) => globalKeywords.includes(v) ? { position: v } : void 0],
  [/^(?:position-|pos-)?(static)$/, ([, v]) => ({ position: v })]
];
var justifies = [
  // contents
  ["justify-start", { "justify-content": "flex-start" }],
  ["justify-end", { "justify-content": "flex-end" }],
  ["justify-center", { "justify-content": "center" }],
  ["justify-between", { "justify-content": "space-between" }],
  ["justify-around", { "justify-content": "space-around" }],
  ["justify-evenly", { "justify-content": "space-evenly" }],
  ["justify-stretch", { "justify-content": "stretch" }],
  ["justify-left", { "justify-content": "left" }],
  ["justify-right", { "justify-content": "right" }],
  ...makeGlobalStaticRules("justify", "justify-content"),
  // items
  ["justify-items-start", { "justify-items": "start" }],
  ["justify-items-end", { "justify-items": "end" }],
  ["justify-items-center", { "justify-items": "center" }],
  ["justify-items-stretch", { "justify-items": "stretch" }],
  ...makeGlobalStaticRules("justify-items"),
  // selfs
  ["justify-self-auto", { "justify-self": "auto" }],
  ["justify-self-start", { "justify-self": "start" }],
  ["justify-self-end", { "justify-self": "end" }],
  ["justify-self-center", { "justify-self": "center" }],
  ["justify-self-stretch", { "justify-self": "stretch" }],
  ...makeGlobalStaticRules("justify-self")
];
var orders = [
  [/^order-(.+)$/, ([, v]) => ({ order: h.bracket.cssvar.number(v) })],
  ["order-first", { order: "-9999" }],
  ["order-last", { order: "9999" }],
  ["order-none", { order: "0" }]
];
var alignments = [
  // contents
  ["content-center", { "align-content": "center" }],
  ["content-start", { "align-content": "flex-start" }],
  ["content-end", { "align-content": "flex-end" }],
  ["content-between", { "align-content": "space-between" }],
  ["content-around", { "align-content": "space-around" }],
  ["content-evenly", { "align-content": "space-evenly" }],
  ...makeGlobalStaticRules("content", "align-content"),
  // items
  ["items-start", { "align-items": "flex-start" }],
  ["items-end", { "align-items": "flex-end" }],
  ["items-center", { "align-items": "center" }],
  ["items-baseline", { "align-items": "baseline" }],
  ["items-stretch", { "align-items": "stretch" }],
  ...makeGlobalStaticRules("items", "align-items"),
  // selfs
  ["self-auto", { "align-self": "auto" }],
  ["self-start", { "align-self": "flex-start" }],
  ["self-end", { "align-self": "flex-end" }],
  ["self-center", { "align-self": "center" }],
  ["self-stretch", { "align-self": "stretch" }],
  ["self-baseline", { "align-self": "baseline" }],
  ...makeGlobalStaticRules("self", "align-self")
];
var placements = [
  // contents
  ["place-content-center", { "place-content": "center" }],
  ["place-content-start", { "place-content": "start" }],
  ["place-content-end", { "place-content": "end" }],
  ["place-content-between", { "place-content": "space-between" }],
  ["place-content-around", { "place-content": "space-around" }],
  ["place-content-evenly", { "place-content": "space-evenly" }],
  ["place-content-stretch", { "place-content": "stretch" }],
  ...makeGlobalStaticRules("place-content"),
  // items
  ["place-items-start", { "place-items": "start" }],
  ["place-items-end", { "place-items": "end" }],
  ["place-items-center", { "place-items": "center" }],
  ["place-items-stretch", { "place-items": "stretch" }],
  ...makeGlobalStaticRules("place-items"),
  // selfs
  ["place-self-auto", { "place-self": "auto" }],
  ["place-self-start", { "place-self": "start" }],
  ["place-self-end", { "place-self": "end" }],
  ["place-self-center", { "place-self": "center" }],
  ["place-self-stretch", { "place-self": "stretch" }],
  ...makeGlobalStaticRules("place-self")
];
var flexGridJustifiesAlignments = [...justifies, ...alignments, ...placements].flatMap(([k, v]) => [
  [`flex-${k}`, v],
  [`grid-${k}`, v]
]);
function handleInsetValue(v, { theme: theme4 }) {
  var _a3, _b2;
  return (_b2 = (_a3 = theme4.spacing) == null ? void 0 : _a3[v]) != null ? _b2 : h.bracket.cssvar.global.auto.fraction.rem(v);
}
function handleInsetValues([, d, v], ctx) {
  const r = handleInsetValue(v, ctx);
  if (r != null && d in insetMap)
    return insetMap[d].map((i) => [i.slice(1), r]);
}
var insets = [
  [
    /^(?:position-|pos-)?inset-(.+)$/,
    ([, v], ctx) => ({ inset: handleInsetValue(v, ctx) }),
    {
      autocomplete: [
        "(position|pos)-inset-<directions>-$spacing",
        "(position|pos)-inset-(block|inline)-$spacing",
        "(position|pos)-inset-(bs|be|is|ie)-$spacing",
        "(position|pos)-(top|left|right|bottom)-$spacing"
      ]
    }
  ],
  [/^(?:position-|pos-)?(start|end)-(.+)$/, handleInsetValues],
  [/^(?:position-|pos-)?inset-([xy])-(.+)$/, handleInsetValues],
  [/^(?:position-|pos-)?inset-([rltbse])-(.+)$/, handleInsetValues],
  [/^(?:position-|pos-)?inset-(block|inline)-(.+)$/, handleInsetValues],
  [/^(?:position-|pos-)?inset-([bi][se])-(.+)$/, handleInsetValues],
  [/^(?:position-|pos-)?(top|left|right|bottom)-(.+)$/, ([, d, v], ctx) => ({ [d]: handleInsetValue(v, ctx) })]
];
var floats = [
  // floats
  ["float-left", { float: "left" }],
  ["float-right", { float: "right" }],
  ["float-start", { float: "inline-start" }],
  ["float-end", { float: "inline-end" }],
  ["float-none", { float: "none" }],
  ...makeGlobalStaticRules("float"),
  // clears
  ["clear-left", { clear: "left" }],
  ["clear-right", { clear: "right" }],
  ["clear-both", { clear: "both" }],
  ["clear-start", { clear: "inline-start" }],
  ["clear-end", { clear: "inline-end" }],
  ["clear-none", { clear: "none" }],
  ...makeGlobalStaticRules("clear")
];
var zIndexes = [
  [/^(?:position-|pos-)?z([\d.]+)$/, ([, v]) => ({ "z-index": h.number(v) })],
  [/^(?:position-|pos-)?z-(.+)$/, ([, v], { theme: theme4 }) => {
    var _a3, _b2;
    return { "z-index": (_b2 = (_a3 = theme4.zIndex) == null ? void 0 : _a3[v]) != null ? _b2 : h.bracket.cssvar.global.auto.number(v) };
  }, { autocomplete: "z-<num>" }]
];
var boxSizing = [
  ["box-border", { "box-sizing": "border-box" }],
  ["box-content", { "box-sizing": "content-box" }],
  ...makeGlobalStaticRules("box", "box-sizing")
];

// ../../packages-presets/preset-mini/src/_rules/question-mark.ts
var questionMark = [
  [
    /^(where|\?)$/,
    (_, { constructCSS, generator }) => {
      if (generator.userConfig.envMode === "dev")
        return `@keyframes __un_qm{0%{box-shadow:inset 4px 4px #ff1e90, inset -4px -4px #ff1e90}100%{box-shadow:inset 8px 8px #3399ff, inset -8px -8px #3399ff}} ${constructCSS({ animation: "__un_qm 0.5s ease-in-out alternate infinite" })}`;
    }
  ]
];

// ../../packages-presets/preset-mini/src/_rules/static.ts
var cursorValues = ["auto", "default", "none", "context-menu", "help", "pointer", "progress", "wait", "cell", "crosshair", "text", "vertical-text", "alias", "copy", "move", "no-drop", "not-allowed", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out"];
var containValues = ["none", "strict", "content", "size", "inline-size", "layout", "style", "paint"];
var varEmpty = " ";
var displays = [
  ["inline", { display: "inline" }],
  ["block", { display: "block" }],
  ["inline-block", { display: "inline-block" }],
  ["contents", { display: "contents" }],
  ["flow-root", { display: "flow-root" }],
  ["list-item", { display: "list-item" }],
  ["hidden", { display: "none" }],
  [/^display-(.+)$/, ([, c]) => ({ display: h.bracket.cssvar.global(c) })]
];
var appearances = [
  ["visible", { visibility: "visible" }],
  ["invisible", { visibility: "hidden" }],
  ["backface-visible", { "backface-visibility": "visible" }],
  ["backface-hidden", { "backface-visibility": "hidden" }],
  ...makeGlobalStaticRules("backface", "backface-visibility")
];
var cursors = [
  [/^cursor-(.+)$/, ([, c]) => ({ cursor: h.bracket.cssvar.global(c) })],
  ...cursorValues.map((v) => [`cursor-${v}`, { cursor: v }])
];
var contains = [
  [/^contain-(.*)$/, ([, d]) => {
    if (h.bracket(d) != null) {
      return {
        contain: h.bracket(d).split(" ").map((e2) => {
          var _a3;
          return (_a3 = h.cssvar.fraction(e2)) != null ? _a3 : e2;
        }).join(" ")
      };
    }
    return containValues.includes(d) ? { contain: d } : void 0;
  }]
];
var pointerEvents = [
  ["pointer-events-auto", { "pointer-events": "auto" }],
  ["pointer-events-none", { "pointer-events": "none" }],
  ...makeGlobalStaticRules("pointer-events")
];
var resizes = [
  ["resize-x", { resize: "horizontal" }],
  ["resize-y", { resize: "vertical" }],
  ["resize", { resize: "both" }],
  ["resize-none", { resize: "none" }],
  ...makeGlobalStaticRules("resize")
];
var userSelects = [
  ["select-auto", { "-webkit-user-select": "auto", "user-select": "auto" }],
  ["select-all", { "-webkit-user-select": "all", "user-select": "all" }],
  ["select-text", { "-webkit-user-select": "text", "user-select": "text" }],
  ["select-none", { "-webkit-user-select": "none", "user-select": "none" }],
  ...makeGlobalStaticRules("select", "user-select")
];
var whitespaces = [
  [
    /^(?:whitespace-|ws-)([-\w]+)$/,
    ([, v]) => ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces", ...globalKeywords].includes(v) ? { "white-space": v } : void 0,
    { autocomplete: "(whitespace|ws)-(normal|nowrap|pre|pre-line|pre-wrap|break-spaces)" }
  ]
];
var contentVisibility = [
  [/^intrinsic-size-(.+)$/, ([, d]) => ({ "contain-intrinsic-size": h.bracket.cssvar.global.fraction.rem(d) }), { autocomplete: "intrinsic-size-<num>" }],
  ["content-visibility-visible", { "content-visibility": "visible" }],
  ["content-visibility-hidden", { "content-visibility": "hidden" }],
  ["content-visibility-auto", { "content-visibility": "auto" }],
  ...makeGlobalStaticRules("content-visibility")
];
var contents = [
  [/^content-(.+)$/, ([, v]) => ({ content: h.bracket.cssvar(v) })],
  ["content-empty", { content: '""' }],
  ["content-none", { content: "none" }]
];
var breaks = [
  ["break-normal", { "overflow-wrap": "normal", "word-break": "normal" }],
  ["break-words", { "overflow-wrap": "break-word" }],
  ["break-all", { "word-break": "break-all" }],
  ["break-keep", { "word-break": "keep-all" }],
  ["break-anywhere", { "overflow-wrap": "anywhere" }]
];
var textWraps = [
  ["text-wrap", { "text-wrap": "wrap" }],
  ["text-nowrap", { "text-wrap": "nowrap" }],
  ["text-balance", { "text-wrap": "balance" }],
  ["text-pretty", { "text-wrap": "pretty" }]
];
var textOverflows = [
  ["truncate", { "overflow": "hidden", "text-overflow": "ellipsis", "white-space": "nowrap" }],
  ["text-truncate", { "overflow": "hidden", "text-overflow": "ellipsis", "white-space": "nowrap" }],
  ["text-ellipsis", { "text-overflow": "ellipsis" }],
  ["text-clip", { "text-overflow": "clip" }]
];
var textTransforms = [
  ["case-upper", { "text-transform": "uppercase" }],
  ["case-lower", { "text-transform": "lowercase" }],
  ["case-capital", { "text-transform": "capitalize" }],
  ["case-normal", { "text-transform": "none" }],
  ...makeGlobalStaticRules("case", "text-transform")
];
var fontStyles = [
  ["italic", { "font-style": "italic" }],
  ["not-italic", { "font-style": "normal" }],
  ["font-italic", { "font-style": "italic" }],
  ["font-not-italic", { "font-style": "normal" }],
  ["oblique", { "font-style": "oblique" }],
  ["not-oblique", { "font-style": "normal" }],
  ["font-oblique", { "font-style": "oblique" }],
  ["font-not-oblique", { "font-style": "normal" }]
];
var fontSmoothings = [
  ["antialiased", {
    "-webkit-font-smoothing": "antialiased",
    "-moz-osx-font-smoothing": "grayscale"
  }],
  ["subpixel-antialiased", {
    "-webkit-font-smoothing": "auto",
    "-moz-osx-font-smoothing": "auto"
  }]
];

// ../../packages-presets/preset-mini/src/_rules/ring.ts
var ringBase = {
  "--un-ring-inset": varEmpty,
  "--un-ring-offset-width": "0px",
  "--un-ring-offset-color": "#fff",
  "--un-ring-width": "0px",
  "--un-ring-color": "rgb(147 197 253 / 0.5)",
  "--un-shadow": "0 0 rgb(0 0 0 / 0)"
};
var preflightKeys = Object.keys(ringBase);
var rings = [
  // ring
  [/^ring(?:-(.+))?$/, ([, d], { theme: theme4 }) => {
    var _a3, _b2;
    const value = (_b2 = (_a3 = theme4.ringWidth) == null ? void 0 : _a3[d || "DEFAULT"]) != null ? _b2 : h.px(d || "1");
    if (value) {
      return {
        "--un-ring-width": value,
        "--un-ring-offset-shadow": "var(--un-ring-inset) 0 0 0 var(--un-ring-offset-width) var(--un-ring-offset-color)",
        "--un-ring-shadow": "var(--un-ring-inset) 0 0 0 calc(var(--un-ring-width) + var(--un-ring-offset-width)) var(--un-ring-color)",
        "box-shadow": "var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow)"
      };
    }
  }, { custom: { preflightKeys }, autocomplete: "ring-$ringWidth" }],
  // size
  [/^ring-(?:width-|size-)(.+)$/, handleWidth3, { autocomplete: "ring-(width|size)-$lineWidth" }],
  // offset size
  ["ring-offset", { "--un-ring-offset-width": "1px" }],
  [/^ring-offset-(?:width-|size-)?(.+)$/, ([, d], { theme: theme4 }) => {
    var _a3, _b2;
    return { "--un-ring-offset-width": (_b2 = (_a3 = theme4.lineWidth) == null ? void 0 : _a3[d]) != null ? _b2 : h.bracket.cssvar.px(d) };
  }, { autocomplete: "ring-offset-(width|size)-$lineWidth" }],
  // colors
  [/^ring-(.+)$/, handleColorOrWidth3, { autocomplete: "ring-$colors" }],
  [/^ring-op(?:acity)?-?(.+)$/, ([, opacity3]) => ({ "--un-ring-opacity": h.bracket.percent.cssvar(opacity3) }), { autocomplete: "ring-(op|opacity)-<percent>" }],
  // offset color
  [/^ring-offset-(.+)$/, colorResolver("--un-ring-offset-color", "ring-offset", "borderColor"), { autocomplete: "ring-offset-$colors" }],
  [/^ring-offset-op(?:acity)?-?(.+)$/, ([, opacity3]) => ({ "--un-ring-offset-opacity": h.bracket.percent.cssvar(opacity3) }), { autocomplete: "ring-offset-(op|opacity)-<percent>" }],
  // style
  ["ring-inset", { "--un-ring-inset": "inset" }]
];
function handleWidth3([, b], { theme: theme4 }) {
  var _a3, _b2;
  return { "--un-ring-width": (_b2 = (_a3 = theme4.ringWidth) == null ? void 0 : _a3[b]) != null ? _b2 : h.bracket.cssvar.px(b) };
}
function handleColorOrWidth3(match, ctx) {
  if (isCSSMathFn(h.bracket(match[1])))
    return handleWidth3(match, ctx);
  return colorResolver("--un-ring-color", "ring", "borderColor")(match, ctx);
}

// ../../packages-presets/preset-mini/src/_rules/shadow.ts
var boxShadowsBase = {
  "--un-ring-offset-shadow": "0 0 rgb(0 0 0 / 0)",
  "--un-ring-shadow": "0 0 rgb(0 0 0 / 0)",
  "--un-shadow-inset": varEmpty,
  "--un-shadow": "0 0 rgb(0 0 0 / 0)"
};
var preflightKeys2 = Object.keys(boxShadowsBase);
var boxShadows = [
  // color
  [/^shadow(?:-(.+))?$/, (match, context) => {
    var _a3;
    const [, d] = match;
    const { theme: theme4 } = context;
    const v = (_a3 = theme4.boxShadow) == null ? void 0 : _a3[d || "DEFAULT"];
    const c = d ? h.bracket.cssvar(d) : void 0;
    if ((v != null || c != null) && !hasParseableColor(c, theme4, "shadowColor")) {
      return {
        "--un-shadow": colorableShadows(v || c, "--un-shadow-color").join(","),
        "box-shadow": "var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow)"
      };
    }
    return colorResolver("--un-shadow-color", "shadow", "shadowColor")(match, context);
  }, { custom: { preflightKeys: preflightKeys2 }, autocomplete: ["shadow-$colors", "shadow-$boxShadow"] }],
  [/^shadow-op(?:acity)?-?(.+)$/, ([, opacity3]) => ({ "--un-shadow-opacity": h.bracket.percent.cssvar(opacity3) }), { autocomplete: "shadow-(op|opacity)-<percent>" }],
  // inset
  ["shadow-inset", { "--un-shadow-inset": "inset" }]
];

// ../../packages-presets/preset-mini/src/_rules/size.ts
var sizeMapping = {
  h: "height",
  w: "width",
  inline: "inline-size",
  block: "block-size"
};
function getPropName(minmax, hw) {
  return `${minmax || ""}${sizeMapping[hw]}`;
}
function getSizeValue(minmax, hw, theme4, prop) {
  var _a3;
  const key = getPropName(minmax, hw).replace(/-(\w)/g, (_, p) => p.toUpperCase());
  const v = (_a3 = theme4[key]) == null ? void 0 : _a3[prop];
  if (v != null)
    return v;
  switch (prop) {
    case "fit":
    case "max":
    case "min":
      return `${prop}-content`;
  }
  return h.bracket.cssvar.global.auto.fraction.rem(prop);
}
var sizes = [
  [/^size-(min-|max-)?(.+)$/, ([, m, s], { theme: theme4 }) => ({ [getPropName(m, "w")]: getSizeValue(m, "w", theme4, s), [getPropName(m, "h")]: getSizeValue(m, "h", theme4, s) })],
  [/^(?:size-)?(min-|max-)?([wh])-?(.+)$/, ([, m, w, s], { theme: theme4 }) => ({ [getPropName(m, w)]: getSizeValue(m, w, theme4, s) })],
  [/^(?:size-)?(min-|max-)?(block|inline)-(.+)$/, ([, m, w, s], { theme: theme4 }) => ({ [getPropName(m, w)]: getSizeValue(m, w, theme4, s) }), {
    autocomplete: [
      "(w|h)-$width|height|maxWidth|maxHeight|minWidth|minHeight|inlineSize|blockSize|maxInlineSize|maxBlockSize|minInlineSize|minBlockSize",
      "(block|inline)-$width|height|maxWidth|maxHeight|minWidth|minHeight|inlineSize|blockSize|maxInlineSize|maxBlockSize|minInlineSize|minBlockSize",
      "(max|min)-(w|h|block|inline)",
      "(max|min)-(w|h|block|inline)-$width|height|maxWidth|maxHeight|minWidth|minHeight|inlineSize|blockSize|maxInlineSize|maxBlockSize|minInlineSize|minBlockSize",
      "(w|h)-full",
      "(max|min)-(w|h)-full"
    ]
  }],
  [/^(?:size-)?(min-|max-)?(h)-screen-(.+)$/, ([, m, h3, p], context) => ({ [getPropName(m, h3)]: handleBreakpoint(context, p, "verticalBreakpoints") })],
  [/^(?:size-)?(min-|max-)?(w)-screen-(.+)$/, ([, m, w, p], context) => ({ [getPropName(m, w)]: handleBreakpoint(context, p) }), {
    autocomplete: [
      "(w|h)-screen",
      "(min|max)-(w|h)-screen",
      "h-screen-$verticalBreakpoints",
      "(min|max)-h-screen-$verticalBreakpoints",
      "w-screen-$breakpoints",
      "(min|max)-w-screen-$breakpoints"
    ]
  }]
];
function handleBreakpoint(context, point, key = "breakpoints") {
  var _a3;
  const bp = resolveBreakpoints(context, key);
  if (bp)
    return (_a3 = bp.find((i) => i.point === point)) == null ? void 0 : _a3.size;
}
function getAspectRatio(prop) {
  if (/^\d+\/\d+$/.test(prop))
    return prop;
  switch (prop) {
    case "square":
      return "1/1";
    case "video":
      return "16/9";
  }
  return h.bracket.cssvar.global.auto.number(prop);
}
var aspectRatio = [
  [/^(?:size-)?aspect-(?:ratio-)?(.+)$/, ([, d]) => ({ "aspect-ratio": getAspectRatio(d) }), { autocomplete: ["aspect-(square|video|ratio)", "aspect-ratio-(square|video)"] }]
];

// ../../packages-presets/preset-mini/src/_rules/spacing.ts
var paddings = [
  [/^pa?()-?(.+)$/, directionSize("padding"), { autocomplete: ["(m|p)<num>", "(m|p)-<num>"] }],
  [/^p-?xy()()$/, directionSize("padding"), { autocomplete: "(m|p)-(xy)" }],
  [/^p-?([xy])(?:-?(.+))?$/, directionSize("padding")],
  [/^p-?([rltbse])(?:-?(.+))?$/, directionSize("padding"), { autocomplete: "(m|p)<directions>-<num>" }],
  [/^p-(block|inline)(?:-(.+))?$/, directionSize("padding"), { autocomplete: "(m|p)-(block|inline)-<num>" }],
  [/^p-?([bi][se])(?:-?(.+))?$/, directionSize("padding"), { autocomplete: "(m|p)-(bs|be|is|ie)-<num>" }]
];
var margins = [
  [/^ma?()-?(.+)$/, directionSize("margin")],
  [/^m-?xy()()$/, directionSize("margin")],
  [/^m-?([xy])(?:-?(.+))?$/, directionSize("margin")],
  [/^m-?([rltbse])(?:-?(.+))?$/, directionSize("margin")],
  [/^m-(block|inline)(?:-(.+))?$/, directionSize("margin")],
  [/^m-?([bi][se])(?:-?(.+))?$/, directionSize("margin")]
];

// ../../packages-presets/preset-mini/src/_rules/svg.ts
var svgUtilities = [
  // fills
  [/^fill-(.+)$/, colorResolver("fill", "fill", "backgroundColor"), { autocomplete: "fill-$colors" }],
  [/^fill-op(?:acity)?-?(.+)$/, ([, opacity3]) => ({ "--un-fill-opacity": h.bracket.percent.cssvar(opacity3) }), { autocomplete: "fill-(op|opacity)-<percent>" }],
  ["fill-none", { fill: "none" }],
  // stroke size
  [/^stroke-(?:width-|size-)?(.+)$/, handleWidth4, { autocomplete: ["stroke-width-$lineWidth", "stroke-size-$lineWidth"] }],
  // stroke dash
  [/^stroke-dash-(.+)$/, ([, s]) => ({ "stroke-dasharray": h.bracket.cssvar.number(s) }), { autocomplete: "stroke-dash-<num>" }],
  [/^stroke-offset-(.+)$/, ([, s], { theme: theme4 }) => {
    var _a3, _b2;
    return { "stroke-dashoffset": (_b2 = (_a3 = theme4.lineWidth) == null ? void 0 : _a3[s]) != null ? _b2 : h.bracket.cssvar.px.numberWithUnit(s) };
  }, { autocomplete: "stroke-offset-$lineWidth" }],
  // stroke colors
  [/^stroke-(.+)$/, handleColorOrWidth4, { autocomplete: "stroke-$colors" }],
  [/^stroke-op(?:acity)?-?(.+)$/, ([, opacity3]) => ({ "--un-stroke-opacity": h.bracket.percent.cssvar(opacity3) }), { autocomplete: "stroke-(op|opacity)-<percent>" }],
  // line cap
  ["stroke-cap-square", { "stroke-linecap": "square" }],
  ["stroke-cap-round", { "stroke-linecap": "round" }],
  ["stroke-cap-auto", { "stroke-linecap": "butt" }],
  // line join
  ["stroke-join-arcs", { "stroke-linejoin": "arcs" }],
  ["stroke-join-bevel", { "stroke-linejoin": "bevel" }],
  ["stroke-join-clip", { "stroke-linejoin": "miter-clip" }],
  ["stroke-join-round", { "stroke-linejoin": "round" }],
  ["stroke-join-auto", { "stroke-linejoin": "miter" }],
  // none
  ["stroke-none", { stroke: "none" }]
];
function handleWidth4([, b], { theme: theme4 }) {
  var _a3, _b2;
  return { "stroke-width": (_b2 = (_a3 = theme4.lineWidth) == null ? void 0 : _a3[b]) != null ? _b2 : h.bracket.cssvar.fraction.px.number(b) };
}
function handleColorOrWidth4(match, ctx) {
  if (isCSSMathFn(h.bracket(match[1])))
    return handleWidth4(match, ctx);
  return colorResolver("stroke", "stroke", "borderColor")(match, ctx);
}

// ../../packages-presets/preset-mini/src/_rules/transform.ts
var transformValues = [
  "translate",
  "rotate",
  "scale"
];
var transformCpu = [
  "translateX(var(--un-translate-x))",
  "translateY(var(--un-translate-y))",
  // 'translateZ(var(--un-translate-z))',
  "rotate(var(--un-rotate))",
  // 'rotateX(var(--un-rotate-x))',
  // 'rotateY(var(--un-rotate-y))',
  "rotateZ(var(--un-rotate-z))",
  "skewX(var(--un-skew-x))",
  "skewY(var(--un-skew-y))",
  "scaleX(var(--un-scale-x))",
  "scaleY(var(--un-scale-y))"
  // 'scaleZ(var(--un-scale-z))',
].join(" ");
var transform = [
  "translateX(var(--un-translate-x))",
  "translateY(var(--un-translate-y))",
  "translateZ(var(--un-translate-z))",
  "rotate(var(--un-rotate))",
  "rotateX(var(--un-rotate-x))",
  "rotateY(var(--un-rotate-y))",
  "rotateZ(var(--un-rotate-z))",
  "skewX(var(--un-skew-x))",
  "skewY(var(--un-skew-y))",
  "scaleX(var(--un-scale-x))",
  "scaleY(var(--un-scale-y))",
  "scaleZ(var(--un-scale-z))"
].join(" ");
var transformGpu = [
  "translate3d(var(--un-translate-x), var(--un-translate-y), var(--un-translate-z))",
  "rotate(var(--un-rotate))",
  "rotateX(var(--un-rotate-x))",
  "rotateY(var(--un-rotate-y))",
  "rotateZ(var(--un-rotate-z))",
  "skewX(var(--un-skew-x))",
  "skewY(var(--un-skew-y))",
  "scaleX(var(--un-scale-x))",
  "scaleY(var(--un-scale-y))",
  "scaleZ(var(--un-scale-z))"
].join(" ");
var transformBase = {
  // transform
  "--un-rotate": 0,
  "--un-rotate-x": 0,
  "--un-rotate-y": 0,
  "--un-rotate-z": 0,
  "--un-scale-x": 1,
  "--un-scale-y": 1,
  "--un-scale-z": 1,
  "--un-skew-x": 0,
  "--un-skew-y": 0,
  "--un-translate-x": 0,
  "--un-translate-y": 0,
  "--un-translate-z": 0
};
var preflightKeys3 = Object.keys(transformBase);
var transforms = [
  // origins
  [
    /^(?:transform-)?origin-(.+)$/,
    ([, s]) => {
      var _a3;
      return { "transform-origin": (_a3 = positionMap[s]) != null ? _a3 : h.bracket.cssvar(s) };
    },
    { autocomplete: [`transform-origin-(${Object.keys(positionMap).join("|")})`, `origin-(${Object.keys(positionMap).join("|")})`] }
  ],
  // perspectives
  [/^(?:transform-)?perspect(?:ive)?-(.+)$/, ([, s]) => {
    const v = h.bracket.cssvar.px.numberWithUnit(s);
    if (v != null) {
      return {
        "-webkit-perspective": v,
        "perspective": v
      };
    }
  }],
  // skip 1 & 2 letters shortcut
  [/^(?:transform-)?perspect(?:ive)?-origin-(.+)$/, ([, s]) => {
    var _a3;
    const v = (_a3 = h.bracket.cssvar(s)) != null ? _a3 : s.length >= 3 ? positionMap[s] : void 0;
    if (v != null) {
      return {
        "-webkit-perspective-origin": v,
        "perspective-origin": v
      };
    }
  }],
  // modifiers
  [/^(?:transform-)?translate-()(.+)$/, handleTranslate, { custom: { preflightKeys: preflightKeys3 } }],
  [/^(?:transform-)?translate-([xyz])-(.+)$/, handleTranslate, { custom: { preflightKeys: preflightKeys3 } }],
  [/^(?:transform-)?rotate-()(.+)$/, handleRotate, { custom: { preflightKeys: preflightKeys3 } }],
  [/^(?:transform-)?rotate-([xyz])-(.+)$/, handleRotate, { custom: { preflightKeys: preflightKeys3 } }],
  [/^(?:transform-)?skew-()(.+)$/, handleSkew, { custom: { preflightKeys: preflightKeys3 } }],
  [/^(?:transform-)?skew-([xy])-(.+)$/, handleSkew, { custom: { preflightKeys: preflightKeys3 }, autocomplete: ["transform-skew-(x|y)-<percent>", "skew-(x|y)-<percent>"] }],
  [/^(?:transform-)?scale-()(.+)$/, handleScale, { custom: { preflightKeys: preflightKeys3 } }],
  [/^(?:transform-)?scale-([xyz])-(.+)$/, handleScale, { custom: { preflightKeys: preflightKeys3 }, autocomplete: [`transform-(${transformValues.join("|")})-<percent>`, `transform-(${transformValues.join("|")})-(x|y|z)-<percent>`, `(${transformValues.join("|")})-<percent>`, `(${transformValues.join("|")})-(x|y|z)-<percent>`] }],
  // style
  [/^(?:transform-)?preserve-3d$/, () => ({ "transform-style": "preserve-3d" })],
  [/^(?:transform-)?preserve-flat$/, () => ({ "transform-style": "flat" })],
  // base
  ["transform", { transform }, { custom: { preflightKeys: preflightKeys3 } }],
  ["transform-cpu", { transform: transformCpu }, {
    custom: { preflightKeys: ["--un-translate-x", "--un-translate-y", "--un-rotate", "--un-rotate-z", "--un-skew-x", "--un-skew-y", "--un-scale-x", "--un-scale-y"] }
  }],
  ["transform-gpu", { transform: transformGpu }, { custom: { preflightKeys: preflightKeys3 } }],
  ["transform-none", { transform: "none" }],
  ...makeGlobalStaticRules("transform")
];
function handleTranslate([, d, b], { theme: theme4 }) {
  var _a3, _b2;
  const v = (_b2 = (_a3 = theme4.spacing) == null ? void 0 : _a3[b]) != null ? _b2 : h.bracket.cssvar.fraction.rem(b);
  if (v != null) {
    return [
      ...transformXYZ(d, v, "translate"),
      ["transform", transform]
    ];
  }
}
function handleScale([, d, b]) {
  const v = h.bracket.cssvar.fraction.percent(b);
  if (v != null) {
    return [
      ...transformXYZ(d, v, "scale"),
      ["transform", transform]
    ];
  }
}
function handleRotate([, d = "", b]) {
  const v = h.bracket.cssvar.degree(b);
  if (v != null) {
    if (d) {
      return {
        "--un-rotate": 0,
        [`--un-rotate-${d}`]: v,
        "transform": transform
      };
    } else {
      return {
        "--un-rotate-x": 0,
        "--un-rotate-y": 0,
        "--un-rotate-z": 0,
        "--un-rotate": v,
        "transform": transform
      };
    }
  }
}
function handleSkew([, d, b]) {
  const v = h.bracket.cssvar.degree(b);
  if (v != null) {
    return [
      ...transformXYZ(d, v, "skew"),
      ["transform", transform]
    ];
  }
}

// ../../packages-presets/preset-mini/src/_rules/transition.ts
function resolveTransitionProperty(prop, theme4) {
  let p;
  if (h.cssvar(prop) != null) {
    p = h.cssvar(prop);
  } else {
    if (prop.startsWith("[") && prop.endsWith("]")) {
      prop = prop.slice(1, -1);
    }
    const props = prop.split(",").map((p2) => {
      var _a3, _b2;
      return (_b2 = (_a3 = theme4.transitionProperty) == null ? void 0 : _a3[p2]) != null ? _b2 : h.properties(p2);
    });
    if (props.every(Boolean)) {
      p = props.join(",");
    }
  }
  return p;
}
var transitions = [
  // transition
  [
    /^transition(?:-(\D+?))?(?:-(\d+))?$/,
    ([, prop, d], { theme: theme4 }) => {
      var _a3, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k;
      if (!prop && !d) {
        return {
          "transition-property": (_a3 = theme4.transitionProperty) == null ? void 0 : _a3.DEFAULT,
          "transition-timing-function": (_b2 = theme4.easing) == null ? void 0 : _b2.DEFAULT,
          "transition-duration": (_d = (_c = theme4.duration) == null ? void 0 : _c.DEFAULT) != null ? _d : h.time("150")
        };
      } else if (prop != null) {
        const p = resolveTransitionProperty(prop, theme4);
        const duration3 = (_f = (_e = theme4.duration) == null ? void 0 : _e[d || "DEFAULT"]) != null ? _f : h.time(d || "150");
        if (p) {
          return {
            "transition-property": p,
            "transition-timing-function": (_g = theme4.easing) == null ? void 0 : _g.DEFAULT,
            "transition-duration": duration3
          };
        }
      } else if (d != null) {
        return {
          "transition-property": (_h = theme4.transitionProperty) == null ? void 0 : _h.DEFAULT,
          "transition-timing-function": (_i = theme4.easing) == null ? void 0 : _i.DEFAULT,
          "transition-duration": (_k = (_j = theme4.duration) == null ? void 0 : _j[d]) != null ? _k : h.time(d)
        };
      }
    },
    {
      autocomplete: "transition-$transitionProperty-$duration"
    }
  ],
  // timings
  [
    /^(?:transition-)?duration-(.+)$/,
    ([, d], { theme: theme4 }) => {
      var _a3, _b2;
      return { "transition-duration": (_b2 = (_a3 = theme4.duration) == null ? void 0 : _a3[d || "DEFAULT"]) != null ? _b2 : h.bracket.cssvar.time(d) };
    },
    { autocomplete: ["transition-duration-$duration", "duration-$duration"] }
  ],
  [
    /^(?:transition-)?delay-(.+)$/,
    ([, d], { theme: theme4 }) => {
      var _a3, _b2;
      return { "transition-delay": (_b2 = (_a3 = theme4.duration) == null ? void 0 : _a3[d || "DEFAULT"]) != null ? _b2 : h.bracket.cssvar.time(d) };
    },
    { autocomplete: ["transition-delay-$duration", "delay-$duration"] }
  ],
  [
    /^(?:transition-)?ease(?:-(.+))?$/,
    ([, d], { theme: theme4 }) => {
      var _a3, _b2;
      return { "transition-timing-function": (_b2 = (_a3 = theme4.easing) == null ? void 0 : _a3[d || "DEFAULT"]) != null ? _b2 : h.bracket.cssvar(d) };
    },
    { autocomplete: ["transition-ease-(linear|in|out|in-out|DEFAULT)", "ease-(linear|in|out|in-out|DEFAULT)"] }
  ],
  // props
  [
    /^(?:transition-)?property-(.+)$/,
    ([, v], { theme: theme4 }) => {
      const p = h.global(v) || resolveTransitionProperty(v, theme4);
      if (p)
        return { "transition-property": p };
    },
    { autocomplete: [
      `transition-property-(${[...globalKeywords].join("|")})`,
      "transition-property-$transitionProperty",
      "property-$transitionProperty"
    ] }
  ],
  // none
  ["transition-none", { transition: "none" }],
  ...makeGlobalStaticRules("transition"),
  // behavior
  ["transition-discrete", { "transition-behavior": "allow-discrete" }],
  ["transition-normal", { "transition-behavior": "normal" }]
];

// ../../packages-presets/preset-mini/src/_rules/typography.ts
var fonts = [
  // text
  [/^text-(.+)$/, handleText, { autocomplete: "text-$fontSize" }],
  // text size
  [/^(?:text|font)-size-(.+)$/, handleSize, { autocomplete: "text-size-$fontSize" }],
  // text colors
  [/^text-(?:color-)?(.+)$/, handlerColorOrSize, { autocomplete: "text-$colors" }],
  // colors
  [/^(?:color|c)-(.+)$/, colorResolver("color", "text", "textColor"), { autocomplete: "(color|c)-$colors" }],
  // style
  [/^(?:text|color|c)-(.+)$/, ([, v]) => globalKeywords.includes(v) ? { color: v } : void 0, { autocomplete: `(text|color|c)-(${globalKeywords.join("|")})` }],
  // opacity
  [/^(?:text|color|c)-op(?:acity)?-?(.+)$/, ([, opacity3]) => ({ "--un-text-opacity": h.bracket.percent.cssvar(opacity3) }), { autocomplete: "(text|color|c)-(op|opacity)-<percent>" }],
  // weights
  [
    /^(?:font|fw)-?([^-]+)$/,
    ([, s], { theme: theme4 }) => {
      var _a3;
      return { "font-weight": ((_a3 = theme4.fontWeight) == null ? void 0 : _a3[s]) || h.bracket.global.number(s) };
    },
    {
      autocomplete: [
        "(font|fw)-(100|200|300|400|500|600|700|800|900)",
        "(font|fw)-$fontWeight"
      ]
    }
  ],
  // leadings
  [
    /^(?:font-)?(?:leading|lh|line-height)-(.+)$/,
    ([, s], { theme: theme4 }) => ({ "line-height": handleThemeByKey(s, theme4, "lineHeight") }),
    { autocomplete: "(leading|lh|line-height)-$lineHeight" }
  ],
  // synthesis
  ["font-synthesis-weight", { "font-synthesis": "weight" }],
  ["font-synthesis-style", { "font-synthesis": "style" }],
  ["font-synthesis-small-caps", { "font-synthesis": "small-caps" }],
  ["font-synthesis-none", { "font-synthesis": "none" }],
  [/^font-synthesis-(.+)$/, ([, s]) => ({ "font-synthesis": h.bracket.cssvar.global(s) })],
  // tracking
  [
    /^(?:font-)?tracking-(.+)$/,
    ([, s], { theme: theme4 }) => {
      var _a3;
      return { "letter-spacing": ((_a3 = theme4.letterSpacing) == null ? void 0 : _a3[s]) || h.bracket.cssvar.global.rem(s) };
    },
    { autocomplete: "tracking-$letterSpacing" }
  ],
  // word-spacing
  [
    /^(?:font-)?word-spacing-(.+)$/,
    ([, s], { theme: theme4 }) => {
      var _a3;
      return { "word-spacing": ((_a3 = theme4.wordSpacing) == null ? void 0 : _a3[s]) || h.bracket.cssvar.global.rem(s) };
    },
    { autocomplete: "word-spacing-$wordSpacing" }
  ],
  // stretch
  ["font-stretch-normal", { "font-stretch": "normal" }],
  ["font-stretch-ultra-condensed", { "font-stretch": "ultra-condensed" }],
  ["font-stretch-extra-condensed", { "font-stretch": "extra-condensed" }],
  ["font-stretch-condensed", { "font-stretch": "condensed" }],
  ["font-stretch-semi-condensed", { "font-stretch": "semi-condensed" }],
  ["font-stretch-semi-expanded", { "font-stretch": "semi-expanded" }],
  ["font-stretch-expanded", { "font-stretch": "expanded" }],
  ["font-stretch-extra-expanded", { "font-stretch": "extra-expanded" }],
  ["font-stretch-ultra-expanded", { "font-stretch": "ultra-expanded" }],
  [
    /^font-stretch-(.+)$/,
    ([, s]) => ({ "font-stretch": h.bracket.cssvar.fraction.global(s) }),
    { autocomplete: "font-stretch-<percentage>" }
  ],
  // family
  [
    /^font-(.+)$/,
    ([, d], { theme: theme4 }) => {
      var _a3;
      return { "font-family": ((_a3 = theme4.fontFamily) == null ? void 0 : _a3[d]) || h.bracket.cssvar.global(d) };
    },
    { autocomplete: "font-$fontFamily" }
  ]
];
var tabSizes = [
  [/^tab(?:-(.+))?$/, ([, s]) => {
    const v = h.bracket.cssvar.global.number(s || "4");
    if (v != null) {
      return {
        "-moz-tab-size": v,
        "-o-tab-size": v,
        "tab-size": v
      };
    }
  }]
];
var textIndents = [
  [/^indent(?:-(.+))?$/, ([, s], { theme: theme4 }) => {
    var _a3;
    return { "text-indent": ((_a3 = theme4.textIndent) == null ? void 0 : _a3[s || "DEFAULT"]) || h.bracket.cssvar.global.fraction.rem(s) };
  }, { autocomplete: "indent-$textIndent" }]
];
var textStrokes = [
  // widths
  [/^text-stroke(?:-(.+))?$/, ([, s], { theme: theme4 }) => {
    var _a3;
    return { "-webkit-text-stroke-width": ((_a3 = theme4.textStrokeWidth) == null ? void 0 : _a3[s || "DEFAULT"]) || h.bracket.cssvar.px(s) };
  }, { autocomplete: "text-stroke-$textStrokeWidth" }],
  // colors
  [/^text-stroke-(.+)$/, colorResolver("-webkit-text-stroke-color", "text-stroke", "borderColor"), { autocomplete: "text-stroke-$colors" }],
  [/^text-stroke-op(?:acity)?-?(.+)$/, ([, opacity3]) => ({ "--un-text-stroke-opacity": h.bracket.percent.cssvar(opacity3) }), { autocomplete: "text-stroke-(op|opacity)-<percent>" }]
];
var textShadows = [
  [/^text-shadow(?:-(.+))?$/, ([, s], { theme: theme4 }) => {
    var _a3;
    const v = (_a3 = theme4.textShadow) == null ? void 0 : _a3[s || "DEFAULT"];
    if (v != null) {
      return {
        "--un-text-shadow": colorableShadows(v, "--un-text-shadow-color").join(","),
        "text-shadow": "var(--un-text-shadow)"
      };
    }
    return { "text-shadow": h.bracket.cssvar.global(s) };
  }, { autocomplete: "text-shadow-$textShadow" }],
  // colors
  [/^text-shadow-color-(.+)$/, colorResolver("--un-text-shadow-color", "text-shadow", "shadowColor"), { autocomplete: "text-shadow-color-$colors" }],
  [/^text-shadow-color-op(?:acity)?-?(.+)$/, ([, opacity3]) => ({ "--un-text-shadow-opacity": h.bracket.percent.cssvar(opacity3) }), { autocomplete: "text-shadow-color-(op|opacity)-<percent>" }]
];
function handleThemeByKey(s, theme4, key) {
  var _a3;
  return ((_a3 = theme4[key]) == null ? void 0 : _a3[s]) || h.bracket.cssvar.global.rem(s);
}
function handleSize([, s], { theme: theme4 }) {
  var _a3, _b2;
  const themed = toArray2((_a3 = theme4.fontSize) == null ? void 0 : _a3[s]);
  const size = (_b2 = themed == null ? void 0 : themed[0]) != null ? _b2 : h.bracket.cssvar.global.rem(s);
  if (size != null)
    return { "font-size": size };
}
function handlerColorOrSize(match, ctx) {
  if (isCSSMathFn(h.bracket(match[1])))
    return handleSize(match, ctx);
  return colorResolver("color", "text", "textColor")(match, ctx);
}
function handleText([, s = "base"], { theme: theme4 }) {
  var _a3, _b2;
  const split = splitShorthand(s, "length");
  if (!split)
    return;
  const [size, leading] = split;
  const sizePairs = toArray2((_a3 = theme4.fontSize) == null ? void 0 : _a3[size]);
  const lineHeight3 = leading ? handleThemeByKey(leading, theme4, "lineHeight") : void 0;
  if (sizePairs == null ? void 0 : sizePairs[0]) {
    const [fontSize4, height3, letterSpacing3] = sizePairs;
    if (typeof height3 === "object") {
      return {
        "font-size": fontSize4,
        ...height3
      };
    }
    return {
      "font-size": fontSize4,
      "line-height": (_b2 = lineHeight3 != null ? lineHeight3 : height3) != null ? _b2 : "1",
      "letter-spacing": letterSpacing3 ? handleThemeByKey(letterSpacing3, theme4, "letterSpacing") : void 0
    };
  }
  const fontSize3 = h.bracketOfLength.rem(size);
  if (lineHeight3 && fontSize3) {
    return {
      "font-size": fontSize3,
      "line-height": lineHeight3
    };
  }
  return { "font-size": h.bracketOfLength.rem(s) };
}

// ../../packages-presets/preset-mini/src/_rules/variables.ts
var variablesAbbrMap = {
  backface: "backface-visibility",
  break: "word-break",
  case: "text-transform",
  content: "align-content",
  fw: "font-weight",
  items: "align-items",
  justify: "justify-content",
  select: "user-select",
  self: "align-self",
  vertical: "vertical-align",
  visible: "visibility",
  whitespace: "white-space",
  ws: "white-space"
};
var cssVariables = [
  [/^(.+?)-(\$.+)$/, ([, name2, varname]) => {
    const prop = variablesAbbrMap[name2];
    if (prop)
      return { [prop]: h.cssvar(varname) };
  }]
];
var cssProperty = [
  [/^\[(.*)\]$/, ([_, body]) => {
    if (!body.includes(":"))
      return;
    const [prop, ...rest] = body.split(":");
    const value = rest.join(":");
    if (!isURI(body) && /^[a-z-]+$/.test(prop) && isValidCSSBody(value)) {
      const parsed = h.bracket(`[${value}]`);
      if (parsed)
        return { [prop]: parsed };
    }
  }]
];
function isValidCSSBody(body) {
  let i = 0;
  function findUntil(c) {
    while (i < body.length) {
      i += 1;
      const char = body[i];
      if (char === c)
        return true;
    }
    return false;
  }
  for (i = 0; i < body.length; i++) {
    const c = body[i];
    if ("\"`'".includes(c)) {
      if (!findUntil(c))
        return false;
    } else if (c === "(") {
      if (!findUntil(")"))
        return false;
    } else if ("[]{}:".includes(c)) {
      return false;
    }
  }
  return true;
}
function isURI(declaration) {
  if (!declaration.includes("://"))
    return false;
  try {
    return new URL(declaration).host !== "";
  } catch (e2) {
    return false;
  }
}

// ../../packages-presets/preset-mini/src/_rules/default.ts
var rules = [
  cssVariables,
  cssProperty,
  contains,
  pointerEvents,
  appearances,
  positions,
  insets,
  zIndexes,
  orders,
  grids,
  floats,
  margins,
  boxSizing,
  displays,
  aspectRatio,
  sizes,
  flex,
  transforms,
  cursors,
  userSelects,
  resizes,
  appearance,
  placements,
  alignments,
  justifies,
  gaps,
  flexGridJustifiesAlignments,
  overflows,
  textOverflows,
  whitespaces,
  breaks,
  borders,
  bgColors,
  colorScheme,
  svgUtilities,
  paddings,
  textAligns,
  textIndents,
  textWraps,
  verticalAligns,
  fonts,
  textTransforms,
  fontStyles,
  textDecorations,
  fontSmoothings,
  tabSizes,
  textStrokes,
  textShadows,
  opacity,
  boxShadows,
  outline,
  rings,
  transitions,
  willChange,
  contentVisibility,
  contents,
  containerParent,
  // should be the last
  questionMark
].flat(1);

// ../../packages-presets/preset-mini/src/shorthands.ts
var shorthands = {
  position: [
    "relative",
    "absolute",
    "fixed",
    "sticky",
    "static"
  ],
  globalKeyword: globalKeywords
};

// ../../packages-presets/preset-mini/src/_theme/colors.ts
var colors = {
  inherit: "inherit",
  current: "currentColor",
  transparent: "transparent",
  black: "#000",
  white: "#fff",
  rose: {
    50: "#fff1f2",
    100: "#ffe4e6",
    200: "#fecdd3",
    300: "#fda4af",
    400: "#fb7185",
    500: "#f43f5e",
    600: "#e11d48",
    700: "#be123c",
    800: "#9f1239",
    900: "#881337",
    950: "#4c0519"
  },
  pink: {
    50: "#fdf2f8",
    100: "#fce7f3",
    200: "#fbcfe8",
    300: "#f9a8d4",
    400: "#f472b6",
    500: "#ec4899",
    600: "#db2777",
    700: "#be185d",
    800: "#9d174d",
    900: "#831843",
    950: "#500724"
  },
  fuchsia: {
    50: "#fdf4ff",
    100: "#fae8ff",
    200: "#f5d0fe",
    300: "#f0abfc",
    400: "#e879f9",
    500: "#d946ef",
    600: "#c026d3",
    700: "#a21caf",
    800: "#86198f",
    900: "#701a75",
    950: "#4a044e"
  },
  purple: {
    50: "#faf5ff",
    100: "#f3e8ff",
    200: "#e9d5ff",
    300: "#d8b4fe",
    400: "#c084fc",
    500: "#a855f7",
    600: "#9333ea",
    700: "#7e22ce",
    800: "#6b21a8",
    900: "#581c87",
    950: "#3b0764"
  },
  violet: {
    50: "#f5f3ff",
    100: "#ede9fe",
    200: "#ddd6fe",
    300: "#c4b5fd",
    400: "#a78bfa",
    500: "#8b5cf6",
    600: "#7c3aed",
    700: "#6d28d9",
    800: "#5b21b6",
    900: "#4c1d95",
    950: "#2e1065"
  },
  indigo: {
    50: "#eef2ff",
    100: "#e0e7ff",
    200: "#c7d2fe",
    300: "#a5b4fc",
    400: "#818cf8",
    500: "#6366f1",
    600: "#4f46e5",
    700: "#4338ca",
    800: "#3730a3",
    900: "#312e81",
    950: "#1e1b4b"
  },
  blue: {
    50: "#eff6ff",
    100: "#dbeafe",
    200: "#bfdbfe",
    300: "#93c5fd",
    400: "#60a5fa",
    500: "#3b82f6",
    600: "#2563eb",
    700: "#1d4ed8",
    800: "#1e40af",
    900: "#1e3a8a",
    950: "#172554"
  },
  sky: {
    50: "#f0f9ff",
    100: "#e0f2fe",
    200: "#bae6fd",
    300: "#7dd3fc",
    400: "#38bdf8",
    500: "#0ea5e9",
    600: "#0284c7",
    700: "#0369a1",
    800: "#075985",
    900: "#0c4a6e",
    950: "#082f49"
  },
  cyan: {
    50: "#ecfeff",
    100: "#cffafe",
    200: "#a5f3fc",
    300: "#67e8f9",
    400: "#22d3ee",
    500: "#06b6d4",
    600: "#0891b2",
    700: "#0e7490",
    800: "#155e75",
    900: "#164e63",
    950: "#083344"
  },
  teal: {
    50: "#f0fdfa",
    100: "#ccfbf1",
    200: "#99f6e4",
    300: "#5eead4",
    400: "#2dd4bf",
    500: "#14b8a6",
    600: "#0d9488",
    700: "#0f766e",
    800: "#115e59",
    900: "#134e4a",
    950: "#042f2e"
  },
  emerald: {
    50: "#ecfdf5",
    100: "#d1fae5",
    200: "#a7f3d0",
    300: "#6ee7b7",
    400: "#34d399",
    500: "#10b981",
    600: "#059669",
    700: "#047857",
    800: "#065f46",
    900: "#064e3b",
    950: "#022c22"
  },
  green: {
    50: "#f0fdf4",
    100: "#dcfce7",
    200: "#bbf7d0",
    300: "#86efac",
    400: "#4ade80",
    500: "#22c55e",
    600: "#16a34a",
    700: "#15803d",
    800: "#166534",
    900: "#14532d",
    950: "#052e16"
  },
  lime: {
    50: "#f7fee7",
    100: "#ecfccb",
    200: "#d9f99d",
    300: "#bef264",
    400: "#a3e635",
    500: "#84cc16",
    600: "#65a30d",
    700: "#4d7c0f",
    800: "#3f6212",
    900: "#365314",
    950: "#1a2e05"
  },
  yellow: {
    50: "#fefce8",
    100: "#fef9c3",
    200: "#fef08a",
    300: "#fde047",
    400: "#facc15",
    500: "#eab308",
    600: "#ca8a04",
    700: "#a16207",
    800: "#854d0e",
    900: "#713f12",
    950: "#422006"
  },
  amber: {
    50: "#fffbeb",
    100: "#fef3c7",
    200: "#fde68a",
    300: "#fcd34d",
    400: "#fbbf24",
    500: "#f59e0b",
    600: "#d97706",
    700: "#b45309",
    800: "#92400e",
    900: "#78350f",
    950: "#451a03"
  },
  orange: {
    50: "#fff7ed",
    100: "#ffedd5",
    200: "#fed7aa",
    300: "#fdba74",
    400: "#fb923c",
    500: "#f97316",
    600: "#ea580c",
    700: "#c2410c",
    800: "#9a3412",
    900: "#7c2d12",
    950: "#431407"
  },
  red: {
    50: "#fef2f2",
    100: "#fee2e2",
    200: "#fecaca",
    300: "#fca5a5",
    400: "#f87171",
    500: "#ef4444",
    600: "#dc2626",
    700: "#b91c1c",
    800: "#991b1b",
    900: "#7f1d1d",
    950: "#450a0a"
  },
  gray: {
    50: "#f9fafb",
    100: "#f3f4f6",
    200: "#e5e7eb",
    300: "#d1d5db",
    400: "#9ca3af",
    500: "#6b7280",
    600: "#4b5563",
    700: "#374151",
    800: "#1f2937",
    900: "#111827",
    950: "#030712"
  },
  slate: {
    50: "#f8fafc",
    100: "#f1f5f9",
    200: "#e2e8f0",
    300: "#cbd5e1",
    400: "#94a3b8",
    500: "#64748b",
    600: "#475569",
    700: "#334155",
    800: "#1e293b",
    900: "#0f172a",
    950: "#020617"
  },
  zinc: {
    50: "#fafafa",
    100: "#f4f4f5",
    200: "#e4e4e7",
    300: "#d4d4d8",
    400: "#a1a1aa",
    500: "#71717a",
    600: "#52525b",
    700: "#3f3f46",
    800: "#27272a",
    900: "#18181b",
    950: "#09090b"
  },
  neutral: {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#e5e5e5",
    300: "#d4d4d4",
    400: "#a3a3a3",
    500: "#737373",
    600: "#525252",
    700: "#404040",
    800: "#262626",
    900: "#171717",
    950: "#0a0a0a"
  },
  stone: {
    50: "#fafaf9",
    100: "#f5f5f4",
    200: "#e7e5e4",
    300: "#d6d3d1",
    400: "#a8a29e",
    500: "#78716c",
    600: "#57534e",
    700: "#44403c",
    800: "#292524",
    900: "#1c1917",
    950: "#0c0a09"
  },
  light: {
    50: "#fdfdfd",
    100: "#fcfcfc",
    200: "#fafafa",
    300: "#f8f9fa",
    400: "#f6f6f6",
    500: "#f2f2f2",
    600: "#f1f3f5",
    700: "#e9ecef",
    800: "#dee2e6",
    900: "#dde1e3",
    950: "#d8dcdf"
  },
  dark: {
    50: "#4a4a4a",
    100: "#3c3c3c",
    200: "#323232",
    300: "#2d2d2d",
    400: "#222222",
    500: "#1f1f1f",
    600: "#1c1c1e",
    700: "#1b1b1b",
    800: "#181818",
    900: "#0f0f0f",
    950: "#080808"
  },
  get lightblue() {
    return this.sky;
  },
  get lightBlue() {
    return this.sky;
  },
  get warmgray() {
    return this.stone;
  },
  get warmGray() {
    return this.stone;
  },
  get truegray() {
    return this.neutral;
  },
  get trueGray() {
    return this.neutral;
  },
  get coolgray() {
    return this.gray;
  },
  get coolGray() {
    return this.gray;
  },
  get bluegray() {
    return this.slate;
  },
  get blueGray() {
    return this.slate;
  }
};
Object.values(colors).forEach((color) => {
  if (typeof color !== "string" && color !== void 0) {
    color.DEFAULT = color.DEFAULT || color[400];
    Object.keys(color).forEach((key) => {
      const short = +key / 100;
      if (short === Math.round(short))
        color[short] = color[key];
    });
  }
});

// ../../packages-presets/preset-mini/src/_theme/filters.ts
var blur = {
  "DEFAULT": "8px",
  "0": "0",
  "sm": "4px",
  "md": "12px",
  "lg": "16px",
  "xl": "24px",
  "2xl": "40px",
  "3xl": "64px"
};
var dropShadow = {
  "DEFAULT": ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"],
  "sm": "0 1px 1px rgb(0 0 0 / 0.05)",
  "md": ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"],
  "lg": ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"],
  "xl": ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"],
  "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
  "none": "0 0 rgb(0 0 0 / 0)"
};

// ../../packages-presets/preset-mini/src/_theme/font.ts
var fontFamily = {
  sans: [
    "ui-sans-serif",
    "system-ui",
    "-apple-system",
    "BlinkMacSystemFont",
    '"Segoe UI"',
    "Roboto",
    '"Helvetica Neue"',
    "Arial",
    '"Noto Sans"',
    "sans-serif",
    '"Apple Color Emoji"',
    '"Segoe UI Emoji"',
    '"Segoe UI Symbol"',
    '"Noto Color Emoji"'
  ].join(","),
  serif: [
    "ui-serif",
    "Georgia",
    "Cambria",
    '"Times New Roman"',
    "Times",
    "serif"
  ].join(","),
  mono: [
    "ui-monospace",
    "SFMono-Regular",
    "Menlo",
    "Monaco",
    "Consolas",
    '"Liberation Mono"',
    '"Courier New"',
    "monospace"
  ].join(",")
};
var fontSize = {
  "xs": ["0.75rem", "1rem"],
  "sm": ["0.875rem", "1.25rem"],
  "base": ["1rem", "1.5rem"],
  "lg": ["1.125rem", "1.75rem"],
  "xl": ["1.25rem", "1.75rem"],
  "2xl": ["1.5rem", "2rem"],
  "3xl": ["1.875rem", "2.25rem"],
  "4xl": ["2.25rem", "2.5rem"],
  "5xl": ["3rem", "1"],
  "6xl": ["3.75rem", "1"],
  "7xl": ["4.5rem", "1"],
  "8xl": ["6rem", "1"],
  "9xl": ["8rem", "1"]
};
var textIndent = {
  "DEFAULT": "1.5rem",
  "xs": "0.5rem",
  "sm": "1rem",
  "md": "1.5rem",
  "lg": "2rem",
  "xl": "2.5rem",
  "2xl": "3rem",
  "3xl": "4rem"
};
var textStrokeWidth = {
  DEFAULT: "1.5rem",
  none: "0",
  sm: "thin",
  md: "medium",
  lg: "thick"
};
var textShadow = {
  DEFAULT: ["0 0 1px rgb(0 0 0 / 0.2)", "0 0 1px rgb(1 0 5 / 0.1)"],
  none: "0 0 rgb(0 0 0 / 0)",
  sm: "1px 1px 3px rgb(36 37 47 / 0.25)",
  md: ["0 1px 2px rgb(30 29 39 / 0.19)", "1px 2px 4px rgb(54 64 147 / 0.18)"],
  lg: ["3px 3px 6px rgb(0 0 0 / 0.26)", "0 0 5px rgb(15 3 86 / 0.22)"],
  xl: ["1px 1px 3px rgb(0 0 0 / 0.29)", "2px 4px 7px rgb(73 64 125 / 0.35)"]
};
var lineHeight = {
  none: "1",
  tight: "1.25",
  snug: "1.375",
  normal: "1.5",
  relaxed: "1.625",
  loose: "2"
};
var letterSpacing = {
  tighter: "-0.05em",
  tight: "-0.025em",
  normal: "0em",
  wide: "0.025em",
  wider: "0.05em",
  widest: "0.1em"
};
var fontWeight = {
  thin: "100",
  extralight: "200",
  light: "300",
  normal: "400",
  medium: "500",
  semibold: "600",
  bold: "700",
  extrabold: "800",
  black: "900"
  // int[0, 900] -> int
};
var wordSpacing = letterSpacing;

// ../../packages-presets/preset-mini/src/_theme/misc.ts
var breakpoints = {
  "sm": "640px",
  "md": "768px",
  "lg": "1024px",
  "xl": "1280px",
  "2xl": "1536px"
};
var verticalBreakpoints = { ...breakpoints };
var lineWidth = {
  DEFAULT: "1px",
  none: "0"
};
var spacing = {
  "DEFAULT": "1rem",
  "none": "0",
  "xs": "0.75rem",
  "sm": "0.875rem",
  "lg": "1.125rem",
  "xl": "1.25rem",
  "2xl": "1.5rem",
  "3xl": "1.875rem",
  "4xl": "2.25rem",
  "5xl": "3rem",
  "6xl": "3.75rem",
  "7xl": "4.5rem",
  "8xl": "6rem",
  "9xl": "8rem"
};
var duration = {
  DEFAULT: "150ms",
  none: "0s",
  75: "75ms",
  100: "100ms",
  150: "150ms",
  200: "200ms",
  300: "300ms",
  500: "500ms",
  700: "700ms",
  1e3: "1000ms"
};
var borderRadius = {
  "DEFAULT": "0.25rem",
  "none": "0",
  "sm": "0.125rem",
  "md": "0.375rem",
  "lg": "0.5rem",
  "xl": "0.75rem",
  "2xl": "1rem",
  "3xl": "1.5rem",
  "full": "9999px"
};
var boxShadow = {
  "DEFAULT": ["var(--un-shadow-inset) 0 1px 3px 0 rgb(0 0 0 / 0.1)", "var(--un-shadow-inset) 0 1px 2px -1px rgb(0 0 0 / 0.1)"],
  "none": "0 0 rgb(0 0 0 / 0)",
  "sm": "var(--un-shadow-inset) 0 1px 2px 0 rgb(0 0 0 / 0.05)",
  "md": ["var(--un-shadow-inset) 0 4px 6px -1px rgb(0 0 0 / 0.1)", "var(--un-shadow-inset) 0 2px 4px -2px rgb(0 0 0 / 0.1)"],
  "lg": ["var(--un-shadow-inset) 0 10px 15px -3px rgb(0 0 0 / 0.1)", "var(--un-shadow-inset) 0 4px 6px -4px rgb(0 0 0 / 0.1)"],
  "xl": ["var(--un-shadow-inset) 0 20px 25px -5px rgb(0 0 0 / 0.1)", "var(--un-shadow-inset) 0 8px 10px -6px rgb(0 0 0 / 0.1)"],
  "2xl": "var(--un-shadow-inset) 0 25px 50px -12px rgb(0 0 0 / 0.25)",
  "inner": "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)"
};
var ringWidth = {
  DEFAULT: "3px",
  none: "0"
};
var zIndex = {
  auto: "auto"
};
var media = {
  mouse: "(hover) and (pointer: fine)"
};

// ../../packages-presets/preset-mini/src/_theme/preflight.ts
var preflightBase = {
  ...transformBase,
  ...boxShadowsBase,
  ...ringBase
};

// ../../packages-presets/preset-mini/src/_theme/size.ts
var baseSize = {
  "xs": "20rem",
  "sm": "24rem",
  "md": "28rem",
  "lg": "32rem",
  "xl": "36rem",
  "2xl": "42rem",
  "3xl": "48rem",
  "4xl": "56rem",
  "5xl": "64rem",
  "6xl": "72rem",
  "7xl": "80rem",
  "prose": "65ch"
};
var width = {
  auto: "auto",
  ...baseSize,
  screen: "100vw"
};
var maxWidth = {
  none: "none",
  ...baseSize,
  screen: "100vw"
};
var blockSize = {
  auto: "auto",
  ...baseSize,
  screen: "100vb"
};
var inlineSize = {
  auto: "auto",
  ...baseSize,
  screen: "100vi"
};
var height = {
  auto: "auto",
  ...baseSize,
  screen: "100vh"
};
var maxHeight = {
  none: "none",
  ...baseSize,
  screen: "100vh"
};
var maxBlockSize = {
  none: "none",
  ...baseSize,
  screen: "100vb"
};
var maxInlineSize = {
  none: "none",
  ...baseSize,
  screen: "100vi"
};
var containers = { ...baseSize };

// ../../packages-presets/preset-mini/src/_theme/transition.ts
var easing = {
  "DEFAULT": "cubic-bezier(0.4, 0, 0.2, 1)",
  "linear": "linear",
  "in": "cubic-bezier(0.4, 0, 1, 1)",
  "out": "cubic-bezier(0, 0, 0.2, 1)",
  "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
};
var transitionProperty = {
  none: "none",
  all: "all",
  colors: ["color", "background-color", "border-color", "text-decoration-color", "fill", "stroke"].join(","),
  opacity: "opacity",
  shadow: "box-shadow",
  transform: "transform",
  get DEFAULT() {
    return [this.colors, "opacity", "box-shadow", "transform", "filter", "backdrop-filter"].join(",");
  }
};

// ../../packages-presets/preset-mini/src/_theme/default.ts
var theme = {
  width,
  height,
  maxWidth,
  maxHeight,
  minWidth: maxWidth,
  minHeight: maxHeight,
  inlineSize,
  blockSize,
  maxInlineSize,
  maxBlockSize,
  minInlineSize: maxInlineSize,
  minBlockSize: maxBlockSize,
  colors,
  fontFamily,
  fontSize,
  fontWeight,
  breakpoints,
  verticalBreakpoints,
  borderRadius,
  lineHeight,
  letterSpacing,
  wordSpacing,
  boxShadow,
  textIndent,
  textShadow,
  textStrokeWidth,
  blur,
  dropShadow,
  easing,
  transitionProperty,
  lineWidth,
  spacing,
  duration,
  ringWidth,
  preflightBase,
  containers,
  zIndex,
  media
};

// ../../packages-presets/preset-mini/src/_variants/aria.ts
var variantAria = {
  name: "aria",
  match(matcher, ctx) {
    var _a3, _b2, _c;
    const variant = variantGetParameter("aria-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const aria = (_c = (_b2 = h.bracket(match)) != null ? _b2 : (_a3 = ctx.theme.aria) == null ? void 0 : _a3[match]) != null ? _c : "";
      if (aria) {
        return {
          matcher: rest,
          selector: (s) => `${s}[aria-${aria}]`
        };
      }
    }
  }
};
function taggedAria(tagName) {
  return {
    name: `${tagName}-aria`,
    match(matcher, ctx) {
      var _a3, _b2, _c;
      const variant = variantGetParameter(`${tagName}-aria-`, matcher, ctx.generator.config.separators);
      if (variant) {
        const [match, rest] = variant;
        const ariaAttribute = (_c = (_b2 = h.bracket(match)) != null ? _b2 : (_a3 = ctx.theme.aria) == null ? void 0 : _a3[match]) != null ? _c : "";
        if (ariaAttribute) {
          return {
            matcher: `${tagName}-[[aria-${ariaAttribute}]]:${rest}`
          };
        }
      }
    }
  };
}
var variantTaggedAriaAttributes = [
  taggedAria("group"),
  taggedAria("peer"),
  taggedAria("parent"),
  taggedAria("previous")
];

// ../../packages-presets/preset-mini/src/_variants/breakpoints.ts
function calcMaxWidthBySize(size) {
  var _a3;
  const value = ((_a3 = size.match(/^-?\d+\.?\d*/)) == null ? void 0 : _a3[0]) || "";
  const unit = size.slice(value.length);
  if (unit === "px") {
    const maxWidth3 = Number.parseFloat(value) - 0.1;
    return Number.isNaN(maxWidth3) ? size : `${maxWidth3}${unit}`;
  }
  return `calc(${size} - 0.1px)`;
}
var sizePseudo = /(max|min)-\[([^\]]*)\]:/;
function variantBreakpoints() {
  const regexCache2 = {};
  return {
    name: "breakpoints",
    match(matcher, context) {
      var _a3;
      if (sizePseudo.test(matcher)) {
        const match = matcher.match(sizePseudo);
        const m = matcher.replace(match[0], "");
        return {
          matcher: m,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (${match[1]}-width: ${match[2]})`
            // parentOrder: order,
          })
        };
      }
      const variantEntries = ((_a3 = resolveBreakpoints(context)) != null ? _a3 : []).map(({ point, size }, idx) => [point, size, idx]);
      for (const [point, size, idx] of variantEntries) {
        if (!regexCache2[point])
          regexCache2[point] = new RegExp(`^((?:([al]t-|[<~]|max-))?${point}(?:${context.generator.config.separators.join("|")}))`);
        const match = matcher.match(regexCache2[point]);
        if (!match)
          continue;
        const [, pre] = match;
        const m = matcher.slice(pre.length);
        if (m === "container")
          continue;
        const isLtPrefix = pre.startsWith("lt-") || pre.startsWith("<") || pre.startsWith("max-");
        const isAtPrefix = pre.startsWith("at-") || pre.startsWith("~");
        let order = 3e3;
        if (isLtPrefix) {
          order -= idx + 1;
          return {
            matcher: m,
            handle: (input, next) => next({
              ...input,
              parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (max-width: ${calcMaxWidthBySize(size)})`,
              parentOrder: order
            })
          };
        }
        order += idx + 1;
        if (isAtPrefix && idx < variantEntries.length - 1) {
          return {
            matcher: m,
            handle: (input, next) => next({
              ...input,
              parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (min-width: ${size}) and (max-width: ${calcMaxWidthBySize(variantEntries[idx + 1][1])})`,
              parentOrder: order
            })
          };
        }
        return {
          matcher: m,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (min-width: ${size})`,
            parentOrder: order
          })
        };
      }
    },
    multiPass: true,
    autocomplete: "(at-|lt-|max-|)$breakpoints:"
  };
}

// ../../packages-presets/preset-mini/src/_variants/children.ts
var variantChildren = [
  variantMatcher("*", (input) => ({ selector: `${input.selector} > *` }))
];

// ../../packages-presets/preset-mini/src/_variants/combinators.ts
function scopeMatcher(name2, combinator) {
  return {
    name: `combinator:${name2}`,
    match(matcher, ctx) {
      var _a3;
      if (!matcher.startsWith(name2))
        return;
      const separators = ctx.generator.config.separators;
      let body = variantGetBracket(`${name2}-`, matcher, separators);
      if (!body) {
        for (const separator of separators) {
          if (matcher.startsWith(`${name2}${separator}`)) {
            body = ["", matcher.slice(name2.length + separator.length)];
            break;
          }
        }
        if (!body)
          return;
      }
      let bracketValue = (_a3 = h.bracket(body[0])) != null ? _a3 : "";
      if (bracketValue === "")
        bracketValue = "*";
      return {
        matcher: body[1],
        selector: (s) => `${s}${combinator}${bracketValue}`
      };
    },
    multiPass: true
  };
}
var variantCombinators = [
  scopeMatcher("all", " "),
  scopeMatcher("children", ">"),
  scopeMatcher("next", "+"),
  scopeMatcher("sibling", "+"),
  scopeMatcher("siblings", "~")
];

// ../../packages-presets/preset-mini/src/_variants/container.ts
var variantContainerQuery = {
  name: "@",
  match(matcher, ctx) {
    var _a3, _b2, _c;
    if (matcher.startsWith("@container"))
      return;
    const variant = variantGetParameter("@", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest, label] = variant;
      const unbracket = h.bracket(match);
      let container2;
      if (unbracket) {
        container2 = h.numberWithUnit(unbracket);
      } else {
        container2 = (_b2 = (_a3 = ctx.theme.containers) == null ? void 0 : _a3[match]) != null ? _b2 : "";
      }
      if (container2) {
        let order = 1e3 + Object.keys((_c = ctx.theme.containers) != null ? _c : {}).indexOf(match);
        if (label)
          order += 1e3;
        return {
          matcher: rest,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@container${label ? ` ${label} ` : " "}(min-width: ${container2})`,
            parentOrder: order
          })
        };
      }
    }
  },
  multiPass: true
};

// ../../packages-presets/preset-mini/src/_variants/dark.ts
function variantColorsMediaOrClass(options = {}) {
  if ((options == null ? void 0 : options.dark) === "class" || typeof options.dark === "object") {
    const { dark = ".dark", light = ".light" } = typeof options.dark === "string" ? {} : options.dark;
    return [
      variantMatcher("dark", toArray2(dark).map((dark2) => (input) => ({ prefix: `${dark2} $$ ${input.prefix}` }))),
      variantMatcher("light", toArray2(light).map((light2) => (input) => ({ prefix: `${light2} $$ ${input.prefix}` })))
    ];
  }
  return [
    variantParentMatcher("dark", "@media (prefers-color-scheme: dark)"),
    variantParentMatcher("light", "@media (prefers-color-scheme: light)")
  ];
}

// ../../packages-presets/preset-mini/src/_variants/data.ts
var variantDataAttribute = {
  name: "data",
  match(matcher, ctx) {
    var _a3, _b2, _c;
    const variant = variantGetParameter("data-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const dataAttribute = (_c = (_b2 = h.bracket(match)) != null ? _b2 : (_a3 = ctx.theme.data) == null ? void 0 : _a3[match]) != null ? _c : "";
      if (dataAttribute) {
        return {
          matcher: rest,
          selector: (s) => `${s}[data-${dataAttribute}]`
        };
      }
    }
  }
};
function taggedData(tagName) {
  return {
    name: `${tagName}-data`,
    match(matcher, ctx) {
      var _a3, _b2, _c;
      const variant = variantGetParameter(`${tagName}-data-`, matcher, ctx.generator.config.separators);
      if (variant) {
        const [match, rest, label] = variant;
        const dataAttribute = (_c = (_b2 = h.bracket(match)) != null ? _b2 : (_a3 = ctx.theme.data) == null ? void 0 : _a3[match]) != null ? _c : "";
        if (dataAttribute) {
          return {
            matcher: `${tagName}-[[data-${dataAttribute}]]${label ? `/${label}` : ""}:${rest}`
          };
        }
      }
    }
  };
}
var variantTaggedDataAttributes = [
  taggedData("group"),
  taggedData("peer"),
  taggedData("parent"),
  taggedData("previous")
];

// ../../packages-presets/preset-mini/src/_variants/directions.ts
var variantLanguageDirections = [
  variantMatcher("rtl", (input) => ({ prefix: `[dir="rtl"] $$ ${input.prefix}` })),
  variantMatcher("ltr", (input) => ({ prefix: `[dir="ltr"] $$ ${input.prefix}` }))
];

// ../../packages-presets/preset-mini/src/_variants/important.ts
function variantImportant() {
  let re;
  return {
    name: "important",
    match(matcher, ctx) {
      if (!re)
        re = new RegExp(`^(important(?:${ctx.generator.config.separators.join("|")})|!)`);
      let base;
      const match = matcher.match(re);
      if (match)
        base = matcher.slice(match[0].length);
      else if (matcher.endsWith("!"))
        base = matcher.slice(0, -1);
      if (base) {
        return {
          matcher: base,
          body: (body) => {
            body.forEach((v) => {
              if (v[1] != null)
                v[1] += " !important";
            });
            return body;
          }
        };
      }
    }
  };
}

// ../../packages-presets/preset-mini/src/_variants/media.ts
var variantPrint = variantParentMatcher("print", "@media print");
var variantCustomMedia = {
  name: "media",
  match(matcher, ctx) {
    var _a3, _b2, _c;
    const variant = variantGetParameter("media-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      let media3 = (_a3 = h.bracket(match)) != null ? _a3 : "";
      if (media3 === "")
        media3 = (_c = (_b2 = ctx.theme.media) == null ? void 0 : _b2[match]) != null ? _c : "";
      if (media3) {
        return {
          matcher: rest,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@media ${media3}`
          })
        };
      }
    }
  },
  multiPass: true
};

// ../../packages-presets/preset-mini/src/_variants/misc.ts
var variantSelector = {
  name: "selector",
  match(matcher, ctx) {
    const variant = variantGetBracket("selector-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const selector = h.bracket(match);
      if (selector) {
        return {
          matcher: rest,
          selector: () => selector
        };
      }
    }
  }
};
var variantCssLayer = {
  name: "layer",
  match(matcher, ctx) {
    var _a3;
    const variant = variantGetParameter("layer-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const layer = (_a3 = h.bracket(match)) != null ? _a3 : match;
      if (layer) {
        return {
          matcher: rest,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@layer ${layer}`
          })
        };
      }
    }
  }
};
var variantInternalLayer = {
  name: "uno-layer",
  match(matcher, ctx) {
    var _a3;
    const variant = variantGetParameter("uno-layer-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const layer = (_a3 = h.bracket(match)) != null ? _a3 : match;
      if (layer) {
        return {
          matcher: rest,
          layer
        };
      }
    }
  }
};
var variantScope = {
  name: "scope",
  match(matcher, ctx) {
    const variant = variantGetBracket("scope-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const scope = h.bracket(match);
      if (scope) {
        return {
          matcher: rest,
          selector: (s) => `${scope} $$ ${s}`
        };
      }
    }
  }
};
var variantVariables = {
  name: "variables",
  match(matcher, ctx) {
    var _a3, _b2;
    if (!matcher.startsWith("["))
      return;
    const [match, rest] = (_a3 = getBracket(matcher, "[", "]")) != null ? _a3 : [];
    if (!(match && rest))
      return;
    let newMatcher;
    for (const separator of ctx.generator.config.separators) {
      if (rest.startsWith(separator)) {
        newMatcher = rest.slice(separator.length);
        break;
      }
    }
    if (newMatcher == null)
      return;
    const variant = (_b2 = h.bracket(match)) != null ? _b2 : "";
    const useParent = variant.startsWith("@");
    if (!(useParent || variant.includes("&")))
      return;
    return {
      matcher: newMatcher,
      handle(input, next) {
        const updates = useParent ? {
          parent: `${input.parent ? `${input.parent} $$ ` : ""}${variant}`
        } : {
          selector: variant.replace(/&/g, input.selector)
        };
        return next({
          ...input,
          ...updates
        });
      }
    };
  },
  multiPass: true
};
var variantTheme = {
  name: "theme-variables",
  match(matcher, ctx) {
    if (!hasThemeFn(matcher))
      return;
    return {
      matcher,
      handle(input, next) {
        return next({
          ...input,
          //  entries: [ [ '--css-spacing', '28px' ] ],
          entries: JSON.parse(transformThemeFn(JSON.stringify(input.entries), ctx.theme))
        });
      }
    };
  }
};

// ../../packages-presets/preset-mini/src/_variants/negative.ts
var anchoredNumberRE = /^-?[0-9.]+(?:[a-z]+|%)?$/;
var numberRE2 = /-?[0-9.]+(?:[a-z]+|%)?/;
var ignoreProps = [
  /\b(opacity|color|flex|backdrop-filter|^filter|transform)\b/
];
function negateMathFunction(value) {
  var _a3;
  const match = value.match(cssMathFnRE) || value.match(cssVarFnRE);
  if (match) {
    const [fnBody, rest] = (_a3 = getStringComponent(`(${match[2]})${match[3]}`, "(", ")", " ")) != null ? _a3 : [];
    if (fnBody)
      return `calc(${match[1]}${fnBody} * -1)${rest ? ` ${rest}` : ""}`;
  }
}
var negateFunctionBodyRE = /\b(hue-rotate)\s*(\(.*)/;
function negateFunctionBody(value) {
  var _a3;
  const match = value.match(negateFunctionBodyRE);
  if (match) {
    const [fnBody, rest] = (_a3 = getStringComponent(match[2], "(", ")", " ")) != null ? _a3 : [];
    if (fnBody) {
      const body = anchoredNumberRE.test(fnBody.slice(1, -1)) ? fnBody.replace(numberRE2, (i) => i.startsWith("-") ? i.slice(1) : `-${i}`) : `(calc(${fnBody} * -1))`;
      return `${match[1]}${body}${rest ? ` ${rest}` : ""}`;
    }
  }
}
var variantNegative = {
  name: "negative",
  match(matcher) {
    if (!matcher.startsWith("-"))
      return;
    return {
      matcher: matcher.slice(1),
      body: (body) => {
        if (body.find((v) => v[0] === CONTROL_MINI_NO_NEGATIVE))
          return;
        let changed = false;
        body.forEach((v) => {
          var _a3;
          const value = (_a3 = v[1]) == null ? void 0 : _a3.toString();
          if (!value || value === "0")
            return;
          if (ignoreProps.some((i) => i.test(v[0])))
            return;
          const negatedFn = negateMathFunction(value);
          if (negatedFn) {
            v[1] = negatedFn;
            changed = true;
            return;
          }
          const negatedBody = negateFunctionBody(value);
          if (negatedBody) {
            v[1] = negatedBody;
            changed = true;
            return;
          }
          if (anchoredNumberRE.test(value)) {
            v[1] = value.replace(numberRE2, (i) => i.startsWith("-") ? i.slice(1) : `-${i}`);
            changed = true;
          }
        });
        if (changed)
          return body;
        return [];
      }
    };
  }
};

// ../../packages-presets/preset-mini/src/_variants/pseudo.ts
var PseudoClasses = Object.fromEntries([
  // pseudo elements part 1
  ["first-letter", "::first-letter"],
  ["first-line", "::first-line"],
  // location
  "any-link",
  "link",
  "visited",
  "target",
  ["open", "[open]"],
  // forms
  "default",
  "checked",
  "indeterminate",
  "placeholder-shown",
  "autofill",
  "optional",
  "required",
  "valid",
  "invalid",
  "user-valid",
  "user-invalid",
  "in-range",
  "out-of-range",
  "read-only",
  "read-write",
  // content
  "empty",
  // interactions
  "focus-within",
  "hover",
  "focus",
  "focus-visible",
  "active",
  "enabled",
  "disabled",
  "popover-open",
  // tree-structural
  "root",
  "empty",
  ["even-of-type", ":nth-of-type(even)"],
  ["even", ":nth-child(even)"],
  ["odd-of-type", ":nth-of-type(odd)"],
  ["odd", ":nth-child(odd)"],
  "first-of-type",
  ["first", ":first-child"],
  "last-of-type",
  ["last", ":last-child"],
  "only-child",
  "only-of-type",
  // pseudo elements part 2
  ["backdrop-element", "::backdrop"],
  ["placeholder", "::placeholder"],
  ["before", "::before"],
  ["after", "::after"],
  ["file", "::file-selector-button"]
].map((key) => Array.isArray(key) ? key : [key, `:${key}`]));
var PseudoClassesKeys = Object.keys(PseudoClasses);
var PseudoClassesColon = Object.fromEntries([
  ["backdrop", "::backdrop"]
].map((key) => Array.isArray(key) ? key : [key, `:${key}`]));
var PseudoClassesColonKeys = Object.keys(PseudoClassesColon);
var PseudoClassFunctions = [
  "not",
  "is",
  "where",
  "has"
];
var PseudoClassesMulti = Object.fromEntries([
  ["selection", ["::selection", " *::selection"]],
  ["marker", ["::marker", " *::marker"]]
]);
var PseudoClassesStr = Object.entries(PseudoClasses).filter(([, pseudo]) => !pseudo.startsWith("::")).map(([key]) => key).sort((a, b) => b.length - a.length).join("|");
var PseudoClassesColonStr = Object.entries(PseudoClassesColon).filter(([, pseudo]) => !pseudo.startsWith("::")).map(([key]) => key).sort((a, b) => b.length - a.length).join("|");
var PseudoClassFunctionsStr = PseudoClassFunctions.join("|");
var PseudoClassesMultiStr = Object.keys(PseudoClassesMulti).sort((a, b) => b.length - a.length).join("|");
function taggedPseudoClassMatcher(tag, parent, combinator) {
  const rawRE = new RegExp(`^(${escapeRegExp(parent)}:)(\\S+)${escapeRegExp(combinator)}\\1`);
  let splitRE;
  let pseudoRE;
  let pseudoColonRE;
  let pseudoVarRE;
  const matchBracket = (input) => {
    var _a3, _b2;
    const body = variantGetBracket(`${tag}-`, input, []);
    if (!body)
      return;
    const [match, rest] = body;
    const bracketValue = h.bracket(match);
    if (bracketValue == null)
      return;
    const label = (_b2 = (_a3 = rest.split(splitRE, 1)) == null ? void 0 : _a3[0]) != null ? _b2 : "";
    const prefix = `${parent}${escapeSelector(label)}`;
    return [
      label,
      input.slice(input.length - (rest.length - label.length - 1)),
      bracketValue.includes("&") ? bracketValue.replace(/&/g, prefix) : `${prefix}${bracketValue}`
    ];
  };
  const matchPseudo = (input) => {
    var _a3;
    const match = input.match(pseudoRE) || input.match(pseudoColonRE);
    if (!match)
      return;
    const [original, fn, pseudoKey] = match;
    const label = (_a3 = match[3]) != null ? _a3 : "";
    let pseudo = PseudoClasses[pseudoKey] || PseudoClassesColon[pseudoKey] || `:${pseudoKey}`;
    if (fn)
      pseudo = `:${fn}(${pseudo})`;
    return [
      label,
      input.slice(original.length),
      `${parent}${escapeSelector(label)}${pseudo}`,
      pseudoKey
    ];
  };
  const matchPseudoVar = (input) => {
    var _a3;
    const match = input.match(pseudoVarRE);
    if (!match)
      return;
    const [original, fn, pseudoValue] = match;
    const label = (_a3 = match[3]) != null ? _a3 : "";
    const pseudo = `:${fn}(${pseudoValue})`;
    return [
      label,
      input.slice(original.length),
      `${parent}${escapeSelector(label)}${pseudo}`
    ];
  };
  return {
    name: `pseudo:${tag}`,
    match(input, ctx) {
      if (!(splitRE && pseudoRE && pseudoColonRE)) {
        splitRE = new RegExp(`(?:${ctx.generator.config.separators.join("|")})`);
        pseudoRE = new RegExp(`^${tag}-(?:(?:(${PseudoClassFunctionsStr})-)?(${PseudoClassesStr}))(?:(/\\w+))?(?:${ctx.generator.config.separators.join("|")})`);
        pseudoColonRE = new RegExp(`^${tag}-(?:(?:(${PseudoClassFunctionsStr})-)?(${PseudoClassesColonStr}))(?:(/\\w+))?(?:${ctx.generator.config.separators.filter((x2) => x2 !== "-").join("|")})`);
        pseudoVarRE = new RegExp(`^${tag}-(?:(${PseudoClassFunctionsStr})-)?\\[(.+)\\](?:(/\\w+))?(?:${ctx.generator.config.separators.filter((x2) => x2 !== "-").join("|")})`);
      }
      if (!input.startsWith(tag))
        return;
      const result = matchBracket(input) || matchPseudo(input) || matchPseudoVar(input);
      if (!result)
        return;
      const [_label, matcher, prefix, pseudoName = ""] = result;
      return {
        matcher,
        handle: (input2, next) => {
          var _a3;
          return next({
            ...input2,
            prefix: `${prefix}${combinator}${input2.prefix}`.replace(rawRE, "$1$2:"),
            sort: (_a3 = PseudoClassesKeys.indexOf(pseudoName)) != null ? _a3 : PseudoClassesColonKeys.indexOf(pseudoName)
          });
        }
      };
    },
    multiPass: true
  };
}
var excludedPseudo = [
  "::-webkit-resizer",
  "::-webkit-scrollbar",
  "::-webkit-scrollbar-button",
  "::-webkit-scrollbar-corner",
  "::-webkit-scrollbar-thumb",
  "::-webkit-scrollbar-track",
  "::-webkit-scrollbar-track-piece",
  "::file-selector-button"
];
var PseudoClassesAndElementsStr = Object.entries(PseudoClasses).map(([key]) => key).sort((a, b) => b.length - a.length).join("|");
var PseudoClassesAndElementsColonStr = Object.entries(PseudoClassesColon).map(([key]) => key).sort((a, b) => b.length - a.length).join("|");
function variantPseudoClassesAndElements() {
  let PseudoClassesAndElementsRE;
  let PseudoClassesAndElementsColonRE;
  let PseudoClassesMultiRE;
  return [
    {
      name: "pseudo",
      match(input, ctx) {
        if (!(PseudoClassesAndElementsRE && PseudoClassesAndElementsColonRE)) {
          PseudoClassesAndElementsRE = new RegExp(`^(${PseudoClassesAndElementsStr})(?:${ctx.generator.config.separators.join("|")})`);
          PseudoClassesAndElementsColonRE = new RegExp(`^(${PseudoClassesAndElementsColonStr})(?:${ctx.generator.config.separators.filter((x2) => x2 !== "-").join("|")})`);
        }
        const match = input.match(PseudoClassesAndElementsRE) || input.match(PseudoClassesAndElementsColonRE);
        if (match) {
          const pseudo = PseudoClasses[match[1]] || PseudoClassesColon[match[1]] || `:${match[1]}`;
          let index = PseudoClassesKeys.indexOf(match[1]);
          if (index === -1)
            index = PseudoClassesColonKeys.indexOf(match[1]);
          if (index === -1)
            index = void 0;
          return {
            matcher: input.slice(match[0].length),
            handle: (input2, next) => {
              const selectors = pseudo.includes("::") && !excludedPseudo.includes(pseudo) ? {
                pseudo: `${input2.pseudo}${pseudo}`
              } : {
                selector: `${input2.selector}${pseudo}`
              };
              return next({
                ...input2,
                ...selectors,
                sort: index,
                noMerge: true
              });
            }
          };
        }
      },
      multiPass: true,
      autocomplete: `(${PseudoClassesAndElementsStr}|${PseudoClassesAndElementsColonStr}):`
    },
    {
      name: "pseudo:multi",
      match(input, ctx) {
        if (!PseudoClassesMultiRE) {
          PseudoClassesMultiRE = new RegExp(`^(${PseudoClassesMultiStr})(?:${ctx.generator.config.separators.join("|")})`);
        }
        const match = input.match(PseudoClassesMultiRE);
        if (match) {
          const pseudos = PseudoClassesMulti[match[1]];
          return pseudos.map((pseudo) => {
            return {
              matcher: input.slice(match[0].length),
              handle: (input2, next) => next({
                ...input2,
                pseudo: `${input2.pseudo}${pseudo}`
              })
            };
          });
        }
      },
      multiPass: false,
      autocomplete: `(${PseudoClassesMultiStr}):`
    }
  ];
}
function variantPseudoClassFunctions() {
  let PseudoClassFunctionsRE;
  let PseudoClassColonFunctionsRE;
  let PseudoClassVarFunctionRE;
  return {
    match(input, ctx) {
      if (!(PseudoClassFunctionsRE && PseudoClassColonFunctionsRE)) {
        PseudoClassFunctionsRE = new RegExp(`^(${PseudoClassFunctionsStr})-(${PseudoClassesStr})(?:${ctx.generator.config.separators.join("|")})`);
        PseudoClassColonFunctionsRE = new RegExp(`^(${PseudoClassFunctionsStr})-(${PseudoClassesColonStr})(?:${ctx.generator.config.separators.filter((x2) => x2 !== "-").join("|")})`);
        PseudoClassVarFunctionRE = new RegExp(`^(${PseudoClassFunctionsStr})-(\\[.+\\])(?:${ctx.generator.config.separators.filter((x2) => x2 !== "-").join("|")})`);
      }
      const match = input.match(PseudoClassFunctionsRE) || input.match(PseudoClassColonFunctionsRE) || input.match(PseudoClassVarFunctionRE);
      if (match) {
        const fn = match[1];
        const fnVal = getBracket(match[2], "[", "]");
        const pseudo = fnVal ? h.bracket(match[2]) : PseudoClasses[match[2]] || PseudoClassesColon[match[2]] || `:${match[2]}`;
        return {
          matcher: input.slice(match[0].length),
          selector: (s) => `${s}:${fn}(${pseudo})`
        };
      }
    },
    multiPass: true,
    autocomplete: `(${PseudoClassFunctionsStr})-(${PseudoClassesStr}|${PseudoClassesColonStr}):`
  };
}
function variantTaggedPseudoClasses(options = {}) {
  var _a3, _b2;
  const attributify = !!(options == null ? void 0 : options.attributifyPseudo);
  let firstPrefix = (_a3 = options == null ? void 0 : options.prefix) != null ? _a3 : "";
  firstPrefix = (_b2 = (Array.isArray(firstPrefix) ? firstPrefix : [firstPrefix]).filter(Boolean)[0]) != null ? _b2 : "";
  const tagWithPrefix = (tag, combinator) => taggedPseudoClassMatcher(tag, attributify ? `[${firstPrefix}${tag}=""]` : `.${firstPrefix}${tag}`, combinator);
  return [
    tagWithPrefix("group", " "),
    tagWithPrefix("peer", "~"),
    tagWithPrefix("parent", ">"),
    tagWithPrefix("previous", "+"),
    tagWithPrefix("group-aria", " "),
    tagWithPrefix("peer-aria", "~"),
    tagWithPrefix("parent-aria", ">"),
    tagWithPrefix("previous-aria", "+")
  ];
}
var PartClassesRE = /(part-\[(.+)\]:)(.+)/;
var variantPartClasses = {
  match(input) {
    const match = input.match(PartClassesRE);
    if (match) {
      const part = `part(${match[2]})`;
      return {
        matcher: input.slice(match[1].length),
        selector: (s) => `${s}::${part}`
      };
    }
  },
  multiPass: true
};

// ../../packages-presets/preset-mini/src/_variants/startingstyle.ts
var variantStartingStyle = {
  name: "starting",
  match(matcher) {
    if (!matcher.startsWith("starting:"))
      return;
    return {
      matcher: matcher.slice(9),
      handle: (input, next) => next({
        ...input,
        parent: `@starting-style`
      })
    };
  }
};

// ../../packages-presets/preset-mini/src/_variants/supports.ts
var variantSupports = {
  name: "supports",
  match(matcher, ctx) {
    var _a3, _b2, _c;
    const variant = variantGetParameter("supports-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      let supports = (_a3 = h.bracket(match)) != null ? _a3 : "";
      if (supports === "")
        supports = (_c = (_b2 = ctx.theme.supports) == null ? void 0 : _b2[match]) != null ? _c : "";
      if (supports) {
        return {
          matcher: rest,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@supports ${supports}`
          })
        };
      }
    }
  },
  multiPass: true
};

// ../../packages-presets/preset-mini/src/_variants/default.ts
function variants(options) {
  return [
    variantAria,
    variantDataAttribute,
    variantCssLayer,
    variantSelector,
    variantInternalLayer,
    variantNegative,
    variantStartingStyle,
    variantImportant(),
    variantSupports,
    variantPrint,
    variantCustomMedia,
    variantBreakpoints(),
    ...variantCombinators,
    ...variantPseudoClassesAndElements(),
    variantPseudoClassFunctions(),
    ...variantTaggedPseudoClasses(options),
    variantPartClasses,
    ...variantColorsMediaOrClass(options),
    ...variantLanguageDirections,
    variantScope,
    ...variantChildren,
    variantContainerQuery,
    variantVariables,
    ...variantTaggedDataAttributes,
    ...variantTaggedAriaAttributes,
    variantTheme
  ];
}

// ../../packages-presets/preset-mini/src/index.ts
var presetMini = definePreset((options = {}) => {
  var _a3, _b2, _c, _d;
  options.dark = (_a3 = options.dark) != null ? _a3 : "class";
  options.attributifyPseudo = (_b2 = options.attributifyPseudo) != null ? _b2 : false;
  options.preflight = (_c = options.preflight) != null ? _c : true;
  options.variablePrefix = (_d = options.variablePrefix) != null ? _d : "un-";
  return {
    name: "@unocss/preset-mini",
    theme,
    rules,
    variants: variants(options),
    options,
    prefix: options.prefix,
    postprocess: VarPrefixPostprocessor(options.variablePrefix),
    preflights: preflights(options),
    extractorDefault: options.arbitraryVariants === false ? void 0 : extractorArbitraryVariants(),
    autocomplete: {
      shorthands
    }
  };
});
var src_default = presetMini;
function VarPrefixPostprocessor(prefix) {
  if (prefix !== "un-") {
    return (obj) => {
      obj.entries.forEach((i) => {
        i[0] = i[0].replace(/^--un-/, `--${prefix}`);
        if (typeof i[1] === "string")
          i[1] = i[1].replace(/var\(--un-/g, `var(--${prefix}`);
      });
    };
  }
}

// ../../packages-presets/preset-wind3/src/postprocessors/important.ts
function important(option) {
  if (option == null || option === false)
    return [];
  const wrapWithIs = (selector) => {
    if (selector.startsWith(":is(") && selector.endsWith(")"))
      return selector;
    if (selector.includes("::"))
      return selector.replace(/(.*?)((?:\s\*)?::.*)/, ":is($1)$2");
    return `:is(${selector})`;
  };
  return [
    option === true ? (util) => {
      util.entries.forEach((i) => {
        if (i[1] != null && !String(i[1]).endsWith("!important"))
          i[1] += " !important";
      });
    } : (util) => {
      if (!util.selector.startsWith(option))
        util.selector = `${option} ${wrapWithIs(util.selector)}`;
    }
  ];
}

// ../../packages-presets/preset-wind3/src/postprocessors/default.ts
function postprocessors(options) {
  return [
    ...toArray2(src_default(options).postprocess),
    ...important(options.important)
  ];
}

// ../../packages-presets/preset-mini/dist/shared/preset-mini.Q9MCfKj3.mjs
var directionMap2 = {
  "l": ["-left"],
  "r": ["-right"],
  "t": ["-top"],
  "b": ["-bottom"],
  "s": ["-inline-start"],
  "e": ["-inline-end"],
  "x": ["-left", "-right"],
  "y": ["-top", "-bottom"],
  "": [""],
  "bs": ["-block-start"],
  "be": ["-block-end"],
  "is": ["-inline-start"],
  "ie": ["-inline-end"],
  "block": ["-block-start", "-block-end"],
  "inline": ["-inline-start", "-inline-end"]
};
var insetMap2 = {
  ...directionMap2,
  s: ["-inset-inline-start"],
  start: ["-inset-inline-start"],
  e: ["-inset-inline-end"],
  end: ["-inset-inline-end"],
  bs: ["-inset-block-start"],
  be: ["-inset-block-end"],
  is: ["-inset-inline-start"],
  ie: ["-inset-inline-end"],
  block: ["-inset-block-start", "-inset-block-end"],
  inline: ["-inset-inline-start", "-inset-inline-end"]
};
var cornerMap2 = {
  "l": ["-top-left", "-bottom-left"],
  "r": ["-top-right", "-bottom-right"],
  "t": ["-top-left", "-top-right"],
  "b": ["-bottom-left", "-bottom-right"],
  "tl": ["-top-left"],
  "lt": ["-top-left"],
  "tr": ["-top-right"],
  "rt": ["-top-right"],
  "bl": ["-bottom-left"],
  "lb": ["-bottom-left"],
  "br": ["-bottom-right"],
  "rb": ["-bottom-right"],
  "": [""],
  "bs": ["-start-start", "-start-end"],
  "be": ["-end-start", "-end-end"],
  "s": ["-end-start", "-start-start"],
  "is": ["-end-start", "-start-start"],
  "e": ["-start-end", "-end-end"],
  "ie": ["-start-end", "-end-end"],
  "ss": ["-start-start"],
  "bs-is": ["-start-start"],
  "is-bs": ["-start-start"],
  "se": ["-start-end"],
  "bs-ie": ["-start-end"],
  "ie-bs": ["-start-end"],
  "es": ["-end-start"],
  "be-is": ["-end-start"],
  "is-be": ["-end-start"],
  "ee": ["-end-end"],
  "be-ie": ["-end-end"],
  "ie-be": ["-end-end"]
};
var xyzMap2 = {
  "x": ["-x"],
  "y": ["-y"],
  "z": ["-z"],
  "": ["-x", "-y"]
};
var xyzArray2 = ["x", "y", "z"];
var basePositionMap2 = [
  "top",
  "top center",
  "top left",
  "top right",
  "bottom",
  "bottom center",
  "bottom left",
  "bottom right",
  "left",
  "left center",
  "left top",
  "left bottom",
  "right",
  "right center",
  "right top",
  "right bottom",
  "center",
  "center top",
  "center bottom",
  "center left",
  "center right",
  "center center"
];
var positionMap2 = Object.assign(
  {},
  ...basePositionMap2.map((p) => ({ [p.replace(/ /, "-")]: p })),
  ...basePositionMap2.map((p) => ({ [p.replace(/\b(\w)\w+/g, "$1").replace(/ /, "")]: p }))
);
var globalKeywords2 = [
  "inherit",
  "initial",
  "revert",
  "revert-layer",
  "unset"
];
var cssMathFnRE2 = /^(calc|clamp|min|max)\s*\((.+)\)(.*)/;
var cssVarFnRE2 = /^(var)\s*\((.+)\)(.*)/;
var numberWithUnitRE2 = /^(-?\d*(?:\.\d+)?)(px|pt|pc|%|r?(?:em|ex|lh|cap|ch|ic)|(?:[sld]?v|cq)(?:[whib]|min|max)|in|cm|mm|rpx)?$/i;
var numberRE3 = /^(-?\d*(?:\.\d+)?)$/;
var unitOnlyRE2 = /^(px|[sld]?v[wh])$/i;
var unitOnlyMap2 = {
  px: 1,
  vw: 100,
  vh: 100,
  svw: 100,
  svh: 100,
  dvw: 100,
  dvh: 100,
  lvh: 100,
  lvw: 100
};
var bracketTypeRe2 = /^\[(color|image|length|size|position|quoted|string):/i;
var splitComma2 = /,(?![^()]*\))/g;
var cssProps2 = [
  // basic props
  "color",
  "border-color",
  "background-color",
  "outline-color",
  "text-decoration-color",
  "flex-grow",
  "flex",
  "flex-shrink",
  "caret-color",
  "font",
  "gap",
  "opacity",
  "visibility",
  "z-index",
  "font-weight",
  "zoom",
  "text-shadow",
  "transform",
  "box-shadow",
  "border",
  // positions
  "background-position",
  "left",
  "right",
  "top",
  "bottom",
  "object-position",
  // sizes
  "max-height",
  "min-height",
  "max-width",
  "min-width",
  "height",
  "width",
  "border-width",
  "margin",
  "padding",
  "outline-width",
  "outline-offset",
  "font-size",
  "line-height",
  "text-indent",
  "vertical-align",
  "border-spacing",
  "letter-spacing",
  "word-spacing",
  // enhances
  "stroke",
  "filter",
  "backdrop-filter",
  "fill",
  "mask",
  "mask-size",
  "mask-border",
  "clip-path",
  "clip",
  "border-radius"
];
function round2(n2) {
  return +n2.toFixed(10);
}
function numberWithUnit2(str) {
  const match = str.match(numberWithUnitRE2);
  if (!match)
    return;
  const [, n2, unit] = match;
  const num = Number.parseFloat(n2);
  if (unit && !Number.isNaN(num))
    return `${round2(num)}${unit}`;
}
function auto2(str) {
  if (str === "auto" || str === "a")
    return "auto";
}
function rem2(str) {
  if (!str)
    return;
  if (unitOnlyRE2.test(str))
    return `${unitOnlyMap2[str]}${str}`;
  const match = str.match(numberWithUnitRE2);
  if (!match)
    return;
  const [, n2, unit] = match;
  const num = Number.parseFloat(n2);
  if (!Number.isNaN(num)) {
    if (num === 0)
      return "0";
    return unit ? `${round2(num)}${unit}` : `${round2(num / 4)}rem`;
  }
}
function px2(str) {
  if (unitOnlyRE2.test(str))
    return `${unitOnlyMap2[str]}${str}`;
  const match = str.match(numberWithUnitRE2);
  if (!match)
    return;
  const [, n2, unit] = match;
  const num = Number.parseFloat(n2);
  if (!Number.isNaN(num))
    return unit ? `${round2(num)}${unit}` : `${round2(num)}px`;
}
function number2(str) {
  if (!numberRE3.test(str))
    return;
  const num = Number.parseFloat(str);
  if (!Number.isNaN(num))
    return round2(num);
}
function percent2(str) {
  if (str.endsWith("%"))
    str = str.slice(0, -1);
  if (!numberRE3.test(str))
    return;
  const num = Number.parseFloat(str);
  if (!Number.isNaN(num))
    return `${round2(num / 100)}`;
}
function fraction2(str) {
  if (!str)
    return;
  if (str === "full")
    return "100%";
  const [left, right] = str.split("/");
  const num = Number.parseFloat(left) / Number.parseFloat(right);
  if (!Number.isNaN(num)) {
    if (num === 0)
      return "0";
    return `${round2(num * 100)}%`;
  }
}
function bracketWithType2(str, requiredType) {
  if (str && str.startsWith("[") && str.endsWith("]")) {
    let base;
    let hintedType;
    const match = str.match(bracketTypeRe2);
    if (!match) {
      base = str.slice(1, -1);
    } else {
      if (!requiredType)
        hintedType = match[1];
      base = str.slice(match[0].length, -1);
    }
    if (!base)
      return;
    if (base === '=""')
      return;
    if (base.startsWith("--"))
      base = `var(${base})`;
    let curly = 0;
    for (const i of base) {
      if (i === "[") {
        curly += 1;
      } else if (i === "]") {
        curly -= 1;
        if (curly < 0)
          return;
      }
    }
    if (curly)
      return;
    switch (hintedType) {
      case "string":
        return base.replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_");
      case "quoted":
        return base.replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_").replace(/(["\\])/g, "\\$1").replace(/^(.+)$/, '"$1"');
    }
    return base.replace(/(url\(.*?\))/g, (v) => v.replace(/_/g, "\\_")).replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_").replace(/(?:calc|clamp|max|min)\((.*)/g, (match2) => {
      const vars = [];
      return match2.replace(/var\((--.+?)[,)]/g, (match3, g1) => {
        vars.push(g1);
        return match3.replace(g1, "--un-calc");
      }).replace(/(-?\d*\.?\d(?!-\d.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ").replace(/--un-calc/g, () => vars.shift());
    });
  }
}
function bracket2(str) {
  return bracketWithType2(str);
}
function bracketOfColor2(str) {
  return bracketWithType2(str, "color");
}
function bracketOfLength2(str) {
  return bracketWithType2(str, "length");
}
function bracketOfPosition2(str) {
  return bracketWithType2(str, "position");
}
function cssvar2(str) {
  if (/^\$[^\s'"`;{}]/.test(str)) {
    const [name2, defaultValue] = str.slice(1).split(",");
    return `var(--${escapeSelector(name2)}${defaultValue ? `, ${defaultValue}` : ""})`;
  }
}
function time2(str) {
  const match = str.match(/^(-?[0-9.]+)(s|ms)?$/i);
  if (!match)
    return;
  const [, n2, unit] = match;
  const num = Number.parseFloat(n2);
  if (!Number.isNaN(num)) {
    if (num === 0 && !unit)
      return "0s";
    return unit ? `${round2(num)}${unit}` : `${round2(num)}ms`;
  }
}
function degree2(str) {
  const match = str.match(/^(-?[0-9.]+)(deg|rad|grad|turn)?$/i);
  if (!match)
    return;
  const [, n2, unit] = match;
  const num = Number.parseFloat(n2);
  if (!Number.isNaN(num)) {
    if (num === 0)
      return "0";
    return unit ? `${round2(num)}${unit}` : `${round2(num)}deg`;
  }
}
function global3(str) {
  if (globalKeywords2.includes(str))
    return str;
}
function properties2(str) {
  if (str.split(",").every((prop) => cssProps2.includes(prop)))
    return str;
}
function position2(str) {
  if (["top", "left", "right", "bottom", "center"].includes(str))
    return str;
}
var valueHandlers = {
  __proto__: null,
  auto: auto2,
  bracket: bracket2,
  bracketOfColor: bracketOfColor2,
  bracketOfLength: bracketOfLength2,
  bracketOfPosition: bracketOfPosition2,
  cssvar: cssvar2,
  degree: degree2,
  fraction: fraction2,
  global: global3,
  number: number2,
  numberWithUnit: numberWithUnit2,
  percent: percent2,
  position: position2,
  properties: properties2,
  px: px2,
  rem: rem2,
  time: time2
};
var handler2 = createValueHandler(valueHandlers);
var h2 = handler2;
var CONTROL_MINI_NO_NEGATIVE2 = "$$mini-no-negative";
function directionSize2(propertyPrefix) {
  return ([_, direction, size], { theme: theme4 }) => {
    var _a3, _b2, _c;
    const v = (_b2 = (_a3 = theme4.spacing) == null ? void 0 : _a3[size || "DEFAULT"]) != null ? _b2 : h2.bracket.cssvar.global.auto.fraction.rem(size);
    if (v != null) {
      return directionMap2[direction].map((i) => [`${propertyPrefix}${i}`, v]);
    } else if (size == null ? void 0 : size.startsWith("-")) {
      const v2 = (_c = theme4.spacing) == null ? void 0 : _c[size.slice(1)];
      if (v2 != null)
        return directionMap2[direction].map((i) => [`${propertyPrefix}${i}`, `calc(${v2} * -1)`]);
    }
  };
}
function getThemeColorForKey2(theme4, colors3, key = "colors") {
  let obj = theme4[key];
  let index = -1;
  for (const c of colors3) {
    index += 1;
    if (obj && typeof obj !== "string") {
      const camel = colors3.slice(index).join("-").replace(/(-[a-z])/g, (n2) => n2.slice(1).toUpperCase());
      if (obj[camel])
        return obj[camel];
      if (obj[c]) {
        obj = obj[c];
        continue;
      }
    }
    return void 0;
  }
  return obj;
}
function getThemeColor2(theme4, colors3, key) {
  return getThemeColorForKey2(theme4, colors3, key) || getThemeColorForKey2(theme4, colors3, "colors");
}
function splitShorthand2(body, type) {
  var _a3, _b2;
  const [front, rest] = (_a3 = getStringComponent(body, "[", "]", ["/", ":"])) != null ? _a3 : [];
  if (front != null) {
    const match = ((_b2 = front.match(bracketTypeRe2)) != null ? _b2 : [])[1];
    if (match == null || match === type)
      return [front, rest];
  }
}
function parseColor3(body, theme4, key) {
  const split = splitShorthand2(body, "color");
  if (!split)
    return;
  const [main, opacity3] = split;
  const colors3 = main.replace(/([a-z])(\d)/g, "$1-$2").split(/-/g);
  const [name2] = colors3;
  if (!name2)
    return;
  let color;
  const bracket3 = h2.bracketOfColor(main);
  const bracketOrMain = bracket3 || main;
  if (h2.numberWithUnit(bracketOrMain))
    return;
  if (/^#[\da-f]+$/i.test(bracketOrMain))
    color = bracketOrMain;
  else if (/^hex-[\da-fA-F]+$/.test(bracketOrMain))
    color = `#${bracketOrMain.slice(4)}`;
  else if (main.startsWith("$"))
    color = h2.cssvar(main);
  color = color || bracket3;
  if (!color) {
    const colorData = getThemeColor2(theme4, [main], key);
    if (typeof colorData === "string")
      color = colorData;
  }
  let no = "DEFAULT";
  if (!color) {
    let keys = colors3;
    let _no;
    const [scale] = colors3.slice(-1);
    if (/^\d+$/.test(scale)) {
      no = _no = scale;
      keys = colors3.slice(0, -1);
    }
    const colorData = getThemeColor2(theme4, keys, key);
    if (typeof colorData === "object") {
      color = colorData[_no != null ? _no : no];
    } else if (typeof colorData === "string" && !_no) {
      color = colorData;
    }
  }
  return {
    opacity: opacity3,
    name: name2,
    no,
    color,
    cssColor: parseCssColor(color),
    alpha: h2.bracket.cssvar.percent(opacity3 != null ? opacity3 : "")
  };
}
function colorResolver2(property, varName, key, shouldPass) {
  return ([, body], { theme: theme4, generator }) => {
    const data = parseColor3(body, theme4, key);
    if (!data)
      return;
    const { alpha, color, cssColor } = data;
    const isDev = generator.config.envMode === "dev";
    const rawColorComment = isDev && color ? ` /* ${color} */` : "";
    const css = {};
    if (cssColor) {
      if (alpha != null) {
        css[property] = colorToString(cssColor, alpha) + rawColorComment;
      } else {
        const opacityVar = `--un-${varName}-opacity`;
        const result = colorToString(cssColor, `var(${opacityVar})`);
        if (result.includes(opacityVar))
          css[opacityVar] = colorOpacityToString(cssColor);
        css[property] = result + rawColorComment;
      }
    } else if (color) {
      if (alpha != null) {
        css[property] = colorToString(color, alpha) + rawColorComment;
      } else {
        const opacityVar = `--un-${varName}-opacity`;
        const result = colorToString(color, `var(${opacityVar})`);
        if (result.includes(opacityVar))
          css[opacityVar] = 1;
        css[property] = result + rawColorComment;
      }
    }
    if ((shouldPass == null ? void 0 : shouldPass(css)) !== false)
      return css;
  };
}
function colorableShadows2(shadows, colorVar) {
  const colored = [];
  shadows = toArray2(shadows);
  for (let i = 0; i < shadows.length; i++) {
    const components = getStringComponents(shadows[i], " ", 6);
    if (!components || components.length < 3)
      return shadows;
    let isInset = false;
    const pos = components.indexOf("inset");
    if (pos !== -1) {
      components.splice(pos, 1);
      isInset = true;
    }
    let colorVarValue = "";
    const lastComp = components.at(-1);
    if (parseCssColor(components.at(0))) {
      const color = parseCssColor(components.shift());
      if (color)
        colorVarValue = `, ${colorToString(color)}`;
    } else if (parseCssColor(lastComp)) {
      const color = parseCssColor(components.pop());
      if (color)
        colorVarValue = `, ${colorToString(color)}`;
    } else if (lastComp && cssVarFnRE2.test(lastComp)) {
      const color = components.pop();
      colorVarValue = `, ${color}`;
    }
    colored.push(`${isInset ? "inset " : ""}${components.join(" ")} var(${colorVar}${colorVarValue})`);
  }
  return colored;
}
function hasParseableColor2(color, theme4, key) {
  var _a3;
  return color != null && !!((_a3 = parseColor3(color, theme4, key)) == null ? void 0 : _a3.color);
}
var reLetters2 = /[a-z]+/gi;
var resolvedBreakpoints2 = /* @__PURE__ */ new WeakMap();
function resolveBreakpoints2({ theme: theme4, generator }, key = "breakpoints") {
  var _a3, _b2;
  const breakpoints3 = ((_b2 = (_a3 = generator == null ? void 0 : generator.userConfig) == null ? void 0 : _a3.theme) == null ? void 0 : _b2[key]) || theme4[key];
  if (!breakpoints3)
    return void 0;
  if (resolvedBreakpoints2.has(theme4))
    return resolvedBreakpoints2.get(theme4);
  const resolved = Object.entries(breakpoints3).sort((a, b) => Number.parseInt(a[1].replace(reLetters2, "")) - Number.parseInt(b[1].replace(reLetters2, ""))).map(([point, size]) => ({ point, size }));
  resolvedBreakpoints2.set(theme4, resolved);
  return resolved;
}
function makeGlobalStaticRules2(prefix, property) {
  return globalKeywords2.map((keyword) => [`${prefix}-${keyword}`, { [property != null ? property : prefix]: keyword }]);
}
function isCSSMathFn2(value) {
  return value != null && cssMathFnRE2.test(value);
}
function isSize2(str) {
  if (str[0] === "[" && str.slice(-1) === "]")
    str = str.slice(1, -1);
  return cssMathFnRE2.test(str) || numberWithUnitRE2.test(str);
}
function transformXYZ2(d, v, name2) {
  const values = v.split(splitComma2);
  if (d || !d && values.length === 1)
    return xyzMap2[d].map((i) => [`--un-${name2}${i}`, v]);
  return values.map((v2, i) => [`--un-${name2}-${xyzArray2[i]}`, v2]);
}

// ../../packages-presets/preset-wind3/src/rules/animation.ts
var animations = [
  [/^(?:animate-)?keyframes-(.+)$/, ([, name2], { theme: theme4 }) => {
    var _a3, _b2;
    const kf = (_b2 = (_a3 = theme4.animation) == null ? void 0 : _a3.keyframes) == null ? void 0 : _b2[name2];
    if (kf) {
      return [
        `@keyframes ${name2}${kf}`,
        { animation: name2 }
      ];
    }
  }, { autocomplete: ["animate-keyframes-$animation.keyframes", "keyframes-$animation.keyframes"] }],
  [/^animate-(.+)$/, ([, name2], { theme: theme4 }) => {
    var _a3, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
    const kf = (_b2 = (_a3 = theme4.animation) == null ? void 0 : _a3.keyframes) == null ? void 0 : _b2[name2];
    if (kf) {
      const duration3 = (_e = (_d = (_c = theme4.animation) == null ? void 0 : _c.durations) == null ? void 0 : _d[name2]) != null ? _e : "1s";
      const timing = (_h = (_g = (_f = theme4.animation) == null ? void 0 : _f.timingFns) == null ? void 0 : _g[name2]) != null ? _h : "linear";
      const count = (_k = (_j = (_i = theme4.animation) == null ? void 0 : _i.counts) == null ? void 0 : _j[name2]) != null ? _k : 1;
      const props = (_m = (_l = theme4.animation) == null ? void 0 : _l.properties) == null ? void 0 : _m[name2];
      return [
        `@keyframes ${name2}${kf}`,
        {
          animation: `${name2} ${duration3} ${timing} ${count}`,
          ...props
        }
      ];
    }
    return { animation: h2.bracket.cssvar(name2) };
  }, { autocomplete: "animate-$animation.keyframes" }],
  [/^animate-name-(.+)/, ([, d]) => {
    var _a3;
    return { "animation-name": (_a3 = h2.bracket.cssvar(d)) != null ? _a3 : d };
  }],
  // timings
  [/^animate-duration-(.+)$/, ([, d], { theme: theme4 }) => {
    var _a3, _b2;
    return { "animation-duration": (_b2 = (_a3 = theme4.duration) == null ? void 0 : _a3[d || "DEFAULT"]) != null ? _b2 : h2.bracket.cssvar.time(d) };
  }, { autocomplete: ["animate-duration", "animate-duration-$duration"] }],
  [/^animate-delay-(.+)$/, ([, d], { theme: theme4 }) => {
    var _a3, _b2;
    return { "animation-delay": (_b2 = (_a3 = theme4.duration) == null ? void 0 : _a3[d || "DEFAULT"]) != null ? _b2 : h2.bracket.cssvar.time(d) };
  }, { autocomplete: ["animate-delay", "animate-delay-$duration"] }],
  [/^animate-ease(?:-(.+))?$/, ([, d], { theme: theme4 }) => {
    var _a3, _b2;
    return { "animation-timing-function": (_b2 = (_a3 = theme4.easing) == null ? void 0 : _a3[d || "DEFAULT"]) != null ? _b2 : h2.bracket.cssvar(d) };
  }, { autocomplete: ["animate-ease", "animate-ease-$easing"] }],
  // fill mode
  [/^animate-(fill-mode-|fill-|mode-)?(.+)$/, ([, t, d]) => ["none", "forwards", "backwards", "both", ...[t ? globalKeywords2 : []]].includes(d) ? { "animation-fill-mode": d } : void 0, {
    autocomplete: [
      "animate-(fill|mode|fill-mode)",
      "animate-(fill|mode|fill-mode)-(none|forwards|backwards|both|inherit|initial|revert|revert-layer|unset)",
      "animate-(none|forwards|backwards|both|inherit|initial|revert|revert-layer|unset)"
    ]
  }],
  // direction
  [/^animate-(direction-)?(.+)$/, ([, t, d]) => ["normal", "reverse", "alternate", "alternate-reverse", ...[t ? globalKeywords2 : []]].includes(d) ? { "animation-direction": d } : void 0, {
    autocomplete: [
      "animate-direction",
      "animate-direction-(normal|reverse|alternate|alternate-reverse|inherit|initial|revert|revert-layer|unset)",
      "animate-(normal|reverse|alternate|alternate-reverse|inherit|initial|revert|revert-layer|unset)"
    ]
  }],
  // others
  [/^animate-(?:iteration-count-|iteration-|count-)(.+)$/, ([, d]) => {
    var _a3;
    return { "animation-iteration-count": (_a3 = h2.bracket.cssvar(d)) != null ? _a3 : d.replace(/-/g, ",") };
  }, { autocomplete: ["animate-(iteration|count|iteration-count)", "animate-(iteration|count|iteration-count)-<num>"] }],
  [/^animate-(play-state-|play-|state-)?(.+)$/, ([, t, d]) => ["paused", "running", ...[t ? globalKeywords2 : []]].includes(d) ? { "animation-play-state": d } : void 0, {
    autocomplete: [
      "animate-(play|state|play-state)",
      "animate-(play|state|play-state)-(paused|running|inherit|initial|revert|revert-layer|unset)",
      "animate-(paused|running|inherit|initial|revert|revert-layer|unset)"
    ]
  }],
  ["animate-none", { animation: "none" }],
  ...makeGlobalStaticRules2("animate", "animation")
];

// ../../packages-presets/preset-wind3/src/rules/background.ts
function bgGradientToValue(cssColor) {
  if (cssColor)
    return colorToString(cssColor, 0);
  return "rgb(255 255 255 / 0)";
}
function bgGradientColorValue(mode, cssColor, color, alpha) {
  if (cssColor) {
    if (alpha != null)
      return colorToString(cssColor, alpha);
    else
      return colorToString(cssColor, `var(--un-${mode}-opacity, ${colorOpacityToString(cssColor)})`);
  }
  return colorToString(color, alpha);
}
function bgGradientColorResolver() {
  return ([, mode, body], { theme: theme4 }) => {
    const data = parseColor3(body, theme4, "backgroundColor");
    if (!data)
      return;
    const { alpha, color, cssColor } = data;
    if (!color)
      return;
    const colorString = bgGradientColorValue(mode, cssColor, color, alpha);
    switch (mode) {
      case "from":
        return {
          "--un-gradient-from-position": "0%",
          "--un-gradient-from": `${colorString} var(--un-gradient-from-position)`,
          "--un-gradient-to-position": "100%",
          "--un-gradient-to": `${bgGradientToValue(cssColor)} var(--un-gradient-to-position)`,
          "--un-gradient-stops": "var(--un-gradient-from), var(--un-gradient-to)"
        };
      case "via":
        return {
          "--un-gradient-via-position": "50%",
          "--un-gradient-to": bgGradientToValue(cssColor),
          "--un-gradient-stops": `var(--un-gradient-from), ${colorString} var(--un-gradient-via-position), var(--un-gradient-to)`
        };
      case "to":
        return {
          "--un-gradient-to-position": "100%",
          "--un-gradient-to": `${colorString} var(--un-gradient-to-position)`
        };
    }
  };
}
function bgGradientPositionResolver() {
  return ([, mode, body]) => {
    return {
      [`--un-gradient-${mode}-position`]: `${Number(h2.bracket.cssvar.percent(body)) * 100}%`
    };
  };
}
var backgroundStyles = [
  // gradients
  [/^bg-gradient-(.+)$/, ([, d]) => ({ "--un-gradient": h2.bracket(d) }), {
    autocomplete: ["bg-gradient", "bg-gradient-(from|to|via)", "bg-gradient-(from|to|via)-$colors", "bg-gradient-(from|to|via)-(op|opacity)", "bg-gradient-(from|to|via)-(op|opacity)-<percent>"]
  }],
  [/^(?:bg-gradient-)?stops-(\[.+\])$/, ([, s]) => ({ "--un-gradient-stops": h2.bracket(s) })],
  [/^(?:bg-gradient-)?(from)-(.+)$/, bgGradientColorResolver()],
  [/^(?:bg-gradient-)?(via)-(.+)$/, bgGradientColorResolver()],
  [/^(?:bg-gradient-)?(to)-(.+)$/, bgGradientColorResolver()],
  [/^(?:bg-gradient-)?(from|via|to)-op(?:acity)?-?(.+)$/, ([, position3, opacity3]) => ({ [`--un-${position3}-opacity`]: h2.bracket.percent(opacity3) })],
  [/^(from|via|to)-([\d.]+)%$/, bgGradientPositionResolver()],
  // images
  [/^bg-gradient-((?:repeating-)?(?:linear|radial|conic))$/, ([, s]) => ({
    "background-image": `${s}-gradient(var(--un-gradient, var(--un-gradient-stops, rgb(255 255 255 / 0))))`
  }), { autocomplete: ["bg-gradient-repeating", "bg-gradient-(linear|radial|conic)", "bg-gradient-repeating-(linear|radial|conic)"] }],
  // ignore any center position
  [/^bg-gradient-to-([rltb]{1,2})$/, ([, d]) => {
    if (d in positionMap2) {
      return {
        "--un-gradient-shape": `to ${positionMap2[d]} in oklch`,
        "--un-gradient": "var(--un-gradient-shape), var(--un-gradient-stops)",
        "background-image": "linear-gradient(var(--un-gradient))"
      };
    }
  }, { autocomplete: `bg-gradient-to-(${Object.keys(positionMap2).filter((k) => k.length <= 2 && Array.from(k).every((c) => "rltb".includes(c))).join("|")})` }],
  [/^(?:bg-gradient-)?shape-(.+)$/, ([, d]) => {
    const v = d in positionMap2 ? `to ${positionMap2[d]}` : h2.bracket(d);
    if (v != null) {
      return {
        "--un-gradient-shape": `${v} in oklch`,
        "--un-gradient": "var(--un-gradient-shape), var(--un-gradient-stops)"
      };
    }
  }, { autocomplete: ["bg-gradient-shape", `bg-gradient-shape-(${Object.keys(positionMap2).join("|")})`, `shape-(${Object.keys(positionMap2).join("|")})`] }],
  ["bg-none", { "background-image": "none" }],
  ["box-decoration-slice", { "box-decoration-break": "slice" }],
  ["box-decoration-clone", { "box-decoration-break": "clone" }],
  ...makeGlobalStaticRules2("box-decoration", "box-decoration-break"),
  // size
  ["bg-auto", { "background-size": "auto" }],
  ["bg-cover", { "background-size": "cover" }],
  ["bg-contain", { "background-size": "contain" }],
  // attachments
  ["bg-fixed", { "background-attachment": "fixed" }],
  ["bg-local", { "background-attachment": "local" }],
  ["bg-scroll", { "background-attachment": "scroll" }],
  // clips
  ["bg-clip-border", { "-webkit-background-clip": "border-box", "background-clip": "border-box" }],
  ["bg-clip-content", { "-webkit-background-clip": "content-box", "background-clip": "content-box" }],
  ["bg-clip-padding", { "-webkit-background-clip": "padding-box", "background-clip": "padding-box" }],
  ["bg-clip-text", { "-webkit-background-clip": "text", "background-clip": "text" }],
  ...globalKeywords2.map((keyword) => [`bg-clip-${keyword}`, {
    "-webkit-background-clip": keyword,
    "background-clip": keyword
  }]),
  // positions
  // skip 1 & 2 letters shortcut
  [/^bg-([-\w]{3,})$/, ([, s]) => ({ "background-position": positionMap2[s] })],
  // repeats
  ["bg-repeat", { "background-repeat": "repeat" }],
  ["bg-no-repeat", { "background-repeat": "no-repeat" }],
  ["bg-repeat-x", { "background-repeat": "repeat-x" }],
  ["bg-repeat-y", { "background-repeat": "repeat-y" }],
  ["bg-repeat-round", { "background-repeat": "round" }],
  ["bg-repeat-space", { "background-repeat": "space" }],
  ...makeGlobalStaticRules2("bg-repeat", "background-repeat"),
  // origins
  ["bg-origin-border", { "background-origin": "border-box" }],
  ["bg-origin-padding", { "background-origin": "padding-box" }],
  ["bg-origin-content", { "background-origin": "content-box" }],
  ...makeGlobalStaticRules2("bg-origin", "background-origin")
];

// ../../packages-presets/preset-wind3/src/rules/behaviors.ts
var listStyles = {
  "disc": "disc",
  "circle": "circle",
  "square": "square",
  "decimal": "decimal",
  "zero-decimal": "decimal-leading-zero",
  "greek": "lower-greek",
  "roman": "lower-roman",
  "upper-roman": "upper-roman",
  "alpha": "lower-alpha",
  "upper-alpha": "upper-alpha",
  "latin": "lower-latin",
  "upper-latin": "upper-latin"
};
var listStyle = [
  // base
  [/^list-(.+?)(?:-(outside|inside))?$/, ([, alias, position3]) => {
    const style = listStyles[alias];
    if (style) {
      if (position3) {
        return {
          "list-style-position": position3,
          "list-style-type": style
        };
      }
      return { "list-style-type": style };
    }
  }, { autocomplete: [`list-(${Object.keys(listStyles).join("|")})`, `list-(${Object.keys(listStyles).join("|")})-(outside|inside)`] }],
  // styles
  ["list-outside", { "list-style-position": "outside" }],
  ["list-inside", { "list-style-position": "inside" }],
  ["list-none", { "list-style-type": "none" }],
  // image
  [/^list-image-(.+)$/, ([, d]) => {
    if (/^\[url\(.+\)\]$/.test(d))
      return { "list-style-image": h2.bracket(d) };
  }],
  ["list-image-none", { "list-style-image": "none" }],
  ...makeGlobalStaticRules2("list", "list-style-type")
];
var accents = [
  [/^accent-(.+)$/, colorResolver2("accent-color", "accent", "accentColor"), { autocomplete: "accent-$colors" }],
  [/^accent-op(?:acity)?-?(.+)$/, ([, d]) => ({ "--un-accent-opacity": h2.bracket.percent(d) }), { autocomplete: ["accent-(op|opacity)", "accent-(op|opacity)-<percent>"] }]
];
var carets = [
  [/^caret-(.+)$/, colorResolver2("caret-color", "caret", "textColor"), { autocomplete: "caret-$colors" }],
  [/^caret-op(?:acity)?-?(.+)$/, ([, d]) => ({ "--un-caret-opacity": h2.bracket.percent(d) }), { autocomplete: ["caret-(op|opacity)", "caret-(op|opacity)-<percent>"] }]
];
var imageRenderings = [
  ["image-render-auto", { "image-rendering": "auto" }],
  ["image-render-edge", { "image-rendering": "crisp-edges" }],
  ["image-render-pixel", [
    ["-ms-interpolation-mode", "nearest-neighbor"],
    ["image-rendering", "-webkit-optimize-contrast"],
    ["image-rendering", "-moz-crisp-edges"],
    ["image-rendering", "-o-pixelated"],
    ["image-rendering", "pixelated"]
  ]]
];
var overscrolls = [
  ["overscroll-auto", { "overscroll-behavior": "auto" }],
  ["overscroll-contain", { "overscroll-behavior": "contain" }],
  ["overscroll-none", { "overscroll-behavior": "none" }],
  ...makeGlobalStaticRules2("overscroll", "overscroll-behavior"),
  ["overscroll-x-auto", { "overscroll-behavior-x": "auto" }],
  ["overscroll-x-contain", { "overscroll-behavior-x": "contain" }],
  ["overscroll-x-none", { "overscroll-behavior-x": "none" }],
  ...makeGlobalStaticRules2("overscroll-x", "overscroll-behavior-x"),
  ["overscroll-y-auto", { "overscroll-behavior-y": "auto" }],
  ["overscroll-y-contain", { "overscroll-behavior-y": "contain" }],
  ["overscroll-y-none", { "overscroll-behavior-y": "none" }],
  ...makeGlobalStaticRules2("overscroll-y", "overscroll-behavior-y")
];
var scrollBehaviors = [
  ["scroll-auto", { "scroll-behavior": "auto" }],
  ["scroll-smooth", { "scroll-behavior": "smooth" }],
  ...makeGlobalStaticRules2("scroll", "scroll-behavior")
];

// ../../packages-presets/preset-wind3/src/rules/columns.ts
var columns = [
  [/^columns-(.+)$/, ([, v]) => ({ columns: h2.bracket.global.number.auto.numberWithUnit(v) }), { autocomplete: "columns-<num>" }],
  // break before
  ["break-before-auto", { "break-before": "auto" }],
  ["break-before-avoid", { "break-before": "avoid" }],
  ["break-before-all", { "break-before": "all" }],
  ["break-before-avoid-page", { "break-before": "avoid-page" }],
  ["break-before-page", { "break-before": "page" }],
  ["break-before-left", { "break-before": "left" }],
  ["break-before-right", { "break-before": "right" }],
  ["break-before-column", { "break-before": "column" }],
  ...makeGlobalStaticRules2("break-before"),
  // break inside
  ["break-inside-auto", { "break-inside": "auto" }],
  ["break-inside-avoid", { "break-inside": "avoid" }],
  ["break-inside-avoid-page", { "break-inside": "avoid-page" }],
  ["break-inside-avoid-column", { "break-inside": "avoid-column" }],
  ...makeGlobalStaticRules2("break-inside"),
  // break after
  ["break-after-auto", { "break-after": "auto" }],
  ["break-after-avoid", { "break-after": "avoid" }],
  ["break-after-all", { "break-after": "all" }],
  ["break-after-avoid-page", { "break-after": "avoid-page" }],
  ["break-after-page", { "break-after": "page" }],
  ["break-after-left", { "break-after": "left" }],
  ["break-after-right", { "break-after": "right" }],
  ["break-after-column", { "break-after": "column" }],
  ...makeGlobalStaticRules2("break-after")
];

// ../../packages-presets/preset-wind3/src/rules/container.ts
var queryMatcher = /@media \(min-width: (.+)\)/;
var container = [
  [
    /^__container$/,
    (m, context) => {
      var _a3, _b2, _c, _d, _e, _f, _g, _h, _i;
      const { theme: theme4, variantHandlers } = context;
      const themePadding = (_a3 = theme4.container) == null ? void 0 : _a3.padding;
      let padding;
      if (isString(themePadding))
        padding = themePadding;
      else
        padding = themePadding == null ? void 0 : themePadding.DEFAULT;
      const themeMaxWidth = (_b2 = theme4.container) == null ? void 0 : _b2.maxWidth;
      let maxWidth3;
      for (const v of variantHandlers) {
        const query = (_d = (_c = v.handle) == null ? void 0 : _c.call(v, {}, (x2) => x2)) == null ? void 0 : _d.parent;
        if (isString(query)) {
          const match = (_e = query.match(queryMatcher)) == null ? void 0 : _e[1];
          if (match) {
            const bp = (_f = resolveBreakpoints2(context)) != null ? _f : [];
            const matchBp = (_g = bp.find((i) => i.size === match)) == null ? void 0 : _g.point;
            if (!themeMaxWidth)
              maxWidth3 = match;
            else if (matchBp)
              maxWidth3 = themeMaxWidth == null ? void 0 : themeMaxWidth[matchBp];
            if (matchBp && !isString(themePadding))
              padding = (_h = themePadding == null ? void 0 : themePadding[matchBp]) != null ? _h : padding;
          }
        }
      }
      const css = {
        "max-width": maxWidth3
      };
      if (!variantHandlers.length)
        css.width = "100%";
      if ((_i = theme4.container) == null ? void 0 : _i.center) {
        css["margin-left"] = "auto";
        css["margin-right"] = "auto";
      }
      if (themePadding) {
        css["padding-left"] = padding;
        css["padding-right"] = padding;
      }
      return css;
    },
    { internal: true }
  ]
];
var containerShortcuts = [
  [/^(?:(\w+)[:-])?container$/, ([, bp], context) => {
    var _a3;
    let points = ((_a3 = resolveBreakpoints2(context)) != null ? _a3 : []).map((i) => i.point);
    if (bp) {
      if (!points.includes(bp))
        return;
      points = points.slice(points.indexOf(bp));
    }
    const shortcuts2 = points.map((p) => `${p}:__container`);
    if (!bp)
      shortcuts2.unshift("__container");
    return shortcuts2;
  }]
];

// ../../packages-presets/preset-mini/dist/shared/preset-mini.TU9YjwzX.mjs
var cursorValues2 = ["auto", "default", "none", "context-menu", "help", "pointer", "progress", "wait", "cell", "crosshair", "text", "vertical-text", "alias", "copy", "move", "no-drop", "not-allowed", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out"];
var containValues2 = ["none", "strict", "content", "size", "inline-size", "layout", "style", "paint"];
var varEmpty2 = " ";
var displays2 = [
  ["inline", { display: "inline" }],
  ["block", { display: "block" }],
  ["inline-block", { display: "inline-block" }],
  ["contents", { display: "contents" }],
  ["flow-root", { display: "flow-root" }],
  ["list-item", { display: "list-item" }],
  ["hidden", { display: "none" }],
  [/^display-(.+)$/, ([, c]) => ({ display: h2.bracket.cssvar.global(c) })]
];
var appearances2 = [
  ["visible", { visibility: "visible" }],
  ["invisible", { visibility: "hidden" }],
  ["backface-visible", { "backface-visibility": "visible" }],
  ["backface-hidden", { "backface-visibility": "hidden" }],
  ...makeGlobalStaticRules2("backface", "backface-visibility")
];
var cursors2 = [
  [/^cursor-(.+)$/, ([, c]) => ({ cursor: h2.bracket.cssvar.global(c) })],
  ...cursorValues2.map((v) => [`cursor-${v}`, { cursor: v }])
];
var contains2 = [
  [/^contain-(.*)$/, ([, d]) => {
    if (h2.bracket(d) != null) {
      return {
        contain: h2.bracket(d).split(" ").map((e2) => {
          var _a3;
          return (_a3 = h2.cssvar.fraction(e2)) != null ? _a3 : e2;
        }).join(" ")
      };
    }
    return containValues2.includes(d) ? { contain: d } : void 0;
  }]
];
var pointerEvents2 = [
  ["pointer-events-auto", { "pointer-events": "auto" }],
  ["pointer-events-none", { "pointer-events": "none" }],
  ...makeGlobalStaticRules2("pointer-events")
];
var resizes2 = [
  ["resize-x", { resize: "horizontal" }],
  ["resize-y", { resize: "vertical" }],
  ["resize", { resize: "both" }],
  ["resize-none", { resize: "none" }],
  ...makeGlobalStaticRules2("resize")
];
var userSelects2 = [
  ["select-auto", { "-webkit-user-select": "auto", "user-select": "auto" }],
  ["select-all", { "-webkit-user-select": "all", "user-select": "all" }],
  ["select-text", { "-webkit-user-select": "text", "user-select": "text" }],
  ["select-none", { "-webkit-user-select": "none", "user-select": "none" }],
  ...makeGlobalStaticRules2("select", "user-select")
];
var whitespaces2 = [
  [
    /^(?:whitespace-|ws-)([-\w]+)$/,
    ([, v]) => ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces", ...globalKeywords2].includes(v) ? { "white-space": v } : void 0,
    { autocomplete: "(whitespace|ws)-(normal|nowrap|pre|pre-line|pre-wrap|break-spaces)" }
  ]
];
var contentVisibility2 = [
  [/^intrinsic-size-(.+)$/, ([, d]) => ({ "contain-intrinsic-size": h2.bracket.cssvar.global.fraction.rem(d) }), { autocomplete: "intrinsic-size-<num>" }],
  ["content-visibility-visible", { "content-visibility": "visible" }],
  ["content-visibility-hidden", { "content-visibility": "hidden" }],
  ["content-visibility-auto", { "content-visibility": "auto" }],
  ...makeGlobalStaticRules2("content-visibility")
];
var contents2 = [
  [/^content-(.+)$/, ([, v]) => ({ content: h2.bracket.cssvar(v) })],
  ["content-empty", { content: '""' }],
  ["content-none", { content: "none" }]
];
var breaks2 = [
  ["break-normal", { "overflow-wrap": "normal", "word-break": "normal" }],
  ["break-words", { "overflow-wrap": "break-word" }],
  ["break-all", { "word-break": "break-all" }],
  ["break-keep", { "word-break": "keep-all" }],
  ["break-anywhere", { "overflow-wrap": "anywhere" }]
];
var textWraps2 = [
  ["text-wrap", { "text-wrap": "wrap" }],
  ["text-nowrap", { "text-wrap": "nowrap" }],
  ["text-balance", { "text-wrap": "balance" }],
  ["text-pretty", { "text-wrap": "pretty" }]
];
var textOverflows2 = [
  ["truncate", { "overflow": "hidden", "text-overflow": "ellipsis", "white-space": "nowrap" }],
  ["text-truncate", { "overflow": "hidden", "text-overflow": "ellipsis", "white-space": "nowrap" }],
  ["text-ellipsis", { "text-overflow": "ellipsis" }],
  ["text-clip", { "text-overflow": "clip" }]
];
var textTransforms2 = [
  ["case-upper", { "text-transform": "uppercase" }],
  ["case-lower", { "text-transform": "lowercase" }],
  ["case-capital", { "text-transform": "capitalize" }],
  ["case-normal", { "text-transform": "none" }],
  ...makeGlobalStaticRules2("case", "text-transform")
];
var fontStyles2 = [
  ["italic", { "font-style": "italic" }],
  ["not-italic", { "font-style": "normal" }],
  ["font-italic", { "font-style": "italic" }],
  ["font-not-italic", { "font-style": "normal" }],
  ["oblique", { "font-style": "oblique" }],
  ["not-oblique", { "font-style": "normal" }],
  ["font-oblique", { "font-style": "oblique" }],
  ["font-not-oblique", { "font-style": "normal" }]
];
var fontSmoothings2 = [
  ["antialiased", {
    "-webkit-font-smoothing": "antialiased",
    "-moz-osx-font-smoothing": "grayscale"
  }],
  ["subpixel-antialiased", {
    "-webkit-font-smoothing": "auto",
    "-moz-osx-font-smoothing": "auto"
  }]
];
var ringBase2 = {
  "--un-ring-inset": varEmpty2,
  "--un-ring-offset-width": "0px",
  "--un-ring-offset-color": "#fff",
  "--un-ring-width": "0px",
  "--un-ring-color": "rgb(147 197 253 / 0.5)",
  "--un-shadow": "0 0 rgb(0 0 0 / 0)"
};
var preflightKeys$2 = Object.keys(ringBase2);
var rings2 = [
  // ring
  [/^ring(?:-(.+))?$/, ([, d], { theme: theme4 }) => {
    var _a3, _b2;
    const value = (_b2 = (_a3 = theme4.ringWidth) == null ? void 0 : _a3[d || "DEFAULT"]) != null ? _b2 : h2.px(d || "1");
    if (value) {
      return {
        "--un-ring-width": value,
        "--un-ring-offset-shadow": "var(--un-ring-inset) 0 0 0 var(--un-ring-offset-width) var(--un-ring-offset-color)",
        "--un-ring-shadow": "var(--un-ring-inset) 0 0 0 calc(var(--un-ring-width) + var(--un-ring-offset-width)) var(--un-ring-color)",
        "box-shadow": "var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow)"
      };
    }
  }, { custom: { preflightKeys: preflightKeys$2 }, autocomplete: "ring-$ringWidth" }],
  // size
  [/^ring-(?:width-|size-)(.+)$/, handleWidth5, { autocomplete: "ring-(width|size)-$lineWidth" }],
  // offset size
  ["ring-offset", { "--un-ring-offset-width": "1px" }],
  [/^ring-offset-(?:width-|size-)?(.+)$/, ([, d], { theme: theme4 }) => {
    var _a3, _b2;
    return { "--un-ring-offset-width": (_b2 = (_a3 = theme4.lineWidth) == null ? void 0 : _a3[d]) != null ? _b2 : h2.bracket.cssvar.px(d) };
  }, { autocomplete: "ring-offset-(width|size)-$lineWidth" }],
  // colors
  [/^ring-(.+)$/, handleColorOrWidth5, { autocomplete: "ring-$colors" }],
  [/^ring-op(?:acity)?-?(.+)$/, ([, opacity3]) => ({ "--un-ring-opacity": h2.bracket.percent.cssvar(opacity3) }), { autocomplete: "ring-(op|opacity)-<percent>" }],
  // offset color
  [/^ring-offset-(.+)$/, colorResolver2("--un-ring-offset-color", "ring-offset", "borderColor"), { autocomplete: "ring-offset-$colors" }],
  [/^ring-offset-op(?:acity)?-?(.+)$/, ([, opacity3]) => ({ "--un-ring-offset-opacity": h2.bracket.percent.cssvar(opacity3) }), { autocomplete: "ring-offset-(op|opacity)-<percent>" }],
  // style
  ["ring-inset", { "--un-ring-inset": "inset" }]
];
function handleWidth5([, b], { theme: theme4 }) {
  var _a3, _b2;
  return { "--un-ring-width": (_b2 = (_a3 = theme4.ringWidth) == null ? void 0 : _a3[b]) != null ? _b2 : h2.bracket.cssvar.px(b) };
}
function handleColorOrWidth5(match, ctx) {
  if (isCSSMathFn2(h2.bracket(match[1])))
    return handleWidth5(match, ctx);
  return colorResolver2("--un-ring-color", "ring", "borderColor")(match, ctx);
}
var boxShadowsBase2 = {
  "--un-ring-offset-shadow": "0 0 rgb(0 0 0 / 0)",
  "--un-ring-shadow": "0 0 rgb(0 0 0 / 0)",
  "--un-shadow-inset": varEmpty2,
  "--un-shadow": "0 0 rgb(0 0 0 / 0)"
};
var preflightKeys$1 = Object.keys(boxShadowsBase2);
var boxShadows2 = [
  // color
  [/^shadow(?:-(.+))?$/, (match, context) => {
    var _a3;
    const [, d] = match;
    const { theme: theme4 } = context;
    const v = (_a3 = theme4.boxShadow) == null ? void 0 : _a3[d || "DEFAULT"];
    const c = d ? h2.bracket.cssvar(d) : void 0;
    if ((v != null || c != null) && !hasParseableColor2(c, theme4, "shadowColor")) {
      return {
        "--un-shadow": colorableShadows2(v || c, "--un-shadow-color").join(","),
        "box-shadow": "var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow)"
      };
    }
    return colorResolver2("--un-shadow-color", "shadow", "shadowColor")(match, context);
  }, { custom: { preflightKeys: preflightKeys$1 }, autocomplete: ["shadow-$colors", "shadow-$boxShadow"] }],
  [/^shadow-op(?:acity)?-?(.+)$/, ([, opacity3]) => ({ "--un-shadow-opacity": h2.bracket.percent.cssvar(opacity3) }), { autocomplete: "shadow-(op|opacity)-<percent>" }],
  // inset
  ["shadow-inset", { "--un-shadow-inset": "inset" }]
];
var transformValues2 = [
  "translate",
  "rotate",
  "scale"
];
var transformCpu2 = [
  "translateX(var(--un-translate-x))",
  "translateY(var(--un-translate-y))",
  // 'translateZ(var(--un-translate-z))',
  "rotate(var(--un-rotate))",
  // 'rotateX(var(--un-rotate-x))',
  // 'rotateY(var(--un-rotate-y))',
  "rotateZ(var(--un-rotate-z))",
  "skewX(var(--un-skew-x))",
  "skewY(var(--un-skew-y))",
  "scaleX(var(--un-scale-x))",
  "scaleY(var(--un-scale-y))"
  // 'scaleZ(var(--un-scale-z))',
].join(" ");
var transform2 = [
  "translateX(var(--un-translate-x))",
  "translateY(var(--un-translate-y))",
  "translateZ(var(--un-translate-z))",
  "rotate(var(--un-rotate))",
  "rotateX(var(--un-rotate-x))",
  "rotateY(var(--un-rotate-y))",
  "rotateZ(var(--un-rotate-z))",
  "skewX(var(--un-skew-x))",
  "skewY(var(--un-skew-y))",
  "scaleX(var(--un-scale-x))",
  "scaleY(var(--un-scale-y))",
  "scaleZ(var(--un-scale-z))"
].join(" ");
var transformGpu2 = [
  "translate3d(var(--un-translate-x), var(--un-translate-y), var(--un-translate-z))",
  "rotate(var(--un-rotate))",
  "rotateX(var(--un-rotate-x))",
  "rotateY(var(--un-rotate-y))",
  "rotateZ(var(--un-rotate-z))",
  "skewX(var(--un-skew-x))",
  "skewY(var(--un-skew-y))",
  "scaleX(var(--un-scale-x))",
  "scaleY(var(--un-scale-y))",
  "scaleZ(var(--un-scale-z))"
].join(" ");
var transformBase2 = {
  // transform
  "--un-rotate": 0,
  "--un-rotate-x": 0,
  "--un-rotate-y": 0,
  "--un-rotate-z": 0,
  "--un-scale-x": 1,
  "--un-scale-y": 1,
  "--un-scale-z": 1,
  "--un-skew-x": 0,
  "--un-skew-y": 0,
  "--un-translate-x": 0,
  "--un-translate-y": 0,
  "--un-translate-z": 0
};
var preflightKeys4 = Object.keys(transformBase2);
var transforms2 = [
  // origins
  [
    /^(?:transform-)?origin-(.+)$/,
    ([, s]) => {
      var _a3;
      return { "transform-origin": (_a3 = positionMap2[s]) != null ? _a3 : h2.bracket.cssvar(s) };
    },
    { autocomplete: [`transform-origin-(${Object.keys(positionMap2).join("|")})`, `origin-(${Object.keys(positionMap2).join("|")})`] }
  ],
  // perspectives
  [/^(?:transform-)?perspect(?:ive)?-(.+)$/, ([, s]) => {
    const v = h2.bracket.cssvar.px.numberWithUnit(s);
    if (v != null) {
      return {
        "-webkit-perspective": v,
        "perspective": v
      };
    }
  }],
  // skip 1 & 2 letters shortcut
  [/^(?:transform-)?perspect(?:ive)?-origin-(.+)$/, ([, s]) => {
    var _a3;
    const v = (_a3 = h2.bracket.cssvar(s)) != null ? _a3 : s.length >= 3 ? positionMap2[s] : void 0;
    if (v != null) {
      return {
        "-webkit-perspective-origin": v,
        "perspective-origin": v
      };
    }
  }],
  // modifiers
  [/^(?:transform-)?translate-()(.+)$/, handleTranslate2, { custom: { preflightKeys: preflightKeys4 } }],
  [/^(?:transform-)?translate-([xyz])-(.+)$/, handleTranslate2, { custom: { preflightKeys: preflightKeys4 } }],
  [/^(?:transform-)?rotate-()(.+)$/, handleRotate2, { custom: { preflightKeys: preflightKeys4 } }],
  [/^(?:transform-)?rotate-([xyz])-(.+)$/, handleRotate2, { custom: { preflightKeys: preflightKeys4 } }],
  [/^(?:transform-)?skew-()(.+)$/, handleSkew2, { custom: { preflightKeys: preflightKeys4 } }],
  [/^(?:transform-)?skew-([xy])-(.+)$/, handleSkew2, { custom: { preflightKeys: preflightKeys4 }, autocomplete: ["transform-skew-(x|y)-<percent>", "skew-(x|y)-<percent>"] }],
  [/^(?:transform-)?scale-()(.+)$/, handleScale2, { custom: { preflightKeys: preflightKeys4 } }],
  [/^(?:transform-)?scale-([xyz])-(.+)$/, handleScale2, { custom: { preflightKeys: preflightKeys4 }, autocomplete: [`transform-(${transformValues2.join("|")})-<percent>`, `transform-(${transformValues2.join("|")})-(x|y|z)-<percent>`, `(${transformValues2.join("|")})-<percent>`, `(${transformValues2.join("|")})-(x|y|z)-<percent>`] }],
  // style
  [/^(?:transform-)?preserve-3d$/, () => ({ "transform-style": "preserve-3d" })],
  [/^(?:transform-)?preserve-flat$/, () => ({ "transform-style": "flat" })],
  // base
  ["transform", { transform: transform2 }, { custom: { preflightKeys: preflightKeys4 } }],
  ["transform-cpu", { transform: transformCpu2 }, {
    custom: { preflightKeys: ["--un-translate-x", "--un-translate-y", "--un-rotate", "--un-rotate-z", "--un-skew-x", "--un-skew-y", "--un-scale-x", "--un-scale-y"] }
  }],
  ["transform-gpu", { transform: transformGpu2 }, { custom: { preflightKeys: preflightKeys4 } }],
  ["transform-none", { transform: "none" }],
  ...makeGlobalStaticRules2("transform")
];
function handleTranslate2([, d, b], { theme: theme4 }) {
  var _a3, _b2;
  const v = (_b2 = (_a3 = theme4.spacing) == null ? void 0 : _a3[b]) != null ? _b2 : h2.bracket.cssvar.fraction.rem(b);
  if (v != null) {
    return [
      ...transformXYZ2(d, v, "translate"),
      ["transform", transform2]
    ];
  }
}
function handleScale2([, d, b]) {
  const v = h2.bracket.cssvar.fraction.percent(b);
  if (v != null) {
    return [
      ...transformXYZ2(d, v, "scale"),
      ["transform", transform2]
    ];
  }
}
function handleRotate2([, d = "", b]) {
  const v = h2.bracket.cssvar.degree(b);
  if (v != null) {
    if (d) {
      return {
        "--un-rotate": 0,
        [`--un-rotate-${d}`]: v,
        "transform": transform2
      };
    } else {
      return {
        "--un-rotate-x": 0,
        "--un-rotate-y": 0,
        "--un-rotate-z": 0,
        "--un-rotate": v,
        "transform": transform2
      };
    }
  }
}
function handleSkew2([, d, b]) {
  const v = h2.bracket.cssvar.degree(b);
  if (v != null) {
    return [
      ...transformXYZ2(d, v, "skew"),
      ["transform", transform2]
    ];
  }
}

// ../../packages-presets/preset-mini/dist/shared/preset-mini.DOOo96_D.mjs
var verticalAlignAlias2 = {
  "mid": "middle",
  "base": "baseline",
  "btm": "bottom",
  "baseline": "baseline",
  "top": "top",
  "start": "top",
  "middle": "middle",
  "bottom": "bottom",
  "end": "bottom",
  "text-top": "text-top",
  "text-bottom": "text-bottom",
  "sub": "sub",
  "super": "super",
  ...Object.fromEntries(globalKeywords2.map((x2) => [x2, x2]))
};
var verticalAligns2 = [
  [
    /^(?:vertical|align|v)-([-\w]+%?)$/,
    ([, v]) => {
      var _a3;
      return { "vertical-align": (_a3 = verticalAlignAlias2[v]) != null ? _a3 : h2.numberWithUnit(v) };
    },
    {
      autocomplete: [
        `(vertical|align|v)-(${Object.keys(verticalAlignAlias2).join("|")})`,
        "(vertical|align|v)-<percentage>"
      ]
    }
  ]
];
var textAlignValues2 = ["center", "left", "right", "justify", "start", "end"];
var textAligns2 = [
  ...textAlignValues2.map((v) => [`text-${v}`, { "text-align": v }]),
  ...[
    ...globalKeywords2,
    ...textAlignValues2
  ].map((v) => [`text-align-${v}`, { "text-align": v }])
];
var outline2 = [
  // size
  [/^outline-(?:width-|size-)?(.+)$/, handleWidth$2, { autocomplete: "outline-(width|size)-<num>" }],
  // color
  [/^outline-(?:color-)?(.+)$/, handleColorOrWidth$2, { autocomplete: "outline-$colors" }],
  // offset
  [/^outline-offset-(.+)$/, ([, d], { theme: theme4 }) => {
    var _a3, _b2;
    return { "outline-offset": (_b2 = (_a3 = theme4.lineWidth) == null ? void 0 : _a3[d]) != null ? _b2 : h2.bracket.cssvar.global.px(d) };
  }, { autocomplete: "outline-(offset)-<num>" }],
  // style
  ["outline", { "outline-style": "solid" }],
  ...["auto", "dashed", "dotted", "double", "hidden", "solid", "groove", "ridge", "inset", "outset", ...globalKeywords2].map((v) => [`outline-${v}`, { "outline-style": v }]),
  ["outline-none", { "outline": "2px solid transparent", "outline-offset": "2px" }]
];
function handleWidth$2([, b], { theme: theme4 }) {
  var _a3, _b2;
  return { "outline-width": (_b2 = (_a3 = theme4.lineWidth) == null ? void 0 : _a3[b]) != null ? _b2 : h2.bracket.cssvar.global.px(b) };
}
function handleColorOrWidth$2(match, ctx) {
  if (isCSSMathFn2(h2.bracket(match[1])))
    return handleWidth$2(match, ctx);
  return colorResolver2("outline-color", "outline-color", "borderColor")(match, ctx);
}
var appearance2 = [
  ["appearance-auto", { "-webkit-appearance": "auto", "appearance": "auto" }],
  ["appearance-none", { "-webkit-appearance": "none", "appearance": "none" }]
];
function willChangeProperty2(prop) {
  var _a3;
  return (_a3 = h2.properties.auto.global(prop)) != null ? _a3 : {
    contents: "contents",
    scroll: "scroll-position"
  }[prop];
}
var willChange2 = [
  [/^will-change-(.+)/, ([, p]) => ({ "will-change": willChangeProperty2(p) })]
];
var borderStyles2 = ["solid", "dashed", "dotted", "double", "hidden", "none", "groove", "ridge", "inset", "outset", ...globalKeywords2];
var borders2 = [
  // compound
  [/^(?:border|b)()(?:-(.+))?$/, handlerBorderSize2, { autocomplete: "(border|b)-<directions>" }],
  [/^(?:border|b)-([xy])(?:-(.+))?$/, handlerBorderSize2],
  [/^(?:border|b)-([rltbse])(?:-(.+))?$/, handlerBorderSize2],
  [/^(?:border|b)-(block|inline)(?:-(.+))?$/, handlerBorderSize2],
  [/^(?:border|b)-([bi][se])(?:-(.+))?$/, handlerBorderSize2],
  // size
  [/^(?:border|b)-()(?:width|size)-(.+)$/, handlerBorderSize2, { autocomplete: ["(border|b)-<num>", "(border|b)-<directions>-<num>"] }],
  [/^(?:border|b)-([xy])-(?:width|size)-(.+)$/, handlerBorderSize2],
  [/^(?:border|b)-([rltbse])-(?:width|size)-(.+)$/, handlerBorderSize2],
  [/^(?:border|b)-(block|inline)-(?:width|size)-(.+)$/, handlerBorderSize2],
  [/^(?:border|b)-([bi][se])-(?:width|size)-(.+)$/, handlerBorderSize2],
  // colors
  [/^(?:border|b)-()(?:color-)?(.+)$/, handlerBorderColorOrSize2, { autocomplete: ["(border|b)-$colors", "(border|b)-<directions>-$colors"] }],
  [/^(?:border|b)-([xy])-(?:color-)?(.+)$/, handlerBorderColorOrSize2],
  [/^(?:border|b)-([rltbse])-(?:color-)?(.+)$/, handlerBorderColorOrSize2],
  [/^(?:border|b)-(block|inline)-(?:color-)?(.+)$/, handlerBorderColorOrSize2],
  [/^(?:border|b)-([bi][se])-(?:color-)?(.+)$/, handlerBorderColorOrSize2],
  // opacity
  [/^(?:border|b)-()op(?:acity)?-?(.+)$/, handlerBorderOpacity2, { autocomplete: "(border|b)-(op|opacity)-<percent>" }],
  [/^(?:border|b)-([xy])-op(?:acity)?-?(.+)$/, handlerBorderOpacity2],
  [/^(?:border|b)-([rltbse])-op(?:acity)?-?(.+)$/, handlerBorderOpacity2],
  [/^(?:border|b)-(block|inline)-op(?:acity)?-?(.+)$/, handlerBorderOpacity2],
  [/^(?:border|b)-([bi][se])-op(?:acity)?-?(.+)$/, handlerBorderOpacity2],
  // radius
  [/^(?:border-|b-)?(?:rounded|rd)()(?:-(.+))?$/, handlerRounded2, { autocomplete: ["(border|b)-(rounded|rd)", "(border|b)-(rounded|rd)-$borderRadius", "(rounded|rd)", "(rounded|rd)-$borderRadius"] }],
  [/^(?:border-|b-)?(?:rounded|rd)-([rltbse])(?:-(.+))?$/, handlerRounded2],
  [/^(?:border-|b-)?(?:rounded|rd)-([rltb]{2})(?:-(.+))?$/, handlerRounded2],
  [/^(?:border-|b-)?(?:rounded|rd)-([bise][se])(?:-(.+))?$/, handlerRounded2],
  [/^(?:border-|b-)?(?:rounded|rd)-([bi][se]-[bi][se])(?:-(.+))?$/, handlerRounded2],
  // style
  [/^(?:border|b)-(?:style-)?()(.+)$/, handlerBorderStyle2, { autocomplete: ["(border|b)-style", `(border|b)-(${borderStyles2.join("|")})`, "(border|b)-<directions>-style", `(border|b)-<directions>-(${borderStyles2.join("|")})`, `(border|b)-<directions>-style-(${borderStyles2.join("|")})`, `(border|b)-style-(${borderStyles2.join("|")})`] }],
  [/^(?:border|b)-([xy])-(?:style-)?(.+)$/, handlerBorderStyle2],
  [/^(?:border|b)-([rltbse])-(?:style-)?(.+)$/, handlerBorderStyle2],
  [/^(?:border|b)-(block|inline)-(?:style-)?(.+)$/, handlerBorderStyle2],
  [/^(?:border|b)-([bi][se])-(?:style-)?(.+)$/, handlerBorderStyle2]
];
function transformBorderColor2(color, alpha, direction) {
  if (alpha != null) {
    return {
      [`border${direction}-color`]: colorToString(color, alpha)
    };
  }
  if (direction === "") {
    const object = {};
    const opacityVar = `--un-border-opacity`;
    const result = colorToString(color, `var(${opacityVar})`);
    if (result.includes(opacityVar))
      object[opacityVar] = typeof color === "string" ? 1 : colorOpacityToString(color);
    object["border-color"] = result;
    return object;
  } else {
    const object = {};
    const opacityVar = "--un-border-opacity";
    const opacityDirectionVar = `--un-border${direction}-opacity`;
    const result = colorToString(color, `var(${opacityDirectionVar})`);
    if (result.includes(opacityDirectionVar)) {
      object[opacityVar] = typeof color === "string" ? 1 : colorOpacityToString(color);
      object[opacityDirectionVar] = `var(${opacityVar})`;
    }
    object[`border${direction}-color`] = result;
    return object;
  }
}
function borderColorResolver2(direction) {
  return ([, body], theme4) => {
    const data = parseColor3(body, theme4, "borderColor");
    if (!data)
      return;
    const { alpha, color, cssColor } = data;
    if (cssColor)
      return transformBorderColor2(cssColor, alpha, direction);
    else if (color)
      return transformBorderColor2(color, alpha, direction);
  };
}
function handlerBorderSize2([, a = "", b], { theme: theme4 }) {
  var _a3, _b2;
  const v = (_b2 = (_a3 = theme4.lineWidth) == null ? void 0 : _a3[b || "DEFAULT"]) != null ? _b2 : h2.bracket.cssvar.global.px(b || "1");
  if (a in directionMap2 && v != null)
    return directionMap2[a].map((i) => [`border${i}-width`, v]);
}
function handlerBorderColorOrSize2([, a = "", b], ctx) {
  if (a in directionMap2) {
    if (isCSSMathFn2(h2.bracket(b)))
      return handlerBorderSize2(["", a, b], ctx);
    if (hasParseableColor2(b, ctx.theme, "borderColor")) {
      return Object.assign(
        {},
        ...directionMap2[a].map((i) => borderColorResolver2(i)(["", b], ctx.theme))
      );
    }
  }
}
function handlerBorderOpacity2([, a = "", opacity3]) {
  const v = h2.bracket.percent.cssvar(opacity3);
  if (a in directionMap2 && v != null)
    return directionMap2[a].map((i) => [`--un-border${i}-opacity`, v]);
}
function handlerRounded2([, a = "", s], { theme: theme4 }) {
  var _a3;
  const v = ((_a3 = theme4.borderRadius) == null ? void 0 : _a3[s || "DEFAULT"]) || h2.bracket.cssvar.global.fraction.rem(s || "1");
  if (a in cornerMap2 && v != null)
    return cornerMap2[a].map((i) => [`border${i}-radius`, v]);
}
function handlerBorderStyle2([, a = "", s]) {
  if (borderStyles2.includes(s) && a in directionMap2)
    return directionMap2[a].map((i) => [`border${i}-style`, s]);
}
var opacity2 = [
  [/^op(?:acity)?-?(.+)$/, ([, d]) => ({ opacity: h2.bracket.percent.cssvar(d) })]
];
var bgUrlRE2 = /^\[url\(.+\)\]$/;
var bgLengthRE2 = /^\[(?:length|size):.+\]$/;
var bgPositionRE2 = /^\[position:.+\]$/;
var bgGradientRE2 = /^\[(?:linear|conic|radial)-gradient\(.+\)\]$/;
var bgImageRE2 = /^\[image:.+\]$/;
var bgColors2 = [
  [/^bg-(.+)$/, (...args) => {
    const d = args[0][1];
    if (bgUrlRE2.test(d))
      return { "--un-url": h2.bracket(d), "background-image": "var(--un-url)" };
    if (bgLengthRE2.test(d) && h2.bracketOfLength(d) != null)
      return { "background-size": h2.bracketOfLength(d).split(" ").map((e2) => {
        var _a3;
        return (_a3 = h2.fraction.auto.px.cssvar(e2)) != null ? _a3 : e2;
      }).join(" ") };
    if ((isSize2(d) || bgPositionRE2.test(d)) && h2.bracketOfPosition(d) != null)
      return { "background-position": h2.bracketOfPosition(d).split(" ").map((e2) => {
        var _a3;
        return (_a3 = h2.position.fraction.auto.px.cssvar(e2)) != null ? _a3 : e2;
      }).join(" ") };
    if (bgGradientRE2.test(d) || bgImageRE2.test(d)) {
      const s = h2.bracket(d);
      if (s) {
        const url = s.startsWith("http") ? `url(${s})` : h2.cssvar(s);
        return { "background-image": url != null ? url : s };
      }
    }
    return colorResolver2("background-color", "bg", "backgroundColor")(...args);
  }, { autocomplete: "bg-$colors" }],
  [/^bg-op(?:acity)?-?(.+)$/, ([, opacity22]) => ({ "--un-bg-opacity": h2.bracket.percent.cssvar(opacity22) }), { autocomplete: "bg-(op|opacity)-<percent>" }]
];
var colorScheme2 = [
  [/^color-scheme-(\w+)$/, ([, v]) => ({ "color-scheme": v })]
];
var containerParent2 = [
  [/^@container(?:\/(\w+))?(?:-(normal|inline-size|size))?$/, ([, l, v]) => {
    return {
      "container-type": v != null ? v : "inline-size",
      "container-name": l
    };
  }]
];
var decorationStyles2 = ["solid", "double", "dotted", "dashed", "wavy", ...globalKeywords2];
var textDecorations2 = [
  [/^(?:decoration-)?(underline|overline|line-through)$/, ([, s]) => ({ "text-decoration-line": s }), { autocomplete: "decoration-(underline|overline|line-through)" }],
  // size
  [/^(?:underline|decoration)-(?:size-)?(.+)$/, handleWidth$1, { autocomplete: "(underline|decoration)-<num>" }],
  [/^(?:underline|decoration)-(auto|from-font)$/, ([, s]) => ({ "text-decoration-thickness": s }), { autocomplete: "(underline|decoration)-(auto|from-font)" }],
  // colors
  [/^(?:underline|decoration)-(.+)$/, handleColorOrWidth$1, { autocomplete: "(underline|decoration)-$colors" }],
  [/^(?:underline|decoration)-op(?:acity)?-?(.+)$/, ([, opacity3]) => ({ "--un-line-opacity": h2.bracket.percent.cssvar(opacity3) }), { autocomplete: "(underline|decoration)-(op|opacity)-<percent>" }],
  // offset
  [/^(?:underline|decoration)-offset-(.+)$/, ([, s], { theme: theme4 }) => {
    var _a3, _b2;
    return { "text-underline-offset": (_b2 = (_a3 = theme4.lineWidth) == null ? void 0 : _a3[s]) != null ? _b2 : h2.auto.bracket.cssvar.global.px(s) };
  }, { autocomplete: "(underline|decoration)-(offset)-<num>" }],
  // style
  ...decorationStyles2.map((v) => [`underline-${v}`, { "text-decoration-style": v }]),
  ...decorationStyles2.map((v) => [`decoration-${v}`, { "text-decoration-style": v }]),
  ["no-underline", { "text-decoration": "none" }],
  ["decoration-none", { "text-decoration": "none" }]
];
function handleWidth$1([, b], { theme: theme4 }) {
  var _a3, _b2;
  return { "text-decoration-thickness": (_b2 = (_a3 = theme4.lineWidth) == null ? void 0 : _a3[b]) != null ? _b2 : h2.bracket.cssvar.global.px(b) };
}
function handleColorOrWidth$1(match, ctx) {
  if (isCSSMathFn2(h2.bracket(match[1])))
    return handleWidth$1(match, ctx);
  const result = colorResolver2("text-decoration-color", "line", "borderColor")(match, ctx);
  if (result) {
    return {
      "-webkit-text-decoration-color": result["text-decoration-color"],
      ...result
    };
  }
}
var flex2 = [
  // display
  ["flex", { display: "flex" }],
  ["inline-flex", { display: "inline-flex" }],
  ["flex-inline", { display: "inline-flex" }],
  // flex
  [/^flex-(.*)$/, ([, d]) => ({ flex: h2.bracket(d) != null ? h2.bracket(d).split(" ").map((e2) => {
    var _a3;
    return (_a3 = h2.cssvar.fraction(e2)) != null ? _a3 : e2;
  }).join(" ") : h2.cssvar.fraction(d) })],
  ["flex-1", { flex: "1 1 0%" }],
  ["flex-auto", { flex: "1 1 auto" }],
  ["flex-initial", { flex: "0 1 auto" }],
  ["flex-none", { flex: "none" }],
  // shrink/grow/basis
  [/^(?:flex-)?shrink(?:-(.*))?$/, ([, d = ""]) => {
    var _a3;
    return { "flex-shrink": (_a3 = h2.bracket.cssvar.number(d)) != null ? _a3 : 1 };
  }, { autocomplete: ["flex-shrink-<num>", "shrink-<num>"] }],
  [/^(?:flex-)?grow(?:-(.*))?$/, ([, d = ""]) => {
    var _a3;
    return { "flex-grow": (_a3 = h2.bracket.cssvar.number(d)) != null ? _a3 : 1 };
  }, { autocomplete: ["flex-grow-<num>", "grow-<num>"] }],
  [/^(?:flex-)?basis-(.+)$/, ([, d], { theme: theme4 }) => {
    var _a3, _b2;
    return { "flex-basis": (_b2 = (_a3 = theme4.spacing) == null ? void 0 : _a3[d]) != null ? _b2 : h2.bracket.cssvar.auto.fraction.rem(d) };
  }, { autocomplete: ["flex-basis-$spacing", "basis-$spacing"] }],
  // directions
  ["flex-row", { "flex-direction": "row" }],
  ["flex-row-reverse", { "flex-direction": "row-reverse" }],
  ["flex-col", { "flex-direction": "column" }],
  ["flex-col-reverse", { "flex-direction": "column-reverse" }],
  // wraps
  ["flex-wrap", { "flex-wrap": "wrap" }],
  ["flex-wrap-reverse", { "flex-wrap": "wrap-reverse" }],
  ["flex-nowrap", { "flex-wrap": "nowrap" }]
];
var directions2 = {
  "": "",
  "x": "column-",
  "y": "row-",
  "col": "column-",
  "row": "row-"
};
function handleGap2([, d = "", s], { theme: theme4 }) {
  var _a3, _b2;
  const v = (_b2 = (_a3 = theme4.spacing) == null ? void 0 : _a3[s]) != null ? _b2 : h2.bracket.cssvar.global.rem(s);
  if (v != null) {
    return {
      [`${directions2[d]}gap`]: v
    };
  }
}
var gaps2 = [
  [/^(?:flex-|grid-)?gap-?()(.+)$/, handleGap2, { autocomplete: ["gap-$spacing", "gap-<num>"] }],
  [/^(?:flex-|grid-)?gap-([xy])-?(.+)$/, handleGap2, { autocomplete: ["gap-(x|y)-$spacing", "gap-(x|y)-<num>"] }],
  [/^(?:flex-|grid-)?gap-(col|row)-?(.+)$/, handleGap2, { autocomplete: ["gap-(col|row)-$spacing", "gap-(col|row)-<num>"] }]
];
function rowCol2(s) {
  return s.replace("col", "column");
}
function rowColTheme2(s) {
  return s[0] === "r" ? "Row" : "Column";
}
function autoDirection2(c, theme4, prop) {
  var _a3;
  const v = (_a3 = theme4[`gridAuto${rowColTheme2(c)}`]) == null ? void 0 : _a3[prop];
  if (v != null)
    return v;
  switch (prop) {
    case "min":
      return "min-content";
    case "max":
      return "max-content";
    case "fr":
      return "minmax(0,1fr)";
  }
  return h2.bracket.cssvar.auto.rem(prop);
}
var grids2 = [
  // displays
  ["grid", { display: "grid" }],
  ["inline-grid", { display: "inline-grid" }],
  // global
  [/^(?:grid-)?(row|col)-(.+)$/, ([, c, v], { theme: theme4 }) => {
    var _a3, _b2;
    return {
      [`grid-${rowCol2(c)}`]: (_b2 = (_a3 = theme4[`grid${rowColTheme2(c)}`]) == null ? void 0 : _a3[v]) != null ? _b2 : h2.bracket.cssvar.auto(v)
    };
  }],
  // span
  [/^(?:grid-)?(row|col)-span-(.+)$/, ([, c, s]) => {
    if (s === "full")
      return { [`grid-${rowCol2(c)}`]: "1/-1" };
    const v = h2.bracket.number(s);
    if (v != null)
      return { [`grid-${rowCol2(c)}`]: `span ${v}/span ${v}` };
  }, { autocomplete: "(grid-row|grid-col|row|col)-span-<num>" }],
  // starts & ends
  [/^(?:grid-)?(row|col)-start-(.+)$/, ([, c, v]) => {
    var _a3;
    return { [`grid-${rowCol2(c)}-start`]: (_a3 = h2.bracket.cssvar(v)) != null ? _a3 : v };
  }],
  [/^(?:grid-)?(row|col)-end-(.+)$/, ([, c, v]) => {
    var _a3;
    return { [`grid-${rowCol2(c)}-end`]: (_a3 = h2.bracket.cssvar(v)) != null ? _a3 : v };
  }, { autocomplete: "(grid-row|grid-col|row|col)-(start|end)-<num>" }],
  // auto flows
  [/^(?:grid-)?auto-(rows|cols)-(.+)$/, ([, c, v], { theme: theme4 }) => ({ [`grid-auto-${rowCol2(c)}`]: autoDirection2(c, theme4, v) }), { autocomplete: "(grid-auto|auto)-(rows|cols)-<num>" }],
  // grid-auto-flow, auto-flow: uno
  // grid-flow: wind
  [/^(?:grid-auto-flow|auto-flow|grid-flow)-(.+)$/, ([, v]) => ({ "grid-auto-flow": h2.bracket.cssvar(v) })],
  [/^(?:grid-auto-flow|auto-flow|grid-flow)-(row|col|dense|row-dense|col-dense)$/, ([, v]) => ({ "grid-auto-flow": rowCol2(v).replace("-", " ") }), { autocomplete: ["(grid-auto-flow|auto-flow|grid-flow)-(row|col|dense|row-dense|col-dense)"] }],
  // templates
  [/^(?:grid-)?(rows|cols)-(.+)$/, ([, c, v], { theme: theme4 }) => {
    var _a3, _b2;
    return {
      [`grid-template-${rowCol2(c)}`]: (_b2 = (_a3 = theme4[`gridTemplate${rowColTheme2(c)}`]) == null ? void 0 : _a3[v]) != null ? _b2 : h2.bracket.cssvar(v)
    };
  }],
  [/^(?:grid-)?(rows|cols)-minmax-([\w.-]+)$/, ([, c, d]) => ({ [`grid-template-${rowCol2(c)}`]: `repeat(auto-fill,minmax(${d},1fr))` })],
  [/^(?:grid-)?(rows|cols)-(\d+)$/, ([, c, d]) => ({ [`grid-template-${rowCol2(c)}`]: `repeat(${d},minmax(0,1fr))` }), { autocomplete: "(grid-rows|grid-cols|rows|cols)-<num>" }],
  // areas
  [/^grid-area(s)?-(.+)$/, ([, s, v]) => {
    var _a3;
    if (s != null)
      return { "grid-template-areas": (_a3 = h2.cssvar(v)) != null ? _a3 : v.split("-").map((s2) => `"${h2.bracket(s2)}"`).join(" ") };
    return { "grid-area": h2.bracket.cssvar(v) };
  }],
  // template none
  ["grid-rows-none", { "grid-template-rows": "none" }],
  ["grid-cols-none", { "grid-template-columns": "none" }],
  // template subgrid
  ["grid-rows-subgrid", { "grid-template-rows": "subgrid" }],
  ["grid-cols-subgrid", { "grid-template-columns": "subgrid" }]
];
var overflowValues2 = [
  "auto",
  "hidden",
  "clip",
  "visible",
  "scroll",
  "overlay",
  ...globalKeywords2
];
var overflows2 = [
  [/^(?:overflow|of)-(.+)$/, ([, v]) => overflowValues2.includes(v) ? { overflow: v } : void 0, { autocomplete: [`(overflow|of)-(${overflowValues2.join("|")})`, `(overflow|of)-(x|y)-(${overflowValues2.join("|")})`] }],
  [/^(?:overflow|of)-([xy])-(.+)$/, ([, d, v]) => overflowValues2.includes(v) ? { [`overflow-${d}`]: v } : void 0]
];
var positions2 = [
  [/^(?:position-|pos-)?(relative|absolute|fixed|sticky)$/, ([, v]) => ({ position: v }), {
    autocomplete: [
      "(position|pos)-<position>",
      "(position|pos)-<globalKeyword>",
      "<position>"
    ]
  }],
  [/^(?:position-|pos-)([-\w]+)$/, ([, v]) => globalKeywords2.includes(v) ? { position: v } : void 0],
  [/^(?:position-|pos-)?(static)$/, ([, v]) => ({ position: v })]
];
var justifies2 = [
  // contents
  ["justify-start", { "justify-content": "flex-start" }],
  ["justify-end", { "justify-content": "flex-end" }],
  ["justify-center", { "justify-content": "center" }],
  ["justify-between", { "justify-content": "space-between" }],
  ["justify-around", { "justify-content": "space-around" }],
  ["justify-evenly", { "justify-content": "space-evenly" }],
  ["justify-stretch", { "justify-content": "stretch" }],
  ["justify-left", { "justify-content": "left" }],
  ["justify-right", { "justify-content": "right" }],
  ...makeGlobalStaticRules2("justify", "justify-content"),
  // items
  ["justify-items-start", { "justify-items": "start" }],
  ["justify-items-end", { "justify-items": "end" }],
  ["justify-items-center", { "justify-items": "center" }],
  ["justify-items-stretch", { "justify-items": "stretch" }],
  ...makeGlobalStaticRules2("justify-items"),
  // selfs
  ["justify-self-auto", { "justify-self": "auto" }],
  ["justify-self-start", { "justify-self": "start" }],
  ["justify-self-end", { "justify-self": "end" }],
  ["justify-self-center", { "justify-self": "center" }],
  ["justify-self-stretch", { "justify-self": "stretch" }],
  ...makeGlobalStaticRules2("justify-self")
];
var orders2 = [
  [/^order-(.+)$/, ([, v]) => ({ order: h2.bracket.cssvar.number(v) })],
  ["order-first", { order: "-9999" }],
  ["order-last", { order: "9999" }],
  ["order-none", { order: "0" }]
];
var alignments2 = [
  // contents
  ["content-center", { "align-content": "center" }],
  ["content-start", { "align-content": "flex-start" }],
  ["content-end", { "align-content": "flex-end" }],
  ["content-between", { "align-content": "space-between" }],
  ["content-around", { "align-content": "space-around" }],
  ["content-evenly", { "align-content": "space-evenly" }],
  ...makeGlobalStaticRules2("content", "align-content"),
  // items
  ["items-start", { "align-items": "flex-start" }],
  ["items-end", { "align-items": "flex-end" }],
  ["items-center", { "align-items": "center" }],
  ["items-baseline", { "align-items": "baseline" }],
  ["items-stretch", { "align-items": "stretch" }],
  ...makeGlobalStaticRules2("items", "align-items"),
  // selfs
  ["self-auto", { "align-self": "auto" }],
  ["self-start", { "align-self": "flex-start" }],
  ["self-end", { "align-self": "flex-end" }],
  ["self-center", { "align-self": "center" }],
  ["self-stretch", { "align-self": "stretch" }],
  ["self-baseline", { "align-self": "baseline" }],
  ...makeGlobalStaticRules2("self", "align-self")
];
var placements2 = [
  // contents
  ["place-content-center", { "place-content": "center" }],
  ["place-content-start", { "place-content": "start" }],
  ["place-content-end", { "place-content": "end" }],
  ["place-content-between", { "place-content": "space-between" }],
  ["place-content-around", { "place-content": "space-around" }],
  ["place-content-evenly", { "place-content": "space-evenly" }],
  ["place-content-stretch", { "place-content": "stretch" }],
  ...makeGlobalStaticRules2("place-content"),
  // items
  ["place-items-start", { "place-items": "start" }],
  ["place-items-end", { "place-items": "end" }],
  ["place-items-center", { "place-items": "center" }],
  ["place-items-stretch", { "place-items": "stretch" }],
  ...makeGlobalStaticRules2("place-items"),
  // selfs
  ["place-self-auto", { "place-self": "auto" }],
  ["place-self-start", { "place-self": "start" }],
  ["place-self-end", { "place-self": "end" }],
  ["place-self-center", { "place-self": "center" }],
  ["place-self-stretch", { "place-self": "stretch" }],
  ...makeGlobalStaticRules2("place-self")
];
var flexGridJustifiesAlignments2 = [...justifies2, ...alignments2, ...placements2].flatMap(([k, v]) => [
  [`flex-${k}`, v],
  [`grid-${k}`, v]
]);
function handleInsetValue2(v, { theme: theme4 }) {
  var _a3, _b2;
  return (_b2 = (_a3 = theme4.spacing) == null ? void 0 : _a3[v]) != null ? _b2 : h2.bracket.cssvar.global.auto.fraction.rem(v);
}
function handleInsetValues2([, d, v], ctx) {
  const r = handleInsetValue2(v, ctx);
  if (r != null && d in insetMap2)
    return insetMap2[d].map((i) => [i.slice(1), r]);
}
var insets2 = [
  [
    /^(?:position-|pos-)?inset-(.+)$/,
    ([, v], ctx) => ({ inset: handleInsetValue2(v, ctx) }),
    {
      autocomplete: [
        "(position|pos)-inset-<directions>-$spacing",
        "(position|pos)-inset-(block|inline)-$spacing",
        "(position|pos)-inset-(bs|be|is|ie)-$spacing",
        "(position|pos)-(top|left|right|bottom)-$spacing"
      ]
    }
  ],
  [/^(?:position-|pos-)?(start|end)-(.+)$/, handleInsetValues2],
  [/^(?:position-|pos-)?inset-([xy])-(.+)$/, handleInsetValues2],
  [/^(?:position-|pos-)?inset-([rltbse])-(.+)$/, handleInsetValues2],
  [/^(?:position-|pos-)?inset-(block|inline)-(.+)$/, handleInsetValues2],
  [/^(?:position-|pos-)?inset-([bi][se])-(.+)$/, handleInsetValues2],
  [/^(?:position-|pos-)?(top|left|right|bottom)-(.+)$/, ([, d, v], ctx) => ({ [d]: handleInsetValue2(v, ctx) })]
];
var floats2 = [
  // floats
  ["float-left", { float: "left" }],
  ["float-right", { float: "right" }],
  ["float-start", { float: "inline-start" }],
  ["float-end", { float: "inline-end" }],
  ["float-none", { float: "none" }],
  ...makeGlobalStaticRules2("float"),
  // clears
  ["clear-left", { clear: "left" }],
  ["clear-right", { clear: "right" }],
  ["clear-both", { clear: "both" }],
  ["clear-start", { clear: "inline-start" }],
  ["clear-end", { clear: "inline-end" }],
  ["clear-none", { clear: "none" }],
  ...makeGlobalStaticRules2("clear")
];
var zIndexes2 = [
  [/^(?:position-|pos-)?z([\d.]+)$/, ([, v]) => ({ "z-index": h2.number(v) })],
  [/^(?:position-|pos-)?z-(.+)$/, ([, v], { theme: theme4 }) => {
    var _a3, _b2;
    return { "z-index": (_b2 = (_a3 = theme4.zIndex) == null ? void 0 : _a3[v]) != null ? _b2 : h2.bracket.cssvar.global.auto.number(v) };
  }, { autocomplete: "z-<num>" }]
];
var boxSizing2 = [
  ["box-border", { "box-sizing": "border-box" }],
  ["box-content", { "box-sizing": "content-box" }],
  ...makeGlobalStaticRules2("box", "box-sizing")
];
var questionMark2 = [
  [
    /^(where|\?)$/,
    (_, { constructCSS, generator }) => {
      if (generator.userConfig.envMode === "dev")
        return `@keyframes __un_qm{0%{box-shadow:inset 4px 4px #ff1e90, inset -4px -4px #ff1e90}100%{box-shadow:inset 8px 8px #3399ff, inset -8px -8px #3399ff}} ${constructCSS({ animation: "__un_qm 0.5s ease-in-out alternate infinite" })}`;
    }
  ]
];
var sizeMapping2 = {
  h: "height",
  w: "width",
  inline: "inline-size",
  block: "block-size"
};
function getPropName2(minmax, hw) {
  return `${minmax || ""}${sizeMapping2[hw]}`;
}
function getSizeValue2(minmax, hw, theme4, prop) {
  var _a3;
  const key = getPropName2(minmax, hw).replace(/-(\w)/g, (_, p) => p.toUpperCase());
  const v = (_a3 = theme4[key]) == null ? void 0 : _a3[prop];
  if (v != null)
    return v;
  switch (prop) {
    case "fit":
    case "max":
    case "min":
      return `${prop}-content`;
  }
  return h2.bracket.cssvar.global.auto.fraction.rem(prop);
}
var sizes2 = [
  [/^size-(min-|max-)?(.+)$/, ([, m, s], { theme: theme4 }) => ({ [getPropName2(m, "w")]: getSizeValue2(m, "w", theme4, s), [getPropName2(m, "h")]: getSizeValue2(m, "h", theme4, s) })],
  [/^(?:size-)?(min-|max-)?([wh])-?(.+)$/, ([, m, w, s], { theme: theme4 }) => ({ [getPropName2(m, w)]: getSizeValue2(m, w, theme4, s) })],
  [/^(?:size-)?(min-|max-)?(block|inline)-(.+)$/, ([, m, w, s], { theme: theme4 }) => ({ [getPropName2(m, w)]: getSizeValue2(m, w, theme4, s) }), {
    autocomplete: [
      "(w|h)-$width|height|maxWidth|maxHeight|minWidth|minHeight|inlineSize|blockSize|maxInlineSize|maxBlockSize|minInlineSize|minBlockSize",
      "(block|inline)-$width|height|maxWidth|maxHeight|minWidth|minHeight|inlineSize|blockSize|maxInlineSize|maxBlockSize|minInlineSize|minBlockSize",
      "(max|min)-(w|h|block|inline)",
      "(max|min)-(w|h|block|inline)-$width|height|maxWidth|maxHeight|minWidth|minHeight|inlineSize|blockSize|maxInlineSize|maxBlockSize|minInlineSize|minBlockSize",
      "(w|h)-full",
      "(max|min)-(w|h)-full"
    ]
  }],
  [/^(?:size-)?(min-|max-)?(h)-screen-(.+)$/, ([, m, h22, p], context) => ({ [getPropName2(m, h22)]: handleBreakpoint2(context, p, "verticalBreakpoints") })],
  [/^(?:size-)?(min-|max-)?(w)-screen-(.+)$/, ([, m, w, p], context) => ({ [getPropName2(m, w)]: handleBreakpoint2(context, p) }), {
    autocomplete: [
      "(w|h)-screen",
      "(min|max)-(w|h)-screen",
      "h-screen-$verticalBreakpoints",
      "(min|max)-h-screen-$verticalBreakpoints",
      "w-screen-$breakpoints",
      "(min|max)-w-screen-$breakpoints"
    ]
  }]
];
function handleBreakpoint2(context, point, key = "breakpoints") {
  var _a3;
  const bp = resolveBreakpoints2(context, key);
  if (bp)
    return (_a3 = bp.find((i) => i.point === point)) == null ? void 0 : _a3.size;
}
function getAspectRatio2(prop) {
  if (/^\d+\/\d+$/.test(prop))
    return prop;
  switch (prop) {
    case "square":
      return "1/1";
    case "video":
      return "16/9";
  }
  return h2.bracket.cssvar.global.auto.number(prop);
}
var aspectRatio2 = [
  [/^(?:size-)?aspect-(?:ratio-)?(.+)$/, ([, d]) => ({ "aspect-ratio": getAspectRatio2(d) }), { autocomplete: ["aspect-(square|video|ratio)", "aspect-ratio-(square|video)"] }]
];
var paddings2 = [
  [/^pa?()-?(.+)$/, directionSize2("padding"), { autocomplete: ["(m|p)<num>", "(m|p)-<num>"] }],
  [/^p-?xy()()$/, directionSize2("padding"), { autocomplete: "(m|p)-(xy)" }],
  [/^p-?([xy])(?:-?(.+))?$/, directionSize2("padding")],
  [/^p-?([rltbse])(?:-?(.+))?$/, directionSize2("padding"), { autocomplete: "(m|p)<directions>-<num>" }],
  [/^p-(block|inline)(?:-(.+))?$/, directionSize2("padding"), { autocomplete: "(m|p)-(block|inline)-<num>" }],
  [/^p-?([bi][se])(?:-?(.+))?$/, directionSize2("padding"), { autocomplete: "(m|p)-(bs|be|is|ie)-<num>" }]
];
var margins2 = [
  [/^ma?()-?(.+)$/, directionSize2("margin")],
  [/^m-?xy()()$/, directionSize2("margin")],
  [/^m-?([xy])(?:-?(.+))?$/, directionSize2("margin")],
  [/^m-?([rltbse])(?:-?(.+))?$/, directionSize2("margin")],
  [/^m-(block|inline)(?:-(.+))?$/, directionSize2("margin")],
  [/^m-?([bi][se])(?:-?(.+))?$/, directionSize2("margin")]
];
var svgUtilities2 = [
  // fills
  [/^fill-(.+)$/, colorResolver2("fill", "fill", "backgroundColor"), { autocomplete: "fill-$colors" }],
  [/^fill-op(?:acity)?-?(.+)$/, ([, opacity3]) => ({ "--un-fill-opacity": h2.bracket.percent.cssvar(opacity3) }), { autocomplete: "fill-(op|opacity)-<percent>" }],
  ["fill-none", { fill: "none" }],
  // stroke size
  [/^stroke-(?:width-|size-)?(.+)$/, handleWidth6, { autocomplete: ["stroke-width-$lineWidth", "stroke-size-$lineWidth"] }],
  // stroke dash
  [/^stroke-dash-(.+)$/, ([, s]) => ({ "stroke-dasharray": h2.bracket.cssvar.number(s) }), { autocomplete: "stroke-dash-<num>" }],
  [/^stroke-offset-(.+)$/, ([, s], { theme: theme4 }) => {
    var _a3, _b2;
    return { "stroke-dashoffset": (_b2 = (_a3 = theme4.lineWidth) == null ? void 0 : _a3[s]) != null ? _b2 : h2.bracket.cssvar.px.numberWithUnit(s) };
  }, { autocomplete: "stroke-offset-$lineWidth" }],
  // stroke colors
  [/^stroke-(.+)$/, handleColorOrWidth6, { autocomplete: "stroke-$colors" }],
  [/^stroke-op(?:acity)?-?(.+)$/, ([, opacity3]) => ({ "--un-stroke-opacity": h2.bracket.percent.cssvar(opacity3) }), { autocomplete: "stroke-(op|opacity)-<percent>" }],
  // line cap
  ["stroke-cap-square", { "stroke-linecap": "square" }],
  ["stroke-cap-round", { "stroke-linecap": "round" }],
  ["stroke-cap-auto", { "stroke-linecap": "butt" }],
  // line join
  ["stroke-join-arcs", { "stroke-linejoin": "arcs" }],
  ["stroke-join-bevel", { "stroke-linejoin": "bevel" }],
  ["stroke-join-clip", { "stroke-linejoin": "miter-clip" }],
  ["stroke-join-round", { "stroke-linejoin": "round" }],
  ["stroke-join-auto", { "stroke-linejoin": "miter" }],
  // none
  ["stroke-none", { stroke: "none" }]
];
function handleWidth6([, b], { theme: theme4 }) {
  var _a3, _b2;
  return { "stroke-width": (_b2 = (_a3 = theme4.lineWidth) == null ? void 0 : _a3[b]) != null ? _b2 : h2.bracket.cssvar.fraction.px.number(b) };
}
function handleColorOrWidth6(match, ctx) {
  if (isCSSMathFn2(h2.bracket(match[1])))
    return handleWidth6(match, ctx);
  return colorResolver2("stroke", "stroke", "borderColor")(match, ctx);
}
function resolveTransitionProperty2(prop, theme4) {
  let p;
  if (h2.cssvar(prop) != null) {
    p = h2.cssvar(prop);
  } else {
    if (prop.startsWith("[") && prop.endsWith("]")) {
      prop = prop.slice(1, -1);
    }
    const props = prop.split(",").map((p2) => {
      var _a3, _b2;
      return (_b2 = (_a3 = theme4.transitionProperty) == null ? void 0 : _a3[p2]) != null ? _b2 : h2.properties(p2);
    });
    if (props.every(Boolean)) {
      p = props.join(",");
    }
  }
  return p;
}
var transitions2 = [
  // transition
  [
    /^transition(?:-(\D+?))?(?:-(\d+))?$/,
    ([, prop, d], { theme: theme4 }) => {
      var _a3, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k;
      if (!prop && !d) {
        return {
          "transition-property": (_a3 = theme4.transitionProperty) == null ? void 0 : _a3.DEFAULT,
          "transition-timing-function": (_b2 = theme4.easing) == null ? void 0 : _b2.DEFAULT,
          "transition-duration": (_d = (_c = theme4.duration) == null ? void 0 : _c.DEFAULT) != null ? _d : h2.time("150")
        };
      } else if (prop != null) {
        const p = resolveTransitionProperty2(prop, theme4);
        const duration3 = (_f = (_e = theme4.duration) == null ? void 0 : _e[d || "DEFAULT"]) != null ? _f : h2.time(d || "150");
        if (p) {
          return {
            "transition-property": p,
            "transition-timing-function": (_g = theme4.easing) == null ? void 0 : _g.DEFAULT,
            "transition-duration": duration3
          };
        }
      } else if (d != null) {
        return {
          "transition-property": (_h = theme4.transitionProperty) == null ? void 0 : _h.DEFAULT,
          "transition-timing-function": (_i = theme4.easing) == null ? void 0 : _i.DEFAULT,
          "transition-duration": (_k = (_j = theme4.duration) == null ? void 0 : _j[d]) != null ? _k : h2.time(d)
        };
      }
    },
    {
      autocomplete: "transition-$transitionProperty-$duration"
    }
  ],
  // timings
  [
    /^(?:transition-)?duration-(.+)$/,
    ([, d], { theme: theme4 }) => {
      var _a3, _b2;
      return { "transition-duration": (_b2 = (_a3 = theme4.duration) == null ? void 0 : _a3[d || "DEFAULT"]) != null ? _b2 : h2.bracket.cssvar.time(d) };
    },
    { autocomplete: ["transition-duration-$duration", "duration-$duration"] }
  ],
  [
    /^(?:transition-)?delay-(.+)$/,
    ([, d], { theme: theme4 }) => {
      var _a3, _b2;
      return { "transition-delay": (_b2 = (_a3 = theme4.duration) == null ? void 0 : _a3[d || "DEFAULT"]) != null ? _b2 : h2.bracket.cssvar.time(d) };
    },
    { autocomplete: ["transition-delay-$duration", "delay-$duration"] }
  ],
  [
    /^(?:transition-)?ease(?:-(.+))?$/,
    ([, d], { theme: theme4 }) => {
      var _a3, _b2;
      return { "transition-timing-function": (_b2 = (_a3 = theme4.easing) == null ? void 0 : _a3[d || "DEFAULT"]) != null ? _b2 : h2.bracket.cssvar(d) };
    },
    { autocomplete: ["transition-ease-(linear|in|out|in-out|DEFAULT)", "ease-(linear|in|out|in-out|DEFAULT)"] }
  ],
  // props
  [
    /^(?:transition-)?property-(.+)$/,
    ([, v], { theme: theme4 }) => {
      const p = h2.global(v) || resolveTransitionProperty2(v, theme4);
      if (p)
        return { "transition-property": p };
    },
    { autocomplete: [
      `transition-property-(${[...globalKeywords2].join("|")})`,
      "transition-property-$transitionProperty",
      "property-$transitionProperty"
    ] }
  ],
  // none
  ["transition-none", { transition: "none" }],
  ...makeGlobalStaticRules2("transition"),
  // behavior
  ["transition-discrete", { "transition-behavior": "allow-discrete" }],
  ["transition-normal", { "transition-behavior": "normal" }]
];
var fonts2 = [
  // text
  [/^text-(.+)$/, handleText2, { autocomplete: "text-$fontSize" }],
  // text size
  [/^(?:text|font)-size-(.+)$/, handleSize2, { autocomplete: "text-size-$fontSize" }],
  // text colors
  [/^text-(?:color-)?(.+)$/, handlerColorOrSize2, { autocomplete: "text-$colors" }],
  // colors
  [/^(?:color|c)-(.+)$/, colorResolver2("color", "text", "textColor"), { autocomplete: "(color|c)-$colors" }],
  // style
  [/^(?:text|color|c)-(.+)$/, ([, v]) => globalKeywords2.includes(v) ? { color: v } : void 0, { autocomplete: `(text|color|c)-(${globalKeywords2.join("|")})` }],
  // opacity
  [/^(?:text|color|c)-op(?:acity)?-?(.+)$/, ([, opacity3]) => ({ "--un-text-opacity": h2.bracket.percent.cssvar(opacity3) }), { autocomplete: "(text|color|c)-(op|opacity)-<percent>" }],
  // weights
  [
    /^(?:font|fw)-?([^-]+)$/,
    ([, s], { theme: theme4 }) => {
      var _a3;
      return { "font-weight": ((_a3 = theme4.fontWeight) == null ? void 0 : _a3[s]) || h2.bracket.global.number(s) };
    },
    {
      autocomplete: [
        "(font|fw)-(100|200|300|400|500|600|700|800|900)",
        "(font|fw)-$fontWeight"
      ]
    }
  ],
  // leadings
  [
    /^(?:font-)?(?:leading|lh|line-height)-(.+)$/,
    ([, s], { theme: theme4 }) => ({ "line-height": handleThemeByKey2(s, theme4, "lineHeight") }),
    { autocomplete: "(leading|lh|line-height)-$lineHeight" }
  ],
  // synthesis
  ["font-synthesis-weight", { "font-synthesis": "weight" }],
  ["font-synthesis-style", { "font-synthesis": "style" }],
  ["font-synthesis-small-caps", { "font-synthesis": "small-caps" }],
  ["font-synthesis-none", { "font-synthesis": "none" }],
  [/^font-synthesis-(.+)$/, ([, s]) => ({ "font-synthesis": h2.bracket.cssvar.global(s) })],
  // tracking
  [
    /^(?:font-)?tracking-(.+)$/,
    ([, s], { theme: theme4 }) => {
      var _a3;
      return { "letter-spacing": ((_a3 = theme4.letterSpacing) == null ? void 0 : _a3[s]) || h2.bracket.cssvar.global.rem(s) };
    },
    { autocomplete: "tracking-$letterSpacing" }
  ],
  // word-spacing
  [
    /^(?:font-)?word-spacing-(.+)$/,
    ([, s], { theme: theme4 }) => {
      var _a3;
      return { "word-spacing": ((_a3 = theme4.wordSpacing) == null ? void 0 : _a3[s]) || h2.bracket.cssvar.global.rem(s) };
    },
    { autocomplete: "word-spacing-$wordSpacing" }
  ],
  // stretch
  ["font-stretch-normal", { "font-stretch": "normal" }],
  ["font-stretch-ultra-condensed", { "font-stretch": "ultra-condensed" }],
  ["font-stretch-extra-condensed", { "font-stretch": "extra-condensed" }],
  ["font-stretch-condensed", { "font-stretch": "condensed" }],
  ["font-stretch-semi-condensed", { "font-stretch": "semi-condensed" }],
  ["font-stretch-semi-expanded", { "font-stretch": "semi-expanded" }],
  ["font-stretch-expanded", { "font-stretch": "expanded" }],
  ["font-stretch-extra-expanded", { "font-stretch": "extra-expanded" }],
  ["font-stretch-ultra-expanded", { "font-stretch": "ultra-expanded" }],
  [
    /^font-stretch-(.+)$/,
    ([, s]) => ({ "font-stretch": h2.bracket.cssvar.fraction.global(s) }),
    { autocomplete: "font-stretch-<percentage>" }
  ],
  // family
  [
    /^font-(.+)$/,
    ([, d], { theme: theme4 }) => {
      var _a3;
      return { "font-family": ((_a3 = theme4.fontFamily) == null ? void 0 : _a3[d]) || h2.bracket.cssvar.global(d) };
    },
    { autocomplete: "font-$fontFamily" }
  ]
];
var tabSizes2 = [
  [/^tab(?:-(.+))?$/, ([, s]) => {
    const v = h2.bracket.cssvar.global.number(s || "4");
    if (v != null) {
      return {
        "-moz-tab-size": v,
        "-o-tab-size": v,
        "tab-size": v
      };
    }
  }]
];
var textIndents2 = [
  [/^indent(?:-(.+))?$/, ([, s], { theme: theme4 }) => {
    var _a3;
    return { "text-indent": ((_a3 = theme4.textIndent) == null ? void 0 : _a3[s || "DEFAULT"]) || h2.bracket.cssvar.global.fraction.rem(s) };
  }, { autocomplete: "indent-$textIndent" }]
];
var textStrokes2 = [
  // widths
  [/^text-stroke(?:-(.+))?$/, ([, s], { theme: theme4 }) => {
    var _a3;
    return { "-webkit-text-stroke-width": ((_a3 = theme4.textStrokeWidth) == null ? void 0 : _a3[s || "DEFAULT"]) || h2.bracket.cssvar.px(s) };
  }, { autocomplete: "text-stroke-$textStrokeWidth" }],
  // colors
  [/^text-stroke-(.+)$/, colorResolver2("-webkit-text-stroke-color", "text-stroke", "borderColor"), { autocomplete: "text-stroke-$colors" }],
  [/^text-stroke-op(?:acity)?-?(.+)$/, ([, opacity3]) => ({ "--un-text-stroke-opacity": h2.bracket.percent.cssvar(opacity3) }), { autocomplete: "text-stroke-(op|opacity)-<percent>" }]
];
var textShadows2 = [
  [/^text-shadow(?:-(.+))?$/, ([, s], { theme: theme4 }) => {
    var _a3;
    const v = (_a3 = theme4.textShadow) == null ? void 0 : _a3[s || "DEFAULT"];
    if (v != null) {
      return {
        "--un-text-shadow": colorableShadows2(v, "--un-text-shadow-color").join(","),
        "text-shadow": "var(--un-text-shadow)"
      };
    }
    return { "text-shadow": h2.bracket.cssvar.global(s) };
  }, { autocomplete: "text-shadow-$textShadow" }],
  // colors
  [/^text-shadow-color-(.+)$/, colorResolver2("--un-text-shadow-color", "text-shadow", "shadowColor"), { autocomplete: "text-shadow-color-$colors" }],
  [/^text-shadow-color-op(?:acity)?-?(.+)$/, ([, opacity3]) => ({ "--un-text-shadow-opacity": h2.bracket.percent.cssvar(opacity3) }), { autocomplete: "text-shadow-color-(op|opacity)-<percent>" }]
];
function handleThemeByKey2(s, theme4, key) {
  var _a3;
  return ((_a3 = theme4[key]) == null ? void 0 : _a3[s]) || h2.bracket.cssvar.global.rem(s);
}
function handleSize2([, s], { theme: theme4 }) {
  var _a3, _b2;
  const themed = toArray2((_a3 = theme4.fontSize) == null ? void 0 : _a3[s]);
  const size = (_b2 = themed == null ? void 0 : themed[0]) != null ? _b2 : h2.bracket.cssvar.global.rem(s);
  if (size != null)
    return { "font-size": size };
}
function handlerColorOrSize2(match, ctx) {
  if (isCSSMathFn2(h2.bracket(match[1])))
    return handleSize2(match, ctx);
  return colorResolver2("color", "text", "textColor")(match, ctx);
}
function handleText2([, s = "base"], { theme: theme4 }) {
  var _a3, _b2;
  const split = splitShorthand2(s, "length");
  if (!split)
    return;
  const [size, leading] = split;
  const sizePairs = toArray2((_a3 = theme4.fontSize) == null ? void 0 : _a3[size]);
  const lineHeight3 = leading ? handleThemeByKey2(leading, theme4, "lineHeight") : void 0;
  if (sizePairs == null ? void 0 : sizePairs[0]) {
    const [fontSize22, height3, letterSpacing3] = sizePairs;
    if (typeof height3 === "object") {
      return {
        "font-size": fontSize22,
        ...height3
      };
    }
    return {
      "font-size": fontSize22,
      "line-height": (_b2 = lineHeight3 != null ? lineHeight3 : height3) != null ? _b2 : "1",
      "letter-spacing": letterSpacing3 ? handleThemeByKey2(letterSpacing3, theme4, "letterSpacing") : void 0
    };
  }
  const fontSize3 = h2.bracketOfLength.rem(size);
  if (lineHeight3 && fontSize3) {
    return {
      "font-size": fontSize3,
      "line-height": lineHeight3
    };
  }
  return { "font-size": h2.bracketOfLength.rem(s) };
}
var variablesAbbrMap2 = {
  backface: "backface-visibility",
  break: "word-break",
  case: "text-transform",
  content: "align-content",
  fw: "font-weight",
  items: "align-items",
  justify: "justify-content",
  select: "user-select",
  self: "align-self",
  vertical: "vertical-align",
  visible: "visibility",
  whitespace: "white-space",
  ws: "white-space"
};
var cssVariables2 = [
  [/^(.+?)-(\$.+)$/, ([, name2, varname]) => {
    const prop = variablesAbbrMap2[name2];
    if (prop)
      return { [prop]: h2.cssvar(varname) };
  }]
];
var cssProperty2 = [
  [/^\[(.*)\]$/, ([_, body]) => {
    if (!body.includes(":"))
      return;
    const [prop, ...rest] = body.split(":");
    const value = rest.join(":");
    if (!isURI2(body) && /^[a-z-]+$/.test(prop) && isValidCSSBody2(value)) {
      const parsed = h2.bracket(`[${value}]`);
      if (parsed)
        return { [prop]: parsed };
    }
  }]
];
function isValidCSSBody2(body) {
  let i = 0;
  function findUntil(c) {
    while (i < body.length) {
      i += 1;
      const char = body[i];
      if (char === c)
        return true;
    }
    return false;
  }
  for (i = 0; i < body.length; i++) {
    const c = body[i];
    if ("\"`'".includes(c)) {
      if (!findUntil(c))
        return false;
    } else if (c === "(") {
      if (!findUntil(")"))
        return false;
    } else if ("[]{}:".includes(c)) {
      return false;
    }
  }
  return true;
}
function isURI2(declaration) {
  if (!declaration.includes("://"))
    return false;
  try {
    return new URL(declaration).host !== "";
  } catch (e2) {
    return false;
  }
}
var rules2 = [
  cssVariables2,
  cssProperty2,
  contains2,
  pointerEvents2,
  appearances2,
  positions2,
  insets2,
  zIndexes2,
  orders2,
  grids2,
  floats2,
  margins2,
  boxSizing2,
  displays2,
  aspectRatio2,
  sizes2,
  flex2,
  transforms2,
  cursors2,
  userSelects2,
  resizes2,
  appearance2,
  placements2,
  alignments2,
  justifies2,
  gaps2,
  flexGridJustifiesAlignments2,
  overflows2,
  textOverflows2,
  whitespaces2,
  breaks2,
  borders2,
  bgColors2,
  colorScheme2,
  svgUtilities2,
  paddings2,
  textAligns2,
  textIndents2,
  textWraps2,
  verticalAligns2,
  fonts2,
  textTransforms2,
  fontStyles2,
  textDecorations2,
  fontSmoothings2,
  tabSizes2,
  textStrokes2,
  textShadows2,
  opacity2,
  boxShadows2,
  outline2,
  rings2,
  transitions2,
  willChange2,
  contentVisibility2,
  contents2,
  containerParent2,
  // should be the last
  questionMark2
].flat(1);

// ../../packages-presets/preset-wind3/src/rules/divide.ts
var divides = [
  // divides
  [/^divide-?([xy])$/, handlerDivide, { autocomplete: ["divide-(x|y|block|inline)", "divide-(x|y|block|inline)-reverse", "divide-(x|y|block|inline)-$lineWidth"] }],
  [/^divide-?([xy])-?(.+)$/, handlerDivide],
  [/^divide-?([xy])-reverse$/, ([, d]) => ({ [`--un-divide-${d}-reverse`]: 1 })],
  [/^divide-(block|inline)$/, handlerDivide],
  [/^divide-(block|inline)-(.+)$/, handlerDivide],
  [/^divide-(block|inline)-reverse$/, ([, d]) => ({ [`--un-divide-${d}-reverse`]: 1 })],
  // color & opacity
  [/^divide-(.+)$/, colorResolver2("border-color", "divide", "borderColor"), { autocomplete: "divide-$colors" }],
  [/^divide-op(?:acity)?-?(.+)$/, ([, opacity3]) => ({ "--un-divide-opacity": h2.bracket.percent(opacity3) }), { autocomplete: ["divide-(op|opacity)", "divide-(op|opacity)-<percent>"] }],
  // styles
  ...borderStyles2.map((style) => [`divide-${style}`, { "border-style": style }])
];
function handlerDivide([, d, s], { theme: theme4 }) {
  var _a3, _b2;
  let v = (_b2 = (_a3 = theme4.lineWidth) == null ? void 0 : _a3[s || "DEFAULT"]) != null ? _b2 : h2.bracket.cssvar.px(s || "1");
  if (v != null) {
    if (v === "0")
      v = "0px";
    const results = directionMap2[d].map((item) => {
      const key = `border${item}-width`;
      const value = item.endsWith("right") || item.endsWith("bottom") ? `calc(${v} * var(--un-divide-${d}-reverse))` : `calc(${v} * calc(1 - var(--un-divide-${d}-reverse)))`;
      return [key, value];
    });
    if (results) {
      return [
        [`--un-divide-${d}-reverse`, 0],
        ...results
      ];
    }
  }
}

// ../../packages-presets/preset-wind3/src/rules/filters.ts
var filterBase = {
  "--un-blur": varEmpty2,
  "--un-brightness": varEmpty2,
  "--un-contrast": varEmpty2,
  "--un-drop-shadow": varEmpty2,
  "--un-grayscale": varEmpty2,
  "--un-hue-rotate": varEmpty2,
  "--un-invert": varEmpty2,
  "--un-saturate": varEmpty2,
  "--un-sepia": varEmpty2
};
var filterBaseKeys = Object.keys(filterBase);
var filterMetaCustom = {
  preflightKeys: filterBaseKeys
};
var filterProperty = "var(--un-blur) var(--un-brightness) var(--un-contrast) var(--un-drop-shadow) var(--un-grayscale) var(--un-hue-rotate) var(--un-invert) var(--un-saturate) var(--un-sepia)";
var backdropFilterBase = {
  "--un-backdrop-blur": varEmpty2,
  "--un-backdrop-brightness": varEmpty2,
  "--un-backdrop-contrast": varEmpty2,
  "--un-backdrop-grayscale": varEmpty2,
  "--un-backdrop-hue-rotate": varEmpty2,
  "--un-backdrop-invert": varEmpty2,
  "--un-backdrop-opacity": varEmpty2,
  "--un-backdrop-saturate": varEmpty2,
  "--un-backdrop-sepia": varEmpty2
};
var backdropFilterBaseKeys = Object.keys(backdropFilterBase);
var backdropMetaCustom = {
  preflightKeys: backdropFilterBaseKeys
};
var backdropFilterProperty = "var(--un-backdrop-blur) var(--un-backdrop-brightness) var(--un-backdrop-contrast) var(--un-backdrop-grayscale) var(--un-backdrop-hue-rotate) var(--un-backdrop-invert) var(--un-backdrop-opacity) var(--un-backdrop-saturate) var(--un-backdrop-sepia)";
var composeMetaCustom = {
  preflightKeys: [...filterBaseKeys, ...backdropFilterBaseKeys]
};
function percentWithDefault(str) {
  let v = h2.bracket.cssvar(str || "");
  if (v != null)
    return v;
  v = str ? h2.percent(str) : "1";
  if (v != null && Number.parseFloat(v) <= 1)
    return v;
}
function toFilter(varName, resolver) {
  return ([, b, s], { theme: theme4 }) => {
    var _a3;
    const value = (_a3 = resolver(s, theme4)) != null ? _a3 : s === "none" ? "0" : "";
    if (value !== "") {
      if (b) {
        return {
          [`--un-${b}${varName}`]: `${varName}(${value})`,
          "-webkit-backdrop-filter": backdropFilterProperty,
          "backdrop-filter": backdropFilterProperty
        };
      } else {
        return {
          [`--un-${varName}`]: `${varName}(${value})`,
          filter: filterProperty
        };
      }
    }
  };
}
function dropShadowResolver([, s], { theme: theme4 }) {
  var _a3;
  let v = (_a3 = theme4.dropShadow) == null ? void 0 : _a3[s || "DEFAULT"];
  if (v != null) {
    const shadows = colorableShadows2(v, "--un-drop-shadow-color");
    return {
      "--un-drop-shadow": `drop-shadow(${shadows.join(") drop-shadow(")})`,
      "filter": filterProperty
    };
  }
  v = h2.bracket.cssvar(s);
  if (v != null) {
    return {
      "--un-drop-shadow": `drop-shadow(${v})`,
      "filter": filterProperty
    };
  }
}
var filters = [
  // filters
  [/^(?:(backdrop-)|filter-)?blur(?:-(.+))?$/, toFilter("blur", (s, theme4) => {
    var _a3;
    return ((_a3 = theme4.blur) == null ? void 0 : _a3[s || "DEFAULT"]) || h2.bracket.cssvar.px(s);
  }), { custom: composeMetaCustom, autocomplete: ["(backdrop|filter)-blur-$blur", "blur-$blur", "filter-blur"] }],
  [/^(?:(backdrop-)|filter-)?brightness-(.+)$/, toFilter("brightness", (s) => h2.bracket.cssvar.percent(s)), { custom: composeMetaCustom, autocomplete: ["(backdrop|filter)-brightness-<percent>", "brightness-<percent>"] }],
  [/^(?:(backdrop-)|filter-)?contrast-(.+)$/, toFilter("contrast", (s) => h2.bracket.cssvar.percent(s)), { custom: composeMetaCustom, autocomplete: ["(backdrop|filter)-contrast-<percent>", "contrast-<percent>"] }],
  // drop-shadow only on filter
  [/^(?:filter-)?drop-shadow(?:-(.+))?$/, dropShadowResolver, {
    custom: filterMetaCustom,
    autocomplete: [
      "filter-drop",
      "filter-drop-shadow",
      "filter-drop-shadow-color",
      "drop-shadow",
      "drop-shadow-color",
      "filter-drop-shadow-$dropShadow",
      "drop-shadow-$dropShadow",
      "filter-drop-shadow-color-$colors",
      "drop-shadow-color-$colors",
      "filter-drop-shadow-color-(op|opacity)",
      "drop-shadow-color-(op|opacity)",
      "filter-drop-shadow-color-(op|opacity)-<percent>",
      "drop-shadow-color-(op|opacity)-<percent>"
    ]
  }],
  [/^(?:filter-)?drop-shadow-color-(.+)$/, colorResolver2("--un-drop-shadow-color", "drop-shadow", "shadowColor")],
  [/^(?:filter-)?drop-shadow-color-op(?:acity)?-?(.+)$/, ([, opacity3]) => ({ "--un-drop-shadow-opacity": h2.bracket.percent(opacity3) })],
  [/^(?:(backdrop-)|filter-)?grayscale(?:-(.+))?$/, toFilter("grayscale", percentWithDefault), { custom: composeMetaCustom, autocomplete: ["(backdrop|filter)-grayscale", "(backdrop|filter)-grayscale-<percent>", "grayscale-<percent>"] }],
  [/^(?:(backdrop-)|filter-)?hue-rotate-(.+)$/, toFilter("hue-rotate", (s) => h2.bracket.cssvar.degree(s)), { custom: composeMetaCustom }],
  [/^(?:(backdrop-)|filter-)?invert(?:-(.+))?$/, toFilter("invert", percentWithDefault), { custom: composeMetaCustom, autocomplete: ["(backdrop|filter)-invert", "(backdrop|filter)-invert-<percent>", "invert-<percent>"] }],
  // opacity only on backdrop-filter
  [/^(backdrop-)op(?:acity)?-(.+)$/, toFilter("opacity", (s) => h2.bracket.cssvar.percent(s)), { custom: composeMetaCustom, autocomplete: ["backdrop-(op|opacity)", "backdrop-(op|opacity)-<percent>"] }],
  [/^(?:(backdrop-)|filter-)?saturate-(.+)$/, toFilter("saturate", (s) => h2.bracket.cssvar.percent(s)), { custom: composeMetaCustom, autocomplete: ["(backdrop|filter)-saturate", "(backdrop|filter)-saturate-<percent>", "saturate-<percent>"] }],
  [/^(?:(backdrop-)|filter-)?sepia(?:-(.+))?$/, toFilter("sepia", percentWithDefault), { custom: composeMetaCustom, autocomplete: ["(backdrop|filter)-sepia", "(backdrop|filter)-sepia-<percent>", "sepia-<percent>"] }],
  // base
  ["filter", { filter: filterProperty }, { custom: filterMetaCustom }],
  ["backdrop-filter", {
    "-webkit-backdrop-filter": backdropFilterProperty,
    "backdrop-filter": backdropFilterProperty
  }, { custom: backdropMetaCustom }],
  // nones
  ["filter-none", { filter: "none" }],
  ["backdrop-filter-none", {
    "-webkit-backdrop-filter": "none",
    "backdrop-filter": "none"
  }],
  ...globalKeywords2.map((keyword) => [`filter-${keyword}`, { filter: keyword }]),
  ...globalKeywords2.map((keyword) => [`backdrop-filter-${keyword}`, {
    "-webkit-backdrop-filter": keyword,
    "backdrop-filter": keyword
  }])
];

// ../../packages-presets/preset-wind3/src/rules/line-clamp.ts
var lineClamps = [
  [/^line-clamp-(\d+)$/, ([, v]) => ({
    "overflow": "hidden",
    "display": "-webkit-box",
    "-webkit-box-orient": "vertical",
    "-webkit-line-clamp": v,
    "line-clamp": v
  }), { autocomplete: ["line-clamp", "line-clamp-<num>"] }],
  ...["none", ...globalKeywords2].map((keyword) => [`line-clamp-${keyword}`, {
    "overflow": "visible",
    "display": "block",
    "-webkit-box-orient": "horizontal",
    "-webkit-line-clamp": keyword,
    "line-clamp": keyword
  }])
];

// ../../packages-presets/preset-wind3/src/rules/placeholder.ts
var placeholders = [
  // The prefix `$ ` is intentional. This rule is not to be matched directly from user-generated token.
  // See variants/placeholder.
  [/^\$ placeholder-(.+)$/, colorResolver2("color", "placeholder", "accentColor"), { autocomplete: "placeholder-$colors" }],
  [/^\$ placeholder-op(?:acity)?-?(.+)$/, ([, opacity3]) => ({ "--un-placeholder-opacity": h2.bracket.percent(opacity3) }), { autocomplete: ["placeholder-(op|opacity)", "placeholder-(op|opacity)-<percent>"] }]
];

// ../../packages-presets/preset-wind3/src/rules/scrolls.ts
var scrollSnapTypeBase = {
  "--un-scroll-snap-strictness": "proximity"
};
var custom = { preflightKeys: Object.keys(scrollSnapTypeBase) };
var scrolls = [
  // snap type
  [/^snap-(x|y)$/, ([, d]) => ({
    "scroll-snap-type": `${d} var(--un-scroll-snap-strictness)`
  }), { custom, autocomplete: "snap-(x|y|both)" }],
  [/^snap-both$/, () => ({
    "scroll-snap-type": "both var(--un-scroll-snap-strictness)"
  }), { custom }],
  ["snap-mandatory", { "--un-scroll-snap-strictness": "mandatory" }],
  ["snap-proximity", { "--un-scroll-snap-strictness": "proximity" }],
  ["snap-none", { "scroll-snap-type": "none" }],
  // snap align
  ["snap-start", { "scroll-snap-align": "start" }],
  ["snap-end", { "scroll-snap-align": "end" }],
  ["snap-center", { "scroll-snap-align": "center" }],
  ["snap-align-none", { "scroll-snap-align": "none" }],
  // snap stop
  ["snap-normal", { "scroll-snap-stop": "normal" }],
  ["snap-always", { "scroll-snap-stop": "always" }],
  // scroll margin
  [/^scroll-ma?()-?(.+)$/, directionSize2("scroll-margin"), {
    autocomplete: [
      "scroll-(m|p|ma|pa|block|inline)",
      "scroll-(m|p|ma|pa|block|inline)-$spacing",
      "scroll-(m|p|ma|pa|block|inline)-(x|y|r|l|t|b|bs|be|is|ie)",
      "scroll-(m|p|ma|pa|block|inline)-(x|y|r|l|t|b|bs|be|is|ie)-$spacing"
    ]
  }],
  [/^scroll-m-?([xy])-?(.+)$/, directionSize2("scroll-margin")],
  [/^scroll-m-?([rltb])-?(.+)$/, directionSize2("scroll-margin")],
  [/^scroll-m-(block|inline)-(.+)$/, directionSize2("scroll-margin")],
  [/^scroll-m-?([bi][se])-?(.+)$/, directionSize2("scroll-margin")],
  // scroll padding
  [/^scroll-pa?()-?(.+)$/, directionSize2("scroll-padding")],
  [/^scroll-p-?([xy])-?(.+)$/, directionSize2("scroll-padding")],
  [/^scroll-p-?([rltb])-?(.+)$/, directionSize2("scroll-padding")],
  [/^scroll-p-(block|inline)-(.+)$/, directionSize2("scroll-padding")],
  [/^scroll-p-?([bi][se])-?(.+)$/, directionSize2("scroll-padding")]
];

// ../../packages-presets/preset-wind3/src/rules/spacing.ts
var spaces = [
  [/^space-([xy])-(.+)$/, handlerSpace, { autocomplete: ["space-(x|y|block|inline)", "space-(x|y|block|inline)-reverse", "space-(x|y|block|inline)-$spacing"] }],
  [/^space-([xy])-reverse$/, ([, d]) => ({ [`--un-space-${d}-reverse`]: 1 })],
  [/^space-(block|inline)-(.+)$/, handlerSpace],
  [/^space-(block|inline)-reverse$/, ([, d]) => ({ [`--un-space-${d}-reverse`]: 1 })]
];
function handlerSpace([, d, s], { theme: theme4 }) {
  var _a3, _b2;
  let v = (_b2 = (_a3 = theme4.spacing) == null ? void 0 : _a3[s || "DEFAULT"]) != null ? _b2 : h2.bracket.cssvar.auto.fraction.rem(s || "1");
  if (v != null) {
    if (v === "0")
      v = "0px";
    const results = directionMap2[d].map((item) => {
      const key = `margin${item}`;
      const value = item.endsWith("right") || item.endsWith("bottom") ? `calc(${v} * var(--un-space-${d}-reverse))` : `calc(${v} * calc(1 - var(--un-space-${d}-reverse)))`;
      return [key, value];
    });
    if (results) {
      return [
        [`--un-space-${d}-reverse`, 0],
        ...results
      ];
    }
  }
}

// ../../packages-presets/preset-wind3/src/rules/static.ts
var textTransforms3 = [
  // tailwind compat
  ["uppercase", { "text-transform": "uppercase" }],
  ["lowercase", { "text-transform": "lowercase" }],
  ["capitalize", { "text-transform": "capitalize" }],
  ["normal-case", { "text-transform": "none" }]
];
var hyphens = [
  ...["manual", "auto", "none", ...globalKeywords2].map((keyword) => [`hyphens-${keyword}`, {
    "-webkit-hyphens": keyword,
    "-ms-hyphens": keyword,
    "hyphens": keyword
  }])
];
var writingModes = [
  ["write-vertical-right", { "writing-mode": "vertical-rl" }],
  ["write-vertical-left", { "writing-mode": "vertical-lr" }],
  ["write-normal", { "writing-mode": "horizontal-tb" }],
  ...makeGlobalStaticRules2("write", "writing-mode")
];
var writingOrientations = [
  ["write-orient-mixed", { "text-orientation": "mixed" }],
  ["write-orient-sideways", { "text-orientation": "sideways" }],
  ["write-orient-upright", { "text-orientation": "upright" }],
  ...makeGlobalStaticRules2("write-orient", "text-orientation")
];
var screenReadersAccess = [
  [
    "sr-only",
    {
      "position": "absolute",
      "width": "1px",
      "height": "1px",
      "padding": "0",
      "margin": "-1px",
      "overflow": "hidden",
      "clip": "rect(0,0,0,0)",
      "white-space": "nowrap",
      "border-width": 0
    }
  ],
  [
    "not-sr-only",
    {
      "position": "static",
      "width": "auto",
      "height": "auto",
      "padding": "0",
      "margin": "0",
      "overflow": "visible",
      "clip": "auto",
      "white-space": "normal"
    }
  ]
];
var isolations = [
  ["isolate", { isolation: "isolate" }],
  ["isolate-auto", { isolation: "auto" }],
  ["isolation-auto", { isolation: "auto" }]
];
var objectPositions = [
  // object fit
  ["object-cover", { "object-fit": "cover" }],
  ["object-contain", { "object-fit": "contain" }],
  ["object-fill", { "object-fit": "fill" }],
  ["object-scale-down", { "object-fit": "scale-down" }],
  ["object-none", { "object-fit": "none" }],
  // object position
  [/^object-(.+)$/, ([, d]) => {
    if (positionMap2[d])
      return { "object-position": positionMap2[d] };
    if (h2.bracketOfPosition(d) != null)
      return { "object-position": h2.bracketOfPosition(d).split(" ").map((e2) => {
        var _a3;
        return (_a3 = h2.position.fraction.auto.px.cssvar(e2)) != null ? _a3 : e2;
      }).join(" ") };
  }, { autocomplete: `object-(${Object.keys(positionMap2).join("|")})` }]
];
var backgroundBlendModes = [
  ["bg-blend-multiply", { "background-blend-mode": "multiply" }],
  ["bg-blend-screen", { "background-blend-mode": "screen" }],
  ["bg-blend-overlay", { "background-blend-mode": "overlay" }],
  ["bg-blend-darken", { "background-blend-mode": "darken" }],
  ["bg-blend-lighten", { "background-blend-mode": "lighten" }],
  ["bg-blend-color-dodge", { "background-blend-mode": "color-dodge" }],
  ["bg-blend-color-burn", { "background-blend-mode": "color-burn" }],
  ["bg-blend-hard-light", { "background-blend-mode": "hard-light" }],
  ["bg-blend-soft-light", { "background-blend-mode": "soft-light" }],
  ["bg-blend-difference", { "background-blend-mode": "difference" }],
  ["bg-blend-exclusion", { "background-blend-mode": "exclusion" }],
  ["bg-blend-hue", { "background-blend-mode": "hue" }],
  ["bg-blend-saturation", { "background-blend-mode": "saturation" }],
  ["bg-blend-color", { "background-blend-mode": "color" }],
  ["bg-blend-luminosity", { "background-blend-mode": "luminosity" }],
  ["bg-blend-normal", { "background-blend-mode": "normal" }],
  ...makeGlobalStaticRules2("bg-blend", "background-blend")
];
var mixBlendModes = [
  ["mix-blend-multiply", { "mix-blend-mode": "multiply" }],
  ["mix-blend-screen", { "mix-blend-mode": "screen" }],
  ["mix-blend-overlay", { "mix-blend-mode": "overlay" }],
  ["mix-blend-darken", { "mix-blend-mode": "darken" }],
  ["mix-blend-lighten", { "mix-blend-mode": "lighten" }],
  ["mix-blend-color-dodge", { "mix-blend-mode": "color-dodge" }],
  ["mix-blend-color-burn", { "mix-blend-mode": "color-burn" }],
  ["mix-blend-hard-light", { "mix-blend-mode": "hard-light" }],
  ["mix-blend-soft-light", { "mix-blend-mode": "soft-light" }],
  ["mix-blend-difference", { "mix-blend-mode": "difference" }],
  ["mix-blend-exclusion", { "mix-blend-mode": "exclusion" }],
  ["mix-blend-hue", { "mix-blend-mode": "hue" }],
  ["mix-blend-saturation", { "mix-blend-mode": "saturation" }],
  ["mix-blend-color", { "mix-blend-mode": "color" }],
  ["mix-blend-luminosity", { "mix-blend-mode": "luminosity" }],
  ["mix-blend-plus-lighter", { "mix-blend-mode": "plus-lighter" }],
  ["mix-blend-normal", { "mix-blend-mode": "normal" }],
  ...makeGlobalStaticRules2("mix-blend")
];
var dynamicViewportHeight = [
  ["min-h-dvh", { "min-height": "100dvh" }],
  ["min-h-svh", { "min-height": "100svh" }],
  ["min-h-lvh", { "min-height": "100lvh" }],
  ["h-dvh", { height: "100dvh" }],
  ["h-svh", { height: "100svh" }],
  ["h-lvh", { height: "100lvh" }],
  ["max-h-dvh", { "max-height": "100dvh" }],
  ["max-h-svh", { "max-height": "100svh" }],
  ["max-h-lvh", { "max-height": "100lvh" }]
];

// ../../packages-presets/preset-wind3/src/rules/table.ts
var borderSpacingBase = {
  "--un-border-spacing-x": 0,
  "--un-border-spacing-y": 0
};
var custom2 = { preflightKeys: Object.keys(borderSpacingBase) };
var borderSpacingProperty = "var(--un-border-spacing-x) var(--un-border-spacing-y)";
var tables = [
  // displays
  ["inline-table", { display: "inline-table" }],
  ["table", { display: "table" }],
  ["table-caption", { display: "table-caption" }],
  ["table-cell", { display: "table-cell" }],
  ["table-column", { display: "table-column" }],
  ["table-column-group", { display: "table-column-group" }],
  ["table-footer-group", { display: "table-footer-group" }],
  ["table-header-group", { display: "table-header-group" }],
  ["table-row", { display: "table-row" }],
  ["table-row-group", { display: "table-row-group" }],
  // layouts
  ["border-collapse", { "border-collapse": "collapse" }],
  ["border-separate", { "border-collapse": "separate" }],
  [/^border-spacing-(.+)$/, ([, s], { theme: theme4 }) => {
    var _a3, _b2;
    const v = (_b2 = (_a3 = theme4.spacing) == null ? void 0 : _a3[s]) != null ? _b2 : h2.bracket.cssvar.global.auto.fraction.rem(s);
    if (v != null) {
      return {
        "--un-border-spacing-x": v,
        "--un-border-spacing-y": v,
        "border-spacing": borderSpacingProperty
      };
    }
  }, { custom: custom2, autocomplete: ["border-spacing", "border-spacing-$spacing"] }],
  [/^border-spacing-([xy])-(.+)$/, ([, d, s], { theme: theme4 }) => {
    var _a3, _b2;
    const v = (_b2 = (_a3 = theme4.spacing) == null ? void 0 : _a3[s]) != null ? _b2 : h2.bracket.cssvar.global.auto.fraction.rem(s);
    if (v != null) {
      return {
        [`--un-border-spacing-${d}`]: v,
        "border-spacing": borderSpacingProperty
      };
    }
  }, { custom: custom2, autocomplete: ["border-spacing-(x|y)", "border-spacing-(x|y)-$spacing"] }],
  ["caption-top", { "caption-side": "top" }],
  ["caption-bottom", { "caption-side": "bottom" }],
  ["table-auto", { "table-layout": "auto" }],
  ["table-fixed", { "table-layout": "fixed" }],
  ["table-empty-cells-visible", { "empty-cells": "show" }],
  ["table-empty-cells-hidden", { "empty-cells": "hide" }]
];

// ../../packages-presets/preset-wind3/src/rules/touch-actions.ts
var touchActionBase = {
  "--un-pan-x": varEmpty2,
  "--un-pan-y": varEmpty2,
  "--un-pinch-zoom": varEmpty2
};
var custom3 = { preflightKeys: Object.keys(touchActionBase) };
var touchActionProperty = "var(--un-pan-x) var(--un-pan-y) var(--un-pinch-zoom)";
var touchActions = [
  [/^touch-pan-(x|left|right)$/, ([, d]) => ({
    "--un-pan-x": `pan-${d}`,
    "touch-action": touchActionProperty
  }), { custom: custom3, autocomplete: ["touch-pan", "touch-pan-(x|left|right|y|up|down)"] }],
  [/^touch-pan-(y|up|down)$/, ([, d]) => ({
    "--un-pan-y": `pan-${d}`,
    "touch-action": touchActionProperty
  }), { custom: custom3 }],
  ["touch-pinch-zoom", {
    "--un-pinch-zoom": "pinch-zoom",
    "touch-action": touchActionProperty
  }, { custom: custom3 }],
  ["touch-auto", { "touch-action": "auto" }],
  ["touch-manipulation", { "touch-action": "manipulation" }],
  ["touch-none", { "touch-action": "none" }],
  ...makeGlobalStaticRules2("touch", "touch-action")
];

// ../../packages-presets/preset-wind3/src/rules/typography.ts
var fontVariantNumericBase = {
  "--un-ordinal": varEmpty2,
  "--un-slashed-zero": varEmpty2,
  "--un-numeric-figure": varEmpty2,
  "--un-numeric-spacing": varEmpty2,
  "--un-numeric-fraction": varEmpty2
};
var custom4 = { preflightKeys: Object.keys(fontVariantNumericBase) };
function toEntries(entry) {
  return {
    ...entry,
    "font-variant-numeric": "var(--un-ordinal) var(--un-slashed-zero) var(--un-numeric-figure) var(--un-numeric-spacing) var(--un-numeric-fraction)"
  };
}
var fontVariantNumeric = [
  [/^ordinal$/, () => toEntries({ "--un-ordinal": "ordinal" }), { custom: custom4, autocomplete: "ordinal" }],
  [/^slashed-zero$/, () => toEntries({ "--un-slashed-zero": "slashed-zero" }), { custom: custom4, autocomplete: "slashed-zero" }],
  [/^lining-nums$/, () => toEntries({ "--un-numeric-figure": "lining-nums" }), { custom: custom4, autocomplete: "lining-nums" }],
  [/^oldstyle-nums$/, () => toEntries({ "--un-numeric-figure": "oldstyle-nums" }), { custom: custom4, autocomplete: "oldstyle-nums" }],
  [/^proportional-nums$/, () => toEntries({ "--un-numeric-spacing": "proportional-nums" }), { custom: custom4, autocomplete: "proportional-nums" }],
  [/^tabular-nums$/, () => toEntries({ "--un-numeric-spacing": "tabular-nums" }), { custom: custom4, autocomplete: "tabular-nums" }],
  [/^diagonal-fractions$/, () => toEntries({ "--un-numeric-fraction": "diagonal-fractions" }), { custom: custom4, autocomplete: "diagonal-fractions" }],
  [/^stacked-fractions$/, () => toEntries({ "--un-numeric-fraction": "stacked-fractions" }), { custom: custom4, autocomplete: "stacked-fractions" }],
  ["normal-nums", { "font-variant-numeric": "normal" }]
];

// ../../packages-presets/preset-wind3/src/rules/variables.ts
var variablesAbbrMap3 = {
  "bg-blend": "background-blend-mode",
  "bg-clip": "-webkit-background-clip",
  "bg-gradient": "linear-gradient",
  "bg-image": "background-image",
  "bg-origin": "background-origin",
  "bg-position": "background-position",
  "bg-repeat": "background-repeat",
  "bg-size": "background-size",
  "mix-blend": "mix-blend-mode",
  "object": "object-fit",
  "object-position": "object-position",
  "write": "writing-mode",
  "write-orient": "text-orientation"
};
var cssVariables3 = [
  [/^(.+?)-(\$.+)$/, ([, name2, varname]) => {
    const prop = variablesAbbrMap3[name2];
    if (prop)
      return { [prop]: h2.cssvar(varname) };
  }]
];

// ../../packages-presets/preset-wind3/src/rules/view-transition.ts
var viewTransition = [
  [/^view-transition-([\w-]+)$/, ([, name2]) => {
    return { "view-transition-name": name2 };
  }]
];

// ../../packages-presets/preset-wind3/src/rules/default.ts
var rules3 = [
  cssVariables2,
  cssVariables3,
  cssProperty2,
  container,
  contains2,
  screenReadersAccess,
  pointerEvents2,
  appearances2,
  positions2,
  insets2,
  lineClamps,
  isolations,
  zIndexes2,
  orders2,
  grids2,
  floats2,
  margins2,
  boxSizing2,
  displays2,
  aspectRatio2,
  sizes2,
  flex2,
  tables,
  transforms2,
  animations,
  cursors2,
  touchActions,
  userSelects2,
  resizes2,
  scrolls,
  listStyle,
  appearance2,
  columns,
  placements2,
  alignments2,
  justifies2,
  gaps2,
  flexGridJustifiesAlignments2,
  spaces,
  divides,
  overflows2,
  overscrolls,
  scrollBehaviors,
  textOverflows2,
  whitespaces2,
  breaks2,
  borders2,
  bgColors2,
  backgroundStyles,
  colorScheme2,
  svgUtilities2,
  objectPositions,
  paddings2,
  textAligns2,
  textIndents2,
  textWraps2,
  verticalAligns2,
  fonts2,
  textTransforms2,
  textTransforms3,
  fontStyles2,
  fontVariantNumeric,
  textDecorations2,
  fontSmoothings2,
  tabSizes2,
  textStrokes2,
  textShadows2,
  hyphens,
  writingModes,
  writingOrientations,
  carets,
  accents,
  opacity2,
  backgroundBlendModes,
  mixBlendModes,
  boxShadows2,
  outline2,
  rings2,
  imageRenderings,
  filters,
  transitions2,
  willChange2,
  contentVisibility2,
  contents2,
  placeholders,
  containerParent2,
  viewTransition,
  dynamicViewportHeight,
  questionMark2
].flat(1);

// ../../packages-presets/preset-wind3/src/shortcuts.ts
var shortcuts = [
  ...containerShortcuts
];

// ../../packages-presets/preset-mini/dist/colors.mjs
var colors2 = {
  inherit: "inherit",
  current: "currentColor",
  transparent: "transparent",
  black: "#000",
  white: "#fff",
  rose: {
    50: "#fff1f2",
    100: "#ffe4e6",
    200: "#fecdd3",
    300: "#fda4af",
    400: "#fb7185",
    500: "#f43f5e",
    600: "#e11d48",
    700: "#be123c",
    800: "#9f1239",
    900: "#881337",
    950: "#4c0519"
  },
  pink: {
    50: "#fdf2f8",
    100: "#fce7f3",
    200: "#fbcfe8",
    300: "#f9a8d4",
    400: "#f472b6",
    500: "#ec4899",
    600: "#db2777",
    700: "#be185d",
    800: "#9d174d",
    900: "#831843",
    950: "#500724"
  },
  fuchsia: {
    50: "#fdf4ff",
    100: "#fae8ff",
    200: "#f5d0fe",
    300: "#f0abfc",
    400: "#e879f9",
    500: "#d946ef",
    600: "#c026d3",
    700: "#a21caf",
    800: "#86198f",
    900: "#701a75",
    950: "#4a044e"
  },
  purple: {
    50: "#faf5ff",
    100: "#f3e8ff",
    200: "#e9d5ff",
    300: "#d8b4fe",
    400: "#c084fc",
    500: "#a855f7",
    600: "#9333ea",
    700: "#7e22ce",
    800: "#6b21a8",
    900: "#581c87",
    950: "#3b0764"
  },
  violet: {
    50: "#f5f3ff",
    100: "#ede9fe",
    200: "#ddd6fe",
    300: "#c4b5fd",
    400: "#a78bfa",
    500: "#8b5cf6",
    600: "#7c3aed",
    700: "#6d28d9",
    800: "#5b21b6",
    900: "#4c1d95",
    950: "#2e1065"
  },
  indigo: {
    50: "#eef2ff",
    100: "#e0e7ff",
    200: "#c7d2fe",
    300: "#a5b4fc",
    400: "#818cf8",
    500: "#6366f1",
    600: "#4f46e5",
    700: "#4338ca",
    800: "#3730a3",
    900: "#312e81",
    950: "#1e1b4b"
  },
  blue: {
    50: "#eff6ff",
    100: "#dbeafe",
    200: "#bfdbfe",
    300: "#93c5fd",
    400: "#60a5fa",
    500: "#3b82f6",
    600: "#2563eb",
    700: "#1d4ed8",
    800: "#1e40af",
    900: "#1e3a8a",
    950: "#172554"
  },
  sky: {
    50: "#f0f9ff",
    100: "#e0f2fe",
    200: "#bae6fd",
    300: "#7dd3fc",
    400: "#38bdf8",
    500: "#0ea5e9",
    600: "#0284c7",
    700: "#0369a1",
    800: "#075985",
    900: "#0c4a6e",
    950: "#082f49"
  },
  cyan: {
    50: "#ecfeff",
    100: "#cffafe",
    200: "#a5f3fc",
    300: "#67e8f9",
    400: "#22d3ee",
    500: "#06b6d4",
    600: "#0891b2",
    700: "#0e7490",
    800: "#155e75",
    900: "#164e63",
    950: "#083344"
  },
  teal: {
    50: "#f0fdfa",
    100: "#ccfbf1",
    200: "#99f6e4",
    300: "#5eead4",
    400: "#2dd4bf",
    500: "#14b8a6",
    600: "#0d9488",
    700: "#0f766e",
    800: "#115e59",
    900: "#134e4a",
    950: "#042f2e"
  },
  emerald: {
    50: "#ecfdf5",
    100: "#d1fae5",
    200: "#a7f3d0",
    300: "#6ee7b7",
    400: "#34d399",
    500: "#10b981",
    600: "#059669",
    700: "#047857",
    800: "#065f46",
    900: "#064e3b",
    950: "#022c22"
  },
  green: {
    50: "#f0fdf4",
    100: "#dcfce7",
    200: "#bbf7d0",
    300: "#86efac",
    400: "#4ade80",
    500: "#22c55e",
    600: "#16a34a",
    700: "#15803d",
    800: "#166534",
    900: "#14532d",
    950: "#052e16"
  },
  lime: {
    50: "#f7fee7",
    100: "#ecfccb",
    200: "#d9f99d",
    300: "#bef264",
    400: "#a3e635",
    500: "#84cc16",
    600: "#65a30d",
    700: "#4d7c0f",
    800: "#3f6212",
    900: "#365314",
    950: "#1a2e05"
  },
  yellow: {
    50: "#fefce8",
    100: "#fef9c3",
    200: "#fef08a",
    300: "#fde047",
    400: "#facc15",
    500: "#eab308",
    600: "#ca8a04",
    700: "#a16207",
    800: "#854d0e",
    900: "#713f12",
    950: "#422006"
  },
  amber: {
    50: "#fffbeb",
    100: "#fef3c7",
    200: "#fde68a",
    300: "#fcd34d",
    400: "#fbbf24",
    500: "#f59e0b",
    600: "#d97706",
    700: "#b45309",
    800: "#92400e",
    900: "#78350f",
    950: "#451a03"
  },
  orange: {
    50: "#fff7ed",
    100: "#ffedd5",
    200: "#fed7aa",
    300: "#fdba74",
    400: "#fb923c",
    500: "#f97316",
    600: "#ea580c",
    700: "#c2410c",
    800: "#9a3412",
    900: "#7c2d12",
    950: "#431407"
  },
  red: {
    50: "#fef2f2",
    100: "#fee2e2",
    200: "#fecaca",
    300: "#fca5a5",
    400: "#f87171",
    500: "#ef4444",
    600: "#dc2626",
    700: "#b91c1c",
    800: "#991b1b",
    900: "#7f1d1d",
    950: "#450a0a"
  },
  gray: {
    50: "#f9fafb",
    100: "#f3f4f6",
    200: "#e5e7eb",
    300: "#d1d5db",
    400: "#9ca3af",
    500: "#6b7280",
    600: "#4b5563",
    700: "#374151",
    800: "#1f2937",
    900: "#111827",
    950: "#030712"
  },
  slate: {
    50: "#f8fafc",
    100: "#f1f5f9",
    200: "#e2e8f0",
    300: "#cbd5e1",
    400: "#94a3b8",
    500: "#64748b",
    600: "#475569",
    700: "#334155",
    800: "#1e293b",
    900: "#0f172a",
    950: "#020617"
  },
  zinc: {
    50: "#fafafa",
    100: "#f4f4f5",
    200: "#e4e4e7",
    300: "#d4d4d8",
    400: "#a1a1aa",
    500: "#71717a",
    600: "#52525b",
    700: "#3f3f46",
    800: "#27272a",
    900: "#18181b",
    950: "#09090b"
  },
  neutral: {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#e5e5e5",
    300: "#d4d4d4",
    400: "#a3a3a3",
    500: "#737373",
    600: "#525252",
    700: "#404040",
    800: "#262626",
    900: "#171717",
    950: "#0a0a0a"
  },
  stone: {
    50: "#fafaf9",
    100: "#f5f5f4",
    200: "#e7e5e4",
    300: "#d6d3d1",
    400: "#a8a29e",
    500: "#78716c",
    600: "#57534e",
    700: "#44403c",
    800: "#292524",
    900: "#1c1917",
    950: "#0c0a09"
  },
  light: {
    50: "#fdfdfd",
    100: "#fcfcfc",
    200: "#fafafa",
    300: "#f8f9fa",
    400: "#f6f6f6",
    500: "#f2f2f2",
    600: "#f1f3f5",
    700: "#e9ecef",
    800: "#dee2e6",
    900: "#dde1e3",
    950: "#d8dcdf"
  },
  dark: {
    50: "#4a4a4a",
    100: "#3c3c3c",
    200: "#323232",
    300: "#2d2d2d",
    400: "#222222",
    500: "#1f1f1f",
    600: "#1c1c1e",
    700: "#1b1b1b",
    800: "#181818",
    900: "#0f0f0f",
    950: "#080808"
  },
  get lightblue() {
    return this.sky;
  },
  get lightBlue() {
    return this.sky;
  },
  get warmgray() {
    return this.stone;
  },
  get warmGray() {
    return this.stone;
  },
  get truegray() {
    return this.neutral;
  },
  get trueGray() {
    return this.neutral;
  },
  get coolgray() {
    return this.gray;
  },
  get coolGray() {
    return this.gray;
  },
  get bluegray() {
    return this.slate;
  },
  get blueGray() {
    return this.slate;
  }
};
Object.values(colors2).forEach((color) => {
  if (typeof color !== "string" && color !== void 0) {
    color.DEFAULT = color.DEFAULT || color[400];
    Object.keys(color).forEach((key) => {
      const short = +key / 100;
      if (short === Math.round(short))
        color[short] = color[key];
    });
  }
});

// ../../packages-presets/preset-mini/dist/shared/preset-mini.HR8qseZe.mjs
var blur2 = {
  "DEFAULT": "8px",
  "0": "0",
  "sm": "4px",
  "md": "12px",
  "lg": "16px",
  "xl": "24px",
  "2xl": "40px",
  "3xl": "64px"
};
var dropShadow2 = {
  "DEFAULT": ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"],
  "sm": "0 1px 1px rgb(0 0 0 / 0.05)",
  "md": ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"],
  "lg": ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"],
  "xl": ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"],
  "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
  "none": "0 0 rgb(0 0 0 / 0)"
};
var fontFamily2 = {
  sans: [
    "ui-sans-serif",
    "system-ui",
    "-apple-system",
    "BlinkMacSystemFont",
    '"Segoe UI"',
    "Roboto",
    '"Helvetica Neue"',
    "Arial",
    '"Noto Sans"',
    "sans-serif",
    '"Apple Color Emoji"',
    '"Segoe UI Emoji"',
    '"Segoe UI Symbol"',
    '"Noto Color Emoji"'
  ].join(","),
  serif: [
    "ui-serif",
    "Georgia",
    "Cambria",
    '"Times New Roman"',
    "Times",
    "serif"
  ].join(","),
  mono: [
    "ui-monospace",
    "SFMono-Regular",
    "Menlo",
    "Monaco",
    "Consolas",
    '"Liberation Mono"',
    '"Courier New"',
    "monospace"
  ].join(",")
};
var fontSize2 = {
  "xs": ["0.75rem", "1rem"],
  "sm": ["0.875rem", "1.25rem"],
  "base": ["1rem", "1.5rem"],
  "lg": ["1.125rem", "1.75rem"],
  "xl": ["1.25rem", "1.75rem"],
  "2xl": ["1.5rem", "2rem"],
  "3xl": ["1.875rem", "2.25rem"],
  "4xl": ["2.25rem", "2.5rem"],
  "5xl": ["3rem", "1"],
  "6xl": ["3.75rem", "1"],
  "7xl": ["4.5rem", "1"],
  "8xl": ["6rem", "1"],
  "9xl": ["8rem", "1"]
};
var textIndent2 = {
  "DEFAULT": "1.5rem",
  "xs": "0.5rem",
  "sm": "1rem",
  "md": "1.5rem",
  "lg": "2rem",
  "xl": "2.5rem",
  "2xl": "3rem",
  "3xl": "4rem"
};
var textStrokeWidth2 = {
  DEFAULT: "1.5rem",
  none: "0",
  sm: "thin",
  md: "medium",
  lg: "thick"
};
var textShadow2 = {
  DEFAULT: ["0 0 1px rgb(0 0 0 / 0.2)", "0 0 1px rgb(1 0 5 / 0.1)"],
  none: "0 0 rgb(0 0 0 / 0)",
  sm: "1px 1px 3px rgb(36 37 47 / 0.25)",
  md: ["0 1px 2px rgb(30 29 39 / 0.19)", "1px 2px 4px rgb(54 64 147 / 0.18)"],
  lg: ["3px 3px 6px rgb(0 0 0 / 0.26)", "0 0 5px rgb(15 3 86 / 0.22)"],
  xl: ["1px 1px 3px rgb(0 0 0 / 0.29)", "2px 4px 7px rgb(73 64 125 / 0.35)"]
};
var lineHeight2 = {
  none: "1",
  tight: "1.25",
  snug: "1.375",
  normal: "1.5",
  relaxed: "1.625",
  loose: "2"
};
var letterSpacing2 = {
  tighter: "-0.05em",
  tight: "-0.025em",
  normal: "0em",
  wide: "0.025em",
  wider: "0.05em",
  widest: "0.1em"
};
var fontWeight2 = {
  thin: "100",
  extralight: "200",
  light: "300",
  normal: "400",
  medium: "500",
  semibold: "600",
  bold: "700",
  extrabold: "800",
  black: "900"
  // int[0, 900] -> int
};
var wordSpacing2 = letterSpacing2;
var breakpoints2 = {
  "sm": "640px",
  "md": "768px",
  "lg": "1024px",
  "xl": "1280px",
  "2xl": "1536px"
};
var verticalBreakpoints2 = { ...breakpoints2 };
var lineWidth2 = {
  DEFAULT: "1px",
  none: "0"
};
var spacing2 = {
  "DEFAULT": "1rem",
  "none": "0",
  "xs": "0.75rem",
  "sm": "0.875rem",
  "lg": "1.125rem",
  "xl": "1.25rem",
  "2xl": "1.5rem",
  "3xl": "1.875rem",
  "4xl": "2.25rem",
  "5xl": "3rem",
  "6xl": "3.75rem",
  "7xl": "4.5rem",
  "8xl": "6rem",
  "9xl": "8rem"
};
var duration2 = {
  DEFAULT: "150ms",
  none: "0s",
  75: "75ms",
  100: "100ms",
  150: "150ms",
  200: "200ms",
  300: "300ms",
  500: "500ms",
  700: "700ms",
  1e3: "1000ms"
};
var borderRadius2 = {
  "DEFAULT": "0.25rem",
  "none": "0",
  "sm": "0.125rem",
  "md": "0.375rem",
  "lg": "0.5rem",
  "xl": "0.75rem",
  "2xl": "1rem",
  "3xl": "1.5rem",
  "full": "9999px"
};
var boxShadow2 = {
  "DEFAULT": ["var(--un-shadow-inset) 0 1px 3px 0 rgb(0 0 0 / 0.1)", "var(--un-shadow-inset) 0 1px 2px -1px rgb(0 0 0 / 0.1)"],
  "none": "0 0 rgb(0 0 0 / 0)",
  "sm": "var(--un-shadow-inset) 0 1px 2px 0 rgb(0 0 0 / 0.05)",
  "md": ["var(--un-shadow-inset) 0 4px 6px -1px rgb(0 0 0 / 0.1)", "var(--un-shadow-inset) 0 2px 4px -2px rgb(0 0 0 / 0.1)"],
  "lg": ["var(--un-shadow-inset) 0 10px 15px -3px rgb(0 0 0 / 0.1)", "var(--un-shadow-inset) 0 4px 6px -4px rgb(0 0 0 / 0.1)"],
  "xl": ["var(--un-shadow-inset) 0 20px 25px -5px rgb(0 0 0 / 0.1)", "var(--un-shadow-inset) 0 8px 10px -6px rgb(0 0 0 / 0.1)"],
  "2xl": "var(--un-shadow-inset) 0 25px 50px -12px rgb(0 0 0 / 0.25)",
  "inner": "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)"
};
var ringWidth2 = {
  DEFAULT: "3px",
  none: "0"
};
var zIndex2 = {
  auto: "auto"
};
var media2 = {
  mouse: "(hover) and (pointer: fine)"
};
var preflightBase2 = {
  ...transformBase2,
  ...boxShadowsBase2,
  ...ringBase2
};
var baseSize2 = {
  "xs": "20rem",
  "sm": "24rem",
  "md": "28rem",
  "lg": "32rem",
  "xl": "36rem",
  "2xl": "42rem",
  "3xl": "48rem",
  "4xl": "56rem",
  "5xl": "64rem",
  "6xl": "72rem",
  "7xl": "80rem",
  "prose": "65ch"
};
var width2 = {
  auto: "auto",
  ...baseSize2,
  screen: "100vw"
};
var maxWidth2 = {
  none: "none",
  ...baseSize2,
  screen: "100vw"
};
var blockSize2 = {
  auto: "auto",
  ...baseSize2,
  screen: "100vb"
};
var inlineSize2 = {
  auto: "auto",
  ...baseSize2,
  screen: "100vi"
};
var height2 = {
  auto: "auto",
  ...baseSize2,
  screen: "100vh"
};
var maxHeight2 = {
  none: "none",
  ...baseSize2,
  screen: "100vh"
};
var maxBlockSize2 = {
  none: "none",
  ...baseSize2,
  screen: "100vb"
};
var maxInlineSize2 = {
  none: "none",
  ...baseSize2,
  screen: "100vi"
};
var containers2 = { ...baseSize2 };
var easing2 = {
  "DEFAULT": "cubic-bezier(0.4, 0, 0.2, 1)",
  "linear": "linear",
  "in": "cubic-bezier(0.4, 0, 1, 1)",
  "out": "cubic-bezier(0, 0, 0.2, 1)",
  "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
};
var transitionProperty2 = {
  none: "none",
  all: "all",
  colors: ["color", "background-color", "border-color", "text-decoration-color", "fill", "stroke"].join(","),
  opacity: "opacity",
  shadow: "box-shadow",
  transform: "transform",
  get DEFAULT() {
    return [this.colors, "opacity", "box-shadow", "transform", "filter", "backdrop-filter"].join(",");
  }
};
var theme2 = {
  width: width2,
  height: height2,
  maxWidth: maxWidth2,
  maxHeight: maxHeight2,
  minWidth: maxWidth2,
  minHeight: maxHeight2,
  inlineSize: inlineSize2,
  blockSize: blockSize2,
  maxInlineSize: maxInlineSize2,
  maxBlockSize: maxBlockSize2,
  minInlineSize: maxInlineSize2,
  minBlockSize: maxBlockSize2,
  colors: colors2,
  fontFamily: fontFamily2,
  fontSize: fontSize2,
  fontWeight: fontWeight2,
  breakpoints: breakpoints2,
  verticalBreakpoints: verticalBreakpoints2,
  borderRadius: borderRadius2,
  lineHeight: lineHeight2,
  letterSpacing: letterSpacing2,
  wordSpacing: wordSpacing2,
  boxShadow: boxShadow2,
  textIndent: textIndent2,
  textShadow: textShadow2,
  textStrokeWidth: textStrokeWidth2,
  blur: blur2,
  dropShadow: dropShadow2,
  easing: easing2,
  transitionProperty: transitionProperty2,
  lineWidth: lineWidth2,
  spacing: spacing2,
  duration: duration2,
  ringWidth: ringWidth2,
  preflightBase: preflightBase2,
  containers: containers2,
  zIndex: zIndex2,
  media: media2
};

// ../../packages-presets/preset-wind3/src/theme.ts
var theme3 = {
  ...theme2,
  aria: {
    busy: 'busy="true"',
    checked: 'checked="true"',
    disabled: 'disabled="true"',
    expanded: 'expanded="true"',
    hidden: 'hidden="true"',
    pressed: 'pressed="true"',
    readonly: 'readonly="true"',
    required: 'required="true"',
    selected: 'selected="true"'
  },
  animation: {
    keyframes: {
      "pulse": "{0%, 100% {opacity:1} 50% {opacity:.5}}",
      "bounce": "{0%, 100% {transform:translateY(-25%);animation-timing-function:cubic-bezier(0.8,0,1,1)} 50% {transform:translateY(0);animation-timing-function:cubic-bezier(0,0,0.2,1)}}",
      "spin": "{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}",
      "ping": "{0%{transform:scale(1);opacity:1}75%,100%{transform:scale(2);opacity:0}}",
      "bounce-alt": "{from,20%,53%,80%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1);transform:translate3d(0,0,0)}40%,43%{animation-timing-function:cubic-bezier(0.755,0.05,0.855,0.06);transform:translate3d(0,-30px,0)}70%{animation-timing-function:cubic-bezier(0.755,0.05,0.855,0.06);transform:translate3d(0,-15px,0)}90%{transform:translate3d(0,-4px,0)}}",
      "flash": "{from,50%,to{opacity:1}25%,75%{opacity:0}}",
      "pulse-alt": "{from{transform:scale3d(1,1,1)}50%{transform:scale3d(1.05,1.05,1.05)}to{transform:scale3d(1,1,1)}}",
      "rubber-band": "{from{transform:scale3d(1,1,1)}30%{transform:scale3d(1.25,0.75,1)}40%{transform:scale3d(0.75,1.25,1)}50%{transform:scale3d(1.15,0.85,1)}65%{transform:scale3d(0.95,1.05,1)}75%{transform:scale3d(1.05,0.95,1)}to{transform:scale3d(1,1,1)}}",
      "shake-x": "{from,to{transform:translate3d(0,0,0)}10%,30%,50%,70%,90%{transform:translate3d(-10px,0,0)}20%,40%,60%,80%{transform:translate3d(10px,0,0)}}",
      "shake-y": "{from,to{transform:translate3d(0,0,0)}10%,30%,50%,70%,90%{transform:translate3d(0,-10px,0)}20%,40%,60%,80%{transform:translate3d(0,10px,0)}}",
      "head-shake": "{0%{transform:translateX(0)}6.5%{transform:translateX(-6px) rotateY(-9deg)}18.5%{transform:translateX(5px) rotateY(7deg)}31.5%{transform:translateX(-3px) rotateY(-5deg)}43.5%{transform:translateX(2px) rotateY(3deg)}50%{transform:translateX(0)}}",
      "swing": "{20%{transform:rotate3d(0,0,1,15deg)}40%{transform:rotate3d(0,0,1,-10deg)}60%{transform:rotate3d(0,0,1,5deg)}80%{transform:rotate3d(0,0,1,-5deg)}to{transform:rotate3d(0,0,1,0deg)}}",
      "tada": "{from{transform:scale3d(1,1,1)}10%,20%{transform:scale3d(0.9,0.9,0.9) rotate3d(0,0,1,-3deg)}30%,50%,70%,90%{transform:scale3d(1.1,1.1,1.1) rotate3d(0,0,1,3deg)}40%,60%,80%{transform:scale3d(1.1,1.1,1.1) rotate3d(0,0,1,-3deg)}to{transform:scale3d(1,1,1)}}",
      "wobble": "{from{transform:translate3d(0,0,0)}15%{transform:translate3d(-25%,0,0) rotate3d(0,0,1,-5deg)}30%{transform:translate3d(20%,0,0) rotate3d(0,0,1,3deg)}45%{transform:translate3d(-15%,0,0) rotate3d(0,0,1,-3deg)}60%{transform:translate3d(10%,0,0) rotate3d(0,0,1,2deg)}75%{transform:translate3d(-5%,0,0) rotate3d(0,0,1,-1deg)}to{transform:translate3d(0,0,0)}}",
      "jello": "{from,11.1%,to{transform:translate3d(0,0,0)}22.2%{transform:skewX(-12.5deg) skewY(-12.5deg)}33.3%{transform:skewX(6.25deg) skewY(6.25deg)}44.4%{transform:skewX(-3.125deg)skewY(-3.125deg)}55.5%{transform:skewX(1.5625deg) skewY(1.5625deg)}66.6%{transform:skewX(-0.78125deg) skewY(-0.78125deg)}77.7%{transform:skewX(0.390625deg) skewY(0.390625deg)}88.8%{transform:skewX(-0.1953125deg) skewY(-0.1953125deg)}}",
      "heart-beat": "{0%{transform:scale(1)}14%{transform:scale(1.3)}28%{transform:scale(1)}42%{transform:scale(1.3)}70%{transform:scale(1)}}",
      "hinge": "{0%{transform-origin:top left;animation-timing-function:ease-in-out}20%,60%{transform:rotate3d(0,0,1,80deg);transform-origin:top left;animation-timing-function:ease-in-out}40%,80%{transform:rotate3d(0,0,1,60deg);transform-origin:top left;animation-timing-function:ease-in-out}to{transform:translate3d(0,700px,0);opacity:0}}",
      "jack-in-the-box": "{from{opacity:0;transform-origin:center bottom;transform:scale(0.1) rotate(30deg)}50%{transform:rotate(-10deg)}70%{transform:rotate(3deg)}to{transform:scale(1)}}",
      "light-speed-in-left": "{from{opacity:0;transform:translate3d(-100%,0,0) skewX(-30deg)}60%{opacity:1;transform:skewX(20deg)}80%{transform:skewX(-5deg)}to{transform:translate3d(0,0,0)}}",
      "light-speed-in-right": "{from{opacity:0;transform:translate3d(100%,0,0) skewX(-30deg)}60%{opacity:1;transform:skewX(20deg)}80%{transform:skewX(-5deg)}to{transform:translate3d(0,0,0)}}",
      "light-speed-out-left": "{from{opacity:1}to{opacity:0;transform:translate3d(-100%,0,0) skewX(30deg)}}",
      "light-speed-out-right": "{from{opacity:1}to{opacity:0;transform:translate3d(100%,0,0) skewX(30deg)}}",
      "flip": "{from{transform:perspective(400px) scale3d(1,1,1) translate3d(0,0,0) rotate3d(0,1,0,-360deg);animation-timing-function:ease-out}40%{transform:perspective(400px) scale3d(1,1,1) translate3d(0,0,150px) rotate3d(0,1,0,-190deg);animation-timing-function:ease-out}50%{transform:perspective(400px) scale3d(1,1,1) translate3d(0,0,150px) rotate3d(0,1,0,-170deg);animation-timing-function:ease-in}80%{transform:perspective(400px) scale3d(0.95,0.95,0.95) translate3d(0,0,0) rotate3d(0,1,0,0deg);animation-timing-function:ease-in}to{transform:perspective(400px) scale3d(1,1,1) translate3d(0,0,0) rotate3d(0,1,0,0deg);animation-timing-function:ease-in}}",
      "flip-in-x": "{from{transform:perspective(400px) rotate3d(1,0,0,90deg);animation-timing-function:ease-in;opacity:0}40%{transform:perspective(400px) rotate3d(1,0,0,-20deg);animation-timing-function:ease-in}60%{transform:perspective(400px) rotate3d(1,0,0,10deg);opacity:1}80%{transform:perspective(400px) rotate3d(1,0,0,-5deg)}to{transform:perspective(400px)}}",
      "flip-in-y": "{from{transform:perspective(400px) rotate3d(0,1,0,90deg);animation-timing-function:ease-in;opacity:0}40%{transform:perspective(400px) rotate3d(0,1,0,-20deg);animation-timing-function:ease-in}60%{transform:perspective(400px) rotate3d(0,1,0,10deg);opacity:1}80%{transform:perspective(400px) rotate3d(0,1,0,-5deg)}to{transform:perspective(400px)}}",
      "flip-out-x": "{from{transform:perspective(400px)}30%{transform:perspective(400px) rotate3d(1,0,0,-20deg);opacity:1}to{transform:perspective(400px) rotate3d(1,0,0,90deg);opacity:0}}",
      "flip-out-y": "{from{transform:perspective(400px)}30%{transform:perspective(400px) rotate3d(0,1,0,-15deg);opacity:1}to{transform:perspective(400px) rotate3d(0,1,0,90deg);opacity:0}}",
      "rotate-in": "{from{transform-origin:center;transform:rotate3d(0,0,1,-200deg);opacity:0}to{transform-origin:center;transform:translate3d(0,0,0);opacity:1}}",
      "rotate-in-down-left": "{from{transform-origin:left bottom;transform:rotate3d(0,0,1,-45deg);opacity:0}to{transform-origin:left bottom;transform:translate3d(0,0,0);opacity:1}}",
      "rotate-in-down-right": "{from{transform-origin:right bottom;transform:rotate3d(0,0,1,45deg);opacity:0}to{transform-origin:right bottom;transform:translate3d(0,0,0);opacity:1}}",
      "rotate-in-up-left": "{from{transform-origin:left top;transform:rotate3d(0,0,1,45deg);opacity:0}to{transform-origin:left top;transform:translate3d(0,0,0);opacity:1}}",
      "rotate-in-up-right": "{from{transform-origin:right bottom;transform:rotate3d(0,0,1,-90deg);opacity:0}to{transform-origin:right bottom;transform:translate3d(0,0,0);opacity:1}}",
      "rotate-out": "{from{transform-origin:center;opacity:1}to{transform-origin:center;transform:rotate3d(0,0,1,200deg);opacity:0}}",
      "rotate-out-down-left": "{from{transform-origin:left bottom;opacity:1}to{transform-origin:left bottom;transform:rotate3d(0,0,1,45deg);opacity:0}}",
      "rotate-out-down-right": "{from{transform-origin:right bottom;opacity:1}to{transform-origin:right bottom;transform:rotate3d(0,0,1,-45deg);opacity:0}}",
      "rotate-out-up-left": "{from{transform-origin:left bottom;opacity:1}to{transform-origin:left bottom;transform:rotate3d(0,0,1,-45deg);opacity:0}}",
      "rotate-out-up-right": "{from{transform-origin:right bottom;opacity:1}to{transform-origin:left bottom;transform:rotate3d(0,0,1,90deg);opacity:0}}",
      "roll-in": "{from{opacity:0;transform:translate3d(-100%,0,0) rotate3d(0,0,1,-120deg)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "roll-out": "{from{opacity:1}to{opacity:0;transform:translate3d(100%,0,0) rotate3d(0,0,1,120deg)}}",
      "zoom-in": "{from{opacity:0;transform:scale3d(0.3,0.3,0.3)}50%{opacity:1}}",
      "zoom-in-down": "{from{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(0,-1000px,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}60%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(0,60px,0);animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
      "zoom-in-left": "{from{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(-1000px,0,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}60%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(10px,0,0);animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
      "zoom-in-right": "{from{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(1000px,0,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}60%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(-10px,0,0);animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
      "zoom-in-up": "{from{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(0,1000px,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}60%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(0,-60px,0);animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
      "zoom-out": "{from{opacity:1}50%{opacity:0;transform:scale3d(0.3,0.3,0.3)}to{opacity:0}}",
      "zoom-out-down": "{40%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(0,-60px,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}to{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(0,2000px,0);transform-origin:center bottom;animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
      "zoom-out-left": "{40%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(42px,0,0)}to{opacity:0;transform:scale(0.1) translate3d(-2000px,0,0);transform-origin:left center}}",
      "zoom-out-right": "{40%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(-42px,0,0)}to{opacity:0;transform:scale(0.1) translate3d(2000px,0,0);transform-origin:right center}}",
      "zoom-out-up": "{40%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(0,60px,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}to{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(0,-2000px,0);transform-origin:center bottom;animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
      "bounce-in": "{from,20%,40%,60%,80%,to{animation-timing-function:ease-in-out}0%{opacity:0;transform:scale3d(0.3,0.3,0.3)}20%{transform:scale3d(1.1,1.1,1.1)}40%{transform:scale3d(0.9,0.9,0.9)}60%{transform:scale3d(1.03,1.03,1.03);opacity:1}80%{transform:scale3d(0.97,0.97,0.97)}to{opacity:1;transform:scale3d(1,1,1)}}",
      "bounce-in-down": "{from,60%,75%,90%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1)}0%{opacity:0;transform:translate3d(0,-3000px,0)}60%{opacity:1;transform:translate3d(0,25px,0)}75%{transform:translate3d(0,-10px,0)}90%{transform:translate3d(0,5px,0)}to{transform:translate3d(0,0,0)}}",
      "bounce-in-left": "{from,60%,75%,90%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1)}0%{opacity:0;transform:translate3d(-3000px,0,0)}60%{opacity:1;transform:translate3d(25px,0,0)}75%{transform:translate3d(-10px,0,0)}90%{transform:translate3d(5px,0,0)}to{transform:translate3d(0,0,0)}}",
      "bounce-in-right": "{from,60%,75%,90%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1)}0%{opacity:0;transform:translate3d(3000px,0,0)}60%{opacity:1;transform:translate3d(-25px,0,0)}75%{transform:translate3d(10px,0,0)}90%{transform:translate3d(-5px,0,0)}to{transform:translate3d(0,0,0)}}",
      "bounce-in-up": "{from,60%,75%,90%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1)}0%{opacity:0;transform:translate3d(0,3000px,0)}60%{opacity:1;transform:translate3d(0,-20px,0)}75%{transform:translate3d(0,10px,0)}90%{transform:translate3d(0,-5px,0)}to{transform:translate3d(0,0,0)}}",
      "bounce-out": "{20%{transform:scale3d(0.9,0.9,0.9)}50%,55%{opacity:1;transform:scale3d(1.1,1.1,1.1)}to{opacity:0;transform:scale3d(0.3,0.3,0.3)}}",
      "bounce-out-down": "{20%{transform:translate3d(0,10px,0)}40%,45%{opacity:1;transform:translate3d(0,-20px,0)}to{opacity:0;transform:translate3d(0,2000px,0)}}",
      "bounce-out-left": "{20%{opacity:1;transform:translate3d(20px,0,0)}to{opacity:0;transform:translate3d(-2000px,0,0)}}",
      "bounce-out-right": "{20%{opacity:1;transform:translate3d(-20px,0,0)}to{opacity:0;transform:translate3d(2000px,0,0)}}",
      "bounce-out-up": "{20%{transform:translate3d(0,-10px,0)}40%,45%{opacity:1;transform:translate3d(0,20px,0)}to{opacity:0;transform:translate3d(0,-2000px,0)}}",
      "slide-in-down": "{from{transform:translate3d(0,-100%,0);visibility:visible}to{transform:translate3d(0,0,0)}}",
      "slide-in-left": "{from{transform:translate3d(-100%,0,0);visibility:visible}to{transform:translate3d(0,0,0)}}",
      "slide-in-right": "{from{transform:translate3d(100%,0,0);visibility:visible}to{transform:translate3d(0,0,0)}}",
      "slide-in-up": "{from{transform:translate3d(0,100%,0);visibility:visible}to{transform:translate3d(0,0,0)}}",
      "slide-out-down": "{from{transform:translate3d(0,0,0)}to{visibility:hidden;transform:translate3d(0,100%,0)}}",
      "slide-out-left": "{from{transform:translate3d(0,0,0)}to{visibility:hidden;transform:translate3d(-100%,0,0)}}",
      "slide-out-right": "{from{transform:translate3d(0,0,0)}to{visibility:hidden;transform:translate3d(100%,0,0)}}",
      "slide-out-up": "{from{transform:translate3d(0,0,0)}to{visibility:hidden;transform:translate3d(0,-100%,0)}}",
      "fade-in": "{from{opacity:0}to{opacity:1}}",
      "fade-in-down": "{from{opacity:0;transform:translate3d(0,-100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-down-big": "{from{opacity:0;transform:translate3d(0,-2000px,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-left": "{from{opacity:0;transform:translate3d(-100%,0,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-left-big": "{from{opacity:0;transform:translate3d(-2000px,0,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-right": "{from{opacity:0;transform:translate3d(100%,0,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-right-big": "{from{opacity:0;transform:translate3d(2000px,0,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-up": "{from{opacity:0;transform:translate3d(0,100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-up-big": "{from{opacity:0;transform:translate3d(0,2000px,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-top-left": "{from{opacity:0;transform:translate3d(-100%,-100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-top-right": "{from{opacity:0;transform:translate3d(100%,-100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-bottom-left": "{from{opacity:0;transform:translate3d(-100%,100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-bottom-right": "{from{opacity:0;transform:translate3d(100%,100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-out": "{from{opacity:1}to{opacity:0}}",
      "fade-out-down": "{from{opacity:1}to{opacity:0;transform:translate3d(0,100%,0)}}",
      "fade-out-down-big": "{from{opacity:1}to{opacity:0;transform:translate3d(0,2000px,0)}}",
      "fade-out-left": "{from{opacity:1}to{opacity:0;transform:translate3d(-100%,0,0)}}",
      "fade-out-left-big": "{from{opacity:1}to{opacity:0;transform:translate3d(-2000px,0,0)}}",
      "fade-out-right": "{from{opacity:1}to{opacity:0;transform:translate3d(100%,0,0)}}",
      "fade-out-right-big": "{from{opacity:1}to{opacity:0;transform:translate3d(2000px,0,0)}}",
      "fade-out-up": "{from{opacity:1}to{opacity:0;transform:translate3d(0,-100%,0)}}",
      "fade-out-up-big": "{from{opacity:1}to{opacity:0;transform:translate3d(0,-2000px,0)}}",
      "fade-out-top-left": "{from{opacity:1;transform:translate3d(0,0,0)}to{opacity:0;transform:translate3d(-100%,-100%,0)}}",
      "fade-out-top-right": "{from{opacity:1;transform:translate3d(0,0,0)}to{opacity:0;transform:translate3d(100%,-100%,0)}}",
      "fade-out-bottom-left": "{from{opacity:1;transform:translate3d(0,0,0)}to{opacity:0;transform:translate3d(-100%,100%,0)}}",
      "fade-out-bottom-right": "{from{opacity:1;transform:translate3d(0,0,0)}to{opacity:0;transform:translate3d(100%,100%,0)}}",
      "back-in-up": "{0%{opacity:0.7;transform:translateY(1200px) scale(0.7)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:1;transform:scale(1)}}",
      "back-in-down": "{0%{opacity:0.7;transform:translateY(-1200px) scale(0.7)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:1;transform:scale(1)}}",
      "back-in-right": "{0%{opacity:0.7;transform:translateX(2000px) scale(0.7)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:1;transform:scale(1)}}",
      "back-in-left": "{0%{opacity:0.7;transform:translateX(-2000px) scale(0.7)}80%{opacity:0.7;transform:translateX(0px) scale(0.7)}100%{opacity:1;transform:scale(1)}}",
      "back-out-up": "{0%{opacity:1;transform:scale(1)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:0.7;transform:translateY(-700px) scale(0.7)}}",
      "back-out-down": "{0%{opacity:1;transform:scale(1)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:0.7;transform:translateY(700px) scale(0.7)}}",
      "back-out-right": "{0%{opacity:1;transform:scale(1)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:0.7;transform:translateX(2000px) scale(0.7)}}",
      "back-out-left": "{0%{opacity:1;transform:scale(1)}80%{opacity:0.7;transform:translateX(-2000px) scale(0.7)}100%{opacity:0.7;transform:translateY(-700px) scale(0.7)}}"
    },
    durations: {
      "pulse": "2s",
      "heart-beat": "1.3s",
      "bounce-in": "0.75s",
      "bounce-out": "0.75s",
      "flip-out-x": "0.75s",
      "flip-out-y": "0.75s",
      "hinge": "2s"
    },
    timingFns: {
      "pulse": "cubic-bezier(0.4,0,.6,1)",
      "ping": "cubic-bezier(0,0,.2,1)",
      "head-shake": "ease-in-out",
      "heart-beat": "ease-in-out",
      "pulse-alt": "ease-in-out",
      "light-speed-in-left": "ease-out",
      "light-speed-in-right": "ease-out",
      "light-speed-out-left": "ease-in",
      "light-speed-out-right": "ease-in"
    },
    properties: {
      "bounce-alt": { "transform-origin": "center bottom" },
      "jello": { "transform-origin": "center" },
      "swing": { "transform-origin": "top center" },
      "flip": { "backface-visibility": "visible" },
      "flip-in-x": { "backface-visibility": "visible !important" },
      "flip-in-y": { "backface-visibility": "visible !important" },
      "flip-out-x": { "backface-visibility": "visible !important" },
      "flip-out-y": { "backface-visibility": "visible !important" },
      "rotate-in": { "transform-origin": "center" },
      "rotate-in-down-left": { "transform-origin": "left bottom" },
      "rotate-in-down-right": { "transform-origin": "right bottom" },
      "rotate-in-up-left": { "transform-origin": "left bottom" },
      "rotate-in-up-right": { "transform-origin": "right bottom" },
      "rotate-out": { "transform-origin": "center" },
      "rotate-out-down-left": { "transform-origin": "left bottom" },
      "rotate-out-down-right": { "transform-origin": "right bottom" },
      "rotate-out-up-left": { "transform-origin": "left bottom" },
      "rotate-out-up-right": { "transform-origin": "right bottom" },
      "hinge": { "transform-origin": "top left" },
      "zoom-out-down": { "transform-origin": "center bottom" },
      "zoom-out-left": { "transform-origin": "left center" },
      "zoom-out-right": { "transform-origin": "right center" },
      "zoom-out-up": { "transform-origin": "center bottom" }
    },
    counts: {
      "spin": "infinite",
      "ping": "infinite",
      "pulse": "infinite",
      "pulse-alt": "infinite",
      "bounce": "infinite",
      "bounce-alt": "infinite"
    },
    category: {
      "pulse": "Attention Seekers",
      "bounce": "Attention Seekers",
      "spin": "Attention Seekers",
      "ping": "Attention Seekers",
      "bounce-alt": "Attention Seekers",
      "flash": "Attention Seekers",
      "pulse-alt": "Attention Seekers",
      "rubber-band": "Attention Seekers",
      "shake-x": "Attention Seekers",
      "shake-y": "Attention Seekers",
      "head-shake": "Attention Seekers",
      "swing": "Attention Seekers",
      "tada": "Attention Seekers",
      "wobble": "Attention Seekers",
      "jello": "Attention Seekers",
      "heart-beat": "Attention Seekers",
      "hinge": "Specials",
      "jack-in-the-box": "Specials",
      "light-speed-in-left": "Lightspeed",
      "light-speed-in-right": "Lightspeed",
      "light-speed-out-left": "Lightspeed",
      "light-speed-out-right": "Lightspeed",
      "flip": "Flippers",
      "flip-in-x": "Flippers",
      "flip-in-y": "Flippers",
      "flip-out-x": "Flippers",
      "flip-out-y": "Flippers",
      "rotate-in": "Rotating Entrances",
      "rotate-in-down-left": "Rotating Entrances",
      "rotate-in-down-right": "Rotating Entrances",
      "rotate-in-up-left": "Rotating Entrances",
      "rotate-in-up-right": "Rotating Entrances",
      "rotate-out": "Rotating Exits",
      "rotate-out-down-left": "Rotating Exits",
      "rotate-out-down-right": "Rotating Exits",
      "rotate-out-up-left": "Rotating Exits",
      "rotate-out-up-right": "Rotating Exits",
      "roll-in": "Specials",
      "roll-out": "Specials",
      "zoom-in": "Zooming Entrances",
      "zoom-in-down": "Zooming Entrances",
      "zoom-in-left": "Zooming Entrances",
      "zoom-in-right": "Zooming Entrances",
      "zoom-in-up": "Zooming Entrances",
      "zoom-out": "Zooming Exits",
      "zoom-out-down": "Zooming Exits",
      "zoom-out-left": "Zooming Exits",
      "zoom-out-right": "Zooming Exits",
      "zoom-out-up": "Zooming Exits",
      "bounce-in": "Bouncing Entrances",
      "bounce-in-down": "Bouncing Entrances",
      "bounce-in-left": "Bouncing Entrances",
      "bounce-in-right": "Bouncing Entrances",
      "bounce-in-up": "Bouncing Entrances",
      "bounce-out": "Bouncing Exits",
      "bounce-out-down": "Bouncing Exits",
      "bounce-out-left": "Bouncing Exits",
      "bounce-out-right": "Bouncing Exits",
      "bounce-out-up": "Bouncing Exits",
      "slide-in-down": "Sliding Entrances",
      "slide-in-left": "Sliding Entrances",
      "slide-in-right": "Sliding Entrances",
      "slide-in-up": "Sliding Entrances",
      "slide-out-down": "Sliding Exits",
      "slide-out-left": "Sliding Exits",
      "slide-out-right": "Sliding Exits",
      "slide-out-up": "Sliding Exits",
      "fade-in": "Fading Entrances",
      "fade-in-down": "Fading Entrances",
      "fade-in-down-big": "Fading Entrances",
      "fade-in-left": "Fading Entrances",
      "fade-in-left-big": "Fading Entrances",
      "fade-in-right": "Fading Entrances",
      "fade-in-right-big": "Fading Entrances",
      "fade-in-up": "Fading Entrances",
      "fade-in-up-big": "Fading Entrances",
      "fade-in-top-left": "Fading Entrances",
      "fade-in-top-right": "Fading Entrances",
      "fade-in-bottom-left": "Fading Entrances",
      "fade-in-bottom-right": "Fading Entrances",
      "fade-out": "Fading Exits",
      "fade-out-down": "Fading Exits",
      "fade-out-down-big": "Fading Exits",
      "fade-out-left": "Fading Exits",
      "fade-out-left-big": "Fading Exits",
      "fade-out-right": "Fading Exits",
      "fade-out-right-big": "Fading Exits",
      "fade-out-up": "Fading Exits",
      "fade-out-up-big": "Fading Exits",
      "fade-out-top-left": "Fading Exits",
      "fade-out-top-right": "Fading Exits",
      "fade-out-bottom-left": "Fading Exits",
      "fade-out-bottom-right": "Fading Exits",
      "back-in-up": "Back Entrances",
      "back-in-down": "Back Entrances",
      "back-in-right": "Back Entrances",
      "back-in-left": "Back Entrances",
      "back-out-up": "Back Exits",
      "back-out-down": "Back Exits",
      "back-out-right": "Back Exits",
      "back-out-left": "Back Exits"
    }
  },
  media: {
    portrait: "(orientation: portrait)",
    landscape: "(orientation: landscape)",
    os_dark: "(prefers-color-scheme: dark)",
    os_light: "(prefers-color-scheme: light)",
    motion_ok: "(prefers-reduced-motion: no-preference)",
    motion_not_ok: "(prefers-reduced-motion: reduce)",
    high_contrast: "(prefers-contrast: high)",
    low_contrast: "(prefers-contrast: low)",
    opacity_ok: "(prefers-reduced-transparency: no-preference)",
    opacity_not_ok: "(prefers-reduced-transparency: reduce)",
    use_data_ok: "(prefers-reduced-data: no-preference)",
    use_data_not_ok: "(prefers-reduced-data: reduce)",
    touch: "(hover: none) and (pointer: coarse)",
    stylus: "(hover: none) and (pointer: fine)",
    pointer: "(hover) and (pointer: coarse)",
    mouse: "(hover) and (pointer: fine)",
    hd_color: "(dynamic-range: high)"
  },
  supports: {
    grid: "(display: grid)"
  },
  preflightBase: {
    ...transformBase2,
    ...touchActionBase,
    ...scrollSnapTypeBase,
    ...fontVariantNumericBase,
    ...borderSpacingBase,
    ...boxShadowsBase2,
    ...ringBase2,
    ...filterBase,
    ...backdropFilterBase
  }
};

// ../../packages-presets/preset-wind3/src/variants/combinators.ts
var variantCombinators2 = [
  variantMatcher("svg", (input) => ({ selector: `${input.selector} svg` }))
];

// ../../packages-presets/preset-wind3/src/variants/dark.ts
var variantColorsScheme = [
  variantMatcher(".dark", (input) => ({ prefix: `.dark $$ ${input.prefix}` })),
  variantMatcher(".light", (input) => ({ prefix: `.light $$ ${input.prefix}` })),
  variantParentMatcher("@dark", "@media (prefers-color-scheme: dark)"),
  variantParentMatcher("@light", "@media (prefers-color-scheme: light)")
];

// ../../packages-presets/preset-mini/dist/shared/preset-mini.Bj22ZzV1.mjs
var variantAria2 = {
  name: "aria",
  match(matcher, ctx) {
    var _a3, _b2, _c;
    const variant = variantGetParameter("aria-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const aria = (_c = (_b2 = h2.bracket(match)) != null ? _b2 : (_a3 = ctx.theme.aria) == null ? void 0 : _a3[match]) != null ? _c : "";
      if (aria) {
        return {
          matcher: rest,
          selector: (s) => `${s}[aria-${aria}]`
        };
      }
    }
  }
};
function taggedAria2(tagName) {
  return {
    name: `${tagName}-aria`,
    match(matcher, ctx) {
      var _a3, _b2, _c;
      const variant = variantGetParameter(`${tagName}-aria-`, matcher, ctx.generator.config.separators);
      if (variant) {
        const [match, rest] = variant;
        const ariaAttribute = (_c = (_b2 = h2.bracket(match)) != null ? _b2 : (_a3 = ctx.theme.aria) == null ? void 0 : _a3[match]) != null ? _c : "";
        if (ariaAttribute) {
          return {
            matcher: `${tagName}-[[aria-${ariaAttribute}]]:${rest}`
          };
        }
      }
    }
  };
}
var variantTaggedAriaAttributes2 = [
  taggedAria2("group"),
  taggedAria2("peer"),
  taggedAria2("parent"),
  taggedAria2("previous")
];
function calcMaxWidthBySize2(size) {
  var _a3;
  const value = ((_a3 = size.match(/^-?\d+\.?\d*/)) == null ? void 0 : _a3[0]) || "";
  const unit = size.slice(value.length);
  if (unit === "px") {
    const maxWidth3 = Number.parseFloat(value) - 0.1;
    return Number.isNaN(maxWidth3) ? size : `${maxWidth3}${unit}`;
  }
  return `calc(${size} - 0.1px)`;
}
var sizePseudo2 = /(max|min)-\[([^\]]*)\]:/;
function variantBreakpoints2() {
  const regexCache2 = {};
  return {
    name: "breakpoints",
    match(matcher, context) {
      var _a3;
      if (sizePseudo2.test(matcher)) {
        const match = matcher.match(sizePseudo2);
        const m = matcher.replace(match[0], "");
        return {
          matcher: m,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (${match[1]}-width: ${match[2]})`
            // parentOrder: order,
          })
        };
      }
      const variantEntries = ((_a3 = resolveBreakpoints2(context)) != null ? _a3 : []).map(({ point, size }, idx) => [point, size, idx]);
      for (const [point, size, idx] of variantEntries) {
        if (!regexCache2[point])
          regexCache2[point] = new RegExp(`^((?:([al]t-|[<~]|max-))?${point}(?:${context.generator.config.separators.join("|")}))`);
        const match = matcher.match(regexCache2[point]);
        if (!match)
          continue;
        const [, pre] = match;
        const m = matcher.slice(pre.length);
        if (m === "container")
          continue;
        const isLtPrefix = pre.startsWith("lt-") || pre.startsWith("<") || pre.startsWith("max-");
        const isAtPrefix = pre.startsWith("at-") || pre.startsWith("~");
        let order = 3e3;
        if (isLtPrefix) {
          order -= idx + 1;
          return {
            matcher: m,
            handle: (input, next) => next({
              ...input,
              parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (max-width: ${calcMaxWidthBySize2(size)})`,
              parentOrder: order
            })
          };
        }
        order += idx + 1;
        if (isAtPrefix && idx < variantEntries.length - 1) {
          return {
            matcher: m,
            handle: (input, next) => next({
              ...input,
              parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (min-width: ${size}) and (max-width: ${calcMaxWidthBySize2(variantEntries[idx + 1][1])})`,
              parentOrder: order
            })
          };
        }
        return {
          matcher: m,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (min-width: ${size})`,
            parentOrder: order
          })
        };
      }
    },
    multiPass: true,
    autocomplete: "(at-|lt-|max-|)$breakpoints:"
  };
}
var variantChildren2 = [
  variantMatcher("*", (input) => ({ selector: `${input.selector} > *` }))
];
function scopeMatcher2(name2, combinator) {
  return {
    name: `combinator:${name2}`,
    match(matcher, ctx) {
      var _a3;
      if (!matcher.startsWith(name2))
        return;
      const separators = ctx.generator.config.separators;
      let body = variantGetBracket(`${name2}-`, matcher, separators);
      if (!body) {
        for (const separator of separators) {
          if (matcher.startsWith(`${name2}${separator}`)) {
            body = ["", matcher.slice(name2.length + separator.length)];
            break;
          }
        }
        if (!body)
          return;
      }
      let bracketValue = (_a3 = h2.bracket(body[0])) != null ? _a3 : "";
      if (bracketValue === "")
        bracketValue = "*";
      return {
        matcher: body[1],
        selector: (s) => `${s}${combinator}${bracketValue}`
      };
    },
    multiPass: true
  };
}
var variantCombinators3 = [
  scopeMatcher2("all", " "),
  scopeMatcher2("children", ">"),
  scopeMatcher2("next", "+"),
  scopeMatcher2("sibling", "+"),
  scopeMatcher2("siblings", "~")
];
var variantContainerQuery2 = {
  name: "@",
  match(matcher, ctx) {
    var _a3, _b2, _c;
    if (matcher.startsWith("@container"))
      return;
    const variant = variantGetParameter("@", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest, label] = variant;
      const unbracket = h2.bracket(match);
      let container2;
      if (unbracket) {
        container2 = h2.numberWithUnit(unbracket);
      } else {
        container2 = (_b2 = (_a3 = ctx.theme.containers) == null ? void 0 : _a3[match]) != null ? _b2 : "";
      }
      if (container2) {
        let order = 1e3 + Object.keys((_c = ctx.theme.containers) != null ? _c : {}).indexOf(match);
        if (label)
          order += 1e3;
        return {
          matcher: rest,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@container${label ? ` ${label} ` : " "}(min-width: ${container2})`,
            parentOrder: order
          })
        };
      }
    }
  },
  multiPass: true
};
function variantColorsMediaOrClass2(options = {}) {
  if ((options == null ? void 0 : options.dark) === "class" || typeof options.dark === "object") {
    const { dark = ".dark", light = ".light" } = typeof options.dark === "string" ? {} : options.dark;
    return [
      variantMatcher("dark", toArray2(dark).map((dark2) => (input) => ({ prefix: `${dark2} $$ ${input.prefix}` }))),
      variantMatcher("light", toArray2(light).map((light2) => (input) => ({ prefix: `${light2} $$ ${input.prefix}` })))
    ];
  }
  return [
    variantParentMatcher("dark", "@media (prefers-color-scheme: dark)"),
    variantParentMatcher("light", "@media (prefers-color-scheme: light)")
  ];
}
var variantDataAttribute2 = {
  name: "data",
  match(matcher, ctx) {
    var _a3, _b2, _c;
    const variant = variantGetParameter("data-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const dataAttribute = (_c = (_b2 = h2.bracket(match)) != null ? _b2 : (_a3 = ctx.theme.data) == null ? void 0 : _a3[match]) != null ? _c : "";
      if (dataAttribute) {
        return {
          matcher: rest,
          selector: (s) => `${s}[data-${dataAttribute}]`
        };
      }
    }
  }
};
function taggedData2(tagName) {
  return {
    name: `${tagName}-data`,
    match(matcher, ctx) {
      var _a3, _b2, _c;
      const variant = variantGetParameter(`${tagName}-data-`, matcher, ctx.generator.config.separators);
      if (variant) {
        const [match, rest, label] = variant;
        const dataAttribute = (_c = (_b2 = h2.bracket(match)) != null ? _b2 : (_a3 = ctx.theme.data) == null ? void 0 : _a3[match]) != null ? _c : "";
        if (dataAttribute) {
          return {
            matcher: `${tagName}-[[data-${dataAttribute}]]${label ? `/${label}` : ""}:${rest}`
          };
        }
      }
    }
  };
}
var variantTaggedDataAttributes2 = [
  taggedData2("group"),
  taggedData2("peer"),
  taggedData2("parent"),
  taggedData2("previous")
];
var variantLanguageDirections2 = [
  variantMatcher("rtl", (input) => ({ prefix: `[dir="rtl"] $$ ${input.prefix}` })),
  variantMatcher("ltr", (input) => ({ prefix: `[dir="ltr"] $$ ${input.prefix}` }))
];
function variantImportant2() {
  let re;
  return {
    name: "important",
    match(matcher, ctx) {
      if (!re)
        re = new RegExp(`^(important(?:${ctx.generator.config.separators.join("|")})|!)`);
      let base;
      const match = matcher.match(re);
      if (match)
        base = matcher.slice(match[0].length);
      else if (matcher.endsWith("!"))
        base = matcher.slice(0, -1);
      if (base) {
        return {
          matcher: base,
          body: (body) => {
            body.forEach((v) => {
              if (v[1] != null)
                v[1] += " !important";
            });
            return body;
          }
        };
      }
    }
  };
}
var variantPrint2 = variantParentMatcher("print", "@media print");
var variantCustomMedia2 = {
  name: "media",
  match(matcher, ctx) {
    var _a3, _b2, _c;
    const variant = variantGetParameter("media-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      let media3 = (_a3 = h2.bracket(match)) != null ? _a3 : "";
      if (media3 === "")
        media3 = (_c = (_b2 = ctx.theme.media) == null ? void 0 : _b2[match]) != null ? _c : "";
      if (media3) {
        return {
          matcher: rest,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@media ${media3}`
          })
        };
      }
    }
  },
  multiPass: true
};
var variantSelector2 = {
  name: "selector",
  match(matcher, ctx) {
    const variant = variantGetBracket("selector-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const selector = h2.bracket(match);
      if (selector) {
        return {
          matcher: rest,
          selector: () => selector
        };
      }
    }
  }
};
var variantCssLayer2 = {
  name: "layer",
  match(matcher, ctx) {
    var _a3;
    const variant = variantGetParameter("layer-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const layer = (_a3 = h2.bracket(match)) != null ? _a3 : match;
      if (layer) {
        return {
          matcher: rest,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@layer ${layer}`
          })
        };
      }
    }
  }
};
var variantInternalLayer2 = {
  name: "uno-layer",
  match(matcher, ctx) {
    var _a3;
    const variant = variantGetParameter("uno-layer-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const layer = (_a3 = h2.bracket(match)) != null ? _a3 : match;
      if (layer) {
        return {
          matcher: rest,
          layer
        };
      }
    }
  }
};
var variantScope2 = {
  name: "scope",
  match(matcher, ctx) {
    const variant = variantGetBracket("scope-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const scope = h2.bracket(match);
      if (scope) {
        return {
          matcher: rest,
          selector: (s) => `${scope} $$ ${s}`
        };
      }
    }
  }
};
var variantVariables2 = {
  name: "variables",
  match(matcher, ctx) {
    var _a3, _b2;
    if (!matcher.startsWith("["))
      return;
    const [match, rest] = (_a3 = getBracket(matcher, "[", "]")) != null ? _a3 : [];
    if (!(match && rest))
      return;
    let newMatcher;
    for (const separator of ctx.generator.config.separators) {
      if (rest.startsWith(separator)) {
        newMatcher = rest.slice(separator.length);
        break;
      }
    }
    if (newMatcher == null)
      return;
    const variant = (_b2 = h2.bracket(match)) != null ? _b2 : "";
    const useParent = variant.startsWith("@");
    if (!(useParent || variant.includes("&")))
      return;
    return {
      matcher: newMatcher,
      handle(input, next) {
        const updates = useParent ? {
          parent: `${input.parent ? `${input.parent} $$ ` : ""}${variant}`
        } : {
          selector: variant.replace(/&/g, input.selector)
        };
        return next({
          ...input,
          ...updates
        });
      }
    };
  },
  multiPass: true
};
var variantTheme2 = {
  name: "theme-variables",
  match(matcher, ctx) {
    if (!hasThemeFn(matcher))
      return;
    return {
      matcher,
      handle(input, next) {
        return next({
          ...input,
          //  entries: [ [ '--css-spacing', '28px' ] ],
          entries: JSON.parse(transformThemeFn(JSON.stringify(input.entries), ctx.theme))
        });
      }
    };
  }
};
var anchoredNumberRE2 = /^-?[0-9.]+(?:[a-z]+|%)?$/;
var numberRE4 = /-?[0-9.]+(?:[a-z]+|%)?/;
var ignoreProps2 = [
  /\b(opacity|color|flex|backdrop-filter|^filter|transform)\b/
];
function negateMathFunction2(value) {
  var _a3;
  const match = value.match(cssMathFnRE2) || value.match(cssVarFnRE2);
  if (match) {
    const [fnBody, rest] = (_a3 = getStringComponent(`(${match[2]})${match[3]}`, "(", ")", " ")) != null ? _a3 : [];
    if (fnBody)
      return `calc(${match[1]}${fnBody} * -1)${rest ? ` ${rest}` : ""}`;
  }
}
var negateFunctionBodyRE2 = /\b(hue-rotate)\s*(\(.*)/;
function negateFunctionBody2(value) {
  var _a3;
  const match = value.match(negateFunctionBodyRE2);
  if (match) {
    const [fnBody, rest] = (_a3 = getStringComponent(match[2], "(", ")", " ")) != null ? _a3 : [];
    if (fnBody) {
      const body = anchoredNumberRE2.test(fnBody.slice(1, -1)) ? fnBody.replace(numberRE4, (i) => i.startsWith("-") ? i.slice(1) : `-${i}`) : `(calc(${fnBody} * -1))`;
      return `${match[1]}${body}${rest ? ` ${rest}` : ""}`;
    }
  }
}
var variantNegative2 = {
  name: "negative",
  match(matcher) {
    if (!matcher.startsWith("-"))
      return;
    return {
      matcher: matcher.slice(1),
      body: (body) => {
        if (body.find((v) => v[0] === CONTROL_MINI_NO_NEGATIVE2))
          return;
        let changed = false;
        body.forEach((v) => {
          var _a3;
          const value = (_a3 = v[1]) == null ? void 0 : _a3.toString();
          if (!value || value === "0")
            return;
          if (ignoreProps2.some((i) => i.test(v[0])))
            return;
          const negatedFn = negateMathFunction2(value);
          if (negatedFn) {
            v[1] = negatedFn;
            changed = true;
            return;
          }
          const negatedBody = negateFunctionBody2(value);
          if (negatedBody) {
            v[1] = negatedBody;
            changed = true;
            return;
          }
          if (anchoredNumberRE2.test(value)) {
            v[1] = value.replace(numberRE4, (i) => i.startsWith("-") ? i.slice(1) : `-${i}`);
            changed = true;
          }
        });
        if (changed)
          return body;
        return [];
      }
    };
  }
};
var PseudoClasses2 = Object.fromEntries([
  // pseudo elements part 1
  ["first-letter", "::first-letter"],
  ["first-line", "::first-line"],
  // location
  "any-link",
  "link",
  "visited",
  "target",
  ["open", "[open]"],
  // forms
  "default",
  "checked",
  "indeterminate",
  "placeholder-shown",
  "autofill",
  "optional",
  "required",
  "valid",
  "invalid",
  "user-valid",
  "user-invalid",
  "in-range",
  "out-of-range",
  "read-only",
  "read-write",
  // content
  "empty",
  // interactions
  "focus-within",
  "hover",
  "focus",
  "focus-visible",
  "active",
  "enabled",
  "disabled",
  "popover-open",
  // tree-structural
  "root",
  "empty",
  ["even-of-type", ":nth-of-type(even)"],
  ["even", ":nth-child(even)"],
  ["odd-of-type", ":nth-of-type(odd)"],
  ["odd", ":nth-child(odd)"],
  "first-of-type",
  ["first", ":first-child"],
  "last-of-type",
  ["last", ":last-child"],
  "only-child",
  "only-of-type",
  // pseudo elements part 2
  ["backdrop-element", "::backdrop"],
  ["placeholder", "::placeholder"],
  ["before", "::before"],
  ["after", "::after"],
  ["file", "::file-selector-button"]
].map((key) => Array.isArray(key) ? key : [key, `:${key}`]));
var PseudoClassesKeys2 = Object.keys(PseudoClasses2);
var PseudoClassesColon2 = Object.fromEntries([
  ["backdrop", "::backdrop"]
].map((key) => Array.isArray(key) ? key : [key, `:${key}`]));
var PseudoClassesColonKeys2 = Object.keys(PseudoClassesColon2);
var PseudoClassFunctions2 = [
  "not",
  "is",
  "where",
  "has"
];
var PseudoClassesMulti2 = Object.fromEntries([
  ["selection", ["::selection", " *::selection"]],
  ["marker", ["::marker", " *::marker"]]
]);
var PseudoClassesStr2 = Object.entries(PseudoClasses2).filter(([, pseudo]) => !pseudo.startsWith("::")).map(([key]) => key).sort((a, b) => b.length - a.length).join("|");
var PseudoClassesColonStr2 = Object.entries(PseudoClassesColon2).filter(([, pseudo]) => !pseudo.startsWith("::")).map(([key]) => key).sort((a, b) => b.length - a.length).join("|");
var PseudoClassFunctionsStr2 = PseudoClassFunctions2.join("|");
var PseudoClassesMultiStr2 = Object.keys(PseudoClassesMulti2).sort((a, b) => b.length - a.length).join("|");
function taggedPseudoClassMatcher2(tag, parent, combinator) {
  const rawRE = new RegExp(`^(${escapeRegExp(parent)}:)(\\S+)${escapeRegExp(combinator)}\\1`);
  let splitRE;
  let pseudoRE;
  let pseudoColonRE;
  let pseudoVarRE;
  const matchBracket = (input) => {
    var _a3, _b2;
    const body = variantGetBracket(`${tag}-`, input, []);
    if (!body)
      return;
    const [match, rest] = body;
    const bracketValue = h2.bracket(match);
    if (bracketValue == null)
      return;
    const label = (_b2 = (_a3 = rest.split(splitRE, 1)) == null ? void 0 : _a3[0]) != null ? _b2 : "";
    const prefix = `${parent}${escapeSelector(label)}`;
    return [
      label,
      input.slice(input.length - (rest.length - label.length - 1)),
      bracketValue.includes("&") ? bracketValue.replace(/&/g, prefix) : `${prefix}${bracketValue}`
    ];
  };
  const matchPseudo = (input) => {
    var _a3;
    const match = input.match(pseudoRE) || input.match(pseudoColonRE);
    if (!match)
      return;
    const [original, fn, pseudoKey] = match;
    const label = (_a3 = match[3]) != null ? _a3 : "";
    let pseudo = PseudoClasses2[pseudoKey] || PseudoClassesColon2[pseudoKey] || `:${pseudoKey}`;
    if (fn)
      pseudo = `:${fn}(${pseudo})`;
    return [
      label,
      input.slice(original.length),
      `${parent}${escapeSelector(label)}${pseudo}`,
      pseudoKey
    ];
  };
  const matchPseudoVar = (input) => {
    var _a3;
    const match = input.match(pseudoVarRE);
    if (!match)
      return;
    const [original, fn, pseudoValue] = match;
    const label = (_a3 = match[3]) != null ? _a3 : "";
    const pseudo = `:${fn}(${pseudoValue})`;
    return [
      label,
      input.slice(original.length),
      `${parent}${escapeSelector(label)}${pseudo}`
    ];
  };
  return {
    name: `pseudo:${tag}`,
    match(input, ctx) {
      if (!(splitRE && pseudoRE && pseudoColonRE)) {
        splitRE = new RegExp(`(?:${ctx.generator.config.separators.join("|")})`);
        pseudoRE = new RegExp(`^${tag}-(?:(?:(${PseudoClassFunctionsStr2})-)?(${PseudoClassesStr2}))(?:(/\\w+))?(?:${ctx.generator.config.separators.join("|")})`);
        pseudoColonRE = new RegExp(`^${tag}-(?:(?:(${PseudoClassFunctionsStr2})-)?(${PseudoClassesColonStr2}))(?:(/\\w+))?(?:${ctx.generator.config.separators.filter((x2) => x2 !== "-").join("|")})`);
        pseudoVarRE = new RegExp(`^${tag}-(?:(${PseudoClassFunctionsStr2})-)?\\[(.+)\\](?:(/\\w+))?(?:${ctx.generator.config.separators.filter((x2) => x2 !== "-").join("|")})`);
      }
      if (!input.startsWith(tag))
        return;
      const result = matchBracket(input) || matchPseudo(input) || matchPseudoVar(input);
      if (!result)
        return;
      const [_label, matcher, prefix, pseudoName = ""] = result;
      return {
        matcher,
        handle: (input2, next) => {
          var _a3;
          return next({
            ...input2,
            prefix: `${prefix}${combinator}${input2.prefix}`.replace(rawRE, "$1$2:"),
            sort: (_a3 = PseudoClassesKeys2.indexOf(pseudoName)) != null ? _a3 : PseudoClassesColonKeys2.indexOf(pseudoName)
          });
        }
      };
    },
    multiPass: true
  };
}
var excludedPseudo2 = [
  "::-webkit-resizer",
  "::-webkit-scrollbar",
  "::-webkit-scrollbar-button",
  "::-webkit-scrollbar-corner",
  "::-webkit-scrollbar-thumb",
  "::-webkit-scrollbar-track",
  "::-webkit-scrollbar-track-piece",
  "::file-selector-button"
];
var PseudoClassesAndElementsStr2 = Object.entries(PseudoClasses2).map(([key]) => key).sort((a, b) => b.length - a.length).join("|");
var PseudoClassesAndElementsColonStr2 = Object.entries(PseudoClassesColon2).map(([key]) => key).sort((a, b) => b.length - a.length).join("|");
function variantPseudoClassesAndElements2() {
  let PseudoClassesAndElementsRE;
  let PseudoClassesAndElementsColonRE;
  let PseudoClassesMultiRE;
  return [
    {
      name: "pseudo",
      match(input, ctx) {
        if (!(PseudoClassesAndElementsRE && PseudoClassesAndElementsColonRE)) {
          PseudoClassesAndElementsRE = new RegExp(`^(${PseudoClassesAndElementsStr2})(?:${ctx.generator.config.separators.join("|")})`);
          PseudoClassesAndElementsColonRE = new RegExp(`^(${PseudoClassesAndElementsColonStr2})(?:${ctx.generator.config.separators.filter((x2) => x2 !== "-").join("|")})`);
        }
        const match = input.match(PseudoClassesAndElementsRE) || input.match(PseudoClassesAndElementsColonRE);
        if (match) {
          const pseudo = PseudoClasses2[match[1]] || PseudoClassesColon2[match[1]] || `:${match[1]}`;
          let index = PseudoClassesKeys2.indexOf(match[1]);
          if (index === -1)
            index = PseudoClassesColonKeys2.indexOf(match[1]);
          if (index === -1)
            index = void 0;
          return {
            matcher: input.slice(match[0].length),
            handle: (input2, next) => {
              const selectors = pseudo.includes("::") && !excludedPseudo2.includes(pseudo) ? {
                pseudo: `${input2.pseudo}${pseudo}`
              } : {
                selector: `${input2.selector}${pseudo}`
              };
              return next({
                ...input2,
                ...selectors,
                sort: index,
                noMerge: true
              });
            }
          };
        }
      },
      multiPass: true,
      autocomplete: `(${PseudoClassesAndElementsStr2}|${PseudoClassesAndElementsColonStr2}):`
    },
    {
      name: "pseudo:multi",
      match(input, ctx) {
        if (!PseudoClassesMultiRE) {
          PseudoClassesMultiRE = new RegExp(`^(${PseudoClassesMultiStr2})(?:${ctx.generator.config.separators.join("|")})`);
        }
        const match = input.match(PseudoClassesMultiRE);
        if (match) {
          const pseudos = PseudoClassesMulti2[match[1]];
          return pseudos.map((pseudo) => {
            return {
              matcher: input.slice(match[0].length),
              handle: (input2, next) => next({
                ...input2,
                pseudo: `${input2.pseudo}${pseudo}`
              })
            };
          });
        }
      },
      multiPass: false,
      autocomplete: `(${PseudoClassesMultiStr2}):`
    }
  ];
}
function variantPseudoClassFunctions2() {
  let PseudoClassFunctionsRE;
  let PseudoClassColonFunctionsRE;
  let PseudoClassVarFunctionRE;
  return {
    match(input, ctx) {
      if (!(PseudoClassFunctionsRE && PseudoClassColonFunctionsRE)) {
        PseudoClassFunctionsRE = new RegExp(`^(${PseudoClassFunctionsStr2})-(${PseudoClassesStr2})(?:${ctx.generator.config.separators.join("|")})`);
        PseudoClassColonFunctionsRE = new RegExp(`^(${PseudoClassFunctionsStr2})-(${PseudoClassesColonStr2})(?:${ctx.generator.config.separators.filter((x2) => x2 !== "-").join("|")})`);
        PseudoClassVarFunctionRE = new RegExp(`^(${PseudoClassFunctionsStr2})-(\\[.+\\])(?:${ctx.generator.config.separators.filter((x2) => x2 !== "-").join("|")})`);
      }
      const match = input.match(PseudoClassFunctionsRE) || input.match(PseudoClassColonFunctionsRE) || input.match(PseudoClassVarFunctionRE);
      if (match) {
        const fn = match[1];
        const fnVal = getBracket(match[2], "[", "]");
        const pseudo = fnVal ? h2.bracket(match[2]) : PseudoClasses2[match[2]] || PseudoClassesColon2[match[2]] || `:${match[2]}`;
        return {
          matcher: input.slice(match[0].length),
          selector: (s) => `${s}:${fn}(${pseudo})`
        };
      }
    },
    multiPass: true,
    autocomplete: `(${PseudoClassFunctionsStr2})-(${PseudoClassesStr2}|${PseudoClassesColonStr2}):`
  };
}
function variantTaggedPseudoClasses2(options = {}) {
  var _a3, _b2;
  const attributify = !!(options == null ? void 0 : options.attributifyPseudo);
  let firstPrefix = (_a3 = options == null ? void 0 : options.prefix) != null ? _a3 : "";
  firstPrefix = (_b2 = (Array.isArray(firstPrefix) ? firstPrefix : [firstPrefix]).filter(Boolean)[0]) != null ? _b2 : "";
  const tagWithPrefix = (tag, combinator) => taggedPseudoClassMatcher2(tag, attributify ? `[${firstPrefix}${tag}=""]` : `.${firstPrefix}${tag}`, combinator);
  return [
    tagWithPrefix("group", " "),
    tagWithPrefix("peer", "~"),
    tagWithPrefix("parent", ">"),
    tagWithPrefix("previous", "+"),
    tagWithPrefix("group-aria", " "),
    tagWithPrefix("peer-aria", "~"),
    tagWithPrefix("parent-aria", ">"),
    tagWithPrefix("previous-aria", "+")
  ];
}
var PartClassesRE2 = /(part-\[(.+)\]:)(.+)/;
var variantPartClasses2 = {
  match(input) {
    const match = input.match(PartClassesRE2);
    if (match) {
      const part = `part(${match[2]})`;
      return {
        matcher: input.slice(match[1].length),
        selector: (s) => `${s}::${part}`
      };
    }
  },
  multiPass: true
};
var variantStartingStyle2 = {
  name: "starting",
  match(matcher) {
    if (!matcher.startsWith("starting:"))
      return;
    return {
      matcher: matcher.slice(9),
      handle: (input, next) => next({
        ...input,
        parent: `@starting-style`
      })
    };
  }
};
var variantSupports2 = {
  name: "supports",
  match(matcher, ctx) {
    var _a3, _b2, _c;
    const variant = variantGetParameter("supports-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      let supports = (_a3 = h2.bracket(match)) != null ? _a3 : "";
      if (supports === "")
        supports = (_c = (_b2 = ctx.theme.supports) == null ? void 0 : _b2[match]) != null ? _c : "";
      if (supports) {
        return {
          matcher: rest,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@supports ${supports}`
          })
        };
      }
    }
  },
  multiPass: true
};
function variants2(options) {
  return [
    variantAria2,
    variantDataAttribute2,
    variantCssLayer2,
    variantSelector2,
    variantInternalLayer2,
    variantNegative2,
    variantStartingStyle2,
    variantImportant2(),
    variantSupports2,
    variantPrint2,
    variantCustomMedia2,
    variantBreakpoints2(),
    ...variantCombinators3,
    ...variantPseudoClassesAndElements2(),
    variantPseudoClassFunctions2(),
    ...variantTaggedPseudoClasses2(options),
    variantPartClasses2,
    ...variantColorsMediaOrClass2(options),
    ...variantLanguageDirections2,
    variantScope2,
    ...variantChildren2,
    variantContainerQuery2,
    variantVariables2,
    ...variantTaggedDataAttributes2,
    ...variantTaggedAriaAttributes2,
    variantTheme2
  ];
}

// ../../packages-presets/preset-wind3/src/variants/media.ts
var variantContrasts = [
  variantParentMatcher("contrast-more", "@media (prefers-contrast: more)"),
  variantParentMatcher("contrast-less", "@media (prefers-contrast: less)")
];
var variantMotions = [
  variantParentMatcher("motion-reduce", "@media (prefers-reduced-motion: reduce)"),
  variantParentMatcher("motion-safe", "@media (prefers-reduced-motion: no-preference)")
];
var variantOrientations = [
  variantParentMatcher("landscape", "@media (orientation: landscape)"),
  variantParentMatcher("portrait", "@media (orientation: portrait)")
];

// ../../packages-presets/preset-wind3/src/variants/misc.ts
var variantSpaceAndDivide = (matcher) => {
  if (matcher.startsWith("_"))
    return;
  if (/space-[xy]-.+$/.test(matcher) || /divide-/.test(matcher)) {
    return {
      matcher,
      selector: (input) => {
        const not = ">:not([hidden])~:not([hidden])";
        return input.includes(not) ? input : `${input}${not}`;
      }
    };
  }
};
var variantStickyHover = [
  variantMatcher("@hover", (input) => ({
    parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (hover: hover) and (pointer: fine)`,
    selector: `${input.selector || ""}:hover`
  }))
];

// ../../packages-presets/preset-wind3/src/variants/mix.ts
function mixComponent(v1, v2, w) {
  return `calc(${v2} + (${v1} - ${v2}) * ${w} / 100)`;
}
function mixColor(color1, color2, weight) {
  var _a3, _b2;
  const colors3 = [color1, color2];
  const cssColors = [];
  for (let c = 0; c < 2; c++) {
    const color = typeof colors3[c] === "string" ? parseCssColor(colors3[c]) : colors3[c];
    if (!color || !["rgb", "rgba"].includes(color.type))
      return;
    cssColors.push(color);
  }
  const newComponents = [];
  for (let x2 = 0; x2 < 3; x2++)
    newComponents.push(mixComponent(cssColors[0].components[x2], cssColors[1].components[x2], weight));
  return {
    type: "rgb",
    components: newComponents,
    alpha: mixComponent((_a3 = cssColors[0].alpha) != null ? _a3 : 1, (_b2 = cssColors[1].alpha) != null ? _b2 : 1, weight)
  };
}
function tint(color, weight) {
  return mixColor("#fff", color, weight);
}
function shade(color, weight) {
  return mixColor("#000", color, weight);
}
function shift(color, weight) {
  const num = Number.parseFloat(`${weight}`);
  if (!Number.isNaN(num))
    return num > 0 ? shade(color, weight) : tint(color, -num);
}
var fns = { tint, shade, shift };
function variantColorMix() {
  let re;
  return {
    name: "mix",
    match(matcher, ctx) {
      if (!re)
        re = new RegExp(`^mix-(tint|shade|shift)-(-?\\d{1,3})(?:${ctx.generator.config.separators.join("|")})`);
      const m = matcher.match(re);
      if (m) {
        return {
          matcher: matcher.slice(m[0].length),
          body: (body) => {
            body.forEach((v) => {
              if (v[1]) {
                const color = parseCssColor(`${v[1]}`);
                if (color) {
                  const mixed = fns[m[1]](color, m[2]);
                  if (mixed)
                    v[1] = colorToString(mixed);
                }
              }
            });
            return body;
          }
        };
      }
    }
  };
}

// ../../packages-presets/preset-wind3/src/variants/placeholder.ts
var placeholderModifier = (input, { theme: theme4 }) => {
  const m = input.match(/^(.*)\b(placeholder-)(.+)$/);
  if (m) {
    const [, pre = "", p, body] = m;
    if (hasParseableColor2(body, theme4, "accentColor") || hasOpacityValue(body)) {
      return {
        // Append `placeholder-$ ` (with space!) to the rule to be matched.
        // The `placeholder-` is added for placeholder variant processing, and
        // the `$ ` is added for rule matching after `placeholder-` is removed by the variant.
        // See rules/placeholder.
        matcher: `${pre}placeholder-$ ${p}${body}`
      };
    }
  }
};
function hasOpacityValue(body) {
  const match = body.match(/^op(?:acity)?-?(.+)$/);
  if (match && match[1] != null)
    return h2.bracket.percent(match[1]) != null;
  return false;
}

// ../../packages-presets/preset-wind3/src/variants/default.ts
function variants3(options) {
  return [
    placeholderModifier,
    variantSpaceAndDivide,
    ...variants2(options),
    ...variantContrasts,
    ...variantOrientations,
    ...variantMotions,
    ...variantCombinators2,
    ...variantColorsScheme,
    ...variantStickyHover,
    variantColorMix()
  ];
}

// ../../packages-presets/preset-wind3/src/index.ts
var presetWind3 = definePreset((options = {}) => {
  var _a3;
  options.important = (_a3 = options.important) != null ? _a3 : false;
  return {
    ...presetMini(options),
    name: "@unocss/preset-wind3",
    theme: theme3,
    rules: rules3,
    shortcuts,
    variants: variants3(options),
    postprocess: postprocessors(options)
  };
});

// ../../packages-deprecated/preset-uno/src/index.ts
var presetUno = definePreset((options = {}) => {
  const wind = presetWind3(options);
  return {
    ...wind,
    name: "@unocss/preset-uno"
  };
});
var src_default2 = presetUno;

// src/contextLoader.ts
var import_fs_extra = _chunk42PBKAQTcjs.__toESM.call(void 0, require_lib(), 1);

// ../../node_modules/.pnpm/unconfig@7.0.0/node_modules/unconfig/dist/presets.mjs
function sourcePluginFactory(options) {
  return {
    ...options,
    transform: (source) => {
      const prefix = `
let __unconfig_data;
let __unconfig_stub = function (data = {}) { __unconfig_data = data };
__unconfig_stub.default = (data = {}) => { __unconfig_data = data };
`;
      const suffix = "export default __unconfig_data;";
      let code = source.replace(new RegExp(`import (.+?) from (['"])${options.targetModule}\\2`), "const $1 = __unconfig_stub;").replace("export default", "const __unconfig_default = ");
      if (code.includes("__unconfig_default"))
        code += `
if (typeof __unconfig_default === "function") __unconfig_default(...${JSON.stringify(options.parameters || [])});`;
      return `${prefix}${code}${suffix}`;
    }
  };
}
function sourceObjectFields(options) {
  const fields = _chunkTR37ZOITcjs.toArray.call(void 0, options.fields);
  return {
    ...options,
    async rewrite(obj) {
      const config = await (typeof obj === "function" ? obj(...options.parameters || []) : obj);
      if (!config)
        return config;
      for (const field of fields) {
        if (field in config)
          return config[field];
      }
    }
  };
}

// ../../packages-presets/preset-attributify/src/variant.ts
var variantsRE = /^(?!.*\[[^:]+:.+\]$)((?:.+:)?!?)(.*)$/;
function variantAttributify(options = {}) {
  var _a3, _b2, _c;
  const prefix = (_a3 = options.prefix) != null ? _a3 : "un-";
  const prefixedOnly = (_b2 = options.prefixedOnly) != null ? _b2 : false;
  const trueToNonValued = (_c = options.trueToNonValued) != null ? _c : false;
  let variantsValueRE;
  return {
    name: "attributify",
    match(input, { generator }) {
      var _a4, _b3;
      const match = isAttributifySelector(input);
      if (!match)
        return;
      let name2 = match[1];
      if (name2.startsWith(prefix))
        name2 = name2.slice(prefix.length);
      else if (prefixedOnly)
        return;
      const content = match[2];
      const [, variants4 = "", body = content] = content.match(variantsRE) || [];
      if (body === "~" || trueToNonValued && body === "true" || !body) {
        return `${variants4}${name2}`;
      }
      if (variantsValueRE == null) {
        const separators = (_b3 = (_a4 = generator == null ? void 0 : generator.config) == null ? void 0 : _a4.separators) == null ? void 0 : _b3.join("|");
        if (separators)
          variantsValueRE = new RegExp(`^(.*\\](?:${separators}))(\\[[^\\]]+?\\])$`);
        else
          variantsValueRE = false;
      }
      if (variantsValueRE) {
        const [, bodyVariant, bracketValue] = content.match(variantsValueRE) || [];
        if (bracketValue)
          return `${bodyVariant}${variants4}${name2}-${bracketValue}`;
      }
      if (variants4 && body.match(/^[\d.]+$/)) {
        const variantParts = variants4.split(/([^:]*:)/g).filter(Boolean);
        const _body = variantParts.pop() + body;
        const _variants = variantParts.join("");
        return [
          { matcher: `${variants4}${name2}-${body}` },
          { matcher: `${_variants}${name2}-${_body}` }
        ];
      }
      return `${variants4}${name2}-${body}`;
    }
  };
}

// ../../packages-presets/preset-attributify/src/autocomplete.ts
var elementRE = /(<\w[\w:.$-]*\s)((?:'[^>']*'|"[^>"]*"|`[^>`]*`|\{[^>}]*\}|[^>]*?)*)/g;
var valuedAttributeRE = /(\?|(?!\d|-{2}|-\d)[\w\u00A0-\uFFFF-:%]+)(?:=("[^"]*|'[^']*))?/g;
var splitterRE = /[\s'"`;>]+/;
function autocompleteExtractorAttributify(options) {
  return {
    name: "attributify",
    extract: ({ content, cursor }) => {
      const matchedElements = content.matchAll(elementRE);
      let attrs;
      let elPos = 0;
      for (const match of matchedElements) {
        const [, prefix, content2] = match;
        const currentPos2 = match.index + prefix.length;
        if (cursor > currentPos2 && cursor <= currentPos2 + content2.length) {
          elPos = currentPos2;
          attrs = content2;
          break;
        }
      }
      if (!attrs)
        return null;
      const matchedAttributes = attrs.matchAll(valuedAttributeRE);
      let attrsPos = 0;
      let attrName;
      let attrValues;
      for (const match of matchedAttributes) {
        const [matched, name2, rawValues] = match;
        const currentPos2 = elPos + match.index;
        if (cursor > currentPos2 && cursor <= currentPos2 + matched.length) {
          attrsPos = currentPos2;
          attrName = name2;
          attrValues = rawValues == null ? void 0 : rawValues.slice(1);
          break;
        }
      }
      if (!attrName)
        return null;
      if (attrName === "class" || attrName === "className" || attrName === ":class")
        return null;
      const hasPrefix = !!(options == null ? void 0 : options.prefix) && attrName.startsWith(options.prefix);
      if ((options == null ? void 0 : options.prefixedOnly) && !hasPrefix)
        return null;
      const attrNameWithoutPrefix = hasPrefix ? attrName.slice(options.prefix.length) : attrName;
      if (attrValues === void 0) {
        return {
          extracted: attrNameWithoutPrefix,
          resolveReplacement(suggestion) {
            const startOffset = hasPrefix ? options.prefix.length : 0;
            return {
              start: attrsPos + startOffset,
              end: attrsPos + attrName.length,
              replacement: suggestion
            };
          }
        };
      }
      const attrValuePos = attrsPos + attrName.length + 2;
      let matchSplit = splitterRE.exec(attrValues);
      let currentPos = 0;
      let value;
      while (matchSplit) {
        const [matched] = matchSplit;
        if (cursor > attrValuePos + currentPos && cursor <= attrValuePos + currentPos + matchSplit.index) {
          value = attrValues.slice(currentPos, currentPos + matchSplit.index);
          break;
        }
        currentPos += matchSplit.index + matched.length;
        matchSplit = splitterRE.exec(attrValues.slice(currentPos));
      }
      if (value === void 0)
        value = attrValues.slice(currentPos);
      const [, variants4 = "", body] = value.match(variantsRE) || [];
      return {
        extracted: `${variants4}${attrNameWithoutPrefix}-${body}`,
        transformSuggestions(suggestions) {
          return suggestions.filter((v) => v.startsWith(`${variants4}${attrNameWithoutPrefix}-`)).map((v) => variants4 + v.slice(variants4.length + attrNameWithoutPrefix.length + 1));
        },
        resolveReplacement(suggestion) {
          return {
            start: currentPos + attrValuePos,
            end: currentPos + attrValuePos + value.length,
            replacement: variants4 + suggestion.slice(variants4.length + attrNameWithoutPrefix.length + 1)
          };
        }
      };
    }
  };
}

// ../../packages-presets/preset-attributify/src/extractor.ts
var strippedPrefixes = [
  "v-bind:",
  ":"
];
var splitterRE2 = /[\s'"`;]+/g;
var elementRE2 = /<[^>\s]*\s((?:'[^']*'|"[^"]*"|`[^`]*`|\{[^}]*\}|=>|[^>]*?)*)/g;
var valuedAttributeRE2 = /(\?|(?!\d|-{2}|-\d)[\w\u00A0-\uFFFF:!%.~<-]+)=?(?:"([^"]*)"|'([^']*)'|\{([^}]*)\})?/g;
var defaultIgnoreAttributes = ["placeholder", "fill", "opacity", "stroke-opacity"];
function extractorAttributify(options) {
  var _a3, _b2, _c;
  const ignoreAttributes = (_a3 = options == null ? void 0 : options.ignoreAttributes) != null ? _a3 : defaultIgnoreAttributes;
  const nonValuedAttribute = (_b2 = options == null ? void 0 : options.nonValuedAttribute) != null ? _b2 : true;
  const trueToNonValued = (_c = options == null ? void 0 : options.trueToNonValued) != null ? _c : false;
  return {
    name: "@unocss/preset-attributify/extractor",
    extract({ code }) {
      return Array.from(code.matchAll(elementRE2)).flatMap((match) => Array.from((match[1] || "").matchAll(valuedAttributeRE2))).flatMap(([, name2, ...contents3]) => {
        const content = contents3.filter(Boolean).join("");
        if (ignoreAttributes.includes(name2))
          return [];
        for (const prefix of strippedPrefixes) {
          if (name2.startsWith(prefix)) {
            name2 = name2.slice(prefix.length);
            break;
          }
        }
        if (!content) {
          if (isValidSelector(name2) && nonValuedAttribute !== false) {
            const result = [`[${name2}=""]`];
            if (trueToNonValued)
              result.push(`[${name2}="true"]`);
            return result;
          }
          return [];
        }
        if (["class", "className"].includes(name2)) {
          return content.split(splitterRE2).filter(isValidSelector);
        } else if (elementRE2.test(content)) {
          elementRE2.lastIndex = 0;
          return this.extract({ code: content });
        } else {
          if ((options == null ? void 0 : options.prefixedOnly) && options.prefix && !name2.startsWith(options.prefix))
            return [];
          return content.split(splitterRE2).filter((v) => Boolean(v) && v !== ":").map((v) => `[${name2}~="${v}"]`);
        }
      });
    }
  };
}

// ../../packages-presets/preset-attributify/src/index.ts
var presetAttributify = definePreset((options = {}) => {
  var _a3, _b2, _c, _d, _e;
  options.strict = (_a3 = options.strict) != null ? _a3 : false;
  options.prefix = (_b2 = options.prefix) != null ? _b2 : "un-";
  options.prefixedOnly = (_c = options.prefixedOnly) != null ? _c : false;
  options.nonValuedAttribute = (_d = options.nonValuedAttribute) != null ? _d : true;
  options.ignoreAttributes = (_e = options.ignoreAttributes) != null ? _e : defaultIgnoreAttributes;
  const variants4 = [
    variantAttributify(options)
  ];
  const extractors = [
    extractorAttributify(options)
  ];
  const autocompleteExtractors = [
    autocompleteExtractorAttributify(options)
  ];
  return {
    name: "@unocss/preset-attributify",
    enforce: "post",
    variants: variants4,
    extractors,
    options,
    autocomplete: {
      extractors: autocompleteExtractors
    },
    extractorDefault: options.strict ? false : void 0
  };
});
var src_default3 = presetAttributify;

// ../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/svg/url.mjs
function encodeSVGforURL(svg) {
  return svg.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}

// ../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/svg/encode-svg-for-css.mjs
function encodeSvgForCss(svg) {
  let useSvg = svg.startsWith("<svg>") ? svg.replace("<svg>", "<svg >") : svg;
  if (!useSvg.includes(" xmlns:xlink=") && useSvg.includes(" xlink:")) {
    useSvg = useSvg.replace(
      "<svg ",
      '<svg xmlns:xlink="http://www.w3.org/1999/xlink" '
    );
  }
  if (!useSvg.includes(" xmlns=")) {
    useSvg = useSvg.replace(
      "<svg ",
      '<svg xmlns="http://www.w3.org/2000/svg" '
    );
  }
  return encodeSVGforURL(useSvg);
}

// ../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/index.mjs
var import_debug = _chunk42PBKAQTcjs.__toESM.call(void 0, _chunkTR37ZOITcjs.require_src.call(void 0, ), 1);

// ../../packages-presets/preset-icons/src/collections.json
var collections_default = ["academicons", "akar-icons", "ant-design", "arcticons", "aws", "basil", "bi", "bitcoin-icons", "bpmn", "brandico", "bubbles", "bx", "bxl", "bxs", "bytesize", "carbon", "catppuccin", "cbi", "charm", "ci", "cib", "cif", "cil", "circle-flags", "circum", "clarity", "codex", "codicon", "covid", "cryptocurrency-color", "cryptocurrency", "cuida", "dashicons", "devicon-line", "devicon-original", "devicon-plain", "devicon", "duo-icons", "ei", "el", "emblemicons", "emojione-monotone", "emojione-v1", "emojione", "entypo-social", "entypo", "eos-icons", "ep", "et", "eva", "f7", "fa-brands", "fa-regular", "fa-solid", "fa", "fa6-brands", "fa6-regular", "fa6-solid", "fad", "famicons", "fe", "feather", "file-icons", "flag", "flagpack", "flat-color-icons", "flat-ui", "flowbite", "fluent-color", "fluent-emoji-flat", "fluent-emoji-high-contrast", "fluent-emoji", "fluent-mdl2", "fluent", "fontelico", "fontisto", "formkit", "foundation", "fxemoji", "gala", "game-icons", "garden", "geo", "gg", "gis", "gravity-ui", "gridicons", "grommet-icons", "guidance", "healthicons", "heroicons-outline", "heroicons-solid", "heroicons", "hugeicons", "humbleicons", "ic", "icomoon-free", "icon-park-outline", "icon-park-solid", "icon-park-twotone", "icon-park", "iconamoon", "iconoir", "icons8", "il", "ion", "iwwa", "ix", "jam", "la", "lets-icons", "line-md", "lineicons", "logos", "ls", "lsicon", "lucide-lab", "lucide", "mage", "majesticons", "maki", "map", "marketeq", "material-symbols-light", "material-symbols", "mdi-light", "mdi", "medical-icon", "memory", "meteocons", "meteor-icons", "mi", "mingcute", "mono-icons", "mynaui", "nimbus", "nonicons", "noto-v1", "noto", "nrk", "octicon", "oi", "ooui", "openmoji", "oui", "pajamas", "pepicons-pencil", "pepicons-pop", "pepicons-print", "pepicons", "ph", "pixelarticons", "prime", "proicons", "ps", "qlementine-icons", "quill", "radix-icons", "raphael", "ri", "rivet-icons", "si-glyph", "si", "simple-icons", "simple-line-icons", "skill-icons", "solar", "stash", "streamline-emojis", "streamline", "subway", "svg-spinners", "system-uicons", "tabler", "tdesign", "teenyicons", "token-branded", "token", "topcoat", "twemoji", "typcn", "uil", "uim", "uis", "uit", "uiw", "unjs", "vaadin", "vs", "vscode-icons", "websymbol", "weui", "whh", "wi", "wpf", "zmdi", "zondicons"];

// ../../packages-presets/preset-icons/src/core.ts
var COLLECTION_NAME_PARTS_MAX = 3;
function createPresetIcons(lookupIconLoader) {
  return definePreset((options = {}) => {
    const {
      scale = 1,
      mode = "auto",
      prefix = "i-",
      warn = false,
      iconifyCollectionsNames,
      collections: customCollections,
      extraProperties = {},
      customizations = {},
      autoInstall = false,
      collectionsNodeResolvePath,
      layer = "icons",
      unit,
      processor
    } = options;
    const flags = getEnvFlags();
    const loaderOptions = {
      addXmlNs: true,
      scale,
      customCollections,
      autoInstall,
      cwd: collectionsNodeResolvePath,
      // avoid warn from @iconify/loader: we'll warn below if not found
      warn: void 0,
      customizations: {
        ...customizations,
        additionalProps: { ...extraProperties },
        trimCustomSvg: true,
        async iconCustomizer(collection, icon, props) {
          var _a3;
          await ((_a3 = customizations.iconCustomizer) == null ? void 0 : _a3.call(customizations, collection, icon, props));
          if (unit) {
            if (!props.width)
              props.width = `${scale}${unit}`;
            if (!props.height)
              props.height = `${scale}${unit}`;
          }
        }
      }
    };
    let iconLoader;
    return {
      name: "@unocss/preset-icons",
      enforce: "pre",
      options,
      layers: { icons: -30 },
      api: {
        encodeSvgForCss,
        parseIconWithLoader
      },
      rules: [[
        /^([\w:-]+)(?:\?(mask|bg|auto))?$/,
        async (matcher) => {
          let [full, body, _mode = mode] = matcher;
          iconLoader = iconLoader || await lookupIconLoader(options);
          const usedProps = {};
          const parsed = await parseIconWithLoader(
            body,
            iconLoader,
            { ...loaderOptions, usedProps },
            iconifyCollectionsNames
          );
          if (!parsed) {
            if (warn && !flags.isESLint)
              warnOnce(`failed to load icon "${full}"`);
            return;
          }
          let cssObject;
          const url = `url("data:image/svg+xml;utf8,${encodeSvgForCss(parsed.svg)}")`;
          if (_mode === "auto")
            _mode = parsed.svg.includes("currentColor") ? "mask" : "bg";
          if (_mode === "mask") {
            cssObject = {
              "--un-icon": url,
              "-webkit-mask": "var(--un-icon) no-repeat",
              "mask": "var(--un-icon) no-repeat",
              "-webkit-mask-size": "100% 100%",
              "mask-size": "100% 100%",
              "background-color": "currentColor",
              // for Safari https://github.com/elk-zone/elk/pull/264
              "color": "inherit",
              ...usedProps
            };
          } else {
            cssObject = {
              "background": `${url} no-repeat`,
              "background-size": "100% 100%",
              "background-color": "transparent",
              ...usedProps
            };
          }
          processor == null ? void 0 : processor(cssObject, {
            ...parsed,
            icon: parsed.name,
            mode: _mode
          });
          return cssObject;
        },
        { layer, prefix }
      ]]
    };
  });
}
function combineLoaders(loaders) {
  return async (...args) => {
    for (const loader of loaders) {
      if (!loader)
        continue;
      const result = await loader(...args);
      if (result)
        return result;
    }
  };
}
function createCDNFetchLoader(fetcher, cdnBase) {
  const cache2 = /* @__PURE__ */ new Map();
  function fetchCollection(name2) {
    if (!collections_default.includes(name2))
      return void 0;
    if (!cache2.has(name2))
      cache2.set(name2, fetcher(`${cdnBase}@iconify-json/${name2}/icons.json`));
    return cache2.get(name2);
  }
  return async (collection, icon, options) => {
    let result = await _chunkTR37ZOITcjs.loadIcon.call(void 0, collection, icon, options);
    if (result)
      return result;
    const iconSet = await fetchCollection(collection);
    if (iconSet) {
      const ids = [
        icon,
        icon.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
        icon.replace(/([a-z])(\d+)/g, "$1-$2")
      ];
      result = await _chunkTR37ZOITcjs.searchForIcon.call(void 0, iconSet, collection, ids, options);
    }
    return result;
  };
}
function getEnvFlags() {
  const isNode2 = typeof process !== "undefined" && process.stdout && !process.versions.deno;
  const isVSCode = isNode2 && !!process.env.VSCODE_CWD;
  const isESLint = isNode2 && !!process.env.ESLINT;
  return {
    isNode: isNode2,
    isVSCode,
    isESLint
  };
}
async function parseIconWithLoader(body, loader, options = {}, safeCollectionsNames = []) {
  let collection = "";
  let name2 = "";
  let svg;
  const allCollections = /* @__PURE__ */ new Set([
    ...collections_default,
    ...safeCollectionsNames,
    ...Object.keys(options.customCollections || {})
  ]);
  if (body.includes(":")) {
    [collection, name2] = body.split(":");
    if (!allCollections.has(collection))
      return;
    svg = await loader(collection, name2, options);
  } else {
    const parts = body.split(/-/g);
    for (let i = COLLECTION_NAME_PARTS_MAX; i >= 1; i--) {
      collection = parts.slice(0, i).join("-");
      if (!allCollections.has(collection))
        continue;
      name2 = parts.slice(i).join("-");
      svg = await loader(collection, name2, options);
      if (svg)
        break;
    }
  }
  if (!svg) {
    return;
  }
  return {
    collection,
    name: name2,
    svg
  };
}

// ../../packages-presets/preset-icons/src/cdn.ts
function createCDNLoader(cdnBase) {
  return createCDNFetchLoader(_chunkYAHR3ES4cjs.$fetch, cdnBase);
}

// ../../packages-presets/preset-icons/src/index.ts
var _factory = /* @__PURE__ */ createPresetIcons(async (options) => {
  const {
    cdn
  } = options;
  const loaders = [];
  const {
    isNode: isNode2,
    isVSCode,
    isESLint
  } = getEnvFlags();
  if (isNode2 && !isVSCode && !isESLint) {
    const nodeLoader = await createNodeLoader();
    if (nodeLoader !== void 0)
      loaders.push(nodeLoader);
  }
  if (cdn)
    loaders.push(createCDNLoader(cdn));
  loaders.push(_chunkTR37ZOITcjs.loadIcon);
  return combineLoaders(loaders);
});
var presetIcons = /* @__PURE__ */ definePreset((options = {}) => {
  const preset = _factory(options);
  const api = preset.api;
  api.createNodeLoader = createNodeLoader;
  return preset;
});
async function createNodeLoader() {
  try {
    return await Promise.resolve().then(() => _interopRequireWildcard(require("./node-loader-DXWKJLWC.cjs"))).then((i) => i == null ? void 0 : i.loadNodeIcon);
  } catch (e2) {
  }
  try {
    return require_node_loader().loadNodeIcon;
  } catch (e2) {
  }
}
var src_default4 = presetIcons;

// ../../packages-presets/preset-tagify/src/extractor.ts
var MARKER = "__TAGIFY__";
var htmlTagRE = /<([\w:-]+)/g;
function extractorTagify(options) {
  const {
    prefix = "",
    excludedTags = ["b", /^h\d+$/, "table"]
  } = options;
  return {
    name: "tagify",
    extract({ code }) {
      return Array.from(code.matchAll(htmlTagRE)).filter(({ 1: match }) => {
        for (const exclude of excludedTags) {
          if (typeof exclude === "string") {
            if (match === exclude)
              return false;
          } else {
            if (exclude.test(match))
              return false;
          }
        }
        return match.startsWith(prefix);
      }).map(([, matched]) => `${MARKER}${matched}`);
    }
  };
}

// ../../packages-presets/preset-tagify/src/variant.ts
function variantTagify(options) {
  var _a3;
  const { extraProperties } = options;
  const prefix = `${MARKER}${(_a3 = options.prefix) != null ? _a3 : ""}`;
  return {
    name: "tagify",
    match(input) {
      if (!input.startsWith(prefix))
        return;
      const matcher = input.slice(prefix.length);
      const handler3 = {
        matcher,
        selector: (i) => i.slice(MARKER.length + 1)
      };
      if (extraProperties) {
        if (typeof extraProperties === "function")
          handler3.body = (entries) => {
            var _a4;
            return [...entries, ...Object.entries((_a4 = extraProperties(matcher)) != null ? _a4 : {})];
          };
        else
          handler3.body = (entries) => [...entries, ...Object.entries(extraProperties)];
      }
      return handler3;
    }
  };
}

// ../../packages-presets/preset-tagify/src/index.ts
var presetTagify = definePreset((options = {}) => {
  const {
    defaultExtractor = true
  } = options;
  const variants4 = [
    variantTagify(options)
  ];
  const extractors = [
    extractorTagify(options)
  ];
  return {
    name: "@unocss/preset-tagify",
    variants: variants4,
    extractors,
    extractorDefault: defaultExtractor ? void 0 : false
  };
});
var src_default5 = presetTagify;

// ../../packages-presets/preset-typography/src/preflights/default.ts
function DEFAULT(theme4) {
  var _a3;
  return {
    "h1,h2,h3,h4,h5,h6": {
      "color": "var(--un-prose-headings)",
      "font-weight": "600",
      "line-height": 1.25
    },
    "a": {
      "color": "var(--un-prose-links)",
      "text-decoration": "underline",
      "font-weight": "500"
    },
    "a code": {
      color: "var(--un-prose-links)"
    },
    "p,ul,ol,pre": {
      "margin": "1em 0",
      "line-height": 1.75
    },
    "blockquote": {
      "margin": "1em 0",
      "padding-left": "1em",
      "font-style": "italic",
      "border-left": ".25em solid var(--un-prose-borders)"
    },
    // taking 16px as a base, we scale h1, h2, h3, and h4 like
    // 16 (base) > 18 (h4) > 22 (h3) > 28 (h2) > 36 (h1)
    "h1": {
      "margin": "1rem 0",
      // h1 is always at the top of the page, so only margin 1 * root font size
      "font-size": "2.25em"
    },
    "h2": {
      "margin": "1.75em 0 .5em",
      "font-size": "1.75em"
    },
    "h3": {
      "margin": "1.5em 0 .5em",
      "font-size": "1.375em"
    },
    "h4": {
      "margin": "1em 0",
      "font-size": "1.125em"
    },
    "img,video": {
      "max-width": "100%"
    },
    "figure,picture": {
      margin: "1em 0"
    },
    "figcaption": {
      "color": "var(--un-prose-captions)",
      "font-size": ".875em"
    },
    "code": {
      "color": "var(--un-prose-code)",
      "font-size": ".875em",
      "font-weight": 600,
      "font-family": (_a3 = theme4.fontFamily) == null ? void 0 : _a3.mono
    },
    ":not(pre) > code::before,:not(pre) > code::after": {
      content: '"`"'
    },
    "pre": {
      "padding": "1.25rem 1.5rem",
      "overflow-x": "auto",
      "border-radius": ".375rem"
    },
    "pre,code": {
      "white-space": "pre",
      "word-spacing": "normal",
      "word-break": "normal",
      "word-wrap": "normal",
      "-moz-tab-size": 4,
      "-o-tab-size": 4,
      "tab-size": 4,
      "-webkit-hyphens": "none",
      "-moz-hyphens": "none",
      "hyphens": "none",
      "background": "transparent"
    },
    "pre code": {
      "font-weight": "inherit"
    },
    "ol,ul": {
      "padding-left": "1.25em"
    },
    "ol": {
      "list-style-type": "decimal"
    },
    'ol[type="A"]': {
      "list-style-type": "upper-alpha"
    },
    'ol[type="a"]': {
      "list-style-type": "lower-alpha"
    },
    'ol[type="A" s]': {
      "list-style-type": "upper-alpha"
    },
    'ol[type="a" s]': {
      "list-style-type": "lower-alpha"
    },
    'ol[type="I"]': {
      "list-style-type": "upper-roman"
    },
    'ol[type="i"]': {
      "list-style-type": "lower-roman"
    },
    'ol[type="I" s]': {
      "list-style-type": "upper-roman"
    },
    'ol[type="i" s]': {
      "list-style-type": "lower-roman"
    },
    'ol[type="1"]': {
      "list-style-type": "decimal"
    },
    "ul": {
      "list-style-type": "disc"
    },
    "ol > li::marker,ul > li::marker,summary::marker": {
      color: "var(--un-prose-lists)"
    },
    "hr": {
      margin: "2em 0",
      border: "1px solid var(--un-prose-hr)"
    },
    "table": {
      "display": "block",
      "margin": "1em 0",
      "border-collapse": "collapse",
      "overflow-x": "auto"
    },
    "tr:nth-child(2n)": {
      background: "var(--un-prose-bg-soft)"
    },
    "td,th": {
      border: "1px solid var(--un-prose-borders)",
      padding: ".625em 1em"
    },
    "abbr": {
      cursor: "help"
    },
    "kbd": {
      "color": "var(--un-prose-code)",
      "border": "1px solid",
      "padding": ".25rem .5rem",
      "font-size": ".875em",
      "border-radius": ".25rem"
    },
    "details": {
      margin: "1em 0",
      padding: "1.25rem 1.5rem",
      background: "var(--un-prose-bg-soft)"
    },
    "summary": {
      "cursor": "pointer",
      "font-weight": "600"
    }
  };
}
var modifiers = [
  ["headings", "h1", "h2", "h3", "h4", "h5", "h6", "th"],
  ["h1"],
  ["h2"],
  ["h3"],
  ["h4"],
  ["h5"],
  ["h6"],
  ["p"],
  ["a"],
  ["blockquote"],
  ["figure"],
  ["figcaption"],
  ["strong"],
  ["em"],
  ["kbd"],
  ["code"],
  ["pre"],
  ["ol"],
  ["ul"],
  ["li"],
  ["table"],
  ["thead"],
  ["tr"],
  ["th"],
  ["td"],
  ["img"],
  ["video"],
  ["hr"]
];
function getElements(modifier) {
  for (const [name2, ...selectors] of modifiers) {
    if (name2 === modifier)
      return selectors.length > 0 ? selectors : [name2];
  }
}

// ../../packages-presets/preset-typography/src/preflights/index.ts
function getCSS(options) {
  let css = "";
  const { escapedSelector, selectorName, preflights: preflights2, compatibility, important: important2 } = options;
  const disableNotUtility = (compatibility == null ? void 0 : compatibility.noColonNot) || (compatibility == null ? void 0 : compatibility.noColonWhere);
  for (const selector in preflights2) {
    const cssDeclarationBlock = preflights2[selector];
    const notProseSelector = `:not(:where(.not-${selectorName},.not-${selectorName} *))`;
    const pseudoCSSMatchArray = selector.split(",").map((s) => {
      const match = s.match(/:[():\-\w]+$/g);
      if (match) {
        const matchStr = match[0];
        s = s.replace(matchStr, "");
        return escapedSelector.map((e2) => disableNotUtility ? `${e2} ${s}${matchStr}` : `${e2} :where(${s})${notProseSelector}${matchStr}`).join(",");
      }
      return null;
    }).filter((v) => v);
    if (pseudoCSSMatchArray.length) {
      css += pseudoCSSMatchArray.join(",");
    } else {
      css += escapedSelector.map((e2) => disableNotUtility ? selector.split(",").map((s) => `${e2} ${s}`).join(",") : `${e2} :where(${selector})${notProseSelector}`).join(",");
    }
    css += "{";
    for (const k in cssDeclarationBlock) {
      const v = cssDeclarationBlock[k];
      css += `${k}:${v}${important2 ? " !important" : ""};`;
    }
    css += "}";
  }
  return css;
}
function getPreflights(context, options) {
  const { compatibility, selectorName, important: important2 = false } = options;
  const cssExtend = typeof (options == null ? void 0 : options.cssExtend) === "function" ? options.cssExtend(context.theme) : options == null ? void 0 : options.cssExtend;
  let escapedSelector = Array.from(options.escapedSelectors);
  if (!escapedSelector[escapedSelector.length - 1].startsWith(".") && !(compatibility == null ? void 0 : compatibility.noColonIs))
    escapedSelector = [`:is(${escapedSelector[escapedSelector.length - 1]},.${options.selectorName})`];
  if (typeof important2 === "string") {
    escapedSelector = escapedSelector.map((e2) => !(compatibility == null ? void 0 : compatibility.noColonIs) ? `:is(${important2}) ${e2}` : `${important2} ${e2}`);
  }
  if (cssExtend)
    return getCSS({ escapedSelector, selectorName, preflights: mergeDeep(DEFAULT(context.theme), cssExtend), compatibility, important: important2 === true });
  return getCSS({ escapedSelector, selectorName, preflights: DEFAULT(context.theme), compatibility, important: important2 === true });
}

// ../../packages-presets/preset-typography/src/index.ts
var presetTypography = definePreset((options) => {
  var _a3, _b2;
  if (options == null ? void 0 : options.className)
    console.warn('[unocss:preset-typography] "className" is deprecated. Please use "selectorName" instead.');
  const escapedSelectors = /* @__PURE__ */ new Set();
  const selectorName = (options == null ? void 0 : options.selectorName) || (options == null ? void 0 : options.className) || "prose";
  const selectorNameRE = new RegExp(`^${selectorName}$`);
  const colorsRE = new RegExp(`^${selectorName}-([-\\w]+)$`);
  const invertRE = new RegExp(`^${selectorName}-invert$`);
  const disableNotUtility = ((_a3 = options == null ? void 0 : options.compatibility) == null ? void 0 : _a3.noColonNot) || ((_b2 = options == null ? void 0 : options.compatibility) == null ? void 0 : _b2.noColonWhere);
  return {
    name: "@unocss/preset-typography",
    enforce: "post",
    layers: { typography: -20 },
    rules: [
      [
        selectorNameRE,
        (_, { rawSelector }) => {
          escapedSelectors.add(toEscapedSelector(rawSelector));
          return { "color": "var(--un-prose-body)", "max-width": "65ch" };
        },
        { layer: "typography" }
      ],
      [
        colorsRE,
        ([, color], { theme: theme4 }) => {
          var _a4, _b3;
          const baseColor = (_a4 = theme4.colors) == null ? void 0 : _a4[color];
          if (baseColor == null)
            return;
          const colorObject = typeof baseColor === "object" ? baseColor : {};
          const TagColorMap = {
            "body": 700,
            "headings": 900,
            "links": 900,
            "lists": 400,
            "hr": 200,
            "captions": 500,
            "code": 900,
            "borders": 200,
            "bg-soft": 100,
            // invert colors (dark mode)
            "invert-body": 200,
            "invert-headings": 100,
            "invert-links": 100,
            "invert-lists": 500,
            "invert-hr": 700,
            "invert-captions": 400,
            "invert-code": 100,
            "invert-borders": 700,
            "invert-bg-soft": 800
          };
          const result = {};
          for (const key in TagColorMap) {
            const value = TagColorMap[key];
            const color2 = (_b3 = colorObject[value]) != null ? _b3 : baseColor;
            let hasAlpha = false;
            for (const placeholder of alphaPlaceholders) {
              if (color2.includes(placeholder)) {
                hasAlpha = true;
                result[`--un-prose-${key}-opacity`] = 1;
                result[`--un-prose-${key}`] = color2.replace(placeholder, `var(--un-prose-${key}-opacity)`);
                break;
              }
            }
            if (!hasAlpha)
              result[`--un-prose-${key}`] = color2;
          }
          return result;
        },
        { layer: "typography" }
      ],
      [
        invertRE,
        () => {
          return {
            "--un-prose-body": "var(--un-prose-invert-body)",
            "--un-prose-headings": "var(--un-prose-invert-headings)",
            "--un-prose-links": "var(--un-prose-invert-links)",
            "--un-prose-lists": "var(--un-prose-invert-lists)",
            "--un-prose-hr": "var(--un-prose-invert-hr)",
            "--un-prose-captions": "var(--un-prose-invert-captions)",
            "--un-prose-code": "var(--un-prose-invert-code)",
            "--un-prose-borders": "var(--un-prose-invert-borders)",
            "--un-prose-bg-soft": "var(--un-prose-invert-bg-soft)"
          };
        },
        { layer: "typography" }
      ]
    ],
    variants: [
      {
        name: "typography element modifiers",
        match: (matcher) => {
          var _a4;
          if (matcher.startsWith(`${selectorName}-`)) {
            const modifyRe = new RegExp(`^${selectorName}-(\\w+)[:-].+$`);
            const modifier = (_a4 = matcher.match(modifyRe)) == null ? void 0 : _a4[1];
            if (modifier) {
              const elements = getElements(modifier);
              if (elements == null ? void 0 : elements.length) {
                return {
                  matcher: matcher.slice(selectorName.length + modifier.length + 2),
                  selector: (s) => {
                    const notProseSelector = `:not(:where(.not-${selectorName},.not-${selectorName} *))`;
                    const escapedSelector = disableNotUtility ? elements.map((e2) => `${s} ${e2}`).join(",") : `${s} :is(:where(${elements})${notProseSelector})`;
                    return escapedSelector;
                  }
                };
              }
            }
          }
        }
      }
    ],
    preflights: [
      {
        layer: "typography",
        getCSS: (context) => {
          if (escapedSelectors.size > 0) {
            return getPreflights(context, { escapedSelectors, ...options, selectorName });
          }
        }
      }
    ]
  };
});
var src_default6 = presetTypography;

// ../../packages-presets/preset-web-fonts/src/providers/bunny.ts
function createBunnyFontsProvider(name2, host) {
  return {
    name: name2,
    getImportUrl(fonts3) {
      const fontFamilies = fonts3.map((font) => {
        const { name: name3, weights, italic } = font;
        const formattedName = name3.toLowerCase().replace(/\s/g, "-");
        if (!(weights == null ? void 0 : weights.length))
          return `${formattedName}${italic ? ":i" : ""}`;
        let weightsAsString = weights.map((weight) => weight.toString());
        const weightsHaveItalic = weightsAsString.some((weight) => weight.endsWith("i"));
        if (!weightsHaveItalic && italic)
          weightsAsString = weightsAsString.map((weight) => weight += "i");
        return `${formattedName}:${weightsAsString.join(",")}`;
      });
      return `${host}/css?family=${fontFamilies.join("|")}&display=swap`;
    }
  };
}
var BunnyFontsProvider = createBunnyFontsProvider(
  "bunny",
  "https://fonts.bunny.net"
);

// ../../packages-presets/preset-web-fonts/src/providers/fontshare.ts
var FontshareProvider = createFontshareProvider("fontshare", "https://api.fontshare.com");
function createFontshareProvider(name2, host) {
  return {
    name: name2,
    getImportUrl(fonts3) {
      const strings = fonts3.map((f) => {
        var _a3;
        let name3 = f.name.replace(/\s+/g, "-").toLocaleLowerCase();
        if ((_a3 = f.weights) == null ? void 0 : _a3.length)
          name3 += `@${f.weights.flatMap((w) => f.italic ? Number(w) + 1 : w).sort().join()}`;
        else name3 += `@${f.italic ? 2 : 1}`;
        return `f[]=${name3}`;
      }).join("&");
      return `${host}/v2/css?${strings}&display=swap`;
    }
  };
}

// ../../packages-presets/preset-web-fonts/src/providers/fontsource/index.ts
function createFontSourceProvider(name2, host) {
  const fontsMap = /* @__PURE__ */ new Map();
  const variablesMap = /* @__PURE__ */ new Map();
  return {
    name: name2,
    async getPreflight(fonts3) {
      const list = await Promise.all(fonts3.map(async (font) => {
        var _a3, _b2, _c, _d;
        const css = [];
        const id = font.name.toLowerCase().replace(/\s+/g, "-");
        let metadata = fontsMap.get(id);
        if (!metadata) {
          const url = `https://api.fontsource.org/v1/fonts/${id}`;
          try {
            metadata = await (await Promise.resolve().then(() => _interopRequireWildcard(require("./node-VEZ3Q33M.cjs")))).$fetch(url);
            fontsMap.set(id, metadata);
          } catch (e2) {
            throw new Error(`Failed to fetch font: ${font.name}`);
          }
        }
        const { subsets, weights } = metadata;
        if (metadata.variable) {
          let variableData = variablesMap.get(id);
          const url = `https://api.fontsource.org/v1/variable/${id}`;
          try {
            variableData = await (await Promise.resolve().then(() => _interopRequireWildcard(require("./node-VEZ3Q33M.cjs")))).$fetch(url);
            variablesMap.set(id, variableData);
          } catch (e2) {
            throw new Error(`Failed to fetch font variable: ${font.name}`);
          }
          const mergeAxes = mergeDeep(variableData.axes, (_a3 = font.variable) != null ? _a3 : {});
          for (const subset of subsets) {
            const url2 = `${host}/fontsource/fonts/${metadata.id}:vf@latest/${subset}-${font.italic ? "wght-italic" : "wght-normal"}.woff2`;
            const fontObj = {
              family: `${metadata.family}`,
              display: "swap",
              style: font.italic ? "italic" : "normal",
              weight: 400,
              src: [{
                url: url2,
                format: "woff2-variations"
              }],
              variable: {
                wght: (_b2 = mergeAxes.wght) != null ? _b2 : void 0,
                wdth: (_c = mergeAxes.wdth) != null ? _c : void 0,
                slnt: (_d = mergeAxes.slnt) != null ? _d : void 0
              },
              unicodeRange: metadata.unicodeRange[subset],
              comment: `${metadata.id}-${subset}-wght-normal`
            };
            css.push(generateFontFace(fontObj));
          }
        } else {
          const _weights = font.weights && font.weights.length > 0 ? font.weights : weights;
          for (const subset of subsets) {
            for (const weight of _weights) {
              const url = `${host}/fontsource/fonts/${metadata.id}@latest/${subset}-${weight}-${font.italic ? "italic" : "normal"}`;
              const fontObj = {
                family: metadata.family,
                display: "swap",
                style: font.italic ? "italic" : "normal",
                weight: Number(weight),
                src: [{
                  url: `${url}.woff2`,
                  format: "woff2"
                }],
                unicodeRange: metadata.unicodeRange[subset],
                comment: `${metadata.id}-${subset}-${weight}${font.italic ? "-italic" : "-normal"}`
              };
              css.push(generateFontFace(fontObj));
            }
          }
        }
        return css;
      }));
      return list.flat().join("\n\n");
    }
  };
}
var FontSourceProvider = createFontSourceProvider("fontsource", "https://cdn.jsdelivr.net");
function generateFontFace(font) {
  const {
    family,
    style,
    display,
    weight,
    variable,
    src,
    unicodeRange,
    comment,
    spacer = "\n  "
  } = font;
  const { wght, wdth, slnt } = variable != null ? variable : {};
  let result = "@font-face {";
  result += `${spacer}font-family: '${family}';`;
  result += `${spacer}font-style: ${slnt ? `oblique ${Number(slnt.max) * -1}deg ${Number(slnt.min) * -1}deg` : style};`;
  result += `${spacer}font-display: ${display};`;
  result += `${spacer}font-weight: ${wght ? getVariableWght(wght) : weight};`;
  if (wdth)
    result += `${spacer}font-stretch: ${wdth.min}% ${wdth.max}%;`;
  result += `${spacer}src: ${src.map(({ url, format }) => `url(${url}) format('${format}')`).join(", ")};`;
  if (unicodeRange)
    result += `${spacer}unicode-range: ${unicodeRange};`;
  if (comment)
    result = `/* ${comment} */
${result}`;
  return `${result}
}`;
}
function getVariableWght(axes) {
  if (!axes)
    return "400";
  if (axes.min === axes.max)
    return `${axes.min}`;
  return `${axes.min} ${axes.max}`;
}

// ../../packages-presets/preset-web-fonts/src/providers/google.ts
function createGoogleCompatibleProvider(name2, host) {
  return {
    name: name2,
    getImportUrl(fonts3) {
      const sort = (weights) => {
        const firstW = weights.map((w) => w[0]);
        const lastW = weights.map((w) => w[1]);
        return `${firstW.join(";")};${lastW.join(";")}`;
      };
      const strings = fonts3.map((i) => {
        var _a3;
        let name3 = i.name.replace(/\s+/g, "+");
        if ((_a3 = i.weights) == null ? void 0 : _a3.length) {
          name3 += i.italic ? `:ital,wght@${sort(i.weights.map((w) => [`0,${w}`, `1,${w}`]))}` : `:wght@${i.weights.join(";")}`;
        }
        return `family=${name3}`;
      }).join("&");
      return `${host}/css2?${strings}&display=swap`;
    }
  };
}
var GoogleFontsProvider = createGoogleCompatibleProvider("google", "https://fonts.googleapis.com");

// ../../packages-presets/preset-web-fonts/src/providers/none.ts
var NoneProvider = {
  name: "none",
  getPreflight() {
    return "";
  },
  getFontName(font) {
    return font.name;
  }
};

// ../../packages-presets/preset-web-fonts/src/preset.ts
var builtinProviders = {
  google: GoogleFontsProvider,
  bunny: BunnyFontsProvider,
  fontshare: FontshareProvider,
  fontsource: FontSourceProvider,
  none: NoneProvider
};
function resolveProvider(provider) {
  if (typeof provider === "string")
    return builtinProviders[provider];
  return provider;
}
function normalizedFontMeta(meta, defaultProvider) {
  if (typeof meta !== "string") {
    meta.provider = resolveProvider(meta.provider || defaultProvider);
    if (meta.weights)
      meta.weights = [...new Set(meta.weights.sort((a, b) => a.toString().localeCompare(b.toString(), "en", { numeric: true })))];
    return meta;
  }
  const [name2, weights = ""] = meta.split(":");
  return {
    name: name2,
    weights: [...new Set(weights.split(/[,;]\s*/).filter(Boolean).sort((a, b) => a.localeCompare(b, "en", { numeric: true })))],
    provider: resolveProvider(defaultProvider)
  };
}
function createWebFontPreset(fetcher) {
  return (options = {}) => {
    const {
      provider: defaultProvider = "google",
      extendTheme = true,
      inlineImports = true,
      themeKey = "fontFamily",
      customFetch = fetcher,
      timeouts = {}
    } = options;
    const processors = toArray2(options.processors || []);
    const fontObject = Object.fromEntries(
      Object.entries(options.fonts || {}).map(([name2, meta]) => [name2, toArray2(meta).map((m) => normalizedFontMeta(m, defaultProvider))])
    );
    const fonts3 = Object.values(fontObject).flatMap((i) => i);
    const importCache = {};
    async function fetchWithTimeout(url) {
      if (timeouts === false)
        return customFetch(url);
      const {
        warning = 1e3,
        failure = 2e3
      } = timeouts;
      let warned4 = false;
      const timer = setTimeout(() => {
        console.warn(`[unocss] Fetching web fonts: ${url}`);
        warned4 = true;
      }, warning);
      return await Promise.race([
        customFetch(url),
        new Promise((_, reject) => {
          setTimeout(() => reject(new Error(`[unocss] Fetch web fonts timeout.`)), failure);
        })
      ]).then((res) => {
        if (warned4)
          console.info(`[unocss] Web fonts fetched.`);
        return res;
      }).finally(() => clearTimeout(timer));
    }
    async function importUrl(url) {
      if (inlineImports) {
        if (!importCache[url]) {
          importCache[url] = fetchWithTimeout(url).catch((e2) => {
            console.error(`[unocss] Failed to fetch web fonts: ${url}`);
            console.error(e2);
            if (typeof process !== "undefined" && process.env.CI)
              throw e2;
          });
        }
        return await importCache[url];
      } else {
        return `@import url('${url}');`;
      }
    }
    const enabledProviders = Array.from(new Set(fonts3.map((i) => i.provider)));
    async function getCSSDefault(fonts4, providers) {
      var _a3;
      const preflights2 = [];
      for (const provider of providers) {
        const fontsForProvider = fonts4.filter((i) => i.provider.name === provider.name);
        if (provider.getImportUrl) {
          const url = provider.getImportUrl(fontsForProvider);
          if (url)
            preflights2.push(await importUrl(url));
        }
        preflights2.push(await ((_a3 = provider.getPreflight) == null ? void 0 : _a3.call(provider, fontsForProvider)));
      }
      const css = preflights2.filter(Boolean).join("\n");
      return css;
    }
    const preset = {
      name: "@unocss/preset-web-fonts",
      preflights: [
        {
          async getCSS() {
            var _a3, _b2;
            let css;
            for (const processor of processors) {
              const result = await ((_a3 = processor.getCSS) == null ? void 0 : _a3.call(processor, fonts3, enabledProviders, getCSSDefault));
              if (result) {
                css = result;
                break;
              }
            }
            if (!css) {
              css = await getCSSDefault(
                fonts3,
                enabledProviders
              );
            }
            for (const processor of processors)
              css = await ((_b2 = processor.transformCSS) == null ? void 0 : _b2.call(processor, css)) || css;
            return css;
          },
          layer: inlineImports ? void 0 : LAYER_IMPORTS
        }
      ]
    };
    if (extendTheme) {
      preset.extendTheme = (theme4) => {
        if (!theme4[themeKey])
          theme4[themeKey] = {};
        const obj = Object.fromEntries(
          Object.entries(fontObject).map(([name2, fonts4]) => [name2, fonts4.map((f) => {
            var _a3, _b2, _c;
            return (_c = (_b2 = (_a3 = f.provider).getFontName) == null ? void 0 : _b2.call(_a3, f)) != null ? _c : `"${f.name}"`;
          })])
        );
        for (const key of Object.keys(obj)) {
          if (typeof theme4[themeKey][key] === "string")
            theme4[themeKey][key] = obj[key].map((i) => `${i},`).join("") + theme4[themeKey][key];
          else
            theme4[themeKey][key] = obj[key].join(",");
        }
      };
    }
    return preset;
  };
}

// ../../packages-presets/preset-web-fonts/src/index.ts
var userAgentWoff2 = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36";
var defaultFetch = async (url) => (await Promise.resolve().then(() => _interopRequireWildcard(require("./node-VEZ3Q33M.cjs")))).$fetch(url, { headers: { "User-Agent": userAgentWoff2 }, retry: 3 });
var presetWebFonts = definePreset(createWebFontPreset(defaultFetch));
var src_default7 = presetWebFonts;

// ../../packages-deprecated/preset-wind/src/index.ts
var presetWind = definePreset((options = {}) => {
  const wind = presetWind3(options);
  return {
    ...wind,
    name: "@unocss/preset-wind"
  };
});
var src_default8 = presetWind;

// ../nuxt/src/options.ts
function resolveOptions(options) {
  var _a3, _b2, _c, _d, _e;
  if (options.presets == null) {
    options.presets = [];
    const presetMap = {
      uno: src_default2,
      attributify: src_default3,
      tagify: src_default5,
      icons: src_default4,
      webFonts: src_default7,
      typography: src_default6,
      wind: src_default8
    };
    for (const [key, preset] of Object.entries(presetMap)) {
      const option = options[key];
      if (option)
        options.presets.push(preset(typeof option === "boolean" ? {} : option));
    }
  }
  (_a3 = options.content) != null ? _a3 : options.content = {};
  (_c = (_b2 = options.content).pipeline) != null ? _c : _b2.pipeline = {};
  if (options.content.pipeline !== false) {
    (_e = (_d = options.content.pipeline).exclude) != null ? _e : _d.exclude = defaultPipelineExclude;
    if (Array.isArray(options.content.pipeline.exclude))
      options.content.pipeline.exclude.push(/\?macro=true/);
  }
}

// src/annotation.ts



// ../../virtual-shared/integration/src/match-positions.ts
async function isPug(uno, code, id = "") {
  var _a3, _b2;
  const pugExtractor = (_a3 = uno.config.extractors) == null ? void 0 : _a3.find((e2) => e2.name === "pug");
  if (!pugExtractor)
    return { pug: false, code: "" };
  const ctx = { code, id };
  await ((_b2 = pugExtractor.extract) == null ? void 0 : _b2.call(pugExtractor, ctx));
  const extractResult = ctx.code.startsWith(code) ? ctx.code.substring(code.length + 2) : ctx.code;
  return ctx.code !== code ? { pug: true, code: extractResult } : { pug: false, code: "" };
}
function getPlainClassMatchedPositionsForPug(codeSplit, matchedPlain, start) {
  const result = [];
  matchedPlain.forEach((plainClassName) => {
    if (plainClassName.includes(":")) {
      if (plainClassName === codeSplit)
        result.push([start, start + plainClassName.length, plainClassName]);
    } else {
      const regex = new RegExp(`.(${plainClassName})[.#=s(]|.(${plainClassName})$`);
      const match = regex.exec(codeSplit);
      if (match) {
        result.push([start + match.index + 1, start + match.index + plainClassName.length + 1, plainClassName]);
      } else {
        if (plainClassName === codeSplit)
          result.push([start, start + plainClassName.length, plainClassName]);
      }
    }
  });
  return result;
}
function getMatchedPositions(code, matched, extraAnnotations = [], options = {}) {
  const result = [];
  const attributify = [];
  const plain = /* @__PURE__ */ new Set();
  const includeRanges = [];
  if (options.excludeRegex) {
    for (const regex of options.excludeRegex) {
      for (const match of code.matchAll(regex)) {
        const content = match[0];
        code = code.slice(0, match.index) + " ".repeat(content.length) + code.slice(match.index + content.length);
      }
    }
  }
  if (options.includeRegex) {
    for (const regex of options.includeRegex) {
      for (const match of code.matchAll(regex))
        includeRanges.push([match.index, match.index + match[0].length]);
    }
  } else {
    includeRanges.push([0, code.length]);
  }
  Array.from(matched).forEach((v) => {
    const match = isAttributifySelector(v);
    if (!match) {
      highlightLessGreaterThanSign(v);
      plain.add(v);
    } else if (!match[2]) {
      highlightLessGreaterThanSign(match[1]);
      plain.add(match[1]);
    } else {
      attributify.push(match);
    }
  });
  function highlightLessGreaterThanSign(str) {
    if (/[><]/.test(str)) {
      for (const match of code.matchAll(new RegExp(escapeRegExp(str), "g"))) {
        const start2 = match.index;
        const end = start2 + match[0].length;
        result.push([start2, end, match[0]]);
      }
    }
  }
  let start = 0;
  code.split(splitWithVariantGroupRE).forEach((i) => {
    const end = start + i.length;
    if (options.isPug) {
      result.push(...getPlainClassMatchedPositionsForPug(i, plain, start));
    } else {
      if (plain.has(i))
        result.push([start, end, i]);
    }
    start = end;
  });
  for (const match of code.matchAll(quotedArbitraryValuesRE)) {
    const start2 = match.index;
    const end = start2 + match[0].length;
    if (plain.has(match[0]))
      result.push([start2, end, match[0]]);
  }
  for (const match of code.matchAll(arbitraryPropertyRE)) {
    const start2 = match.index;
    const end = start2 + match[0].length;
    if (plain.has(match[0])) {
      const index = result.findIndex(([s, e2]) => s === start2 && e2 === end);
      if (index < 0)
        result.push([start2, end, match[0]]);
    }
  }
  attributify.forEach(([, name2, value]) => {
    const regex = new RegExp(`(${escapeRegExp(name2)}=)(['"])[^\\2]*?${escapeRegExp(value)}[^\\2]*?\\2`, "g");
    Array.from(code.matchAll(regex)).forEach((match) => {
      var _a3, _b2, _c;
      const escaped = match[1];
      const body = match[0].slice(escaped.length);
      let bodyIndex = (_b2 = (_a3 = body.match(`[\\b\\s'"]${escapeRegExp(value)}[\\b\\s'"]`)) == null ? void 0 : _a3.index) != null ? _b2 : -1;
      if (/[\s'"]/.test((_c = body[bodyIndex]) != null ? _c : ""))
        bodyIndex++;
      if (bodyIndex < 0)
        return;
      const start2 = match.index + escaped.length + bodyIndex;
      const end = start2 + value.length;
      result.push([start2, end, `[${name2}="${value}"]`]);
    });
  });
  result.push(...extraAnnotations.map((i) => [i.offset, i.offset + i.length, i.className]));
  return result.filter(([start2, end]) => {
    if (includeRanges.some(([s, e2]) => start2 >= s && end <= e2))
      return true;
    return false;
  }).sort((a, b) => a[0] - b[0]);
}
var ignoreTransformers = [
  "@unocss/transformer-directives",
  "@unocss/transformer-compile-class"
];
async function getMatchedPositionsFromCode(uno, code, id = "", options = {}) {
  var _a3;
  const s = new MagicString(code);
  const tokens = /* @__PURE__ */ new Set();
  const ctx = { uno, tokens };
  const transformers = (_a3 = uno.config.transformers) == null ? void 0 : _a3.filter((i) => !ignoreTransformers.includes(i.name));
  const annotations = [];
  for (const enforce of ["pre", "default", "post"]) {
    for (const i of (transformers == null ? void 0 : transformers.filter((i2) => {
      var _a4;
      return ((_a4 = i2.enforce) != null ? _a4 : "default") === enforce;
    })) || []) {
      const result2 = await i.transform(s, id, ctx);
      const _annotations = result2 == null ? void 0 : result2.highlightAnnotations;
      if (_annotations)
        annotations.push(..._annotations);
    }
  }
  const { pug, code: pugCode } = await isPug(uno, s.toString(), id);
  const result = await uno.generate(pug ? pugCode : s.toString(), { preflights: false });
  return getMatchedPositions(code, [...result.matched], annotations, {
    isPug: pug,
    ...options
  });
}

// src/getMatched.ts

var cache = /* @__PURE__ */ new Map();
function registerDocumentCacheCleaner(loader) {
  loader.ext.subscriptions.push(
    _vscode.workspace.onDidChangeTextDocument((e2) => {
      cache.delete(e2.document.uri.fsPath);
    })
  );
}
function getMatchedPositionsFromDoc(uno, doc, force = false) {
  const id = doc.uri.fsPath;
  if (force)
    cache.delete(id);
  if (cache.has(id))
    return cache.get(id);
  const options = getConfig().strictAnnotationMatch ? {
    includeRegex: defaultIdeMatchInclude,
    excludeRegex: defaultIdeMatchExclude
  } : void 0;
  const result = getMatchedPositionsFromCode(
    uno,
    doc.getText(),
    id,
    options
  );
  cache.set(id, result);
  return result;
}

// src/log.ts

var log = _vscode.window.createOutputChannel("UnoCSS");

// src/utils.ts

var import_parser_postcss = _chunk42PBKAQTcjs.__toESM.call(void 0, require_parser_postcss(), 1);
var import_standalone = _chunk42PBKAQTcjs.__toESM.call(void 0, require_standalone(), 1);
var remUnitRE = /(-?[\d.]+)rem(\s+!important)?;/;
var matchCssVarNameRE = /var\((?<cssVarName>--[^,|)]+)(?:,(?<fallback>[^)]+))?\)/g;
var cssColorRE = /(?:#|0x)(?:[a-f0-9]{3}|[a-f0-9]{6})\b|(?:rgb|hsl)a?\(.*\)/g;
var varFnRE = /var\((--[^,|)]+)(?:,([^)]+))?\)/;
function throttle(func, timeFrame) {
  let lastTime = 0;
  let timer;
  return function(...args) {
    const now = Date.now();
    clearTimeout(timer);
    if (now - lastTime >= timeFrame) {
      lastTime = now;
      return func(...args);
    } else {
      timer = setTimeout(func, timeFrame, ...args);
    }
  };
}
async function getCSS2(uno, utilName) {
  const { css } = await uno.generate(new Set(toArray2(utilName)), { preflights: false, safelist: false });
  return css;
}
function addRemToPxComment(str, remToPixel = 16) {
  if (!str)
    return "";
  if (remToPixel < 1)
    return str;
  let index = 0;
  const output = [];
  while (index < str.length) {
    const rem3 = str.slice(index).match(remUnitRE);
    if (!rem3 || !rem3.index)
      break;
    const px3 = ` /* ${Number.parseFloat(rem3[1]) * remToPixel}px */`;
    const end = index + rem3.index + rem3[0].length;
    output.push(str.slice(index, end));
    output.push(px3);
    index = end;
  }
  output.push(str.slice(index));
  return output.join("");
}
async function getPrettiedCSS(uno, util, remToPxRatio) {
  const result = await uno.generate(new Set(toArray2(util)), { preflights: false, safelist: false });
  const css = addRemToPxComment(result.css, remToPxRatio);
  const prettified = import_standalone.default.format(css, {
    parser: "css",
    plugins: [import_parser_postcss.default]
  });
  return {
    ...result,
    prettified
  };
}
async function getPrettiedMarkdown(uno, util, remToPxRatio) {
  return `\`\`\`css
${(await getPrettiedCSS(uno, util, remToPxRatio)).prettified}
\`\`\``;
}
function getCssVariables(code) {
  var _a3, _b2, _c;
  const regex = /(?<key>--[^\s:]+):(?<value>.+?)[!;]/g;
  const cssVariables4 = /* @__PURE__ */ new Map();
  for (const match of code.matchAll(regex)) {
    const key = (_a3 = match.groups) == null ? void 0 : _a3.key;
    if (key)
      cssVariables4.set(key, (_c = (_b2 = match.groups) == null ? void 0 : _b2.value) != null ? _c : "");
  }
  return cssVariables4;
}
function getColorString(str) {
  var _a3, _b2, _c;
  let colorString = (_a3 = str.match(cssColorRE)) == null ? void 0 : _a3[0];
  if (!colorString)
    return;
  const cssVars = getCssVariables(str);
  for (const match of colorString.matchAll(matchCssVarNameRE)) {
    const matchedString = match[0];
    const cssVarName = (_b2 = match.groups) == null ? void 0 : _b2.cssVarName;
    const fallback = (_c = match.groups) == null ? void 0 : _c.fallback;
    if (cssVarName && cssVars.get(cssVarName)) {
      colorString = colorString.replaceAll(matchedString, () => {
        var _a4, _b3;
        let v = (_a4 = cssVars.get(cssVarName)) != null ? _a4 : matchedString;
        while (v && v.startsWith("var(")) {
          const varName = (_b3 = v.match(varFnRE)) == null ? void 0 : _b3[1];
          if (!varName) {
            v = "";
            break;
          }
          v = cssVars.get(varName) || "";
        }
        return v || "1";
      });
    } else if (fallback) {
      colorString = colorString.replaceAll(matchedString, fallback);
    }
    colorString = colorString.replaceAll(/,?\s+var\(--.*?\)/g, "");
  }
  if (/\/\)/.test(colorString))
    colorString = colorString.replace(/ \/\)/g, "/ 1)");
  return convertToRGBA(colorString);
}
function isSubdir(parent, child) {
  const relative = _path3.default.relative(parent, child);
  return relative && !relative.startsWith("..") && !_path3.default.isAbsolute(relative);
}
var reRgbFn = /rgb\((\d+)\s+(\d+)\s+(\d+)\s*\/\s*([\d.]+)\)/;
function convertToRGBA(rgbColor) {
  const match = rgbColor.match(reRgbFn);
  if (match) {
    const r = Number.parseInt(match[1].trim());
    const g = Number.parseInt(match[2].trim());
    const b = Number.parseInt(match[3].trim());
    const alpha = Number.parseFloat(match[4].trim());
    const rgbaColor = `rgba(${r}, ${g}, ${b}, ${alpha})`;
    return rgbaColor;
  }
  return rgbColor;
}
var styleTagsRe = /<style[^>]*>[\s\S]*?<\/style>/g;
function shouldProvideAutocomplete(code, id, offset) {
  const isSfcLike = id.match(/\.(svelte|vue|astro)$/);
  const isInStyleTag = isSfcLike ? [...code.matchAll(styleTagsRe)].map((v) => [v.index, v.index + v[0].length]).some(([start, end]) => offset > start && offset < end) : true;
  if (isInStyleTag)
    return true;
  const codeStripStrings = code.slice(offset).replace(/"[^"]*"|\{[^}]*\}|'[^']*'/g, "");
  const isInStartTag = /^[^<>]*>/.test(codeStripStrings);
  return isInStartTag;
}

// src/annotation.ts
async function registerAnnotations(loader) {
  const config = getConfig();
  const disposals = [];
  disposals.push(
    config.watchChanged(
      ["underline", "colorPreview", "remToPxPreview", "remToPxRatio"],
      () => {
        updateAnnotation();
      }
    )
  );
  disposals.push(_vscode.workspace.onDidSaveTextDocument(async (doc) => {
    var _a3;
    const id = doc.uri.fsPath;
    const dir = _path3.default.dirname(id);
    if (loader.contextsMap.has(dir)) {
      const ctx = loader.contextsMap.get(dir);
      if (!ctx.getConfigFileList().includes(id))
        return;
      try {
        await ctx.reloadConfig();
        log.appendLine(`\u{1F6E0} Config reloaded by ${_path3.default.relative(loader.cwd, doc.uri.fsPath)}`);
      } catch (e2) {
        log.appendLine("\u26A0\uFE0F Error on loading config");
        log.appendLine(String((_a3 = e2.stack) != null ? _a3 : e2));
      }
    }
  }));
  const UnderlineDecoration = _vscode.window.createTextEditorDecorationType({
    textDecoration: "none; border-bottom: 1px dashed currentColor",
    rangeBehavior: _vscode.DecorationRangeBehavior.ClosedClosed
  });
  const NoneDecoration = _vscode.window.createTextEditorDecorationType({
    textDecoration: "none",
    rangeBehavior: _vscode.DecorationRangeBehavior.ClosedClosed
  });
  const borderRadius3 = config.colorPreviewRadius || "50%";
  const colorDecoration = _vscode.window.createTextEditorDecorationType({
    before: {
      width: "0.9em",
      height: "0.9em",
      contentText: " ",
      border: "1px solid",
      margin: `auto 0.2em auto 0;vertical-align: middle;border-radius: ${borderRadius3};`
    },
    dark: {
      before: {
        borderColor: "#eeeeee50"
      }
    },
    light: {
      before: {
        borderColor: "#00000050"
      }
    }
  });
  async function updateAnnotation(editor = _vscode.window.activeTextEditor) {
    var _a3;
    try {
      const doc = editor == null ? void 0 : editor.document;
      if (!doc)
        return reset(editor);
      const id = doc.uri.fsPath;
      if (!loader.isTarget(id))
        return reset(editor);
      const code = doc.getText();
      if (!code)
        return reset(editor);
      const ctx = await loader.resolveClosestContext(code, id);
      if (!ctx)
        return reset(editor);
      const isTarget = ctx.filter(code, id) || code.includes(INCLUDE_COMMENT_IDE) || loader.configSources.includes(id) || isCssId(id);
      if (!isTarget)
        return reset(editor);
      const result = await ctx.uno.generate(code, { id, preflights: false, minify: true });
      const colorRanges = [];
      const remToPxRatio = config.remToPxPreview ? config.remToPxRatio : -1;
      const positions3 = await getMatchedPositionsFromDoc(ctx.uno, doc);
      const isAttributify = ctx.uno.config.presets.some((i) => i.name === "@unocss/preset-attributify");
      const ranges2 = (await Promise.all(
        positions3.map(async (i) => {
          var _a4;
          try {
            const md = await getPrettiedMarkdown(ctx.uno, isAttributify ? [i[2], `[${i[2]}=""]`] : i[2], remToPxRatio);
            if (config.colorPreview) {
              const color = getColorString(md);
              if (color && !colorRanges.find((r) => r.range.start.isEqual(doc.positionAt(i[0])))) {
                colorRanges.push({
                  range: new (0, _vscode.Range)(doc.positionAt(i[0]), doc.positionAt(i[1])),
                  renderOptions: { before: { backgroundColor: color } }
                });
              }
            }
            return {
              range: new (0, _vscode.Range)(doc.positionAt(i[0]), doc.positionAt(i[1])),
              get hoverMessage() {
                return new (0, _vscode.MarkdownString)(md);
              }
            };
          } catch (e2) {
            log.appendLine(`\u26A0\uFE0F Failed to parse ${i[2]}`);
            log.appendLine(String((_a4 = e2.stack) != null ? _a4 : e2));
            return void 0;
          }
        })
      )).filter(Boolean);
      editor.setDecorations(colorDecoration, colorRanges);
      if (config.underline) {
        editor.setDecorations(NoneDecoration, []);
        editor.setDecorations(UnderlineDecoration, ranges2);
      } else {
        editor.setDecorations(UnderlineDecoration, []);
        editor.setDecorations(NoneDecoration, ranges2);
      }
      loader.status.text = `UnoCSS: ${result.matched.size}`;
      loader.status.tooltip = new (0, _vscode.MarkdownString)(`${result.matched.size} utilities used in this file`);
      loader.status.show();
    } catch (e2) {
      log.appendLine("\u26A0\uFE0F Error on annotation");
      log.appendLine(String((_a3 = e2.stack) != null ? _a3 : e2));
    }
  }
  function reset(editor) {
    editor == null ? void 0 : editor.setDecorations(UnderlineDecoration, []);
    editor == null ? void 0 : editor.setDecorations(NoneDecoration, []);
    editor == null ? void 0 : editor.setDecorations(colorDecoration, []);
    loader.status.hide();
  }
  const throttledUpdateAnnotation = throttle(updateAnnotation, 200);
  disposals.push(_vscode.window.onDidChangeActiveTextEditor(updateAnnotation));
  disposals.push(_vscode.workspace.onDidChangeTextDocument((e2) => {
    var _a3;
    if (e2.document === ((_a3 = _vscode.window.activeTextEditor) == null ? void 0 : _a3.document))
      throttledUpdateAnnotation();
  }));
  loader.events.on("reload", async () => {
    await updateAnnotation();
  });
  loader.events.on("unload", async () => {
    reset(_vscode.window.activeTextEditor);
    disposals.forEach((disposal) => disposal.dispose());
  });
  await updateAnnotation();
}

// ../../node_modules/.pnpm/fzf@0.5.2/node_modules/fzf/dist/fzf.es.js
var normalized = {
  216: "O",
  223: "s",
  248: "o",
  273: "d",
  295: "h",
  305: "i",
  320: "l",
  322: "l",
  359: "t",
  383: "s",
  384: "b",
  385: "B",
  387: "b",
  390: "O",
  392: "c",
  393: "D",
  394: "D",
  396: "d",
  398: "E",
  400: "E",
  402: "f",
  403: "G",
  407: "I",
  409: "k",
  410: "l",
  412: "M",
  413: "N",
  414: "n",
  415: "O",
  421: "p",
  427: "t",
  429: "t",
  430: "T",
  434: "V",
  436: "y",
  438: "z",
  477: "e",
  485: "g",
  544: "N",
  545: "d",
  549: "z",
  564: "l",
  565: "n",
  566: "t",
  567: "j",
  570: "A",
  571: "C",
  572: "c",
  573: "L",
  574: "T",
  575: "s",
  576: "z",
  579: "B",
  580: "U",
  581: "V",
  582: "E",
  583: "e",
  584: "J",
  585: "j",
  586: "Q",
  587: "q",
  588: "R",
  589: "r",
  590: "Y",
  591: "y",
  592: "a",
  593: "a",
  595: "b",
  596: "o",
  597: "c",
  598: "d",
  599: "d",
  600: "e",
  603: "e",
  604: "e",
  605: "e",
  606: "e",
  607: "j",
  608: "g",
  609: "g",
  610: "G",
  613: "h",
  614: "h",
  616: "i",
  618: "I",
  619: "l",
  620: "l",
  621: "l",
  623: "m",
  624: "m",
  625: "m",
  626: "n",
  627: "n",
  628: "N",
  629: "o",
  633: "r",
  634: "r",
  635: "r",
  636: "r",
  637: "r",
  638: "r",
  639: "r",
  640: "R",
  641: "R",
  642: "s",
  647: "t",
  648: "t",
  649: "u",
  651: "v",
  652: "v",
  653: "w",
  654: "y",
  655: "Y",
  656: "z",
  657: "z",
  663: "c",
  665: "B",
  666: "e",
  667: "G",
  668: "H",
  669: "j",
  670: "k",
  671: "L",
  672: "q",
  686: "h",
  867: "a",
  868: "e",
  869: "i",
  870: "o",
  871: "u",
  872: "c",
  873: "d",
  874: "h",
  875: "m",
  876: "r",
  877: "t",
  878: "v",
  879: "x",
  7424: "A",
  7427: "B",
  7428: "C",
  7429: "D",
  7431: "E",
  7432: "e",
  7433: "i",
  7434: "J",
  7435: "K",
  7436: "L",
  7437: "M",
  7438: "N",
  7439: "O",
  7440: "O",
  7441: "o",
  7442: "o",
  7443: "o",
  7446: "o",
  7447: "o",
  7448: "P",
  7449: "R",
  7450: "R",
  7451: "T",
  7452: "U",
  7453: "u",
  7454: "u",
  7455: "m",
  7456: "V",
  7457: "W",
  7458: "Z",
  7522: "i",
  7523: "r",
  7524: "u",
  7525: "v",
  7834: "a",
  7835: "s",
  8305: "i",
  8341: "h",
  8342: "k",
  8343: "l",
  8344: "m",
  8345: "n",
  8346: "p",
  8347: "s",
  8348: "t",
  8580: "c"
};
for (let i = "\u0300".codePointAt(0); i <= "\u036F".codePointAt(0); ++i) {
  const diacritic = String.fromCodePoint(i);
  for (const asciiChar of "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") {
    const withDiacritic = (asciiChar + diacritic).normalize();
    const withDiacriticCodePoint = withDiacritic.codePointAt(0);
    if (withDiacriticCodePoint > 126) {
      normalized[withDiacriticCodePoint] = asciiChar;
    }
  }
}
var ranges = {
  a: [7844, 7863],
  e: [7870, 7879],
  o: [7888, 7907],
  u: [7912, 7921]
};
for (const lowerChar of Object.keys(ranges)) {
  const upperChar = lowerChar.toUpperCase();
  for (let i = ranges[lowerChar][0]; i <= ranges[lowerChar][1]; ++i) {
    normalized[i] = i % 2 === 0 ? upperChar : lowerChar;
  }
}
function normalizeRune(rune) {
  if (rune < 192 || rune > 8580) {
    return rune;
  }
  const normalizedChar = normalized[rune];
  if (normalizedChar !== void 0)
    return normalizedChar.codePointAt(0);
  return rune;
}
function toShort(number3) {
  return number3;
}
function toInt(number3) {
  return number3;
}
function maxInt16(num1, num2) {
  return num1 > num2 ? num1 : num2;
}
var strToRunes = (str) => str.split("").map((s) => s.codePointAt(0));
var whitespaceRunes = new Set(
  " \f\n\r	\v\xA0\u1680\u2028\u2029\u202F\u205F\u3000\uFEFF".split("").map((v) => v.codePointAt(0))
);
for (let codePoint = "\u2000".codePointAt(0); codePoint <= "\u200A".codePointAt(0); codePoint++) {
  whitespaceRunes.add(codePoint);
}
var MAX_ASCII = "\x7F".codePointAt(0);
var CAPITAL_A_RUNE = "A".codePointAt(0);
var CAPITAL_Z_RUNE = "Z".codePointAt(0);
var SMALL_A_RUNE = "a".codePointAt(0);
var SMALL_Z_RUNE = "z".codePointAt(0);
var NUMERAL_ZERO_RUNE = "0".codePointAt(0);
var NUMERAL_NINE_RUNE = "9".codePointAt(0);
function indexAt(index, max, forward) {
  if (forward) {
    return index;
  }
  return max - index - 1;
}
var SCORE_MATCH = 16;
var SCORE_GAP_START = -3;
var SCORE_GAP_EXTENTION = -1;
var BONUS_BOUNDARY = SCORE_MATCH / 2;
var BONUS_NON_WORD = SCORE_MATCH / 2;
var BONUS_CAMEL_123 = BONUS_BOUNDARY + SCORE_GAP_EXTENTION;
var BONUS_CONSECUTIVE = -(SCORE_GAP_START + SCORE_GAP_EXTENTION);
var BONUS_FIRST_CHAR_MULTIPLIER = 2;
function createPosSet(withPos) {
  if (withPos) {
    return /* @__PURE__ */ new Set();
  }
  return null;
}
function alloc16(offset, slab2, size) {
  if (slab2 !== null && slab2.i16.length > offset + size) {
    const subarray = slab2.i16.subarray(offset, offset + size);
    return [offset + size, subarray];
  }
  return [offset, new Int16Array(size)];
}
function alloc32(offset, slab2, size) {
  if (slab2 !== null && slab2.i32.length > offset + size) {
    const subarray = slab2.i32.subarray(offset, offset + size);
    return [offset + size, subarray];
  }
  return [offset, new Int32Array(size)];
}
function charClassOfAscii(rune) {
  if (rune >= SMALL_A_RUNE && rune <= SMALL_Z_RUNE) {
    return 1;
  } else if (rune >= CAPITAL_A_RUNE && rune <= CAPITAL_Z_RUNE) {
    return 2;
  } else if (rune >= NUMERAL_ZERO_RUNE && rune <= NUMERAL_NINE_RUNE) {
    return 4;
  } else {
    return 0;
  }
}
function charClassOfNonAscii(rune) {
  const char = String.fromCodePoint(rune);
  if (char !== char.toUpperCase()) {
    return 1;
  } else if (char !== char.toLowerCase()) {
    return 2;
  } else if (char.match(/\p{Number}/gu) !== null) {
    return 4;
  } else if (char.match(/\p{Letter}/gu) !== null) {
    return 3;
  }
  return 0;
}
function charClassOf(rune) {
  if (rune <= MAX_ASCII) {
    return charClassOfAscii(rune);
  }
  return charClassOfNonAscii(rune);
}
function bonusFor(prevClass, currClass) {
  if (prevClass === 0 && currClass !== 0) {
    return BONUS_BOUNDARY;
  } else if (prevClass === 1 && currClass === 2 || prevClass !== 4 && currClass === 4) {
    return BONUS_CAMEL_123;
  } else if (currClass === 0) {
    return BONUS_NON_WORD;
  }
  return 0;
}
function bonusAt(input, idx) {
  if (idx === 0) {
    return BONUS_BOUNDARY;
  }
  return bonusFor(charClassOf(input[idx - 1]), charClassOf(input[idx]));
}
function trySkip(input, caseSensitive, char, from) {
  let rest = input.slice(from);
  let idx = rest.indexOf(char);
  if (idx === 0) {
    return from;
  }
  if (!caseSensitive && char >= SMALL_A_RUNE && char <= SMALL_Z_RUNE) {
    if (idx > 0) {
      rest = rest.slice(0, idx);
    }
    const uidx = rest.indexOf(char - 32);
    if (uidx >= 0) {
      idx = uidx;
    }
  }
  if (idx < 0) {
    return -1;
  }
  return from + idx;
}
function isAscii(runes) {
  for (const rune of runes) {
    if (rune >= 128) {
      return false;
    }
  }
  return true;
}
function asciiFuzzyIndex(input, pattern, caseSensitive) {
  if (!isAscii(input)) {
    return 0;
  }
  if (!isAscii(pattern)) {
    return -1;
  }
  let firstIdx = 0, idx = 0;
  for (let pidx = 0; pidx < pattern.length; pidx++) {
    idx = trySkip(input, caseSensitive, pattern[pidx], idx);
    if (idx < 0) {
      return -1;
    }
    if (pidx === 0 && idx > 0) {
      firstIdx = idx - 1;
    }
    idx++;
  }
  return firstIdx;
}
var fuzzyMatchV2 = (caseSensitive, normalize, forward, input, pattern, withPos, slab2) => {
  const M = pattern.length;
  if (M === 0) {
    return [{ start: 0, end: 0, score: 0 }, createPosSet(withPos)];
  }
  const N = input.length;
  if (slab2 !== null && N * M > slab2.i16.length) {
    return fuzzyMatchV1(caseSensitive, normalize, forward, input, pattern, withPos);
  }
  const idx = asciiFuzzyIndex(input, pattern, caseSensitive);
  if (idx < 0) {
    return [{ start: -1, end: -1, score: 0 }, null];
  }
  let offset16 = 0, offset32 = 0, H0 = null, C0 = null, B = null, F = null;
  [offset16, H0] = alloc16(offset16, slab2, N);
  [offset16, C0] = alloc16(offset16, slab2, N);
  [offset16, B] = alloc16(offset16, slab2, N);
  [offset32, F] = alloc32(offset32, slab2, M);
  const [, T] = alloc32(offset32, slab2, N);
  for (let i = 0; i < T.length; i++) {
    T[i] = input[i];
  }
  let maxScore = toShort(0), maxScorePos = 0;
  let pidx = 0, lastIdx = 0;
  const pchar0 = pattern[0];
  let pchar = pattern[0], prevH0 = toShort(0), prevCharClass = 0, inGap = false;
  let Tsub = T.subarray(idx);
  let H0sub = H0.subarray(idx).subarray(0, Tsub.length), C0sub = C0.subarray(idx).subarray(0, Tsub.length), Bsub = B.subarray(idx).subarray(0, Tsub.length);
  for (let [off, char] of Tsub.entries()) {
    let charClass = null;
    if (char <= MAX_ASCII) {
      charClass = charClassOfAscii(char);
      if (!caseSensitive && charClass === 2) {
        char += 32;
      }
    } else {
      charClass = charClassOfNonAscii(char);
      if (!caseSensitive && charClass === 2) {
        char = String.fromCodePoint(char).toLowerCase().codePointAt(0);
      }
      if (normalize) {
        char = normalizeRune(char);
      }
    }
    Tsub[off] = char;
    const bonus = bonusFor(prevCharClass, charClass);
    Bsub[off] = bonus;
    prevCharClass = charClass;
    if (char === pchar) {
      if (pidx < M) {
        F[pidx] = toInt(idx + off);
        pidx++;
        pchar = pattern[Math.min(pidx, M - 1)];
      }
      lastIdx = idx + off;
    }
    if (char === pchar0) {
      const score = SCORE_MATCH + bonus * BONUS_FIRST_CHAR_MULTIPLIER;
      H0sub[off] = score;
      C0sub[off] = 1;
      if (M === 1 && (forward && score > maxScore || !forward && score >= maxScore)) {
        maxScore = score;
        maxScorePos = idx + off;
        if (forward && bonus === BONUS_BOUNDARY) {
          break;
        }
      }
      inGap = false;
    } else {
      if (inGap) {
        H0sub[off] = maxInt16(prevH0 + SCORE_GAP_EXTENTION, 0);
      } else {
        H0sub[off] = maxInt16(prevH0 + SCORE_GAP_START, 0);
      }
      C0sub[off] = 0;
      inGap = true;
    }
    prevH0 = H0sub[off];
  }
  if (pidx !== M) {
    return [{ start: -1, end: -1, score: 0 }, null];
  }
  if (M === 1) {
    const result = {
      start: maxScorePos,
      end: maxScorePos + 1,
      score: maxScore
    };
    if (!withPos) {
      return [result, null];
    }
    const pos2 = /* @__PURE__ */ new Set();
    pos2.add(maxScorePos);
    return [result, pos2];
  }
  const f0 = F[0];
  const width3 = lastIdx - f0 + 1;
  let H = null;
  [offset16, H] = alloc16(offset16, slab2, width3 * M);
  {
    const toCopy = H0.subarray(f0, lastIdx + 1);
    for (const [i, v] of toCopy.entries()) {
      H[i] = v;
    }
  }
  let [, C] = alloc16(offset16, slab2, width3 * M);
  {
    const toCopy = C0.subarray(f0, lastIdx + 1);
    for (const [i, v] of toCopy.entries()) {
      C[i] = v;
    }
  }
  const Fsub = F.subarray(1);
  const Psub = pattern.slice(1).slice(0, Fsub.length);
  for (const [off, f] of Fsub.entries()) {
    let inGap2 = false;
    const pchar2 = Psub[off], pidx2 = off + 1, row = pidx2 * width3, Tsub2 = T.subarray(f, lastIdx + 1), Bsub2 = B.subarray(f).subarray(0, Tsub2.length), Csub = C.subarray(row + f - f0).subarray(0, Tsub2.length), Cdiag = C.subarray(row + f - f0 - 1 - width3).subarray(0, Tsub2.length), Hsub = H.subarray(row + f - f0).subarray(0, Tsub2.length), Hdiag = H.subarray(row + f - f0 - 1 - width3).subarray(0, Tsub2.length), Hleft = H.subarray(row + f - f0 - 1).subarray(0, Tsub2.length);
    Hleft[0] = 0;
    for (const [off2, char] of Tsub2.entries()) {
      const col = off2 + f;
      let s1 = 0, s2 = 0, consecutive = 0;
      if (inGap2) {
        s2 = Hleft[off2] + SCORE_GAP_EXTENTION;
      } else {
        s2 = Hleft[off2] + SCORE_GAP_START;
      }
      if (pchar2 === char) {
        s1 = Hdiag[off2] + SCORE_MATCH;
        let b = Bsub2[off2];
        consecutive = Cdiag[off2] + 1;
        if (b === BONUS_BOUNDARY) {
          consecutive = 1;
        } else if (consecutive > 1) {
          b = maxInt16(b, maxInt16(BONUS_CONSECUTIVE, B[col - consecutive + 1]));
        }
        if (s1 + b < s2) {
          s1 += Bsub2[off2];
          consecutive = 0;
        } else {
          s1 += b;
        }
      }
      Csub[off2] = consecutive;
      inGap2 = s1 < s2;
      const score = maxInt16(maxInt16(s1, s2), 0);
      if (pidx2 === M - 1 && (forward && score > maxScore || !forward && score >= maxScore)) {
        maxScore = score;
        maxScorePos = col;
      }
      Hsub[off2] = score;
    }
  }
  const pos = createPosSet(withPos);
  let j = f0;
  if (withPos && pos !== null) {
    let i = M - 1;
    j = maxScorePos;
    let preferMatch = true;
    while (true) {
      const I = i * width3, j0 = j - f0, s = H[I + j0];
      let s1 = 0, s2 = 0;
      if (i > 0 && j >= F[i]) {
        s1 = H[I - width3 + j0 - 1];
      }
      if (j > F[i]) {
        s2 = H[I + j0 - 1];
      }
      if (s > s1 && (s > s2 || s === s2 && preferMatch)) {
        pos.add(j);
        if (i === 0) {
          break;
        }
        i--;
      }
      preferMatch = C[I + j0] > 1 || I + width3 + j0 + 1 < C.length && C[I + width3 + j0 + 1] > 0;
      j--;
    }
  }
  return [{ start: j, end: maxScorePos + 1, score: maxScore }, pos];
};
function calculateScore(caseSensitive, normalize, text, pattern, sidx, eidx, withPos) {
  let pidx = 0, score = 0, inGap = false, consecutive = 0, firstBonus = toShort(0);
  const pos = createPosSet(withPos);
  let prevCharClass = 0;
  if (sidx > 0) {
    prevCharClass = charClassOf(text[sidx - 1]);
  }
  for (let idx = sidx; idx < eidx; idx++) {
    let rune = text[idx];
    const charClass = charClassOf(rune);
    if (!caseSensitive) {
      if (rune >= CAPITAL_A_RUNE && rune <= CAPITAL_Z_RUNE) {
        rune += 32;
      } else if (rune > MAX_ASCII) {
        rune = String.fromCodePoint(rune).toLowerCase().codePointAt(0);
      }
    }
    if (normalize) {
      rune = normalizeRune(rune);
    }
    if (rune === pattern[pidx]) {
      if (withPos && pos !== null) {
        pos.add(idx);
      }
      score += SCORE_MATCH;
      let bonus = bonusFor(prevCharClass, charClass);
      if (consecutive === 0) {
        firstBonus = bonus;
      } else {
        if (bonus === BONUS_BOUNDARY) {
          firstBonus = bonus;
        }
        bonus = maxInt16(maxInt16(bonus, firstBonus), BONUS_CONSECUTIVE);
      }
      if (pidx === 0) {
        score += bonus * BONUS_FIRST_CHAR_MULTIPLIER;
      } else {
        score += bonus;
      }
      inGap = false;
      consecutive++;
      pidx++;
    } else {
      if (inGap) {
        score += SCORE_GAP_EXTENTION;
      } else {
        score += SCORE_GAP_START;
      }
      inGap = true;
      consecutive = 0;
      firstBonus = 0;
    }
    prevCharClass = charClass;
  }
  return [score, pos];
}
var fuzzyMatchV1 = (caseSensitive, normalize, forward, text, pattern, withPos, slab2) => {
  if (pattern.length === 0) {
    return [{ start: 0, end: 0, score: 0 }, null];
  }
  if (asciiFuzzyIndex(text, pattern, caseSensitive) < 0) {
    return [{ start: -1, end: -1, score: 0 }, null];
  }
  let pidx = 0, sidx = -1, eidx = -1;
  const lenRunes = text.length;
  const lenPattern = pattern.length;
  for (let index = 0; index < lenRunes; index++) {
    let rune = text[indexAt(index, lenRunes, forward)];
    if (!caseSensitive) {
      if (rune >= CAPITAL_A_RUNE && rune <= CAPITAL_Z_RUNE) {
        rune += 32;
      } else if (rune > MAX_ASCII) {
        rune = String.fromCodePoint(rune).toLowerCase().codePointAt(0);
      }
    }
    if (normalize) {
      rune = normalizeRune(rune);
    }
    const pchar = pattern[indexAt(pidx, lenPattern, forward)];
    if (rune === pchar) {
      if (sidx < 0) {
        sidx = index;
      }
      pidx++;
      if (pidx === lenPattern) {
        eidx = index + 1;
        break;
      }
    }
  }
  if (sidx >= 0 && eidx >= 0) {
    pidx--;
    for (let index = eidx - 1; index >= sidx; index--) {
      const tidx = indexAt(index, lenRunes, forward);
      let rune = text[tidx];
      if (!caseSensitive) {
        if (rune >= CAPITAL_A_RUNE && rune <= CAPITAL_Z_RUNE) {
          rune += 32;
        } else if (rune > MAX_ASCII) {
          rune = String.fromCodePoint(rune).toLowerCase().codePointAt(0);
        }
      }
      const pidx_ = indexAt(pidx, lenPattern, forward);
      const pchar = pattern[pidx_];
      if (rune === pchar) {
        pidx--;
        if (pidx < 0) {
          sidx = index;
          break;
        }
      }
    }
    if (!forward) {
      const sidxTemp = sidx;
      sidx = lenRunes - eidx;
      eidx = lenRunes - sidxTemp;
    }
    const [score, pos] = calculateScore(
      caseSensitive,
      normalize,
      text,
      pattern,
      sidx,
      eidx,
      withPos
    );
    return [{ start: sidx, end: eidx, score }, pos];
  }
  return [{ start: -1, end: -1, score: 0 }, null];
};
var exactMatchNaive = (caseSensitive, normalize, forward, text, pattern, withPos, slab2) => {
  if (pattern.length === 0) {
    return [{ start: 0, end: 0, score: 0 }, null];
  }
  const lenRunes = text.length;
  const lenPattern = pattern.length;
  if (lenRunes < lenPattern) {
    return [{ start: -1, end: -1, score: 0 }, null];
  }
  if (asciiFuzzyIndex(text, pattern, caseSensitive) < 0) {
    return [{ start: -1, end: -1, score: 0 }, null];
  }
  let pidx = 0;
  let bestPos = -1, bonus = toShort(0), bestBonus = toShort(-1);
  for (let index = 0; index < lenRunes; index++) {
    const index_ = indexAt(index, lenRunes, forward);
    let rune = text[index_];
    if (!caseSensitive) {
      if (rune >= CAPITAL_A_RUNE && rune <= CAPITAL_Z_RUNE) {
        rune += 32;
      } else if (rune > MAX_ASCII) {
        rune = String.fromCodePoint(rune).toLowerCase().codePointAt(0);
      }
    }
    if (normalize) {
      rune = normalizeRune(rune);
    }
    const pidx_ = indexAt(pidx, lenPattern, forward);
    const pchar = pattern[pidx_];
    if (pchar === rune) {
      if (pidx_ === 0) {
        bonus = bonusAt(text, index_);
      }
      pidx++;
      if (pidx === lenPattern) {
        if (bonus > bestBonus) {
          bestPos = index;
          bestBonus = bonus;
        }
        if (bonus === BONUS_BOUNDARY) {
          break;
        }
        index -= pidx - 1;
        pidx = 0;
        bonus = 0;
      }
    } else {
      index -= pidx;
      pidx = 0;
      bonus = 0;
    }
  }
  if (bestPos >= 0) {
    let sidx = 0, eidx = 0;
    if (forward) {
      sidx = bestPos - lenPattern + 1;
      eidx = bestPos + 1;
    } else {
      sidx = lenRunes - (bestPos + 1);
      eidx = lenRunes - (bestPos - lenPattern + 1);
    }
    const [score] = calculateScore(caseSensitive, normalize, text, pattern, sidx, eidx, false);
    return [{ start: sidx, end: eidx, score }, null];
  }
  return [{ start: -1, end: -1, score: 0 }, null];
};
var SLAB_16_SIZE = 100 * 1024;
var SLAB_32_SIZE = 2048;
function makeSlab(size16, size32) {
  return {
    i16: new Int16Array(size16),
    i32: new Int32Array(size32)
  };
}
var slab = makeSlab(SLAB_16_SIZE, SLAB_32_SIZE);
var buildPatternForBasicMatch = (query, casing, normalize) => {
  let caseSensitive = false;
  switch (casing) {
    case "smart-case":
      if (query.toLowerCase() !== query) {
        caseSensitive = true;
      }
      break;
    case "case-sensitive":
      caseSensitive = true;
      break;
    case "case-insensitive":
      query = query.toLowerCase();
      caseSensitive = false;
      break;
  }
  let queryRunes = strToRunes(query);
  if (normalize) {
    queryRunes = queryRunes.map(normalizeRune);
  }
  return {
    queryRunes,
    caseSensitive
  };
};
function getResultFromScoreMap(scoreMap, limit) {
  const scoresInDesc = Object.keys(scoreMap).map((v) => parseInt(v, 10)).sort((a, b) => b - a);
  let result = [];
  for (const score of scoresInDesc) {
    result = result.concat(scoreMap[score]);
    if (result.length >= limit) {
      break;
    }
  }
  return result;
}
function getBasicMatchIter(scoreMap, queryRunes, caseSensitive) {
  return (idx) => {
    const itemRunes = this.runesList[idx];
    if (queryRunes.length > itemRunes.length)
      return;
    let [match, positions3] = this.algoFn(
      caseSensitive,
      this.opts.normalize,
      this.opts.forward,
      itemRunes,
      queryRunes,
      true,
      slab
    );
    if (match.start === -1)
      return;
    if (this.opts.fuzzy === false) {
      positions3 = /* @__PURE__ */ new Set();
      for (let position3 = match.start; position3 < match.end; ++position3) {
        positions3.add(position3);
      }
    }
    const scoreKey = this.opts.sort ? match.score : 0;
    if (scoreMap[scoreKey] === void 0) {
      scoreMap[scoreKey] = [];
    }
    scoreMap[scoreKey].push({
      item: this.items[idx],
      ...match,
      positions: positions3 != null ? positions3 : /* @__PURE__ */ new Set()
    });
  };
}
function basicMatch(query) {
  const { queryRunes, caseSensitive } = buildPatternForBasicMatch(
    query,
    this.opts.casing,
    this.opts.normalize
  );
  const scoreMap = {};
  const iter2 = getBasicMatchIter.bind(this)(
    scoreMap,
    queryRunes,
    caseSensitive
  );
  for (let i = 0, len = this.runesList.length; i < len; ++i) {
    iter2(i);
  }
  return getResultFromScoreMap(scoreMap, this.opts.limit);
}
var isNode = typeof _chunk42PBKAQTcjs.__require !== "undefined" && typeof window === "undefined";
function asyncMatcher(token, len, iter2, onFinish) {
  return new Promise((resolve4, reject) => {
    const INCREMENT = 1e3;
    let i = 0, end = Math.min(INCREMENT, len);
    const step = () => {
      if (token.cancelled)
        return reject("search cancelled");
      for (; i < end; ++i) {
        iter2(i);
      }
      if (end < len) {
        end = Math.min(end + INCREMENT, len);
        isNode ? setImmediate(step) : setTimeout(step);
      } else {
        resolve4(onFinish());
      }
    };
    step();
  });
}
function asyncBasicMatch(query, token) {
  const { queryRunes, caseSensitive } = buildPatternForBasicMatch(
    query,
    this.opts.casing,
    this.opts.normalize
  );
  const scoreMap = {};
  return asyncMatcher(
    token,
    this.runesList.length,
    getBasicMatchIter.bind(this)(scoreMap, queryRunes, caseSensitive),
    () => getResultFromScoreMap(scoreMap, this.opts.limit)
  );
}
var defaultOpts = {
  limit: Infinity,
  selector: (v) => v,
  casing: "smart-case",
  normalize: true,
  fuzzy: "v2",
  tiebreakers: [],
  sort: true,
  forward: true
};
var BaseFinder = class {
  constructor(list, ...optionsTuple) {
    this.opts = { ...defaultOpts, ...optionsTuple[0] };
    this.items = list;
    this.runesList = list.map((item) => strToRunes(this.opts.selector(item).normalize()));
    this.algoFn = exactMatchNaive;
    switch (this.opts.fuzzy) {
      case "v2":
        this.algoFn = fuzzyMatchV2;
        break;
      case "v1":
        this.algoFn = fuzzyMatchV1;
        break;
    }
  }
};
var syncDefaultOpts = {
  ...defaultOpts,
  match: basicMatch
};
var SyncFinder = class extends BaseFinder {
  constructor(list, ...optionsTuple) {
    super(list, ...optionsTuple);
    this.opts = { ...syncDefaultOpts, ...optionsTuple[0] };
  }
  find(query) {
    if (query.length === 0 || this.items.length === 0)
      return this.items.slice(0, this.opts.limit).map(createResultItemWithEmptyPos);
    query = query.normalize();
    let result = this.opts.match.bind(this)(query);
    return postProcessResultItems(result, this.opts);
  }
};
var asyncDefaultOpts = {
  ...defaultOpts,
  match: asyncBasicMatch
};
var createResultItemWithEmptyPos = (item) => ({
  item,
  start: -1,
  end: -1,
  score: 0,
  positions: /* @__PURE__ */ new Set()
});
function postProcessResultItems(result, opts) {
  if (opts.sort) {
    const { selector } = opts;
    result.sort((a, b) => {
      if (a.score === b.score) {
        for (const tiebreaker of opts.tiebreakers) {
          const diff = tiebreaker(a, b, selector);
          if (diff !== 0) {
            return diff;
          }
        }
      }
      return 0;
    });
  }
  if (Number.isFinite(opts.limit)) {
    result.splice(opts.limit);
  }
  return result;
}
function byLengthAsc(a, b, selector) {
  return selector(a.item).length - selector(b.item).length;
}
function byStartAsc(a, b) {
  return a.start - b.start;
}
var Fzf = class {
  constructor(list, ...optionsTuple) {
    this.finder = new SyncFinder(list, ...optionsTuple);
    this.find = this.finder.find.bind(this.finder);
  }
};

// ../../node_modules/.pnpm/lru-cache@11.0.2/node_modules/lru-cache/dist/esm/index.js
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned3 = /* @__PURE__ */ new Set();
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
var _a;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    constructor() {
      _chunk42PBKAQTcjs.__publicField.call(void 0, this, "onabort");
      _chunk42PBKAQTcjs.__publicField.call(void 0, this, "_onabort", []);
      _chunk42PBKAQTcjs.__publicField.call(void 0, this, "reason");
      _chunk42PBKAQTcjs.__publicField.call(void 0, this, "aborted", false);
    }
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController {
    constructor() {
      _chunk42PBKAQTcjs.__publicField.call(void 0, this, "signal", new AS());
      warnACPolyfill();
    }
    abort(reason) {
      var _a3, _b2;
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      (_b2 = (_a3 = this.signal).onabort) == null ? void 0 : _b2.call(_a3, reason);
    }
  };
  let printACPolyfillWarning = ((_a = PROCESS.env) == null ? void 0 : _a.LRU_CACHE_IGNORE_AC_WARNING) !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned3.has(code);
var TYPE = Symbol("type");
var isPosInt = (n2) => n2 && n2 === Math.floor(n2) && n2 > 0 && isFinite(n2);
var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
var ZeroArray = class extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
};
var _constructing;
var _Stack = class _Stack {
  constructor(max, HeapCls) {
    _chunk42PBKAQTcjs.__publicField.call(void 0, this, "heap");
    _chunk42PBKAQTcjs.__publicField.call(void 0, this, "length");
    if (!_chunk42PBKAQTcjs.__privateGet.call(void 0, _Stack, _constructing)) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    _chunk42PBKAQTcjs.__privateSet.call(void 0, _Stack, _constructing, true);
    const s = new _Stack(max, HeapCls);
    _chunk42PBKAQTcjs.__privateSet.call(void 0, _Stack, _constructing, false);
    return s;
  }
  push(n2) {
    this.heap[this.length++] = n2;
  }
  pop() {
    return this.heap[--this.length];
  }
};
_constructing = new WeakMap();
// private constructor
_chunk42PBKAQTcjs.__privateAdd.call(void 0, _Stack, _constructing, false);
var Stack = _Stack;
var _a2, _b, _max, _maxSize, _dispose, _disposeAfter, _fetchMethod, _memoMethod, _size2, _calculatedSize, _keyMap, _keyList, _valList, _next, _prev, _head2, _tail2, _free, _disposed, _sizes, _starts, _ttls, _hasDispose, _hasFetchMethod, _hasDisposeAfter, _LRUCache_instances, initializeTTLTracking_fn, _updateItemAge, _statusTTL, _setItemTTL, _isStale, initializeSizeTracking_fn, _removeItemSize, _addItemSize, _requireSize, indexes_fn, rindexes_fn, isValidIndex_fn, evict_fn, backgroundFetch_fn, isBackgroundFetch_fn, connect_fn, moveToTail_fn, delete_fn, clear_fn;
var _LRUCache = class _LRUCache {
  constructor(options) {
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _LRUCache_instances);
    // options that cannot be changed without disaster
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _max);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _maxSize);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _dispose);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _disposeAfter);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _fetchMethod);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _memoMethod);
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    _chunk42PBKAQTcjs.__publicField.call(void 0, this, "ttl");
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    _chunk42PBKAQTcjs.__publicField.call(void 0, this, "ttlResolution");
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    _chunk42PBKAQTcjs.__publicField.call(void 0, this, "ttlAutopurge");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    _chunk42PBKAQTcjs.__publicField.call(void 0, this, "updateAgeOnGet");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    _chunk42PBKAQTcjs.__publicField.call(void 0, this, "updateAgeOnHas");
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    _chunk42PBKAQTcjs.__publicField.call(void 0, this, "allowStale");
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    _chunk42PBKAQTcjs.__publicField.call(void 0, this, "noDisposeOnSet");
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    _chunk42PBKAQTcjs.__publicField.call(void 0, this, "noUpdateTTL");
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    _chunk42PBKAQTcjs.__publicField.call(void 0, this, "maxEntrySize");
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    _chunk42PBKAQTcjs.__publicField.call(void 0, this, "sizeCalculation");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    _chunk42PBKAQTcjs.__publicField.call(void 0, this, "noDeleteOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    _chunk42PBKAQTcjs.__publicField.call(void 0, this, "noDeleteOnStaleGet");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    _chunk42PBKAQTcjs.__publicField.call(void 0, this, "allowStaleOnFetchAbort");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    _chunk42PBKAQTcjs.__publicField.call(void 0, this, "allowStaleOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    _chunk42PBKAQTcjs.__publicField.call(void 0, this, "ignoreFetchAbort");
    // computed properties
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _size2);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _calculatedSize);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _keyMap);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _keyList);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _valList);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _next);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _prev);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _head2);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _tail2);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _free);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _disposed);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _sizes);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _starts);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _ttls);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _hasDispose);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _hasFetchMethod);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _hasDisposeAfter);
    // conditionally set private methods related to TTL
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _updateItemAge, () => {
    });
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _statusTTL, () => {
    });
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _setItemTTL, () => {
    });
    /* c8 ignore stop */
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _isStale, () => false);
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _removeItemSize, (_i) => {
    });
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _addItemSize, (_i, _s, _st) => {
    });
    _chunk42PBKAQTcjs.__privateAdd.call(void 0, this, _requireSize, (_k, _v, size, sizeCalculation) => {
      if (size || sizeCalculation) {
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      }
      return 0;
    });
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */
    _chunk42PBKAQTcjs.__publicField.call(void 0, this, _a2, "LRUCache");
    const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _max, max);
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _maxSize, maxSize);
    this.maxEntrySize = maxEntrySize || _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _maxSize);
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _maxSize) && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (memoMethod !== void 0 && typeof memoMethod !== "function") {
      throw new TypeError("memoMethod must be a function if defined");
    }
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _memoMethod, memoMethod);
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _fetchMethod, fetchMethod);
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _hasFetchMethod, !!fetchMethod);
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _keyMap, /* @__PURE__ */ new Map());
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _keyList, new Array(max).fill(void 0));
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _valList, new Array(max).fill(void 0));
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _next, new UintArray(max));
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _prev, new UintArray(max));
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _head2, 0);
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _tail2, 0);
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _free, Stack.create(max));
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _size2, 0);
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _calculatedSize, 0);
    if (typeof dispose === "function") {
      _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _dispose, dispose);
    }
    if (typeof disposeAfter === "function") {
      _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _disposeAfter, disposeAfter);
      _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _disposed, []);
    } else {
      _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _disposeAfter, void 0);
      _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _disposed, void 0);
    }
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _hasDispose, !!_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _dispose));
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _hasDisposeAfter, !!_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _disposeAfter));
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _maxSize) !== 0) {
        if (!isPosInt(_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _maxSize))) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, initializeSizeTracking_fn).call(this);
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, initializeTTLTracking_fn).call(this);
    }
    if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _max) === 0 && this.ttl === 0 && _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _maxSize) === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _max) && !_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _maxSize)) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned3.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
      }
    }
  }
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c) {
    return {
      // properties
      starts: _chunk42PBKAQTcjs.__privateGet.call(void 0, c, _starts),
      ttls: _chunk42PBKAQTcjs.__privateGet.call(void 0, c, _ttls),
      sizes: _chunk42PBKAQTcjs.__privateGet.call(void 0, c, _sizes),
      keyMap: _chunk42PBKAQTcjs.__privateGet.call(void 0, c, _keyMap),
      keyList: _chunk42PBKAQTcjs.__privateGet.call(void 0, c, _keyList),
      valList: _chunk42PBKAQTcjs.__privateGet.call(void 0, c, _valList),
      next: _chunk42PBKAQTcjs.__privateGet.call(void 0, c, _next),
      prev: _chunk42PBKAQTcjs.__privateGet.call(void 0, c, _prev),
      get head() {
        return _chunk42PBKAQTcjs.__privateGet.call(void 0, c, _head2);
      },
      get tail() {
        return _chunk42PBKAQTcjs.__privateGet.call(void 0, c, _tail2);
      },
      free: _chunk42PBKAQTcjs.__privateGet.call(void 0, c, _free),
      // methods
      isBackgroundFetch: (p) => {
        var _a3;
        return _chunk42PBKAQTcjs.__privateMethod.call(void 0, _a3 = c, _LRUCache_instances, isBackgroundFetch_fn).call(_a3, p);
      },
      backgroundFetch: (k, index, options, context) => {
        var _a3;
        return _chunk42PBKAQTcjs.__privateMethod.call(void 0, _a3 = c, _LRUCache_instances, backgroundFetch_fn).call(_a3, k, index, options, context);
      },
      moveToTail: (index) => {
        var _a3;
        return _chunk42PBKAQTcjs.__privateMethod.call(void 0, _a3 = c, _LRUCache_instances, moveToTail_fn).call(_a3, index);
      },
      indexes: (options) => {
        var _a3;
        return _chunk42PBKAQTcjs.__privateMethod.call(void 0, _a3 = c, _LRUCache_instances, indexes_fn).call(_a3, options);
      },
      rindexes: (options) => {
        var _a3;
        return _chunk42PBKAQTcjs.__privateMethod.call(void 0, _a3 = c, _LRUCache_instances, rindexes_fn).call(_a3, options);
      },
      isStale: (index) => {
        var _a3;
        return _chunk42PBKAQTcjs.__privateGet.call(void 0, _a3 = c, _isStale).call(_a3, index);
      }
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _max);
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _maxSize);
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _calculatedSize);
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _size2);
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _fetchMethod);
  }
  get memoMethod() {
    return _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _memoMethod);
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _dispose);
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _disposeAfter);
  }
  /**
   * Return the number of ms left in the item's TTL. If item is not in cache,
   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
   */
  getRemainingTTL(key) {
    return _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyMap).has(key) ? Infinity : 0;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i of _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, indexes_fn).call(this)) {
      if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[i] !== void 0 && _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyList)[i] !== void 0 && !_chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isBackgroundFetch_fn).call(this, _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[i])) {
        yield [_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyList)[i], _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[i]];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i of _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, rindexes_fn).call(this)) {
      if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[i] !== void 0 && _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyList)[i] !== void 0 && !_chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isBackgroundFetch_fn).call(this, _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[i])) {
        yield [_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyList)[i], _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[i]];
      }
    }
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i of _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, indexes_fn).call(this)) {
      const k = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyList)[i];
      if (k !== void 0 && !_chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isBackgroundFetch_fn).call(this, _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[i])) {
        yield k;
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i of _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, rindexes_fn).call(this)) {
      const k = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyList)[i];
      if (k !== void 0 && !_chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isBackgroundFetch_fn).call(this, _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[i])) {
        yield k;
      }
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i of _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, indexes_fn).call(this)) {
      const v = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[i];
      if (v !== void 0 && !_chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isBackgroundFetch_fn).call(this, _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[i])) {
        yield _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[i];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i of _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, rindexes_fn).call(this)) {
      const v = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[i];
      if (v !== void 0 && !_chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isBackgroundFetch_fn).call(this, _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[i])) {
        yield _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[i];
      }
    }
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [(_b = Symbol.iterator, _a2 = Symbol.toStringTag, _b)]() {
    return this.entries();
  }
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
   */
  find(fn, getOptions = {}) {
    for (const i of _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, indexes_fn).call(this)) {
      const v = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[i];
      const value = _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      if (fn(value, _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyList)[i], this)) {
        return this.get(_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyList)[i], getOptions);
      }
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from most
   * recently used to least recently used.
   *
   * `fn` is called as `fn(value, key, cache)`.
   *
   * If `thisp` is provided, function will be called in the `this`-context of
   * the provided object, or the cache if no `thisp` object is provided.
   *
   * Does not update age or recenty of use, or iterate over stale values.
   */
  forEach(fn, thisp = this) {
    for (const i of _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, indexes_fn).call(this)) {
      const v = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[i];
      const value = _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn.call(thisp, value, _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyList)[i], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn, thisp = this) {
    for (const i of _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, rindexes_fn).call(this)) {
      const v = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[i];
      const value = _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn.call(thisp, value, _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyList)[i], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = false;
    for (const i of _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: true })) {
      if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _isStale).call(this, i)) {
        _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, delete_fn).call(this, _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyList)[i], "expire");
        deleted = true;
      }
    }
    return deleted;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Returns `undefined` if the key is not present.
   *
   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
   * serialization, the `start` value is always the current timestamp, and the
   * `ttl` is a calculated remaining time to live (negative if expired).
   *
   * Always returns stale values, if their info is found in the cache, so be
   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
   * if relevant.
   */
  info(key) {
    const i = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyMap).get(key);
    if (i === void 0)
      return void 0;
    const v = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[i];
    const value = _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
    if (value === void 0)
      return void 0;
    const entry = { value };
    if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _ttls) && _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _starts)) {
      const ttl = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _ttls)[i];
      const start = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _starts)[i];
      if (ttl && start) {
        const remain = ttl - (perf.now() - start);
        entry.ttl = remain;
        entry.start = Date.now();
      }
    }
    if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _sizes)) {
      entry.size = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _sizes)[i];
    }
    return entry;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to {@link LRUCache#load}.
   *
   * The `start` fields are calculated relative to a portable `Date.now()`
   * timestamp, even if `performance.now()` is available.
   *
   * Stale entries are always included in the `dump`, even if
   * {@link LRUCache.OptionsBase.allowStale} is false.
   *
   * Note: this returns an actual array, not a generator, so it can be more
   * easily passed around.
   */
  dump() {
    const arr = [];
    for (const i of _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, indexes_fn).call(this, { allowStale: true })) {
      const key = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyList)[i];
      const v = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[i];
      const value = _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      if (value === void 0 || key === void 0)
        continue;
      const entry = { value };
      if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _ttls) && _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _starts)) {
        entry.ttl = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _ttls)[i];
        const age = perf.now() - _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _starts)[i];
        entry.start = Math.floor(Date.now() - age);
      }
      if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _sizes)) {
        entry.size = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _sizes)[i];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   *
   * The shape of the resulting cache may be different if the same options are
   * not used in both caches.
   *
   * The `start` fields are assumed to be calculated relative to a portable
   * `Date.now()` timestamp, even if `performance.now()` is available.
   */
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   *
   * Fields on the {@link LRUCache.SetOptions} options param will override
   * their corresponding values in the constructor options for the scope
   * of this single `set()` operation.
   *
   * If `start` is provided, then that will set the effective start
   * time for the TTL calculation. Note that this must be a previous
   * value of `performance.now()` if supported, or a previous value of
   * `Date.now()` if not.
   *
   * Options object may also include `size`, which will prevent
   * calling the `sizeCalculation` function and just use the specified
   * number if it is a positive integer, and `noDisposeOnSet` which
   * will prevent calling a `dispose` function in the case of
   * overwrites.
   *
   * If the `size` (or return value of `sizeCalculation`) for a given
   * entry is greater than `maxEntrySize`, then the item will not be
   * added to the cache.
   *
   * Will update the recency of the entry.
   *
   * If the value is `undefined`, then this is an alias for
   * `cache.delete(key)`. `undefined` is never stored in the cache.
   */
  set(k, v, setOptions = {}) {
    var _a3, _b2, _c, _d, _e;
    if (v === void 0) {
      this.delete(k);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _requireSize).call(this, k, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, delete_fn).call(this, k, "set");
      return this;
    }
    let index = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _size2) === 0 ? void 0 : _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyMap).get(k);
    if (index === void 0) {
      index = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _size2) === 0 ? _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _tail2) : _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _free).length !== 0 ? _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _free).pop() : _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _size2) === _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _max) ? _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, evict_fn).call(this, false) : _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _size2);
      _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyList)[index] = k;
      _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[index] = v;
      _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyMap).set(k, index);
      _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _next)[_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _tail2)] = index;
      _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _prev)[index] = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _tail2);
      _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _tail2, index);
      _chunk42PBKAQTcjs.__privateWrapper.call(void 0, this, _size2)._++;
      _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _addItemSize).call(this, index, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
    } else {
      _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, moveToTail_fn).call(this, index);
      const oldVal = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[index];
      if (v !== oldVal) {
        if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _hasFetchMethod) && _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s } = oldVal;
          if (s !== void 0 && !noDisposeOnSet) {
            if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _hasDispose)) {
              (_a3 = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _dispose)) == null ? void 0 : _a3.call(this, s, k, "set");
            }
            if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _hasDisposeAfter)) {
              (_b2 = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _disposed)) == null ? void 0 : _b2.push([s, k, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _hasDispose)) {
            (_c = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _dispose)) == null ? void 0 : _c.call(this, oldVal, k, "set");
          }
          if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _hasDisposeAfter)) {
            (_d = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _disposed)) == null ? void 0 : _d.push([oldVal, k, "set"]);
          }
        }
        _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _removeItemSize).call(this, index);
        _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _addItemSize).call(this, index, size, status);
        _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[index] = v;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && !_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _ttls)) {
      _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, initializeTTLTracking_fn).call(this);
    }
    if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _ttls)) {
      if (!noUpdateTTL) {
        _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _setItemTTL).call(this, index, ttl, start);
      }
      if (status)
        _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _statusTTL).call(this, status, index);
    }
    if (!noDisposeOnSet && _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _hasDisposeAfter) && _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _disposed)) {
      const dt = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _disposed);
      let task;
      while (task = dt == null ? void 0 : dt.shift()) {
        (_e = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _disposeAfter)) == null ? void 0 : _e.call(this, ...task);
      }
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    var _a3;
    try {
      while (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _size2)) {
        const val = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _head2)];
        _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, evict_fn).call(this, true);
        if (_chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isBackgroundFetch_fn).call(this, val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _hasDisposeAfter) && _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _disposed)) {
        const dt = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _disposed);
        let task;
        while (task = dt == null ? void 0 : dt.shift()) {
          (_a3 = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _disposeAfter)) == null ? void 0 : _a3.call(this, ...task);
        }
      }
    }
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Check if a key is in the cache, without updating the recency of
   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
   * to `true` in either the options or the constructor.
   *
   * Will return `false` if the item is stale, even though it is technically in
   * the cache. The difference can be determined (if it matters) by using a
   * `status` argument, and inspecting the `has` field.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyMap).get(k);
    if (index !== void 0) {
      const v = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[index];
      if (_chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) && v.__staleWhileFetching === void 0) {
        return false;
      }
      if (!_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _isStale).call(this, index)) {
        if (updateAgeOnHas) {
          _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _updateItemAge).call(this, index);
        }
        if (status) {
          status.has = "hit";
          _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _statusTTL).call(this, status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _statusTTL).call(this, status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyMap).get(k);
    if (index === void 0 || !allowStale && _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _isStale).call(this, index)) {
      return;
    }
    const v = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[index];
    return _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
  }
  async fetch(k, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _hasFetchMethod)) {
      if (status)
        status.fetch = "get";
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyMap).get(k);
    if (index === void 0) {
      if (status)
        status.fetch = "miss";
      const p = _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, backgroundFetch_fn).call(this, k, index, options, context);
      return p.__returned = p;
    } else {
      const v = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[index];
      if (_chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
        const stale = allowStale && v.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _isStale).call(this, index);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, moveToTail_fn).call(this, index);
        if (updateAgeOnGet) {
          _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _updateItemAge).call(this, index);
        }
        if (status)
          _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _statusTTL).call(this, status, index);
        return v;
      }
      const p = _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, backgroundFetch_fn).call(this, k, index, options, context);
      const hasStale = p.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  async forceFetch(k, fetchOptions = {}) {
    const v = await this.fetch(k, fetchOptions);
    if (v === void 0)
      throw new Error("fetch() returned undefined");
    return v;
  }
  memo(k, memoOptions = {}) {
    const memoMethod = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _memoMethod);
    if (!memoMethod) {
      throw new Error("no memoMethod provided to constructor");
    }
    const { context, forceRefresh, ...options } = memoOptions;
    const v = this.get(k, options);
    if (!forceRefresh && v !== void 0)
      return v;
    const vv = memoMethod(k, v, {
      options,
      context
    });
    this.set(k, vv, options);
    return vv;
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyMap).get(k);
    if (index !== void 0) {
      const value = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[index];
      const fetching = _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isBackgroundFetch_fn).call(this, value);
      if (status)
        _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _statusTTL).call(this, status, index);
      if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _isStale).call(this, index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, delete_fn).call(this, k, "expire");
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : void 0;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== void 0) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, moveToTail_fn).call(this, index);
        if (updateAgeOnGet) {
          _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _updateItemAge).call(this, index);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  /**
   * Deletes a key out of the cache.
   *
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k) {
    return _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, delete_fn).call(this, k, "delete");
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    return _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, clear_fn).call(this, "delete");
  }
};
_max = new WeakMap();
_maxSize = new WeakMap();
_dispose = new WeakMap();
_disposeAfter = new WeakMap();
_fetchMethod = new WeakMap();
_memoMethod = new WeakMap();
_size2 = new WeakMap();
_calculatedSize = new WeakMap();
_keyMap = new WeakMap();
_keyList = new WeakMap();
_valList = new WeakMap();
_next = new WeakMap();
_prev = new WeakMap();
_head2 = new WeakMap();
_tail2 = new WeakMap();
_free = new WeakMap();
_disposed = new WeakMap();
_sizes = new WeakMap();
_starts = new WeakMap();
_ttls = new WeakMap();
_hasDispose = new WeakMap();
_hasFetchMethod = new WeakMap();
_hasDisposeAfter = new WeakMap();
_LRUCache_instances = new WeakSet();
initializeTTLTracking_fn = function() {
  const ttls = new ZeroArray(_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _max));
  const starts = new ZeroArray(_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _max));
  _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _ttls, ttls);
  _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _starts, starts);
  _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _setItemTTL, (index, ttl, start = perf.now()) => {
    starts[index] = ttl !== 0 ? start : 0;
    ttls[index] = ttl;
    if (ttl !== 0 && this.ttlAutopurge) {
      const t = setTimeout(() => {
        if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _isStale).call(this, index)) {
          _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, delete_fn).call(this, _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyList)[index], "expire");
        }
      }, ttl + 1);
      if (t.unref) {
        t.unref();
      }
    }
  });
  _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _updateItemAge, (index) => {
    starts[index] = ttls[index] !== 0 ? perf.now() : 0;
  });
  _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _statusTTL, (status, index) => {
    if (ttls[index]) {
      const ttl = ttls[index];
      const start = starts[index];
      if (!ttl || !start)
        return;
      status.ttl = ttl;
      status.start = start;
      status.now = cachedNow || getNow();
      const age = status.now - start;
      status.remainingTTL = ttl - age;
    }
  });
  let cachedNow = 0;
  const getNow = () => {
    const n2 = perf.now();
    if (this.ttlResolution > 0) {
      cachedNow = n2;
      const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
      if (t.unref) {
        t.unref();
      }
    }
    return n2;
  };
  this.getRemainingTTL = (key) => {
    const index = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyMap).get(key);
    if (index === void 0) {
      return 0;
    }
    const ttl = ttls[index];
    const start = starts[index];
    if (!ttl || !start) {
      return Infinity;
    }
    const age = (cachedNow || getNow()) - start;
    return ttl - age;
  };
  _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _isStale, (index) => {
    const s = starts[index];
    const t = ttls[index];
    return !!t && !!s && (cachedNow || getNow()) - s > t;
  });
};
_updateItemAge = new WeakMap();
_statusTTL = new WeakMap();
_setItemTTL = new WeakMap();
_isStale = new WeakMap();
initializeSizeTracking_fn = function() {
  const sizes3 = new ZeroArray(_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _max));
  _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _calculatedSize, 0);
  _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _sizes, sizes3);
  _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _removeItemSize, (index) => {
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _calculatedSize, _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _calculatedSize) - sizes3[index]);
    sizes3[index] = 0;
  });
  _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _requireSize, (k, v, size, sizeCalculation) => {
    if (_chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
      return 0;
    }
    if (!isPosInt(size)) {
      if (sizeCalculation) {
        if (typeof sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation must be a function");
        }
        size = sizeCalculation(v, k);
        if (!isPosInt(size)) {
          throw new TypeError("sizeCalculation return invalid (expect positive integer)");
        }
      } else {
        throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
      }
    }
    return size;
  });
  _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _addItemSize, (index, size, status) => {
    sizes3[index] = size;
    if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _maxSize)) {
      const maxSize = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _maxSize) - sizes3[index];
      while (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _calculatedSize) > maxSize) {
        _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, evict_fn).call(this, true);
      }
    }
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _calculatedSize, _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _calculatedSize) + sizes3[index]);
    if (status) {
      status.entrySize = size;
      status.totalCalculatedSize = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _calculatedSize);
    }
  });
};
_removeItemSize = new WeakMap();
_addItemSize = new WeakMap();
_requireSize = new WeakMap();
indexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _size2)) {
    for (let i = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _tail2); true; ) {
      if (!_chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isValidIndex_fn).call(this, i)) {
        break;
      }
      if (allowStale || !_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _isStale).call(this, i)) {
        yield i;
      }
      if (i === _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _head2)) {
        break;
      } else {
        i = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _prev)[i];
      }
    }
  }
};
rindexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _size2)) {
    for (let i = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _head2); true; ) {
      if (!_chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isValidIndex_fn).call(this, i)) {
        break;
      }
      if (allowStale || !_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _isStale).call(this, i)) {
        yield i;
      }
      if (i === _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _tail2)) {
        break;
      } else {
        i = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _next)[i];
      }
    }
  }
};
isValidIndex_fn = function(index) {
  return index !== void 0 && _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyMap).get(_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyList)[index]) === index;
};
evict_fn = function(free) {
  var _a3, _b2;
  const head = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _head2);
  const k = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyList)[head];
  const v = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[head];
  if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _hasFetchMethod) && _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
    v.__abortController.abort(new Error("evicted"));
  } else if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _hasDispose) || _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _hasDisposeAfter)) {
    if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _hasDispose)) {
      (_a3 = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _dispose)) == null ? void 0 : _a3.call(this, v, k, "evict");
    }
    if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _hasDisposeAfter)) {
      (_b2 = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _disposed)) == null ? void 0 : _b2.push([v, k, "evict"]);
    }
  }
  _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _removeItemSize).call(this, head);
  if (free) {
    _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyList)[head] = void 0;
    _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[head] = void 0;
    _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _free).push(head);
  }
  if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _size2) === 1) {
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _head2, _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _tail2, 0));
    _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _free).length = 0;
  } else {
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _head2, _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _next)[head]);
  }
  _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyMap).delete(k);
  _chunk42PBKAQTcjs.__privateWrapper.call(void 0, this, _size2)._--;
  return head;
};
backgroundFetch_fn = function(k, index, options, context) {
  const v = index === void 0 ? void 0 : _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[index];
  if (_chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
    return v;
  }
  const ac = new AC();
  const { signal } = options;
  signal == null ? void 0 : signal.addEventListener("abort", () => ac.abort(signal.reason), {
    signal: ac.signal
  });
  const fetchOpts = {
    signal: ac.signal,
    options,
    context
  };
  const cb = (v2, updateCache = false) => {
    const { aborted } = ac.signal;
    const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
    if (options.status) {
      if (aborted && !updateCache) {
        options.status.fetchAborted = true;
        options.status.fetchError = ac.signal.reason;
        if (ignoreAbort)
          options.status.fetchAbortIgnored = true;
      } else {
        options.status.fetchResolved = true;
      }
    }
    if (aborted && !ignoreAbort && !updateCache) {
      return fetchFail(ac.signal.reason);
    }
    const bf2 = p;
    if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[index] === p) {
      if (v2 === void 0) {
        if (bf2.__staleWhileFetching) {
          _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[index] = bf2.__staleWhileFetching;
        } else {
          _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, delete_fn).call(this, k, "fetch");
        }
      } else {
        if (options.status)
          options.status.fetchUpdated = true;
        this.set(k, v2, fetchOpts.options);
      }
    }
    return v2;
  };
  const eb = (er) => {
    if (options.status) {
      options.status.fetchRejected = true;
      options.status.fetchError = er;
    }
    return fetchFail(er);
  };
  const fetchFail = (er) => {
    const { aborted } = ac.signal;
    const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
    const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
    const noDelete = allowStale || options.noDeleteOnFetchRejection;
    const bf2 = p;
    if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[index] === p) {
      const del = !noDelete || bf2.__staleWhileFetching === void 0;
      if (del) {
        _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, delete_fn).call(this, k, "fetch");
      } else if (!allowStaleAborted) {
        _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[index] = bf2.__staleWhileFetching;
      }
    }
    if (allowStale) {
      if (options.status && bf2.__staleWhileFetching !== void 0) {
        options.status.returnedStale = true;
      }
      return bf2.__staleWhileFetching;
    } else if (bf2.__returned === bf2) {
      throw er;
    }
  };
  const pcall = (res, rej) => {
    var _a3;
    const fmp = (_a3 = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _fetchMethod)) == null ? void 0 : _a3.call(this, k, v, fetchOpts);
    if (fmp && fmp instanceof Promise) {
      fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
    }
    ac.signal.addEventListener("abort", () => {
      if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
        res(void 0);
        if (options.allowStaleOnFetchAbort) {
          res = (v2) => cb(v2, true);
        }
      }
    });
  };
  if (options.status)
    options.status.fetchDispatched = true;
  const p = new Promise(pcall).then(cb, eb);
  const bf = Object.assign(p, {
    __abortController: ac,
    __staleWhileFetching: v,
    __returned: void 0
  });
  if (index === void 0) {
    this.set(k, bf, { ...fetchOpts.options, status: void 0 });
    index = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyMap).get(k);
  } else {
    _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[index] = bf;
  }
  return bf;
};
isBackgroundFetch_fn = function(p) {
  if (!_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _hasFetchMethod))
    return false;
  const b = p;
  return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
};
connect_fn = function(p, n2) {
  _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _prev)[n2] = p;
  _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _next)[p] = n2;
};
moveToTail_fn = function(index) {
  if (index !== _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _tail2)) {
    if (index === _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _head2)) {
      _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _head2, _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _next)[index]);
    } else {
      _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, connect_fn).call(this, _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _prev)[index], _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _next)[index]);
    }
    _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, connect_fn).call(this, _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _tail2), index);
    _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _tail2, index);
  }
};
delete_fn = function(k, reason) {
  var _a3, _b2, _c, _d;
  let deleted = false;
  if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _size2) !== 0) {
    const index = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyMap).get(k);
    if (index !== void 0) {
      deleted = true;
      if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _size2) === 1) {
        _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, clear_fn).call(this, reason);
      } else {
        _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _removeItemSize).call(this, index);
        const v = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[index];
        if (_chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
          v.__abortController.abort(new Error("deleted"));
        } else if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _hasDispose) || _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _hasDisposeAfter)) {
          if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _hasDispose)) {
            (_a3 = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _dispose)) == null ? void 0 : _a3.call(this, v, k, reason);
          }
          if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _hasDisposeAfter)) {
            (_b2 = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _disposed)) == null ? void 0 : _b2.push([v, k, reason]);
          }
        }
        _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyMap).delete(k);
        _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyList)[index] = void 0;
        _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[index] = void 0;
        if (index === _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _tail2)) {
          _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _tail2, _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _prev)[index]);
        } else if (index === _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _head2)) {
          _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _head2, _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _next)[index]);
        } else {
          const pi = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _prev)[index];
          _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _next)[pi] = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _next)[index];
          const ni = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _next)[index];
          _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _prev)[ni] = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _prev)[index];
        }
        _chunk42PBKAQTcjs.__privateWrapper.call(void 0, this, _size2)._--;
        _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _free).push(index);
      }
    }
  }
  if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _hasDisposeAfter) && ((_c = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _disposed)) == null ? void 0 : _c.length)) {
    const dt = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _disposed);
    let task;
    while (task = dt == null ? void 0 : dt.shift()) {
      (_d = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _disposeAfter)) == null ? void 0 : _d.call(this, ...task);
    }
  }
  return deleted;
};
clear_fn = function(reason) {
  var _a3, _b2, _c;
  for (const index of _chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: true })) {
    const v = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList)[index];
    if (_chunk42PBKAQTcjs.__privateMethod.call(void 0, this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
      v.__abortController.abort(new Error("deleted"));
    } else {
      const k = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyList)[index];
      if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _hasDispose)) {
        (_a3 = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _dispose)) == null ? void 0 : _a3.call(this, v, k, reason);
      }
      if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _hasDisposeAfter)) {
        (_b2 = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _disposed)) == null ? void 0 : _b2.push([v, k, reason]);
      }
    }
  }
  _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyMap).clear();
  _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _valList).fill(void 0);
  _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _keyList).fill(void 0);
  if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _ttls) && _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _starts)) {
    _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _ttls).fill(0);
    _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _starts).fill(0);
  }
  if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _sizes)) {
    _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _sizes).fill(0);
  }
  _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _head2, 0);
  _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _tail2, 0);
  _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _free).length = 0;
  _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _calculatedSize, 0);
  _chunk42PBKAQTcjs.__privateSet.call(void 0, this, _size2, 0);
  if (_chunk42PBKAQTcjs.__privateGet.call(void 0, this, _hasDisposeAfter) && _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _disposed)) {
    const dt = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _disposed);
    let task;
    while (task = dt == null ? void 0 : dt.shift()) {
      (_c = _chunk42PBKAQTcjs.__privateGet.call(void 0, this, _disposeAfter)) == null ? void 0 : _c.call(this, ...task);
    }
  }
};
var LRUCache = _LRUCache;

// ../../packages-engine/autocomplete/src/utils.ts
function searchUsageBoundary(line, index, attributify = true) {
  let start = index;
  let end = index;
  const regex = /[^\s>"'`;]/;
  while (start && regex.test(line.charAt(start - 1))) --start;
  while (end < line.length && regex.test(line.charAt(end))) ++end;
  if (attributify) {
    return {
      content: line.slice(start, end),
      start,
      end
    };
  }
  let temp = start - 1;
  const matchClassText = "class";
  const matchClassNameText = "className";
  const applyText = "@apply";
  while (temp > matchClassText.length && !/[="'{}><@;]/.test(line[temp--])) {
  }
  if (line[temp + 1] === "@") {
    const data = line.slice(temp + 1, temp + applyText.length + 1);
    if (data === applyText) {
      return {
        content: line.slice(start, end),
        start,
        end
      };
    }
  }
  if (line[temp] !== "=")
    return;
  if (temp > matchClassNameText.length) {
    const data = line.slice(temp - matchClassNameText.length, temp);
    if (data === matchClassNameText) {
      return {
        content: line.slice(start, end),
        start,
        end
      };
    }
  }
  if (temp > matchClassText.length) {
    const data = line.slice(temp - matchClassText.length, temp);
    if (data === matchClassText) {
      return {
        content: line.slice(start, end),
        start,
        end
      };
    }
  }
}
function searchAttrKey(content, cursor) {
  var _a3;
  const text = content.substring(0, cursor);
  if (/<\w[^>]*$/.test(text))
    return (_a3 = text.match(/\S+(?=\s*=(?:\s*["'])?[^"']*$)/)) == null ? void 0 : _a3[0];
}
function cartesian(arr) {
  return arr.reduce(
    (a, b) => {
      const ret = [];
      a.forEach((a2) => {
        b.forEach((b2) => {
          ret.push(a2.concat([b2]));
        });
      });
      return ret;
    },
    [[]]
  );
}

// ../../packages-engine/autocomplete/src/parse.ts
var shorthands2 = {
  directions: "(x|y|t|b|l|r|s|e)",
  num: `(${[0, 1, 2, 3, 4, 5, 6, 8, 10, 12, 24, 36].join("|")})`,
  percent: `(${[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100].join("|")})`,
  percentage: `(${["10%", "20%", "30%", "40%", "50%", "60%", "70%", "80%", "90%", "100%"].join("|")})`
};
var ignoredThemeKeys = ["DEFAULT"];
function handleRegexMatch(str, regex, onMatched, onNotMatched) {
  let lastIndex = 0;
  Array.from(str.matchAll(regex)).forEach((m) => {
    const index = m.index;
    if (lastIndex !== index)
      onNotMatched(str.slice(lastIndex, index), lastIndex, index);
    onMatched(m);
    lastIndex = index + m[0].length;
  });
  if (lastIndex !== str.length)
    onNotMatched(str.slice(lastIndex), lastIndex, str.length);
}
function parseAutocomplete(template, theme4 = {}, extraShorthands = {}) {
  const parts = [];
  const newShorthands = {
    ...shorthands2,
    ...extraShorthands
  };
  template = template.replace(/<(\w+)>/g, (_, key) => {
    if (!newShorthands[key])
      throw new Error(`Unknown template shorthand: ${key}`);
    return newShorthands[key];
  });
  handleGroups(template);
  const fzf = new Fzf(getAllCombination(parts));
  return {
    parts,
    suggest
  };
  function handleNonGroup(input) {
    handleRegexMatch(
      input,
      /\$([\w.|]+)/g,
      (m) => {
        parts.push({
          type: "theme",
          objects: m[1].split("|").map((i) => {
            return i.split(".").reduce((v, k) => {
              if (!k || !v[k])
                throw new Error(`Invalid theme key ${k}`);
              return v[k];
            }, theme4);
          })
        });
      },
      (str) => {
        parts.push({
          type: "static",
          value: str
        });
      }
    );
  }
  function handleGroups(input) {
    handleRegexMatch(
      input,
      /\((.*?)\)/g,
      (m) => {
        parts.push({
          type: "group",
          values: m[1].split("|")
        });
      },
      (str) => {
        handleNonGroup(str);
      }
    );
  }
  function suggest(input, matchType2 = "prefix") {
    if (input.length > 1 && matchType2 === "fuzzy")
      return fzf.find(input).map((i) => i.item);
    let rest = input.replace(/-/g, "");
    let matched = [""];
    let combinations = [""];
    const tempParts = [...parts];
    while (tempParts.length) {
      const part = tempParts.shift();
      if (part.type === "static") {
        const temp = part.value.replace(/-/g, "");
        if (!rest.startsWith(temp) && !part.value.startsWith(rest))
          return [""];
        matched = matched.map((m) => m + part.value);
        rest = rest.slice(temp.length);
      } else if (part.type === "group") {
        const fullMatched = part.values.find((i) => i && rest.startsWith(i));
        if (fullMatched) {
          matched = matched.map((m) => m + fullMatched);
          rest = rest.slice(fullMatched.length);
          if (!tempParts[0] && rest)
            return [];
          continue;
        } else {
          if (tempParts[0]) {
            const values = part.values.filter((i) => i && i.startsWith(rest));
            rest = "";
            if (values.length) {
              matched = matched.map((m) => values.map((n2) => m + n2)).flat();
              continue;
            }
            break;
          }
          if (matched[0] === "")
            break;
          combinations = part.values.filter((p) => p.startsWith(rest));
          break;
        }
      } else if (part.type === "theme") {
        const keys = part.objects.flatMap((i) => Object.keys(i)).filter((i) => i && !ignoredThemeKeys.includes(i) && i[0] !== "_");
        const fullMatched = keys.find((i) => i && rest.startsWith(i));
        if (fullMatched != null) {
          rest = rest.slice(fullMatched.length);
          const subObjects = part.objects.map((i) => i[fullMatched]).filter((i) => !!i && typeof i === "object");
          if (subObjects.length) {
            matched = matched.map((m) => `${m + fullMatched}-`);
            tempParts.unshift({
              type: "theme",
              objects: subObjects
            });
          } else {
            combinations = keys.filter((i) => i.startsWith(rest));
          }
        } else {
          if (tempParts[0] && tempParts[0].type !== "static") {
            const values = tempParts[0].values;
            if (values)
              matched = matched.filter((i) => i && rest.startsWith(i)).map((m) => values.map((n2) => m + n2)).flat();
          } else {
            combinations = keys.filter((i) => i.startsWith(rest));
          }
          break;
        }
      }
    }
    return combinations.map((i) => matched.map((m) => m + i)).flat().filter((i) => i.length >= input.length);
  }
}
function getValuesFromPartTemplate(part) {
  if (part.type === "static")
    return [part.value];
  if (part.type === "theme") {
    return part.objects.flatMap((i) => {
      const keys = Object.keys(i).filter((i2) => i2 && i2[0] !== "_");
      for (const key in i) {
        const value = i[key];
        if (value === null || value === void 0)
          continue;
        if (typeof value === "object" && !Array.isArray(value)) {
          const subKeys = getValuesFromPartTemplate({
            type: "theme",
            objects: [value]
          }).map((i2) => `${key}-${i2}`);
          keys.push(...subKeys);
        }
      }
      return keys;
    });
  }
  if (part.type === "group")
    return [...part.values];
  return [];
}
function getAllCombination(parts) {
  const values = parts.map((i) => getValuesFromPartTemplate(i));
  const list = uniq(cartesian(values).flatMap((i) => i.join("").replace("-DEFAULT", "")));
  return list;
}

// ../../packages-engine/autocomplete/src/create.ts
function createAutocomplete(_uno, options = {}) {
  var _a3;
  const templateCache = /* @__PURE__ */ new Map();
  const cache2 = new LRUCache({ max: 5e3 });
  let staticUtils = [];
  const templates = [];
  const matchType2 = (_a3 = options.matchType) != null ? _a3 : "prefix";
  let uno;
  const ready = reset();
  return {
    suggest,
    suggestInFile,
    templates,
    cache: cache2,
    reset,
    /**
     * Enumerate possible suggestions from 'aa' - 'zz'
     */
    enumerate
  };
  async function enumerate() {
    const matched = /* @__PURE__ */ new Set();
    const a2z = Array.from("abcdefghijklmnopqrstuvwxyz");
    const a2zd = [...a2z, "-"];
    const keys = a2z.flatMap((i) => [
      i,
      ...a2zd.map((j) => `${i}${j}`)
    ]);
    await Promise.all(
      keys.map((key) => suggest(key).then((i) => i.forEach((j) => matched.add(j))))
    );
    await Promise.all(
      [...matched].filter((i) => /^\w+$/.test(i) && i.length > 3).map((i) => suggest(`${i}-`).then((i2) => i2.forEach((j) => matched.add(j))))
    );
    return matched;
  }
  function getParsed(template) {
    if (!templateCache.has(template))
      templateCache.set(template, parseAutocomplete(template, uno.config.theme, uno.config.autocomplete.shorthands));
    return templateCache.get(template).suggest;
  }
  async function suggest(input, allowsEmptyInput = false) {
    var _a4;
    await ready;
    if (!allowsEmptyInput && input.length < 1)
      return [];
    if (cache2.has(input))
      return cache2.get(input);
    const attributify = uno.config.presets.find((i) => i.name === "@unocss/preset-attributify");
    const attributifyPrefix = (_a4 = attributify == null ? void 0 : attributify.options) == null ? void 0 : _a4.prefix;
    const _input = attributifyPrefix ? input.startsWith(attributifyPrefix) ? input.slice(attributifyPrefix.length) : input.replace(`:${attributifyPrefix}`, ":") : input;
    const matched = await uno.matchVariants(_input);
    let result = (await Promise.all(matched.map(async ([, processed, , variants4]) => {
      let idx = processed ? input.search(escapeRegExp(processed)) : input.length;
      if (idx === -1)
        idx = 0;
      const variantPrefix = input.slice(0, idx);
      const variantSuffix = input.slice(idx + input.length);
      const result2 = processSuggestions(
        await Promise.all([
          suggestSelf(processed),
          suggestStatic(processed),
          suggestUnoCache(processed),
          ...suggestFromPreset(processed),
          ...suggestVariant(processed, variants4)
        ]),
        variantPrefix,
        variantSuffix
      );
      return result2;
    }))).flat();
    if (matchType2 === "fuzzy") {
      const fzf = new Fzf(result, {
        tiebreakers: [byStartAsc, byLengthAsc]
      });
      result = fzf.find(input).map((i) => i.item);
    }
    cache2.set(input, result);
    return result;
  }
  async function suggestInFile(content, cursor) {
    await ready;
    const isInsideAttrValue = searchAttrKey(content, cursor) !== void 0;
    const byExtractor = await searchUsageByExtractor(content, cursor);
    if (byExtractor) {
      const suggestions2 = await suggest(byExtractor.extracted, isInsideAttrValue);
      const formatted = byExtractor.transformSuggestions ? byExtractor.transformSuggestions(suggestions2) : suggestions2;
      return {
        suggestions: suggestions2.map((v, i) => [v, formatted[i]]),
        resolveReplacement: byExtractor.resolveReplacement
      };
    }
    const regular = searchUsageBoundary(
      content,
      cursor,
      (uno.config.presets || []).some((i) => i.name === "@unocss/preset-attributify")
    );
    if (!regular)
      return;
    const suggestions = await suggest(regular.content, isInsideAttrValue);
    return {
      suggestions: suggestions.map((v) => [v, v]),
      resolveReplacement: (suggestion) => ({
        start: regular.start,
        end: regular.end,
        replacement: suggestion
      })
    };
  }
  async function searchUsageByExtractor(content, cursor) {
    if (!uno.config.autocomplete.extractors.length)
      return null;
    for (const extractor of uno.config.autocomplete.extractors) {
      const res = await extractor.extract({ content, cursor });
      if (res)
        return res;
    }
    return null;
  }
  async function suggestSelf(input) {
    const i = await uno.parseToken(input, "-");
    return i ? [input] : [];
  }
  async function suggestStatic(input) {
    if (matchType2 === "fuzzy")
      return staticUtils;
    return staticUtils.filter((i) => i.startsWith(input));
  }
  async function suggestUnoCache(input) {
    const keys = Array.from(uno.cache.entries());
    return keys.filter((i) => i[1] && i[0].startsWith(input)).map((i) => i[0]);
  }
  function suggestFromPreset(input) {
    return templates.map((fn) => typeof fn === "function" ? fn(input) : getParsed(fn)(input, matchType2)) || [];
  }
  function suggestVariant(input, used) {
    return uno.config.variants.filter((v) => v.autocomplete && (v.multiPass || !used.has(v))).flatMap((v) => toArray2(v.autocomplete || [])).map((fn) => typeof fn === "function" ? fn(input) : getParsed(fn)(input, matchType2));
  }
  async function reset() {
    templateCache.clear();
    cache2.clear();
    if (!uno) {
      uno = await Promise.resolve(_uno);
    }
    staticUtils = [
      ...Object.keys(uno.config.rulesStaticMap),
      ...uno.config.shortcuts.filter((i) => typeof i[0] === "string").map((i) => i[0])
    ];
    templates.length = 0;
    templates.push(
      ...uno.config.autocomplete.templates || [],
      ...uno.config.rulesDynamic.flatMap((i) => {
        var _a4;
        return toArray2(((_a4 = i == null ? void 0 : i[2]) == null ? void 0 : _a4.autocomplete) || []);
      }),
      ...uno.config.shortcuts.flatMap((i) => {
        var _a4;
        return toArray2(((_a4 = i == null ? void 0 : i[2]) == null ? void 0 : _a4.autocomplete) || []);
      })
    );
  }
  function processSuggestions(suggestions, prefix = "", suffix = "") {
    return uniq(suggestions.flat()).filter((i) => !!(i && !i.endsWith("-") && !uno.isBlocked(i))).sort((a, b) => {
      var _a4, _b2;
      if (/\d/.test(a) && /\D/.test(b))
        return 1;
      if (/\D/.test(a) && /\d/.test(b))
        return -1;
      const numA = +(((_a4 = a.match(/\d+$/)) == null ? void 0 : _a4[0]) || Number.NaN);
      const numB = +(((_b2 = b.match(/\d+$/)) == null ? void 0 : _b2[0]) || Number.NaN);
      if (!Number.isNaN(numA) && !Number.isNaN(numB))
        return numA - numB;
      return a.localeCompare(b);
    }).map((i) => prefix + i + suffix);
  }
}

// src/autocomplete.ts

var UnoCompletionItem = class extends _vscode.CompletionItem {
  constructor(label, kind, value, uno) {
    super(label, kind);
    this.uno = uno;
    this.value = value;
  }
};
async function registerAutoComplete(loader) {
  const autoCompletes = /* @__PURE__ */ new Map();
  const config = getConfig();
  loader.events.on("contextReload", (ctx) => {
    autoCompletes.delete(ctx);
  });
  loader.events.on("contextUnload", (ctx) => {
    autoCompletes.delete(ctx);
  });
  loader.events.on("unload", (ctx) => {
    autoCompletes.delete(ctx);
  });
  function getAutocomplete(ctx) {
    const cached = autoCompletes.get(ctx);
    if (cached)
      return cached;
    const autocomplete = createAutocomplete(ctx.uno, {
      matchType: config.autocompleteMatchType
    });
    autoCompletes.set(ctx, autocomplete);
    return autocomplete;
  }
  async function getMarkdown(uno, util, remToPxRatio) {
    return new (0, _vscode.MarkdownString)(await getPrettiedMarkdown(uno, util, remToPxRatio));
  }
  const provider = {
    async provideCompletionItems(doc, position3) {
      var _a3;
      const id = doc.uri.fsPath;
      if (!loader.isTarget(id))
        return null;
      const code = doc.getText();
      if (!code)
        return null;
      const offset = _vscode.window.activeTextEditor.document.offsetAt(position3);
      if (config.autocompleteStrict && !shouldProvideAutocomplete(code, id, offset))
        return;
      const ctx = await loader.resolveClosestContext(code, id);
      if (!ctx)
        return null;
      if (!ctx.filter(code, id) && !isCssId(id))
        return null;
      try {
        const autoComplete = getAutocomplete(ctx);
        const result = await autoComplete.suggestInFile(code, doc.offsetAt(position3));
        if (!result)
          return;
        if (!result.suggestions.length)
          return;
        const completionItems = [];
        const suggestions = result.suggestions.slice(0, config.autocompleteMaxItems);
        const isAttributify = ctx.uno.config.presets.some((p) => p.name === "@unocss/preset-attributify");
        for (const [value, label] of suggestions) {
          const css = await getCSS2(ctx.uno, isAttributify ? [value, `[${value}=""]`] : value);
          const colorString = getColorString(css);
          const itemKind = colorString ? _vscode.CompletionItemKind.Color : _vscode.CompletionItemKind.EnumMember;
          const item = new UnoCompletionItem(label, itemKind, value, ctx.uno);
          const resolved = result.resolveReplacement(value);
          item.insertText = resolved.replacement;
          item.range = new (0, _vscode.Range)(doc.positionAt(resolved.start), doc.positionAt(resolved.end));
          if (colorString) {
            item.documentation = colorString;
            item.sortText = /-\d$/.test(label) ? "1" : "2";
          }
          completionItems.push(item);
        }
        return new (0, _vscode.CompletionList)(completionItems, true);
      } catch (e2) {
        log.appendLine("\u26A0\uFE0F Error on getting autocompletion items");
        log.appendLine(String((_a3 = e2.stack) != null ? _a3 : e2));
        return null;
      }
    },
    async resolveCompletionItem(item) {
      const remToPxRatio = config.remToPxPreview ? config.remToPxRatio : -1;
      if (item.kind === _vscode.CompletionItemKind.Color)
        item.detail = await (await getPrettiedCSS(item.uno, item.value, remToPxRatio)).prettified;
      else
        item.documentation = await getMarkdown(item.uno, item.value, remToPxRatio);
      return item;
    }
  };
  let completeUnregister;
  const registerProvider = async () => {
    var _a3;
    (_a3 = completeUnregister == null ? void 0 : completeUnregister.dispose) == null ? void 0 : _a3.call(completeUnregister);
    completeUnregister = _vscode.languages.registerCompletionItemProvider(
      await getLanguageIds(),
      provider,
      ...delimiters
    );
    return completeUnregister;
  };
  loader.ext.subscriptions.push(
    config.watchChanged(
      ["languageIds"],
      async () => {
        loader.ext.subscriptions.push(
          await registerProvider()
        );
      }
    ),
    config.watchChanged(
      [
        "autocompleteMatchType",
        "autocompleteStrict",
        "remToPxRatio",
        "remToPxPreview"
      ],
      () => {
        autoCompletes.clear();
      }
    ),
    await registerProvider()
  );
}

// src/selectionStyle.ts
var import_parser_postcss2 = _chunk42PBKAQTcjs.__toESM.call(void 0, require_parser_postcss(), 1);
var import_standalone2 = _chunk42PBKAQTcjs.__toESM.call(void 0, require_standalone(), 1);

async function registerSelectionStyle(loader) {
  const config = getConfig();
  const integrationDecoration = _vscode.window.createTextEditorDecorationType({});
  async function selectionStyle(editor) {
    var _a3;
    try {
      let reset2 = function() {
        editor.textEditor.setDecorations(integrationDecoration, []);
      };
      var reset = reset2;
      if (!config.selectionStyle)
        return reset2();
      const doc = editor.textEditor.document;
      if (!doc)
        return reset2();
      const id = doc.uri.fsPath;
      const selection = editor.textEditor.selection;
      const range = new (0, _vscode.Range)(
        new (0, _vscode.Position)(selection.start.line, selection.start.character),
        new (0, _vscode.Position)(selection.end.line, selection.end.character)
      );
      let code = editor.textEditor.document.getText(range).trim();
      if (!code.startsWith("<"))
        code = `<div ${code}`;
      if (!code.endsWith(">"))
        code = `${code} >`;
      const ctx = await loader.resolveClosestContext(code, id);
      if (!ctx)
        return reset2();
      const remToPxRatio = config.remToPxPreview ? config.remToPxRatio : -1;
      const result = await getMatchedPositionsFromCode(ctx.uno, code);
      if (result.length <= 1)
        return reset2();
      const uniqMap = /* @__PURE__ */ new Map();
      for (const [start, end, className] of result)
        uniqMap.set(`${start}-${end}`, className);
      const classNamePlaceholder = "___";
      const sheetMap = new TwoKeyMap();
      await Promise.all(Array.from(uniqMap.values()).map(async (name2) => {
        if (!ctx)
          return;
        const tokens = await ctx.uno.parseToken(name2, classNamePlaceholder) || [];
        tokens.forEach(([, className, cssText, media3]) => {
          if (className && cssText) {
            cssText = addRemToPxComment(cssText, remToPxRatio);
            const selector = className.replace(`.${classNamePlaceholder}`, "&").replace(regexScopePlaceholder, " ").trim();
            sheetMap.set(media3, selector, (sheetMap.get(media3, selector) || "") + cssText);
          }
        });
      }));
      const css = Array.from(sheetMap._map.entries()).map(([media3, map]) => {
        const body = Array.from(map.keys()).sort().map((selector) => `${selector}{${map.get(selector)}}`).join("\n");
        return media3 ? `${media3}{${body}}` : body;
      }).join("\n");
      const prettified = import_standalone2.default.format(css, {
        parser: "css",
        plugins: [import_parser_postcss2.default]
      });
      editor.textEditor.setDecorations(integrationDecoration, [{
        range,
        get hoverMessage() {
          return new (0, _vscode.MarkdownString)(`UnoCSS utilities in the selection will be equivalent to:
\`\`\`css
${prettified.trim()}
\`\`\``);
        }
      }]);
    } catch (e2) {
      log.appendLine("\u26A0\uFE0F Error on selectionStyle");
      log.appendLine(String((_a3 = e2.stack) != null ? _a3 : e2));
    }
  }
  const dispose = _vscode.window.onDidChangeTextEditorSelection(throttle(selectionStyle, 200));
  loader.events.on("unload", () => {
    dispose.dispose();
  });
}

// src/usageProvider.ts

var UsageReferenceProvider = class {
  constructor(loader) {
    this.loader = loader;
    this.warned = false;
  }
  async provideReferences(document2, position3, _context, _token) {
    const ctx = await this.loader.resolveClosestContext(document2.getText(), document2.uri.fsPath);
    if (!ctx || !ctx.filter(document2.getText(), document2.uri.fsPath))
      return void 0;
    const positions3 = await getMatchedPositionsFromDoc(ctx.uno, document2);
    const index = document2.offsetAt(position3);
    const matched = positions3.find((i) => i[0] <= index && i[1] >= index);
    if (!matched || !matched[2]) {
      return void 0;
    }
    if (!this.warned) {
      _vscode.window.showInformationMessage(
        `[UnoCSS] Find all references is an experimental feature`,
        "Dismiss",
        "Report Issue"
      ).then((r) => {
        if (r !== "Report Issue")
          return;
        _vscode.env.openExternal(_vscode.Uri.parse("https://github.com/unocss/unocss/pull/4353"));
      });
      this.warned = true;
    }
    const name2 = matched[2];
    const files = await _vscode.workspace.findFiles(
      `**/*.{vue,html,js,ts,jsx,tsx,svelte,astro,elm,php,phtml,mdx,md}`,
      "**/{node_modules,.git,dist,.output,.cache,cache}/**",
      1e3
    );
    const result = (await Promise.all(files.map(async (f) => {
      const doc = await _vscode.workspace.openTextDocument(f);
      if (!ctx.filter(doc.getText(), f.fsPath))
        return void 0;
      const positions4 = await getMatchedPositionsFromDoc(ctx.uno, doc);
      return {
        doc,
        positions: positions4
      };
    }))).filter((i) => !!i);
    const cacheMap = ctx.uno.cache || ctx.uno._cache || /* @__PURE__ */ new Map();
    const target = cacheMap.get(name2);
    if (!target) {
      return positions3.filter((i) => i[2] === name2).map((i) => new (0, _vscode.Location)(document2.uri, new (0, _vscode.Range)(document2.positionAt(i[0]), document2.positionAt(i[1]))));
    }
    const names = /* @__PURE__ */ new Set([
      name2,
      ...[...cacheMap.entries()].filter(([_, utils]) => {
        if (!utils)
          return false;
        if (utils.length !== target.length)
          return false;
        return utils.every((item, index2) => item[2] === target[index2][2]);
      }).map((i) => i[0])
    ]);
    return Object.values(result).flatMap(({ doc, positions: positions4 }) => {
      return positions4.filter((i) => names.has(i[2])).map((i) => new (0, _vscode.Location)(doc.uri, new (0, _vscode.Range)(doc.positionAt(i[0]), doc.positionAt(i[1]))));
    });
  }
};
async function registerUsageProvider(loader) {
  const provider = new UsageReferenceProvider(loader);
  loader.ext.subscriptions.push(
    _vscode.languages.registerReferenceProvider(
      await getLanguageIds(),
      provider
    )
  );
}

// src/contextLoader.ts
var frameworkConfigRE = /^(?:vite|svelte|astro|iles|nuxt|unocss|uno)\.config/;
var unoConfigRE = /\buno(?:css)?\.config\./;
var excludeFileRE = /[\\/](?:node_modules|dist|\.temp|\.cache)[\\/]/;
var ContextLoader = class {
  constructor(cwd, ext, status) {
    this.cwd = cwd;
    this.ext = ext;
    this.status = status;
    this.contextsMap = /* @__PURE__ */ new Map();
    this.configSources = [];
    this.fileContextCache = /* @__PURE__ */ new Map();
    this.configExistsCache = /* @__PURE__ */ new Map();
    this.defaultUnocssConfig = {
      presets: [src_default2()]
    };
    this.events = createNanoEvents();
    this._isRegistered = false;
    this.ready = this.reload();
  }
  isTarget(id) {
    return Array.from(this.contextsMap.keys()).some((cwd) => isSubdir(cwd, id));
  }
  get contexts() {
    return Array.from(new Set(this.contextsMap.values())).filter(notNull);
  }
  async reload() {
    this.ready = this._reload();
    await this.ready;
    this.events.emit("reload");
  }
  async _reload() {
    const dirs = Array.from(this.contextsMap.keys());
    await Promise.allSettled(Array.from(dirs).map((dir) => this.unloadContext(dir)));
    this.fileContextCache.clear();
    this.configExistsCache.clear();
    for (const dir of dirs)
      await this.loadContextInDirectory(dir);
    if (!dirs.length)
      await this.loadContextInDirectory(this.cwd);
  }
  async unload(configDir) {
    const context = this.contextsMap.get(configDir);
    if (!context)
      return;
    this.contextsMap.delete(configDir);
    for (const [path7, ctx] of this.fileContextCache) {
      if (ctx === context)
        this.fileContextCache.delete(path7);
    }
    this.events.emit("unload", context);
  }
  async unloadContext(configDir) {
    const context = this.contextsMap.get(configDir);
    if (!context)
      return;
    this.contextsMap.delete(configDir);
    for (const [path7, ctx] of this.fileContextCache) {
      if (ctx === context)
        this.fileContextCache.delete(path7);
    }
    this.events.emit("contextUnload", context);
    this.events.emit("reload");
  }
  async configExists(dir) {
    if (!this.configExistsCache.has(dir)) {
      const files = await _promises.readdir.call(void 0, dir);
      this.configExistsCache.set(dir, files.some((f) => frameworkConfigRE.test(f)));
    }
    return this.configExistsCache.get(dir);
  }
  async loadContextInDirectory(dir) {
    const cached = this.contextsMap.get(dir);
    if (cached !== void 0)
      return cached;
    for (const file of [".pnp.js", ".pnp.cjs"]) {
      if (await (0, import_fs_extra.exists)(_path3.default.join(dir, file))) {
        try {
          _chunk42PBKAQTcjs.__require.call(void 0, _path3.default.join(dir, file)).setup();
        } catch (e2) {
        }
      }
    }
    const load = async () => {
      var _a3, _b2;
      log.appendLine("\n-----------");
      log.appendLine(`\u{1F6E0} Resolving config for ${dir}`);
      globalThis.defineNuxtConfig = (config) => config;
      const context2 = createContext(
        dir,
        this.defaultUnocssConfig,
        [
          sourcePluginFactory({
            files: [
              "vite.config",
              "svelte.config",
              "iles.config"
            ],
            targetModule: "unocss/vite",
            parameters: [{ command: "serve", mode: "development" }]
          }),
          sourcePluginFactory({
            files: [
              "astro.config"
            ],
            targetModule: "unocss/astro"
          }),
          sourceObjectFields({
            files: "nuxt.config",
            fields: "unocss"
          })
        ],
        (result) => {
          if (result.sources.some((s) => s.includes("nuxt.config")))
            resolveOptions(result.config);
          result.config.details = true;
        }
      );
      context2.updateRoot(dir);
      let sources = [];
      try {
        sources = (await context2.ready).sources;
      } catch (e2) {
        log.appendLine(`\u26A0\uFE0F Error on loading config. Config directory: ${dir}`);
        log.appendLine(String((_a3 = e2.stack) != null ? _a3 : e2));
        console.error(e2);
        return null;
      }
      this.configSources = sources;
      if (!sources.length)
        return null;
      const baseDir = _path3.default.dirname(sources[0]);
      if (baseDir !== dir) {
        this.contextsMap.set(dir, null);
        return null;
      }
      context2.onReload(() => {
        for (const [path7, ctx] of this.fileContextCache) {
          if (ctx === context2 || !ctx)
            this.fileContextCache.delete(path7);
        }
        this.configExistsCache.clear();
        this.events.emit("contextReload", context2);
      });
      for (const [path7, ctx] of this.fileContextCache) {
        if (!ctx)
          this.fileContextCache.delete(path7);
      }
      this.events.emit("contextLoaded", context2);
      const uno = await context2.uno;
      log.appendLine(`\u{1F6E0} New configuration loaded from
${sources.map((s) => `  - ${s}`).join("\n")}`);
      log.appendLine(`\u2139\uFE0F ${uno.config.presets.length} presets, ${uno.config.rulesSize} rules, ${uno.config.shortcuts.length} shortcuts, ${uno.config.variants.length} variants, ${((_b2 = uno.config.transformers) == null ? void 0 : _b2.length) || 0} transformers loaded`);
      if (!sources.some((i) => unoConfigRE.test(i))) {
        log.appendLine("\u{1F4A1} To have the best IDE experience, it's recommended to move UnoCSS configurations into a standalone `uno.config.ts` file at the root of your project.");
        log.appendLine("\u{1F449} Learn more at https://unocss.dev/guide/config-file");
      }
      return context2;
    };
    const context = await load();
    if (!this.contextsMap.has(dir))
      this.contextsMap.set(dir, context);
    this.fileContextCache.clear();
    this.events.emit("reload");
    log.appendLine(`\u{1F5C2}\uFE0F Enabled context: ${Array.from(this.contextsMap.entries()).filter((i) => i[1]).map((i) => i[0]).join(", ") || "[none]"}`);
    if (context)
      this.registerEditorSupport();
    return context;
  }
  async resolveClosestContext(code, file) {
    if (!this.contextsMap.size)
      return void 0;
    if (excludeFileRE.test(file))
      return void 0;
    if (this.fileContextCache.has(file))
      return this.fileContextCache.get(file);
    const entries = Array.from(this.contextsMap.entries()).sort((a, b) => b[0].length - a[0].length);
    for (const [configDir, context] of entries) {
      if (!context)
        continue;
      if (!isSubdir(configDir, file))
        continue;
      if (!context.filter(code, file) && !isCssId(file))
        continue;
      this.fileContextCache.set(file, context);
      return context;
    }
    for (const [configDir, context] of entries) {
      if (!context)
        continue;
      if (isSubdir(configDir, file)) {
        this.fileContextCache.set(file, context);
        return context;
      }
    }
  }
  registerEditorSupport() {
    if (this._isRegistered)
      return;
    registerAutoComplete(this);
    registerAnnotations(this);
    registerSelectionStyle(this);
    registerDocumentCacheCleaner(this);
    registerUsageProvider(this);
    this._isRegistered = true;
  }
};

// src/index.ts
var skipMap = {
  "<!-- @unocss-skip -->": ["<!-- @unocss-skip-start -->\n", "\n<!-- @unocss-skip-end -->"],
  "/* @unocss-skip */": ["/* @unocss-skip-start */\n", "\n/* @unocss-skip-end */"],
  "// @unocss-skip": ["// @unocss-skip-start\n", "\n// @unocss-skip-end"]
};
async function activate(ext) {
  var _a3;
  _process3.default.env.IMPORTX_LOADER = "jiti-v1";
  log.appendLine(`\u26AA\uFE0F UnoCSS for VS Code v${version2}
`);
  const projectPath = (_a3 = _vscode.workspace.workspaceFolders) == null ? void 0 : _a3[0].uri.fsPath;
  if (!projectPath) {
    log.appendLine("\u2796 No active workspace found, UnoCSS is disabled");
    return;
  }
  const config = getConfig();
  if (config.disable) {
    log.appendLine("\u2796 Disabled by configuration");
    return;
  }
  const status = _vscode.window.createStatusBarItem(_vscode.StatusBarAlignment.Right, 200);
  status.text = displayName;
  const root = config.root;
  const loader = await rootRegister(
    ext,
    Array.isArray(root) && !root.length ? [projectPath] : root ? toArray2(root).map((r) => _path3.default.resolve(projectPath, r)) : [projectPath],
    status
  );
  ext.subscriptions.push(
    _vscode.commands.registerCommand(
      commands.reload,
      async () => {
        log.appendLine("\u{1F501} Reloading...");
        await loader.reload();
        log.appendLine("\u2705 Reloaded.");
      }
    ),
    _vscode.commands.registerCommand(
      commands.insertSkipAnnotation,
      async () => {
        const activeTextEditor = _vscode.window.activeTextEditor;
        if (!activeTextEditor)
          return;
        const selection = activeTextEditor.selection;
        if (!selection)
          return;
        const key = await _vscode.window.showQuickPick(Object.keys(skipMap));
        if (!key)
          return;
        const [insertStart, insertEnd] = skipMap[key];
        activeTextEditor.edit((builder) => {
          builder.insert(new (0, _vscode.Position)(selection.start.line, 0), insertStart);
          builder.insert(selection.end, insertEnd);
        });
      }
    )
  );
}
async function rootRegister(ext, root, status) {
  var _b2;
  log.appendLine("\u{1F4C2} roots search mode.");
  const config = getConfig();
  const include = config.include || defaultPipelineInclude;
  const exclude = config.exclude || [/[\\/](node_modules|dist|\.temp|\.cache|\.vscode)[\\/]/, ...defaultPipelineExclude];
  const filter = createFilter(include, exclude);
  const ctx = new ContextLoader(root[0], ext, status);
  await ctx.ready;
  const cacheFileLookUp = /* @__PURE__ */ new Set();
  const rootCache = /* @__PURE__ */ new Set();
  const watcher = _vscode.workspace.createFileSystemWatcher("**/{uno,unocss}.config.{js,ts}");
  ext.subscriptions.push(watcher.onDidChange(async (uri) => {
    const dir = _path2.dirname.call(void 0, uri.fsPath);
    await ctx.unloadContext(dir);
    await ctx.loadContextInDirectory(dir);
  }));
  ext.subscriptions.push(watcher.onDidDelete((uri) => {
    const dir = _path2.dirname.call(void 0, uri.fsPath);
    rootCache.delete(dir);
    ctx.unloadContext(dir);
    cacheFileLookUp.clear();
  }));
  const configNames = [
    "uno.config.js",
    "uno.config.ts",
    "unocss.config.js",
    "unocss.config.ts"
  ];
  const registerUnocss = async (url = ((_a3) => (_a3 = _vscode.window.activeTextEditor) == null ? void 0 : _a3.document.uri.fsPath)()) => {
    if (!url)
      return;
    if (cacheFileLookUp.has(url))
      return;
    if (!filter(url))
      return;
    cacheFileLookUp.add(url);
    if ([...rootCache].some((root2) => url.startsWith(root2)))
      return;
    const configUrl = await findUp(configNames, { cwd: url });
    if (!configUrl)
      return;
    const cwd = _path3.default.dirname(configUrl);
    rootCache.add(`${cwd}/`);
    await ctx.loadContextInDirectory(cwd);
  };
  try {
    await Promise.all(root.map(registerUnocss));
    registerUnocss();
    ext.subscriptions.push(_vscode.window.onDidChangeActiveTextEditor(() => registerUnocss()));
  } catch (e2) {
    log.appendLine(String((_b2 = e2.stack) != null ? _b2 : e2));
  }
  return ctx;
}
function deactivate() {
}



exports.activate = activate; exports.deactivate = deactivate;
/*! Bundled license information:

confbox/dist/yaml.cjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)

confbox/dist/toml.cjs:
  (*!
  * Copyright (c) Squirrel Chat et al., All rights reserved.
  * SPDX-License-Identifier: BSD-3-Clause
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * 1. Redistributions of source code must retain the above copyright notice, this
  *    list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright notice,
  *    this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  * 3. Neither the name of the copyright holder nor the names of its contributors
  *    may be used to endorse or promote products derived from this software without
  *    specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *)

fzf/dist/fzf.es.js:
  (** @license
   * fzf v0.5.2
   * Copyright (c) 2021 Ajit
   * Licensed under BSD 3-Clause
   *)
*/
